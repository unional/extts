/*
Premium TypeScript type definitions for Sencha Ext JS
ExtTS for ExtJS 4.2.1.883

Copyright (C) 2015-2016 ExtFX.NET
Contact: thanhptr@gmail.com

Build date: 2016-04-13 18:10:01 (GMT)
Version: 1.0.0.0

*/

/**
 * The Ext namespace (global object) encapsulates all classes, singletons, and
 * utility methods provided by Sencha's libraries.
 *
 * Most user interface Components are at a lower level of nesting in the namespace,
 * but many common utility functions are provided as direct properties of the Ext namespace.
 *
 * Also many frequently used methods from other classes are provided as shortcuts
 * within the Ext namespace. For example {@link Ext#getCmp Ext.getCmp} aliases
 * {@link Ext.ComponentManager#get Ext.ComponentManager.get}.
 *
 * Many applications are initiated with {@link Ext#onReady Ext.onReady} which is
 * called once the DOM is ready. This ensures all scripts have been loaded,
 * preventing dependency issues. For example:
 *
 *     Ext.onReady(function(){
 *         new Ext.Component({
 *             renderTo: document.body,
 *             html: 'DOM ready!'
 *         });
 *     });
 *
 * For more information about how to use the Ext classes, see:
 *
 * - <a href="http://www.sencha.com/learn/">The Learning Center</a>
 * - <a href="http://www.sencha.com/learn/Ext_FAQ">The FAQ</a>
 * - <a href="http://www.sencha.com/forum/">The forums</a>
 */
declare class Ext {
    /**
     * URL to a 1x1 transparent gif image used by Ext to create inline icons with
     * CSS background images. In older versions of IE, this defaults to
     * "http://sencha.com/s.gif" and you should change this to a URL on your server.
     * For other browsers it uses an inline data URL.
     */
    static BLANK_IMAGE_URL: string;

    /**
     * The current version of Chrome (0 if the browser is not Chrome).
     */
    static chromeVersion: number;

    /**
     * A reusable empty function
     */
    static emptyFn: any;

    /**
     * A zero length string which will pass a truth test. Useful for passing to methods
     * which use a truth test to reject <i>falsy</i> values where a string value must be cleared.
     */
    static emptyString: any;

    /**
     * True if the {@link Ext.fx.Anim} Class is available.
     */
    static enableFx: boolean;

    /**
     * True to automatically uncache orphaned Ext.Elements periodically
     */
    static enableGarbageCollector: any;

    /**
     * True to automatically purge event listeners during garbageCollection.
     */
    static enableListenerCollection: any;

    /**
     * **Experimental.** True to cascade listener removal to child elements when an element
     * is removed. Currently not optimized for performance.
     */
    static enableNestedListenerRemoval: boolean;

    /**
     * An array containing extra enumerables for old browsers
     */
    static enumerables: any;

    /**
     * The current version of Firefox (0 if the browser is not Firefox).
     */
    static firefoxVersion: number;

    /**
     * An instance of '{@link Ext.util.Observable}' through which Ext fires global events.
     *
     * This Observable instance fires the following events:
     *
     * *  **'idle'**
     *
     *    Fires when an event handler finishes its run, just before returning to browser control.
     *
     *    This includes DOM event handlers, Ajax (including JSONP) event handlers, and {@link Ext.util.TaskRunner TaskRunners}
     *
     *    This can be useful for performing cleanup, or update tasks which need to happen only
     *    after all code in an event handler has been run, but which should not be executed in a timer
     *    due to the intervening browser reflow/repaint which would take place.
     *
     * * **'ready'**
     *
     *    Fires when the DOM is ready, and all required classes have been loaded. Functionally
     *    the same as {@link Ext#onReady}, but must be called with the 'single' option:
     *
     *         Ext.on({
     *             ready: function() {
     *                 console.log('document is ready!');
     *             },
     *             single: true
     *         });
     *
     * * **'resumelayouts'**
     *
     *    Fires after global layout processing has been resumed in {@link Ext.AbstractComponent#resumeLayouts}.
     */
    static globalEvents: Ext.util.Observable;

    /**
     * The current version of IE (0 if the browser is not IE). This does not account
     * for the documentMode of the current page, which is factored into {@link #isIE7},
     * {@link #isIE8} and {@link #isIE9}. Thus this is not always true:
     *
     *     Ext.isIE8 == (Ext.ieVersion == 8)
     */
    static ieVersion: number;

    /**
     * True if the detected browser is Chrome.
     */
    static isChrome: boolean;

    /**
     * True if the detected browser uses FireFox 10
     */
    static isFF10: boolean;

    /**
     * True if the detected browser uses FireFox 3.0
     */
    static isFF3_0: boolean;

    /**
     * True if the detected browser uses FireFox 3.5
     */
    static isFF3_5: boolean;

    /**
     * True if the detected browser uses FireFox 3.6
     */
    static isFF3_6: boolean;

    /**
     * True if the detected browser uses FireFox 4
     */
    static isFF4: boolean;

    /**
     * True if the detected browser uses FireFox 5
     */
    static isFF5: boolean;

    /**
     * True if the detected browser uses the Gecko layout engine (e.g. Mozilla, Firefox).
     */
    static isGecko: boolean;

    /**
     * True if the detected browser uses a Gecko 5.0+ layout engine (e.g. Firefox 5.x).
     */
    static isGecko10: boolean;

    /**
     * True if the detected browser uses a Gecko 1.9+ layout engine (e.g. Firefox 3.x).
     */
    static isGecko3: boolean;

    /**
     * True if the detected browser uses a Gecko 2.0+ layout engine (e.g. Firefox 4.x).
     */
    static isGecko4: boolean;

    /**
     * True if the detected browser uses a Gecko 5.0+ layout engine (e.g. Firefox 5.x).
     */
    static isGecko5: boolean;

    /**
     * True if the detected browser is Internet Explorer.
     */
    static isIE: boolean;

    /**
     * True if the detected browser is Internet Explorer 10.x.
     */
    static isIE10: boolean;

    /**
     * True if the detected browser is Internet Explorer 10.x or lower.
     */
    static isIE10m: boolean;

    /**
     * True if the detected browser is Internet Explorer 10.x or higher.
     */
    static isIE10p: boolean;

    /**
     * True if the detected browser is Internet Explorer 6.x.
     */
    static isIE6: boolean;

    /**
     * True if the detected browser is Internet Explorer 7.x.
     */
    static isIE7: boolean;

    /**
     * True if the detected browser is Internet Explorer 7.x or lower.
     */
    static isIE7m: boolean;

    /**
     * True if the detected browser is Internet Explorer 7.x or higher.
     */
    static isIE7p: boolean;

    /**
     * True if the detected browser is Internet Explorer 8.x.
     */
    static isIE8: boolean;

    /**
     * True if the detected browser is Internet Explorer 8.x or lower.
     */
    static isIE8m: boolean;

    /**
     * True if the detected browser is Internet Explorer 8.x or higher.
     */
    static isIE8p: boolean;

    /**
     * True if the detected browser is Internet Explorer 9.x.
     */
    static isIE9: boolean;

    /**
     * True if the detected browser is Internet Explorer 9.x or lower.
     */
    static isIE9m: boolean;

    /**
     * True if the detected browser is Internet Explorer 9.x or higher.
     */
    static isIE9p: boolean;

    /**
     * True if the detected platform is Linux.
     */
    static isLinux: boolean;

    /**
     * True if the detected platform is Mac OS.
     */
    static isMac: boolean;

    /**
     * True if the detected browser is Opera.
     */
    static isOpera: boolean;

    /**
     * True if the detected browser is Opera 10.5x.
     */
    static isOpera10_5: boolean;

    /**
     * True when the document is fully initialized and ready for action
     */
    static isReady: any;

    /**
     * True if the detected browser is Safari.
     */
    static isSafari: boolean;

    /**
     * True if the detected browser is Safari 2.x.
     */
    static isSafari2: boolean;

    /**
     * True if the detected browser is Safari 3.x.
     */
    static isSafari3: boolean;

    /**
     * True if the detected browser is Safari 4.x.
     */
    static isSafari4: boolean;

    /**
     * True if the detected browser is Safari 5.x.
     */
    static isSafari5: boolean;

    /**
     * True if the detected browser is Safari 5.0.x.
     */
    static isSafari5_0: boolean;

    /**
     * True if the page is running over SSL
     */
    static isSecure: boolean;

    /**
     * True if the detected browser uses WebKit.
     */
    static isWebKit: boolean;

    /**
     * True if the detected platform is Windows.
     */
    static isWindows: boolean;

    /**
     * <p>The name of the property in the global namespace (The <code>window</code> in browser environments) which refers to the current instance of Ext.</p>
     * <p>This is usually <code>"Ext"</code>, but if a sandboxed build of ExtJS is being used, this will be an alternative name.</p>
     * <p>If code is being generated for use by <code>eval</code> or to create a <code>new Function</code>, and the global instance
     * of Ext must be referenced, this is the name that should be built into the code.</p>
     *
     * Optional, Defaults to: 'Ext'
     */
    static name: string;

    /**
     * The current version of Opera (0 if the browser is not Opera).
     */
    static operaVersion: number;

    /**
     * The current version of Safari (0 if the browser is not Safari).
     */
    static safariVersion: number;

    /**
     * URL to a blank file used by Ext when in secure mode for iframe src and onReady src
     * to prevent the IE insecure content warning (''about:blank'', except for IE
     * in secure mode, which is ''javascript:""'').
     */
    static SSL_SECURE_URL: string;

    /**
     * Indicates whether to use native browser parsing for JSON methods.
     * This option is ignored if the browser does not support native JSON methods.
     *
     * **Note:** Native JSON methods will not work with objects that have functions.
     * Also, property names must be quoted, otherwise the data will not parse.
     */
    static USE_NATIVE_JSON: boolean;

    /**
     * By default, Ext intelligently decides whether floating elements should be shimmed.
     * If you are using flash, you may want to set this to true.
     */
    static useShims: boolean;

    /**
     * The current version of WebKit (0 if the browser does not use WebKit).
     */
    static webKitVersion: number;

    /**
     * Applies event listeners to elements by selectors when the document is ready.
     * The event name is specified with an '@' suffix.
     *
     *     Ext.addBehaviors({
     *         // add a listener for click on all anchors in element with id foo
     *         '#foo a@click' : function(e, t){
     *             // do something
     *         },
     *
     *         // add the same listener to multiple selectors (separated by comma BEFORE the @)
     *         '#foo a, #bar span.some-class@mouseover' : function(){
     *             // do something
     *         }
     *     });
     *
     * @param {Object} obj The list of behaviors to apply
     */
    static addBehaviors(obj: any);

    /**
     * Adds namespace(s) to known list.
     */
    static addNamespaces(namespace: string);

    /**
     * Loads Ext.app.Application class and starts it up with given configuration after the
     * page is ready.
     *
     * See 'Ext.app.Application' for details.
     *
     * @param {Object/String} config Application config object or name of a class derived from Ext.app.Application.
     */
    static application(config: any|string);

    /**
     * Copies all the properties of config to the specified object.
     * Note that if recursive merging and cloning without referencing the original objects / arrays is needed, use
     * {@link Ext.Object#merge} instead.
     * @param {Object} object The receiver of the properties
     * @param {Object} config The source of the properties
     * @param {Object} [defaults] A different object that will also be applied for default values
     * @return {Object} returns obj
     */
    static apply(object: any, config: any, defaults?: any): any;

    /**
     * Copies all the properties of config to object if they don't already exist.
     * @param {Object} object The receiver of the properties
     * @param {Object} config The source of the properties
     * @return {Object} returns obj
     */
    static applyIf(object: any, config: any): any;

    /**
     * Utility wrapper that suspends layouts of all components for the duration of a given function.
     * @param {Function} fn The function to execute.
     * @param {Object} [scope] The scope ('this' reference) in which the specified function is executed.
     */
    static batchLayouts(fn: Function, scope?: any);

    static bind();

    /**
     * Execute a callback function in a particular scope. If 'callback' argument is a
     * function reference, that is called. If it is a string, the string is assumed to
     * be the name of a method on the given 'scope'. If no function is passed the call
     * is ignored.
     *
     * For example, these calls are equivalent:
     *
     *      var myFunc = this.myFunc;
     *
     *      Ext.callback('myFunc', this, [arg1, arg2]);
     *      Ext.callback(myFunc, this, [arg1, arg2]);
     *
     *      Ext.isFunction(myFunc) && this.myFunc(arg1, arg2);
     *
     * @param {Function} callback The callback to execute
     * @param {Object} [scope] The scope to execute in
     * @param {Array} [args] The arguments to pass to the function
     * @param {Number} [delay] Pass a number to delay the call by a number of milliseconds.
     * @return The value returned by the callback or 'undefined' (if there is a 'delay'
     * or if the 'callback' is not a function).
     */
    static callback(callback: Function, scope?: any, args?: any[], delay?: number);

    /**
     * Old alias to {@link Ext.Array#clean}
     * @deprecated 4.0.0 Use {@link Ext.Array#clean} instead
     */
    static clean();

    /**
     * Clone simple variables including array, {}-like objects, DOM nodes and Date without keeping the old reference.
     * A reference for the object itself is returned if it's not a direct decendant of Object. For model cloning,
     * see {@link Ext.data.Model#copy Model.copy}.
     *
     * @param {Object} item The variable to clone
     * @return {Object} clone
     */
    static clone(item: any): any;

    /**
     * Coerces the first value if possible so that it is comparable to the second value.
     *
     * Coercion only works between the basic atomic data types String, Boolean, Number, Date, null and undefined.
     *
     * Numbers and numeric strings are coerced to Dates using the value as the millisecond era value.
     *
     * Strings are coerced to Dates by parsing using the {@link Ext.Date#defaultFormat defaultFormat}.
     *
     * For example
     *
     *     Ext.coerce('false', true);
     *
     * returns the boolean value 'false' because the second parameter is of type 'Boolean'.
     *
     * @param {Mixed} from The value to coerce
     * @param {Mixed} to The value it must be compared against
     * @return The coerced value.
     */
    static coerce(from: any, to: any);

    /**
     * Copies a set of named properties fom the source object to the destination object.
     *
     * Example:
     *
     *     ImageComponent = Ext.extend(Ext.Component, {
     *         initComponent: function() {
     *             this.autoEl = { tag: 'img' };
     *             MyComponent.superclass.initComponent.apply(this, arguments);
     *             this.initialBox = Ext.copyTo({}, this.initialConfig, 'x,y,width,height');
     *         }
     *     });
     *
     * Important note: To borrow class prototype methods, use {@link Ext.Base#borrow} instead.
     *
     * @param {Object} dest The destination object.
     * @param {Object} source The source object.
     * @param {String/String[]} names Either an Array of property names, or a comma-delimited list
     * of property names to copy.
     * @param {Boolean} [usePrototypeKeys] Defaults to false. Pass true to copy keys off of the
     * prototype as well as the instance.
     * @return {Object} The modified object.
     */
    static copyTo(dest: any, source: any, names: string, usePrototypeKeys?: boolean): any;

    /**
     * Instantiate a class by either full name, alias or alternate name.
     *
     * If {@link Ext.Loader} is {@link Ext.Loader#setConfig enabled} and the class has
     * not been defined yet, it will attempt to load the class via synchronous loading.
     *
     * For example, all these three lines return the same result:
     *
     *      // alias
     *      var window = Ext.create('widget.window', {
     *          width: 600,
     *          height: 800,
     *          ...
     *      });
     *
     *      // alternate name
     *      var window = Ext.create('Ext.Window', {
     *          width: 600,
     *          height: 800,
     *          ...
     *      });
     *
     *      // full class name
     *      var window = Ext.create('Ext.window.Window', {
     *          width: 600,
     *          height: 800,
     *          ...
     *      });
     *
     *      // single object with xclass property:
     *      var window = Ext.create({
     *          xclass: 'Ext.window.Window', // any valid value for 'name' (above)
     *          width: 600,
     *          height: 800,
     *          ...
     *      });
     *
     * @param {String} [name] The class name or alias. Can be specified as 'xclass'
     * property if only one object parameter is specified.
     * @param {Object...} [args] Additional arguments after the name will be passed to
     * the class' constructor.
     * @return {Object} instance
     */
    static create(name?: string, args?: any): any;

    static createByAlias();

    /**
     * Old name for {@link Ext#widget}.
     * @deprecated 4.0.0 Use {@link Ext#widget} instead.
     */
    static createWidget();

    /**
     * Shorthand for {@link Ext.JSON#decode}
     */
    static decode();

    static defer();

    /**
     * Defines a class or override. A basic class is defined like this:
     *
     *      Ext.define('My.awesome.Class', {
     *          someProperty: 'something',
     *
     *          someMethod: function(s) {
     *              alert(s + this.someProperty);
     *          }
     *
     *          ...
     *      });
     *
     *      var obj = new My.awesome.Class();
     *
     *      obj.someMethod('Say '); // alerts 'Say something'
     *
     * To create an anonymous class, pass 'null' for the 'className':
     *
     *      Ext.define(null, {
     *          constructor: function () {
     *              // ...
     *          }
     *      });
     *
     * In some cases, it is helpful to create a nested scope to contain some private
     * properties. The best way to do this is to pass a function instead of an object
     * as the second parameter. This function will be called to produce the class
     * body:
     *
     *      Ext.define('MyApp.foo.Bar', function () {
     *          var id = 0;
     *
     *          return {
     *              nextId: function () {
     *                  return ++id;
     *              }
     *          };
     *      });
     *
     * _Note_ that when using override, the above syntax will not override successfully, because
     * the passed function would need to be executed first to determine whether or not the result
     * is an override or defining a new object. As such, an alternative syntax that immediately
     * invokes the function can be used:
     *
     *      Ext.define('MyApp.override.BaseOverride', function () {
     *          var counter = 0;
     *
     *          return {
     *              override: 'Ext.Component',
     *              logId: function () {
     *                  console.log(++counter, this.id);
     *              }
     *          };
     *      }());
     *
     *
     * When using this form of 'Ext.define', the function is passed a reference to its
     * class. This can be used as an efficient way to access any static properties you
     * may have:
     *
     *      Ext.define('MyApp.foo.Bar', function (Bar) {
     *          return {
     *              statics: {
     *                  staticMethod: function () {
     *                      // ...
     *                  }
     *              },
     *
     *              method: function () {
     *                  return Bar.staticMethod();
     *              }
     *          };
     *      });
     *
     * To define an override, include the 'override' property. The content of an
     * override is aggregated with the specified class in order to extend or modify
     * that class. This can be as simple as setting default property values or it can
     * extend and/or replace methods. This can also extend the statics of the class.
     *
     * One use for an override is to break a large class into manageable pieces.
     *
     *      // File: /src/app/Panel.js
     *
     *      Ext.define('My.app.Panel', {
     *          extend: 'Ext.panel.Panel',
     *          requires: [
     *              'My.app.PanelPart2',
     *              'My.app.PanelPart3'
     *          ]
     *
     *          constructor: function (config) {
     *              this.callParent(arguments); // calls Ext.panel.Panel's constructor
     *              //...
     *          },
     *
     *          statics: {
     *              method: function () {
     *                  return 'abc';
     *              }
     *          }
     *      });
     *
     *      // File: /src/app/PanelPart2.js
     *      Ext.define('My.app.PanelPart2', {
     *          override: 'My.app.Panel',
     *
     *          constructor: function (config) {
     *              this.callParent(arguments); // calls My.app.Panel's constructor
     *              //...
     *          }
     *      });
     *
     * Another use of overrides is to provide optional parts of classes that can be
     * independently required. In this case, the class may even be unaware of the
     * override altogether.
     *
     *      Ext.define('My.ux.CoolTip', {
     *          override: 'Ext.tip.ToolTip',
     *
     *          constructor: function (config) {
     *              this.callParent(arguments); // calls Ext.tip.ToolTip's constructor
     *              //...
     *          }
     *      });
     *
     * The above override can now be required as normal.
     *
     *      Ext.define('My.app.App', {
     *          requires: [
     *              'My.ux.CoolTip'
     *          ]
     *      });
     *
     * Overrides can also contain statics:
     *
     *      Ext.define('My.app.BarMod', {
     *          override: 'Ext.foo.Bar',
     *
     *          statics: {
     *              method: function (x) {
     *                  return this.callParent([x * 2]); // call Ext.foo.Bar.method
     *              }
     *          }
     *      });
     *
     * IMPORTANT: An override is only included in a build if the class it overrides is
     * required. Otherwise, the override, like the target class, is not included.
     *
     * @param {String} className The class name to create in string dot-namespaced format, for example:
     * 'My.very.awesome.Class', 'FeedViewer.plugin.CoolPager'
     * It is highly recommended to follow this simple convention:
     *  - The root and the class name are 'CamelCased'
     *  - Everything else is lower-cased
     * Pass 'null' to create an anonymous class.
     * @param {Object} data The key - value pairs of properties to apply to this class. Property names can be of any valid
     * strings, except those in the reserved listed below:
     *  - 'mixins'
     *  - 'statics'
     *  - 'config'
     *  - 'alias'
     *  - 'self'
     *  - 'singleton'
     *  - 'alternateClassName'
     *  - 'override'
     *
     * @param {Function} createdFn Optional callback to execute after the class is created, the execution scope of which
     * ('this') will be the newly created class itself.
     * @return {Ext.Base}
     */
    static define(className: string, data: any, createdFn: Function): Ext.Base;

    /**
     * Create a closure for deprecated code.
     *
     *     // This means Ext.oldMethod is only supported in 4.0.0beta and older.
     *     // If Ext.getVersion('extjs') returns a version that is later than '4.0.0beta', for example '4.0.0RC',
     *     // the closure will not be invoked
     *     Ext.deprecate('extjs', '4.0.0beta', function() {
     *         Ext.oldMethod = Ext.newMethod;
     *
     *         ...
     *     });
     *
     * @param {String} packageName The package name
     * @param {String} since The last version before it's deprecated
     * @param {Function} closure The callback function to be executed with the specified version is less than the current version
     * @param {Object} scope The execution scope ('this') if the closure
     */
    static deprecate(packageName: string, since: string, closure: Function, scope: any);

    /**
     * Attempts to destroy any objects passed to it by removing all event listeners, removing them from the
     * DOM (if applicable) and calling their destroy functions (if available).  This method is primarily
     * intended for arguments of type {@link Ext.Element} and {@link Ext.Component}, but any subclass of
     * {@link Ext.util.Observable} can be passed in.  Any number of elements and/or components can be
     * passed into this function in a single call as separate arguments.
     *
     * Any number of elements or components, or an Array of either of these to destroy.
     */
    static destroy(args: Ext.dom.Element[]|Ext.util.Observable[]);

    /**
     * Attempts to destroy and then remove a set of named properties of the passed object.
     * @param {Object} o The object (most likely a Component) who's properties you wish to destroy.
     * @param {String...} args One or more names of the properties to destroy and remove from the object.
     */
    static destroyMembers(o: any, args: string);

    static each();

    /**
     * Shorthand for {@link Ext.JSON#encode}
     */
    static encode();

    /**
     * Escapes the passed string for use in a regular expression.
     * @return {String}
     * @deprecated 4.0.0 Use {@link Ext.String#escapeRegex} instead
     */
    static escapeRe(str: string): string;

    /**
     * Convenient shortcut to {@link Ext.Loader#exclude}
     */
    static exclude();

    /**
     * This method deprecated. Use {@link Ext#define Ext.define} instead.
     * @return {Function} The subclass constructor from the <tt>overrides</tt> parameter, or a generated one if not provided.
     * @deprecated 4.0.0 Use {@link Ext#define Ext.define} instead
     */
    static extend(superclass: Function, overrides: any): Function;

    /**
     * Old alias to {@link Ext.Array#flatten}
     * @deprecated 4.0.0 Use {@link Ext.Array#flatten} instead
     */
    static flatten();

    static fly();

    static get();

    /**
     * Returns the current document body as an {@link Ext.Element}.
     * @return {Ext.Element} The document body
     */
    static getBody(): Ext.dom.Element;

    static getClass();

    static getClassName();

    /**
     * This is shorthand reference to {@link Ext.ComponentManager#get}.
     * Looks up an existing {@link Ext.Component Component} by {@link Ext.Component#id id}
     *
     * @param {String} id The component {@link Ext.Component#id id}
     * @return Ext.Component The Component, 'undefined' if not found, or 'null' if a
     * Class was found.
     */
    static getCmp(id: string);

    /**
     * Returns the current HTML document object as an {@link Ext.Element}.
     * @return {Ext.Element} The document
     */
    static getDoc(): Ext.dom.Element;

    /**
     * Returns the dom node for the passed String (id), dom node, or Ext.Element.
     * Optional 'strict' flag is needed for IE since it can return 'name' and
     * 'id' elements by using getElementById.
     *
     * Here are some examples:
     *
     *     // gets dom node based on id
     *     var elDom = Ext.getDom('elId');
     *     // gets dom node based on the dom node
     *     var elDom1 = Ext.getDom(elDom);
     *
     *     // If we don&#39;t know if we are working with an
     *     // Ext.Element or a dom node use Ext.getDom
     *     function(el){
     *         var dom = Ext.getDom(el);
     *         // do something with the dom node
     *     }
     *
     * **Note:** the dom node to be found actually needs to exist (be rendered, etc)
     * when this method is called to be successful.
     *
     * @return HTMLElement
     */
    static getDom(el: string|HTMLElement|Ext.dom.Element);

    /**
     * Returns the current document head as an {@link Ext.Element}.
     * @return {Ext.Element} The document head
     */
    static getHead(): Ext.dom.Element;

    /**
     * Get namespace prefix for a class name.
     *
     *
     * @return {String} Namespace prefix if it's known, otherwise undefined
     */
    static getNamespace(className: string): string;

    /**
     * Returns the current orientation of the mobile device
     * @return {String} Either 'portrait' or 'landscape'
     */
    static getOrientation(): string;

    /**
     * Returns the size of the browser scrollbars. This can differ depending on
     * operating system settings, such as the theme or font size.
     * @param {Boolean} [force] true to force a recalculation of the value.
     * @return {Object} An object containing scrollbar sizes.
     * @return {Number} return.width The width of the vertical scrollbar.
     * @return {Number} return.height The height of the horizontal scrollbar.
     */
    static getScrollbarSize(force?: boolean): any;

    /**
     * Utility method for getting the width of the browser's vertical scrollbar. This
     * can differ depending on operating system settings, such as the theme or font size.
     *
     * This method is deprected in favor of {@link #getScrollbarSize}.
     *
     * @param {Boolean} [force] true to force a recalculation of the value.
     * @return {Number} The width of a vertical scrollbar.
     * @deprecated
     */
    static getScrollBarWidth(force?: boolean): number;

    /**
     * Shortcut to {@link Ext.data.StoreManager#lookup}.
     */
    static getStore();

    /**
     * Get the version number of the supplied package name; will return the last registered version
     * (last Ext.setVersion call) if there's no package name given.
     *
     * @param {String} packageName (Optional) The package name, for example: 'core', 'touch', 'extjs'
     * @return {Ext.Version} The version
     */
    static getVersion(packageName: string): Ext.Version;

    /**
     * Old alias to {@link Ext.String#htmlDecode}
     * @deprecated Use {@link Ext.String#htmlDecode} instead
     */
    static htmlDecode();

    /**
     * Old alias to {@link Ext.String#htmlEncode}
     * @deprecated Use {@link Ext.String#htmlEncode} instead
     */
    static htmlEncode();

    /**
     * Generates unique ids. If the element already has an id, it is unchanged
     * @param {HTMLElement/Ext.Element} [el] The element to generate an id for
     * @param {String} prefix (optional) Id prefix (defaults "ext-gen")
     * @return {String} The generated Id.
     */
    static id(el?: HTMLElement|Ext.dom.Element, prefix?: string): string;

    /**
     * A reusable identity function. The function will always return the first argument, unchanged.
     */
    static identityFn();

    /**
     * Invokes a method on each item in an Array.
     *
     * Example:
     *
     *     Ext.invoke(Ext.query("p"), "getAttribute", "id");
     *     // [el1.getAttribute("id"), el2.getAttribute("id"), ..., elN.getAttribute("id")]
     *
     * @param {Array/NodeList} arr The Array of items to invoke the method on.
     * @param {String} methodName The method name to invoke.
     * @param {Object...} args Arguments to send into the method invocation.
     * @return {Array} The results of invoking the method on each item in the array.
     * @deprecated 4.0.0 Will be removed in the next major version
     */
    static invoke(arr: any[]|any, methodName: string, args: any): any[];

    /**
     * Returns true if the passed value is a JavaScript Array, false otherwise.
     *
     * @param {Object} target The target to test
     * @return {Boolean}
     */
    static isArray(target: any): boolean;

    /**
     * Returns true if the passed value is a boolean.
     *
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isBoolean(value: any): boolean;

    /**
     * Returns true if the passed value is a JavaScript Date object, false otherwise.
     * @param {Object} object The object to test
     * @return {Boolean}
     */
    static isDate(object: any): boolean;

    /**
     * Returns true if the passed value is defined.
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isDefined(value: any): boolean;

    /**
     * Returns true if the passed value is an HTMLElement
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isElement(value: any): boolean;

    /**
     * Returns true if the passed value is empty, false otherwise. The value is deemed to be empty if it is either:
     *
     * - 'null'
     * - 'undefined'
     * - a zero-length array
     * - a zero-length string (Unless the 'allowEmptyString' parameter is set to 'true')
     *
     * @param {Object} value The value to test
     * @param {Boolean} allowEmptyString (optional) true to allow empty strings (defaults to false)
     * @return {Boolean}
     * @markdown
     */
    static isEmpty(value: any, allowEmptyString: boolean): boolean;

    /**
     * Returns true if the passed value is a JavaScript Function, false otherwise.
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isFunction(value: any): boolean;

    /**
     * Returns 'true' if the passed value is iterable, that is, if elements of it are addressable using array
     * notation with numeric indices, 'false' otherwise.
     *
     * Arrays and function 'arguments' objects are iterable. Also HTML collections such as 'NodeList' and 'HTMLCollection'
     * are iterable.
     *
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isIterable(value: any): boolean;

    /**
     * Returns true if the passed value is a number. Returns false for non-finite numbers.
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isNumber(value: any): boolean;

    /**
     * Validates that a value is numeric.
     * @param {Object} value Examples: 1, '1', '2.34'
     * @return {Boolean} True if numeric, false otherwise
     */
    static isNumeric(value: any): boolean;

    /**
     * Returns true if the passed value is a JavaScript Object, false otherwise.
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isObject(value: any): boolean;

    /**
     * Returns true if the passed value is a JavaScript 'primitive', a string, number or boolean.
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isPrimitive(value: any): boolean;

    /**
     * Returns true if the passed value is a string.
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isString(value: any): boolean;

    /**
     * Returns true if the passed value is a TextNode
     * @param {Object} value The value to test
     * @return {Boolean}
     */
    static isTextNode(value: any): boolean;

    /**
     * Iterates either an array or an object. This method delegates to
     * {@link Ext.Array#each Ext.Array.each} if the given value is iterable, and {@link Ext.Object#each Ext.Object.each} otherwise.
     *
     * @param {Object/Array} object The object or array to be iterated.
     * @param {Function} fn The function to be called for each iteration. See and {@link Ext.Array#each Ext.Array.each} and
     * {@link Ext.Object#each Ext.Object.each} for detailed lists of arguments passed to this function depending on the given object
     * type that is being iterated.
     * @param {Object} scope (Optional) The scope ('this' reference) in which the specified function is executed.
     * Defaults to the object being iterated itself.
     * @markdown
     */
    static iterate(object: any|any[], fn: Function, scope: any);

    /**
     * Logs a message. If a console is present it will be used. On Opera, the method
     * "opera.postError" is called. In other cases, the message is logged to an array
     * "Ext.log.out". An attached debugger can watch this array and view the log. The
     * log buffer is limited to a maximum of "Ext.log.max" entries (defaults to 250).
     * The 'Ext.log.out' array can also be written to a popup window by entering the
     * following in the URL bar (a "bookmarklet"):
     *
     *     javascript:void(Ext.log.show());
     *
     * If additional parameters are passed, they are joined and appended to the message.
     * A technique for tracing entry and exit of a function is this:
     *
     *     function foo () {
     *         Ext.log({ indent: 1 }, '>> foo');
     *
     *         // log statements in here or methods called from here will be indented
     *         // by one step
     *
     *         Ext.log({ outdent: 1 }, '<< foo');
     *     }
     *
     * This method does nothing in a release build.
     *
     * @param {String/Object} [options] The message to log or an options object with any
     * of the following properties:
     *
     *  - 'msg': The message to log (required).
     *  - 'level': One of: "error", "warn", "info" or "log" (the default is "log").
     *  - 'dump': An object to dump to the log as part of the message.
     *  - 'stack': True to include a stack trace in the log.
     *  - 'indent': Cause subsequent log statements to be indented one step.
     *  - 'outdent': Cause this and following statements to be one step less indented.
     *
     * @param {String...} [message] The message to log (required unless specified in
     * options object).
     */
    static log(options?: string|any, message?: string);

    /**
     * Old alias to {@link Ext.Array#max}
     * @deprecated 4.0.0 Use {@link Ext.Array#max} instead
     */
    static max();

    /**
     * Old alias to {@link Ext.Array#mean}
     * @deprecated 4.0.0 Use {@link Ext.Array#mean} instead
     */
    static mean();

    /**
     * A convenient alias method for {@link Ext.Object#merge}.
     */
    static merge();

    /**
     * Old alias to {@link Ext.Array#min}
     * @deprecated 4.0.0 Use {@link Ext.Array#min} instead
     */
    static min();

    /**
     * Creates namespaces to be used for scoping variables and classes so that they are not global.
     * Specifying the last node of a namespace implicitly creates all other nodes. Usage:
     *
     *     Ext.namespace('Company', 'Company.data');
     *
     *     // equivalent and preferable to the above syntax
     *     Ext.ns('Company.data');
     *
     *     Company.Widget = function() { ... };
     *
     *     Company.data.CustomStore = function(config) { ... };
     *
     * @return {Object} The namespace object.
     * (If multiple arguments are passed, this will be the last namespace created)
     */
    static namespace(namespaces: string): any;

    /**
     * Convenient alias for {@link Ext#namespace Ext.namespace}.
     */
    static ns();

    /**
     * @deprecated 4.0.0 Please use {@link Ext.Number#from} instead.
     */
    static num();

    /**
     * Shorthand for the {@link Ext.util.Observable#addListener} method of the
     * {@link Ext#globalEvents} Observable instance.
     */
    static on();

    static onDocumentReady();

    /**
     * @ignore
     */
    static onReady();

    /**
     * Overrides members of the specified 'target' with the given values.
     *
     * If the 'target' is a class declared using {@link Ext#define Ext.define}, the
     * 'override' method of that class is called (see {@link Ext.Base#override}) given
     * the 'overrides'.
     *
     * If the 'target' is a function, it is assumed to be a constructor and the contents
     * of 'overrides' are applied to its 'prototype' using {@link Ext#apply Ext.apply}.
     *
     * If the 'target' is an instance of a class declared using {@link Ext#define Ext.define},
     * the 'overrides' are applied to only that instance. In this case, methods are
     * specially processed to allow them to use {@link Ext.Base#callParent}.
     *
     *      var panel = new Ext.Panel({ ... });
     *
     *      Ext.override(panel, {
     *          initComponent: function () {
     *              // extra processing...
     *
     *              this.callParent();
     *          }
     *      });
     *
     * If the 'target' is none of these, the 'overrides' are applied to the 'target'
     * using {@link Ext#apply Ext.apply}.
     *
     * Please refer to {@link Ext#define Ext.define} and {@link Ext.Base#override} for
     * further details.
     *
     * @param {Object} target The target to override.
     * @param {Object} overrides The properties to add or replace on 'target'.
     */
    static override(target: any, overrides: any);

    /**
     * Partitions the set into two sets: a true set and a false set.
     *
     * Example 1:
     *
     *     Ext.partition([true, false, true, true, false]);
     *     // returns [[true, true, true], [false, false]]
     *
     * Example 2:
     *
     *     Ext.partition(
     *         Ext.query("p"),
     *         function(val){
     *             return val.className == "class1"
     *         }
     *     );
     *     // true are those paragraph elements with a className of "class1",
     *     // false set are those that do not have that className.
     *
     * @param {Array/NodeList} arr The array to partition
     * @param {Function} truth (optional) a function to determine truth.
     * If this is omitted the element itself must be able to be evaluated for its truthfulness.
     * @return {Array} [array of truish values, array of falsy values]
     * @deprecated 4.0.0 Will be removed in the next major version
     */
    static partition(arr: any[]|any, truth: Function): any[];

    static pass();

    /**
     * Old alias to {@link Ext.Array#pluck Ext.Array.pluck}
     * @deprecated 4.0.0 Use {@link Ext.Array#pluck Ext.Array.pluck} instead
     */
    static pluck();

    /**
     * Shorthand for {@link Ext.PluginManager#registerType}
     * @param {String} ptype The ptype mnemonic string by which the Plugin class
     * may be looked up.
     * @param {Function} cls The new Plugin class.
     */
    static preg(ptype: string, cls: Function);

    /**
     * Shorthand of {@link Ext.dom.Query#select}
     */
    static query();

    /**
     * Old way for creating Model classes.  Instead use:
     *
     *     Ext.define("MyModel", {
     *         extend: "Ext.data.Model",
     *         fields: []
     *     });
     *
     * @param {String} name Name of the Model class.
     * @param {Object} config A configuration object for the Model you wish to create.
     * @return {Ext.data.Model} The newly registered Model
     * @deprecated 4.0.0 Use {@link Ext#define} instead.
     */
    static regModel(name: string, config: any): Ext.data.Model;

    /**
     * Creates a new store for the given id and config, then registers it with the {@link Ext.data.StoreManager Store Manager}.
     * Sample usage:
     *
     *     Ext.regStore('AllUsers', {
     *         model: 'User'
     *     });
     *
     *     // the store can now easily be used throughout the application
     *     new Ext.List({
     *         store: 'AllUsers',
     *         ... other config
     *     });
     *
     * @param {String} id The id to set on the new store
     * @param {Object} config The store config
     */
    static regStore(id: string, config: any);

    /**
     * Removes a DOM node from the document.
     *
     * Removes this element from the document, removes all DOM event listeners, and
     * deletes the cache reference. All DOM event listeners are removed from this element.
     * If {@link Ext#enableNestedListenerRemoval Ext.enableNestedListenerRemoval} is
     * 'true', then DOM event listeners are also removed from all child nodes.
     * The body node will be ignored if passed in.
     *
     * @param {HTMLElement} node The node to remove
     */
    static removeNode(node: HTMLElement);

    static require();

    static resumeLayouts();

    /**
     * Shorthand of {@link Ext.Element#method-select}.
     */
    static select();

    /**
     * Sets the default font-family to use for components that support a 'glyph' config.
     * @param {String} fontFamily The name of the font-family
     */
    static setGlyphFontFamily(fontFamily: string);

    /**
     * Set version number for the given package name.
     *
     * @param {String} packageName The package name, for example: 'core', 'touch', 'extjs'
     * @param {String/Ext.Version} version The version, for example: '1.2.3alpha', '2.4.0-dev'
     * @return {Ext}
     */
    static setVersion(packageName: string, version: string|Ext.Version): Ext;

    /**
     * Old alias to {@link Ext.Array#sum}
     * @deprecated 4.0.0 Use {@link Ext.Array#sum} instead
     */
    static sum();

    static suspendLayouts();

    static syncRequire();

    static toArray();

    /**
     * Turns an array into a sentence, joined by a specified connector - e.g.:
     *
     *     Ext.toSentence(['Adama', 'Tigh', 'Roslin']); //'Adama, Tigh and Roslin'
     *     Ext.toSentence(['Adama', 'Tigh', 'Roslin'], 'or'); //'Adama, Tigh or Roslin'
     *
     * @param {String[]} items The array to create a sentence from
     * @param {String} connector The string to use to connect the last two words.
     * Usually 'and' or 'or' - defaults to 'and'.
     * @return {String} The sentence string
     * @deprecated 4.0.0 Will be removed in the next major version
     */
    static toSentence(items: string, connector: string): string;

    /**
     * Old alias to {@link Ext#typeOf}
     * @deprecated 4.0.0 Use {@link Ext#typeOf} instead
     */
    static type();

    /**
     * Returns the type of the given variable in string format. List of possible values are:
     *
     * - 'undefined': If the given value is 'undefined'
     * - 'null': If the given value is 'null'
     * - 'string': If the given value is a string
     * - 'number': If the given value is a number
     * - 'boolean': If the given value is a boolean value
     * - 'date': If the given value is a 'Date' object
     * - 'function': If the given value is a function reference
     * - 'object': If the given value is an object
     * - 'array': If the given value is an array
     * - 'regexp': If the given value is a regular expression
     * - 'element': If the given value is a DOM Element
     * - 'textnode': If the given value is a DOM text node and contains something other than whitespace
     * - 'whitespace': If the given value is a DOM text node and contains only whitespace
     *
     * @return {String}
     * @markdown
     */
    static typeOf(value: any): string;

    /**
     * Shorthand for the {@link Ext.util.Observable#removeListener} method of the
     * {@link Ext#globalEvents} Observable instance.
     */
    static un();

    /**
     * Old alias to {@link Ext.Array#unique}
     * @deprecated 4.0.0 Use {@link Ext.Array#unique} instead
     */
    static unique();

    /**
     * Old alias to {@link Ext.String#urlAppend}
     * @deprecated Use {@link Ext.String#urlAppend} instead
     */
    static urlAppend();

    /**
     * Alias for {@link Ext.Object#fromQueryString}.
     *
     * @deprecated 4.0.0 Use {@link Ext.Object#fromQueryString} instead
     */
    static urlDecode();

    /**
     * @deprecated 4.0.0 Use {@link Ext.Object#toQueryString} instead
     */
    static urlEncode();

    /**
     * Utility method for returning a default value if the passed value is empty.
     *
     * The value is deemed to be empty if it is:
     *
     * - null
     * - undefined
     * - an empty array
     * - a zero length string (Unless the 'allowBlank' parameter is 'true')
     *
     * @param {Object} value The value to test
     * @param {Object} defaultValue The value to return if the original value is empty
     * @param {Boolean} [allowBlank=false] true to allow zero length strings to qualify as non-empty.
     * @return {Object} value, if non-empty, else defaultValue
     * @deprecated 4.0.0 Use {@link Ext#valueFrom} instead
     */
    static value(value: any, defaultValue: any, allowBlank?: boolean): any;

    /**
     * Returns the given value itself if it's not empty, as described in {@link Ext#isEmpty}; returns the default
     * value (second argument) otherwise.
     *
     * @param {Object} value The value to test
     * @param {Object} defaultValue The value to return if the original value is empty
     * @param {Boolean} allowBlank (optional) true to allow zero length strings to qualify as non-empty (defaults to false)
     * @return {Object} value, if non-empty, else defaultValue
     */
    static valueFrom(value: any, defaultValue: any, allowBlank: boolean): any;

    /**
     * Convenient shorthand to create a widget by its xtype or a config object.
     * See also {@link Ext.ClassManager#instantiateByAlias}.
     *
     *      var button = Ext.widget('button'); // Equivalent to Ext.create('widget.button');
     *
     *      var panel = Ext.widget('panel', { // Equivalent to Ext.create('widget.panel')
     *          title: 'Panel'
     *      });
     *
     *      var grid = Ext.widget({
     *          xtype: 'grid',
     *          ...
     *      });
     *
     * If a {@link Ext.Component component} instance is passed, it is simply returned.
     *
     * @param {String} [name] The xtype of the widget to create.
     * @param {Object} [config] The configuration object for the widget constructor.
     * @return {Object} The widget instance
     */
    static widget(name?: string, config?: any): any;

    /**
     * Zips N sets together.
     *
     * Example 1:
     *
     *     Ext.zip([1,2,3],[4,5,6]); // [[1,4],[2,5],[3,6]]
     *
     * Example 2:
     *
     *     Ext.zip(
     *         [ "+", "-", "+"],
     *         [  12,  10,  22],
     *         [  43,  15,  96],
     *         function(a, b, c){
     *             return "$" + a + "" + b + "." + c
     *         }
     *     ); // ["$+12.43", "$-10.15", "$+22.96"]
     *
     * @param {Array/NodeList...} arr This argument may be repeated. Array(s)
     * to contribute values.
     * @param {Function} zipper (optional) The last item in the argument list.
     * This will drive how the items are zipped together.
     * @return {Array} The zipped set.
     * @deprecated 4.0.0 Will be removed in the next major version
     */
    static zip(arr: any[], zipper: Function): any[];
}

declare module Ext {
    interface AbstractComponentConfig {
        /**
         * A tag name or {@link Ext.DomHelper DomHelper} spec used to create the {@link #getEl Element} which will
         * encapsulate this Component.
         *
         * You do not normally need to specify this. For the base classes {@link Ext.Component} and
         * {@link Ext.container.Container}, this defaults to **'div'**. The more complex Sencha classes use a more
         * complex DOM structure specified by their own {@link #renderTpl}s.
         *
         * This is intended to allow the developer to create application-specific utility Components encapsulated by
         * different DOM elements. Example usage:
         *
         *     {
         *         xtype: 'component',
         *         autoEl: {
         *             tag: 'img',
         *             src: 'http://www.example.com/example.jpg'
         *         }
         *     }, {
         *         xtype: 'component',
         *         autoEl: {
         *             tag: 'blockquote',
         *             html: 'autoEl is cool!'
         *         }
         *     }, {
         *         xtype: 'container',
         *         autoEl: 'ul',
         *         cls: 'ux-unordered-list',
         *         items: {
         *             xtype: 'component',
         *             autoEl: 'li',
         *             html: 'First list item'
         *         }
         *     }
         *
         * @since 2.3.0
         */
        autoEl?: string|any;

        /**
         * An alias for {@link #loader} config which also allows to specify just a string which will be
         * used as the url that's automatically loaded:
         *
         *     Ext.create('Ext.Component', {
         *         autoLoad: 'content.html',
         *         renderTo: Ext.getBody()
         *     });
         *
         * The above is the same as:
         *
         *     Ext.create('Ext.Component', {
         *         loader: {
         *             url: 'content.html',
         *             autoLoad: true
         *         },
         *         renderTo: Ext.getBody()
         *     });
         *
         * Don't use it together with {@link #loader} config.
         *
         * @deprecated 4.1.1 Use {@link #loader} config instead.
         */
        autoLoad?: Ext.ComponentLoader|any|string|boolean;

        /**
         * This config is intended mainly for non-{@link #cfg-floating} Components which may or may not be shown. Instead of using
         * {@link #renderTo} in the configuration, and rendering upon construction, this allows a Component to render itself
         * upon first _{@link Ext.Component#method-show show}_. If {@link #cfg-floating} is 'true', the value of this config is omitted as if it is 'true'.
         *
         * Specify as 'true' to have this Component render to the document body upon first show.
         *
         * Specify as an element, or the ID of an element to have this Component render to a specific element upon first
         * show.
         */
        autoRender?: boolean|string|HTMLElement|Ext.dom.Element;

        /**
         * 'true' to automatically show the component upon creation. This config option may only be used for
         * {@link #floating} components or components that use {@link #autoRender}.
         *
         * @since 2.3.0
         */
        autoShow?: boolean;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to elements within this
         * component like Panel's body will get a class 'x-panel-body'. This means that if you create a subclass of Panel, and
         * you want it to get all the Panels styling for the element and the body, you leave the 'baseCls' 'x-panel' and use
         * 'componentCls' to add specific styling for this component.
         *
         * Optional, Defaults to: 'x-component'
         */
        baseCls?: string;

        /**
         * Specifies the border size for this component. The border can be a single numeric value to apply to all sides or it can
         * be a CSS style specification for each style, for example: '10 5 3 10' (top, right, bottom, left).
         *
         * For components that have no border by default, setting this won't make the border appear by itself.
         * You also need to specify border color and style:
         *
         *     border: 5,
         *     style: {
         *         borderColor: 'red',
         *         borderStyle: 'solid'
         *     }
         *
         * To turn off the border, use 'border: false'.
         */
        border?: number|string|boolean;

        /**
         * An array describing the child elements of the Component. Each member of the array
         * is an object with these properties:
         *
         * - 'name' - The property name on the Component for the child element.
         * - 'itemId' - The id to combine with the Component's id that is the id of the child element.
         * - 'id' - The id of the child element.
         *
         * If the array member is a string, it is equivalent to '{ name: m, itemId: m }'.
         *
         * For example, a Component which renders a title and body text:
         *
         *     @example
         *     Ext.create('Ext.Component', {
         *         renderTo: Ext.getBody(),
         *         renderTpl: [
         *             '<h1 id="{id}-title">{title}</h1>',
         *             '<p>{msg}</p>',
         *         ],
         *         renderData: {
         *             title: "Error",
         *             msg: "Something went wrong"
         *         },
         *         childEls: ["title"],
         *         listeners: {
         *             afterrender: function(cmp){
         *                 // After rendering the component will have a title property
         *                 cmp.title.setStyle({color: "red"});
         *             }
         *         }
         *     });
         *
         * A more flexible, but somewhat slower, approach is {@link #renderSelectors}.
         */
        childEls?: any;

        /**
         * An optional extra CSS class that will be added to this component's Element. This can be useful
         * for adding customized styles to the component or any of its children using standard CSS rules.
         *
         * @since 1.1.0
         *
         * Optional, Defaults to: ''
         */
        cls?: string;

        /**
         * CSS Class to be added to a components root level element to give distinction to it via styling.
         */
        componentCls?: string;

        /**
         * The sizing and positioning of a Component's internal Elements is the responsibility of the Component's layout
         * manager which sizes a Component's internal structure in response to the Component being sized.
         *
         * Generally, developers will not use this configuration as all provided Components which need their internal
         * elements sizing (Such as {@link Ext.form.field.Base input fields}) come with their own componentLayout managers.
         *
         * The {@link Ext.layout.container.Auto default layout manager} will be used on instances of the base Ext.Component
         * class which simply sizes the Component's encapsulating element to the height and width specified in the
         * {@link #setSize} method.
         */
        componentLayout?: string|any;

        /**
         * Specify an existing HTML element, or the 'id' of an existing HTML element to use as the content for this component.
         *
         * This config option is used to take an existing HTML element and place it in the layout element of a new component
         * (it simply moves the specified DOM element _after the Component is rendered_ to use as the content.
         *
         * **Notes:**
         *
         * The specified HTML element is appended to the layout element of the component _after any configured
         * {@link #html HTML} has been inserted_, and so the document will not contain this element at the time
         * the {@link #event-render} event is fired.
         *
         * The specified HTML element used will not participate in any **'{@link Ext.container.Container#layout layout}'**
         * scheme that the Component may use. It is just HTML. Layouts operate on child
         * **'{@link Ext.container.Container#cfg-items items}'**.
         *
         * Add either the 'x-hidden' or the 'x-hide-display' CSS class to prevent a brief flicker of the content before it
         * is rendered to the panel.
         *
         * @since 3.4.0
         */
        contentEl?: string;

        /**
         * The initial set of data to apply to the '{@link #tpl}' to update the content area of the Component.
         *
         * @since 3.4.0
         */
        data?: any;

        /**
         * 'true' to disable the component.
         * @since 2.3.0
         */
        disabled?: boolean;

        /**
         * CSS class to add when the Component is disabled.
         *
         * Optional, Defaults to: 'x-item-disabled'
         */
        disabledCls?: string;

        /**
         * Create the Component as a floating and use absolute positioning.
         *
         * The z-index of floating Components is handled by a ZIndexManager. If you simply render a floating Component into the DOM, it will be managed
         * by the global {@link Ext.WindowManager WindowManager}.
         *
         * If you include a floating Component as a child item of a Container, then upon render, Ext JS will seek an ancestor floating Component to house a new
         * ZIndexManager instance to manage its descendant floaters. If no floating ancestor can be found, the global WindowManager will be used.
         *
         * When a floating Component which has a ZindexManager managing descendant floaters is destroyed, those descendant floaters will also be destroyed.
         */
        floating?: boolean;

        /**
         * Specify as 'true' to have the Component inject framing elements within the Component at render time to provide a
         * graphical rounded frame around the Component content.
         *
         * This is only necessary when running on outdated, or non standard-compliant browsers such as Microsoft's Internet
         * Explorer prior to version 9 which do not support rounded corners natively.
         *
         * The extra space taken up by this framing is available from the read only property {@link #frameSize}.
         */
        frame?: boolean;

        /**
         * The height of this component in pixels.
         */
        height?: number;

        /**
         * 'true' to hide the component.
         * @since 2.3.0
         */
        hidden?: boolean;

        /**
         * A String which specifies how this Component's encapsulating DOM element will be hidden. Values may be:
         *
         *   - ''display'' : The Component will be hidden using the 'display: none' style.
         *   - ''visibility'' : The Component will be hidden using the 'visibility: hidden' style.
         *   - ''offsets'' : The Component will be hidden by absolutely positioning it out of the visible area of the document.
         *     This is useful when a hidden Component must maintain measurable dimensions. Hiding using 'display' results in a
         *     Component having zero dimensions.
         *
         * @since 1.1.0
         */
        hideMode?: string;

        /**
         * An HTML fragment, or a {@link Ext.DomHelper DomHelper} specification to use as the layout element content.
         * The HTML content is added after the component is rendered, so the document will not contain this HTML at the time
         * the {@link #event-render} event is fired. This content is inserted into the body _before_ any configured {@link #contentEl}
         * is appended.
         *
         * @since 3.4.0
         *
         * Optional, Defaults to: ''
         */
        html?: string|any;

        /**
         * The **unique id of this component instance.**
         *
         * It should not be necessary to use this configuration except for singleton objects in your application. Components
         * created with an 'id' may be accessed globally using {@link Ext#getCmp Ext.getCmp}.
         *
         * Instead of using assigned ids, use the {@link #itemId} config, and {@link Ext.ComponentQuery ComponentQuery}
         * which provides selector-based searching for Sencha Components analogous to DOM querying. The {@link
         * Ext.container.Container Container} class contains {@link Ext.container.Container#down shortcut methods} to query
         * its descendant Components by selector.
         *
         * Note that this 'id' will also be used as the element id for the containing HTML element that is rendered to the
         * page for this component. This allows you to write id-based CSS rules to style the specific instance of this
         * component uniquely, and also to select sub-elements using this component's 'id' as the parent.
         *
         * **Note:** To avoid complications imposed by a unique 'id' also see '{@link #itemId}'.
         *
         * **Note:** To access the container of a Component see '{@link #ownerCt}'.
         *
         * Defaults to an {@link #getId auto-assigned id}.
         *
         * @since 1.1.0
         */
        id?: string;

        /**
         * An 'itemId' can be used as an alternative way to get a reference to a component when no object reference is
         * available. Instead of using an '{@link #id}' with {@link Ext}.{@link Ext#getCmp getCmp}, use 'itemId' with
         * {@link Ext.container.Container}.{@link Ext.container.Container#getComponent getComponent} which will retrieve
         * 'itemId''s or {@link #id}'s. Since 'itemId''s are an index to the container's internal MixedCollection, the
         * 'itemId' is scoped locally to the container -- avoiding potential conflicts with {@link Ext.ComponentManager}
         * which requires a **unique** '{@link #id}'.
         *
         *     var c = new Ext.panel.Panel({ //
         *         {@link Ext.Component#height height}: 300,
         *         {@link #renderTo}: document.body,
         *         {@link Ext.container.Container#layout layout}: 'auto',
         *         {@link Ext.container.Container#cfg-items items}: [
         *             {
         *                 itemId: 'p1',
         *                 {@link Ext.panel.Panel#title title}: 'Panel 1',
         *                 {@link Ext.Component#height height}: 150
         *             },
         *             {
         *                 itemId: 'p2',
         *                 {@link Ext.panel.Panel#title title}: 'Panel 2',
         *                 {@link Ext.Component#height height}: 150
         *             }
         *         ]
         *     })
         *     p1 = c.{@link Ext.container.Container#getComponent getComponent}('p1'); // not the same as {@link Ext#getCmp Ext.getCmp()}
         *     p2 = p1.{@link #ownerCt}.{@link Ext.container.Container#getComponent getComponent}('p2'); // reference via a sibling
         *
         * Also see {@link #id}, '{@link Ext.container.Container#query}', '{@link Ext.container.Container#down}' and
         * '{@link Ext.container.Container#child}'.
         *
         * **Note**: to access the container of an item see {@link #ownerCt}.
         *
         * @since 3.4.0
         */
        itemId?: string;

        /**
         * A configuration object or an instance of a {@link Ext.ComponentLoader} to load remote content
         * for this Component.
         *
         *     Ext.create('Ext.Component', {
         *         loader: {
         *             url: 'content.html',
         *             autoLoad: true
         *         },
         *         renderTo: Ext.getBody()
         *     });
         */
        loader?: Ext.ComponentLoader|any;

        /**
         * Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can
         * be a CSS style specification for each style, for example: '10 5 3 10' (top, right, bottom, left).
         */
        margin?: number|string;

        /**
         * The maximum value in pixels which this Component will set its height to.
         *
         * **Warning:** This will override any size management applied by layout managers.
         */
        maxHeight?: number;

        /**
         * The maximum value in pixels which this Component will set its width to.
         *
         * **Warning:** This will override any size management applied by layout managers.
         */
        maxWidth?: number;

        /**
         * The minimum value in pixels which this Component will set its height to.
         *
         * **Warning:** This will override any size management applied by layout managers.
         */
        minHeight?: number;

        /**
         * The minimum value in pixels which this Component will set its width to.
         *
         * **Warning:** This will override any size management applied by layout managers.
         */
        minWidth?: number;

        /**
         * An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element,
         * and removed when the mouse moves out. This can be useful for adding customized 'active' or 'hover' styles to the
         * component or any of its children using standard CSS rules.
         *
         * @since 2.3.0
         *
         * Optional, Defaults to: ''
         */
        overCls?: string;

        /**
         * Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it
         * can be a CSS style specification for each style, for example: '10 5 3 10' (top, right, bottom, left).
         */
        padding?: number|string;

        /**
         * An array of plugins to be added to this component. Can also be just a single plugin instead of array.
         *
         * Plugins provide custom functionality for a component. The only requirement for
         * a valid plugin is that it contain an 'init' method that accepts a reference of type Ext.Component. When a component
         * is created, if any plugins are available, the component will call the init method on each plugin, passing a
         * reference to itself. Each plugin can then call methods or respond to events on the component as needed to provide
         * its functionality.
         *
         * Plugins can be added to component by either directly referencing the plugin instance:
         *
         *     plugins: [Ext.create('Ext.grid.plugin.CellEditing', {clicksToEdit: 1})],
         *
         * By using config object with ptype:
         *
         *     plugins: [{ptype: 'cellediting', clicksToEdit: 1}],
         *
         * Or with just a ptype:
         *
         *     plugins: ['cellediting', 'gridviewdragdrop'],
         *
         * See {@link Ext.enums.Plugin} for list of all ptypes.
         *
         * @since 2.3.0
         */
        plugins?: Ext.AbstractPlugin|any|Ext.enums.Plugin;

        /**
         * The data used by {@link #renderTpl} in addition to the following property values of the component:
         *
         * - id
         * - ui
         * - uiCls
         * - baseCls
         * - componentCls
         * - frame
         *
         * See {@link #renderSelectors} and {@link #cfg-childEls} for usage examples.
         */
        renderData?: any;

        /**
         * An object containing properties specifying {@link Ext.DomQuery DomQuery} selectors which identify child elements
         * created by the render process.
         *
         * After the Component's internal structure is rendered according to the {@link #renderTpl}, this object is iterated through,
         * and the found Elements are added as properties to the Component using the 'renderSelector' property name.
         *
         * For example, a Component which renders a title and description into its element:
         *
         *     Ext.create('Ext.Component', {
         *         renderTo: Ext.getBody(),
         *         renderTpl: [
         *             '<h1 class="title">{title}</h1>',
         *             '<p>{desc}</p>'
         *         ],
         *         renderData: {
         *             title: "Error",
         *             desc: "Something went wrong"
         *         },
         *         renderSelectors: {
         *             titleEl: 'h1.title',
         *             descEl: 'p'
         *         },
         *         listeners: {
         *             afterrender: function(cmp){
         *                 // After rendering the component will have a titleEl and descEl properties
         *                 cmp.titleEl.setStyle({color: "red"});
         *             }
         *         }
         *     });
         *
         * For a faster, but less flexible, alternative that achieves the same end result (properties for child elements on the
         * Component after render), see {@link #cfg-childEls} and {@link #addChildEls}.
         */
        renderSelectors?: any;

        /**
         * Specify the 'id' of the element, a DOM element or an existing Element that this component will be rendered into.
         *
         * **Notes:**
         *
         * Do *not* use this option if the Component is to be a child item of a {@link Ext.container.Container Container}.
         * It is the responsibility of the {@link Ext.container.Container Container}'s
         * {@link Ext.container.Container#layout layout manager} to render and manage its child items.
         *
         * When using this config, a call to 'render()' is not required.
         *
         * See also: {@link #method-render}.
         *
         * @since 2.3.0
         */
        renderTo?: string|HTMLElement|Ext.dom.Element;

        /**
         * True to layout this component and its descendants in "rtl" (right-to-left) mode.
         * Can be explicitly set to false to override a true value inherited from an ancestor.
         */
        rtl?: boolean;

        /**
         * If this property is a number, it is interpreted as follows:
         *
         *   - 0: Neither width nor height depend on content. This is equivalent to 'false'.
         *   - 1: Width depends on content (shrink wraps), but height does not.
         *   - 2: Height depends on content (shrink wraps), but width does not. The default.
         *   - 3: Both width and height depend on content (shrink wrap). This is equivalent to 'true'.
         *
         * In CSS terms, shrink-wrap width is analogous to an inline-block element as opposed
         * to a block-level element. Some container layouts always shrink-wrap their children,
         * effectively ignoring this property (e.g., {@link Ext.layout.container.HBox},
         * {@link Ext.layout.container.VBox}, {@link Ext.layout.component.Dock}).
         *
         * Optional, Defaults to: 2
         */
        shrinkWrap?: boolean|number;

        /**
         * A custom style specification to be applied to this component's Element. Should be a valid argument to
         * {@link Ext.Element#applyStyles}.
         *
         *     new Ext.panel.Panel({
         *         title: 'Some Title',
         *         renderTo: Ext.getBody(),
         *         width: 400, height: 300,
         *         layout: 'form',
         *         items: [{
         *             xtype: 'textarea',
         *             style: {
         *                 width: '95%',
         *                 marginBottom: '10px'
         *             }
         *         },
         *         new Ext.button.Button({
         *             text: 'Send',
         *             minWidth: '100',
         *             style: {
         *                 marginBottom: '10px'
         *             }
         *         })
         *         ]
         *     });
         *
         * @since 1.1.0
         */
        style?: string|any;

        /**
         * An {@link Ext.Template}, {@link Ext.XTemplate} or an array of strings to form an Ext.XTemplate. Used in
         * conjunction with the '{@link #data}' and '{@link #tplWriteMode}' configurations.
         *
         * @since 3.4.0
         */
        tpl?: Ext.XTemplate|Ext.Template|string;

        /**
         * The Ext.(X)Template method to use when updating the content area of the Component.
         * See '{@link Ext.XTemplate#overwrite}' for information on default mode.
         *
         * @since 3.4.0
         */
        tplWriteMode?: string;

        /**
         * A UI style for a component.
         */
        ui?: string;

        /**
         * The width of this component in pixels.
         */
        width?: number;

        /**
         * This property provides a shorter alternative to creating objects than using a full
         * class name. Using 'xtype' is the most common way to define component instances,
         * especially in a container. For example, the items in a form containing text fields
         * could be created explicitly like so:
         *
         *      items: [
         *          Ext.create('Ext.form.field.Text', {
         *              fieldLabel: 'Foo'
         *          }),
         *          Ext.create('Ext.form.field.Text', {
         *              fieldLabel: 'Bar'
         *          }),
         *          Ext.create('Ext.form.field.Number', {
         *              fieldLabel: 'Num'
         *          })
         *      ]
         *
         * But by using 'xtype', the above becomes:
         *
         *      items: [
         *          {
         *              xtype: 'textfield',
         *              fieldLabel: 'Foo'
         *          },
         *          {
         *              xtype: 'textfield',
         *              fieldLabel: 'Bar'
         *          },
         *          {
         *              xtype: 'numberfield',
         *              fieldLabel: 'Num'
         *          }
         *      ]
         *
         * When the 'xtype' is common to many items, {@link Ext.container.AbstractContainer#defaultType}
         * is another way to specify the 'xtype' for all items that don't have an explicit 'xtype':
         *
         *      defaultType: 'textfield',
         *      items: [
         *          { fieldLabel: 'Foo' },
         *          { fieldLabel: 'Bar' },
         *          { fieldLabel: 'Num', xtype: 'numberfield' }
         *      ]
         *
         * Each member of the 'items' array is now just a "configuration object". These objects
         * are used to create and configure component instances. A configuration object can be
         * manually used to instantiate a component using {@link Ext#widget}:
         *
         *      var text1 = Ext.create('Ext.form.field.Text', {
         *          fieldLabel: 'Foo'
         *      });
         *
         *      // or alternatively:
         *
         *      var text1 = Ext.widget({
         *          xtype: 'textfield',
         *          fieldLabel: 'Foo'
         *      });
         *
         * This conversion of configuration objects into instantiated components is done when
         * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
         * process. As part of the same process, the 'items' array is converted from its raw
         * array form into a {@link Ext.util.MixedCollection} instance.
         *
         * You can define your own 'xtype' on a custom {@link Ext.Component component} by specifying
         * the 'xtype' property in {@link Ext#define}. For example:
         *
         *     Ext.define('MyApp.PressMeButton', {
         *         extend: 'Ext.button.Button',
         *         xtype: 'pressmebutton',
         *         text: 'Press Me'
         *     });
         *
         * Care should be taken when naming an 'xtype' in a custom component because there is
         * a single, shared scope for all xtypes. Third part components should consider using
         * a prefix to avoid collisions.
         *
         *     Ext.define('Foo.form.CoolButton', {
         *         extend: 'Ext.button.Button',
         *         xtype: 'ux-coolbutton',
         *         text: 'Cool!'
         *     });
         *
         * See {@link Ext.enums.Widget} for list of all available xtypes.
         *
         * @since 2.3.0
         */
        xtype?: Ext.enums.Widget;
    }

    /**
     * An abstract base class which provides shared methods for Components across the Sencha product line.
     *
     * Please refer to sub class's documentation.
     */
    export class AbstractComponent extends Ext.Base implements Ext.AbstractComponentConfig {
        /**
         * Setting this property to 'true' causes the {@link #isLayoutRoot} method to return
         * 'true' and stop the search for the top-most component for a layout.
         *
         * Optional, Defaults to: false
         */
        protected _isLayoutRoot: boolean;

        /**
         * The name of the padding property that is used by the layout to manage
         * padding.  See {@link Ext.layout.container.Auto#managePadding managePadding}
         *
         * Optional, Defaults to: 'padding'
         */
        contentPaddingProperty: string;

        /**
         * Indicates whether or not the component can be dragged.
         * @readonly
         */
        draggable: boolean;

        /**
         * @readonly
         * Indicates the width of any framing elements which were added within the encapsulating
         * element to provide graphical, rounded borders. See the {@link #frame} config. This
         * property is 'null' if the component is not framed.
         *
         * This is an object containing the frame width in pixels for all four sides of the
         * Component containing the following properties:
         *
         * The width of the top framing element in pixels.
         * The width of the right framing element in pixels.
         * The width of the bottom framing element in pixels.
         * The width of the left framing element in pixels.
         * The total width of the left and right framing elements in pixels.
         * The total height of the top and right bottom elements in pixels.
         */
        frameSize: any;

        /**
         * 'true' in this class to identify an object as an instantiated Component, or subclass thereof.
         */
        isComponent: boolean;

        /**
         * This is an internal flag that you use when creating custom components. By default this is set to 'true' which means
         * that every component gets a mask when it's disabled. Components like FieldContainer, FieldSet, Field, Button, Tab
         * override this property to 'false' since they want to implement custom disable logic.
         */
        maskOnDisable: boolean;

        /**
         * This Component's owner {@link Ext.container.Container Container} (is set automatically
         * when this Component is added to a Container).
         *
         * *Important.* This is not a universal upwards navigation pointer. It indicates the Container which owns and manages
         * this Component if any. There are other similar relationships such as the {@link Ext.button.Button button} which activates a {@link Ext.button.Button#cfg-menu menu}, or the
         * {@link Ext.menu.Item menu item} which activated a {@link Ext.menu.Item#cfg-menu submenu}, or the
         * {@link Ext.grid.column.Column column header} which activated the column menu.
         *
         * These differences are abstracted away by the {@link #up} method.
         *
         * **Note**: to access items within the Container see {@link #itemId}.
         * @readonly
         * @since 2.3.0
         */
        ownerCt: Ext.container.Container;

        /**
         * Indicates whether or not the component has been rendered.
         * @readonly
         * @since 1.1.0
         */
        rendered: boolean;

        /**
         * A tag name or {@link Ext.DomHelper DomHelper} spec used to create the {@link #getEl Element} which will
         * encapsulate this Component.
         *
         * You do not normally need to specify this. For the base classes {@link Ext.Component} and
         * {@link Ext.container.Container}, this defaults to **'div'**. The more complex Sencha classes use a more
         * complex DOM structure specified by their own {@link #renderTpl}s.
         *
         * This is intended to allow the developer to create application-specific utility Components encapsulated by
         * different DOM elements. Example usage:
         *
         *     {
         *         xtype: 'component',
         *         autoEl: {
         *             tag: 'img',
         *             src: 'http://www.example.com/example.jpg'
         *         }
         *     }, {
         *         xtype: 'component',
         *         autoEl: {
         *             tag: 'blockquote',
         *             html: 'autoEl is cool!'
         *         }
         *     }, {
         *         xtype: 'container',
         *         autoEl: 'ul',
         *         cls: 'ux-unordered-list',
         *         items: {
         *             xtype: 'component',
         *             autoEl: 'li',
         *             html: 'First list item'
         *         }
         *     }
         *
         * @since 2.3.0
         */
        autoEl: string|any;

        /**
         * An alias for {@link #loader} config which also allows to specify just a string which will be
         * used as the url that's automatically loaded:
         *
         *     Ext.create('Ext.Component', {
         *         autoLoad: 'content.html',
         *         renderTo: Ext.getBody()
         *     });
         *
         * The above is the same as:
         *
         *     Ext.create('Ext.Component', {
         *         loader: {
         *             url: 'content.html',
         *             autoLoad: true
         *         },
         *         renderTo: Ext.getBody()
         *     });
         *
         * Don't use it together with {@link #loader} config.
         *
         * @deprecated 4.1.1 Use {@link #loader} config instead.
         */
        autoLoad: Ext.ComponentLoader|any|string|boolean;

        /**
         * This config is intended mainly for non-{@link #cfg-floating} Components which may or may not be shown. Instead of using
         * {@link #renderTo} in the configuration, and rendering upon construction, this allows a Component to render itself
         * upon first _{@link Ext.Component#method-show show}_. If {@link #cfg-floating} is 'true', the value of this config is omitted as if it is 'true'.
         *
         * Specify as 'true' to have this Component render to the document body upon first show.
         *
         * Specify as an element, or the ID of an element to have this Component render to a specific element upon first
         * show.
         */
        autoRender: boolean|string|HTMLElement|Ext.dom.Element;

        /**
         * 'true' to automatically show the component upon creation. This config option may only be used for
         * {@link #floating} components or components that use {@link #autoRender}.
         *
         * @since 2.3.0
         */
        autoShow: boolean;

        /**
         * The base CSS class to apply to this component's element. This will also be prepended to elements within this
         * component like Panel's body will get a class 'x-panel-body'. This means that if you create a subclass of Panel, and
         * you want it to get all the Panels styling for the element and the body, you leave the 'baseCls' 'x-panel' and use
         * 'componentCls' to add specific styling for this component.
         *
         * Optional, Defaults to: 'x-component'
         */
        baseCls: string;

        /**
         * Specifies the border size for this component. The border can be a single numeric value to apply to all sides or it can
         * be a CSS style specification for each style, for example: '10 5 3 10' (top, right, bottom, left).
         *
         * For components that have no border by default, setting this won't make the border appear by itself.
         * You also need to specify border color and style:
         *
         *     border: 5,
         *     style: {
         *         borderColor: 'red',
         *         borderStyle: 'solid'
         *     }
         *
         * To turn off the border, use 'border: false'.
         */
        border: number|string|boolean;

        /**
         * An array describing the child elements of the Component. Each member of the array
         * is an object with these properties:
         *
         * - 'name' - The property name on the Component for the child element.
         * - 'itemId' - The id to combine with the Component's id that is the id of the child element.
         * - 'id' - The id of the child element.
         *
         * If the array member is a string, it is equivalent to '{ name: m, itemId: m }'.
         *
         * For example, a Component which renders a title and body text:
         *
         *     @example
         *     Ext.create('Ext.Component', {
         *         renderTo: Ext.getBody(),
         *         renderTpl: [
         *             '<h1 id="{id}-title">{title}</h1>',
         *             '<p>{msg}</p>',
         *         ],
         *         renderData: {
         *             title: "Error",
         *             msg: "Something went wrong"
         *         },
         *         childEls: ["title"],
         *         listeners: {
         *             afterrender: function(cmp){
         *                 // After rendering the component will have a title property
         *                 cmp.title.setStyle({color: "red"});
         *             }
         *         }
         *     });
         *
         * A more flexible, but somewhat slower, approach is {@link #renderSelectors}.
         */
        childEls: any;

        /**
         * An optional extra CSS class that will be added to this component's Element. This can be useful
         * for adding customized styles to the component or any of its children using standard CSS rules.
         *
         * @since 1.1.0
         *
         * Optional, Defaults to: ''
         */
        cls: string;

        /**
         * CSS Class to be added to a components root level element to give distinction to it via styling.
         */
        componentCls: string;

        /**
         * The sizing and positioning of a Component's internal Elements is the responsibility of the Component's layout
         * manager which sizes a Component's internal structure in response to the Component being sized.
         *
         * Generally, developers will not use this configuration as all provided Components which need their internal
         * elements sizing (Such as {@link Ext.form.field.Base input fields}) come with their own componentLayout managers.
         *
         * The {@link Ext.layout.container.Auto default layout manager} will be used on instances of the base Ext.Component
         * class which simply sizes the Component's encapsulating element to the height and width specified in the
         * {@link #setSize} method.
         */
        componentLayout: string|any;

        /**
         * Specify an existing HTML element, or the 'id' of an existing HTML element to use as the content for this component.
         *
         * This config option is used to take an existing HTML element and place it in the layout element of a new component
         * (it simply moves the specified DOM element _after the Component is rendered_ to use as the content.
         *
         * **Notes:**
         *
         * The specified HTML element is appended to the layout element of the component _after any configured
         * {@link #html HTML} has been inserted_, and so the document will not contain this element at the time
         * the {@link #event-render} event is fired.
         *
         * The specified HTML element used will not participate in any **'{@link Ext.container.Container#layout layout}'**
         * scheme that the Component may use. It is just HTML. Layouts operate on child
         * **'{@link Ext.container.Container#cfg-items items}'**.
         *
         * Add either the 'x-hidden' or the 'x-hide-display' CSS class to prevent a brief flicker of the content before it
         * is rendered to the panel.
         *
         * @since 3.4.0
         */
        contentEl: string;

        /**
         * The initial set of data to apply to the '{@link #tpl}' to update the content area of the Component.
         *
         * @since 3.4.0
         */
        data: any;

        /**
         * 'true' to disable the component.
         * @since 2.3.0
         */
        disabled: boolean;

        /**
         * CSS class to add when the Component is disabled.
         *
         * Optional, Defaults to: 'x-item-disabled'
         */
        disabledCls: string;

        /**
         * Create the Component as a floating and use absolute positioning.
         *
         * The z-index of floating Components is handled by a ZIndexManager. If you simply render a floating Component into the DOM, it will be managed
         * by the global {@link Ext.WindowManager WindowManager}.
         *
         * If you include a floating Component as a child item of a Container, then upon render, Ext JS will seek an ancestor floating Component to house a new
         * ZIndexManager instance to manage its descendant floaters. If no floating ancestor can be found, the global WindowManager will be used.
         *
         * When a floating Component which has a ZindexManager managing descendant floaters is destroyed, those descendant floaters will also be destroyed.
         */
        floating: boolean;

        /**
         * Specify as 'true' to have the Component inject framing elements within the Component at render time to provide a
         * graphical rounded frame around the Component content.
         *
         * This is only necessary when running on outdated, or non standard-compliant browsers such as Microsoft's Internet
         * Explorer prior to version 9 which do not support rounded corners natively.
         *
         * The extra space taken up by this framing is available from the read only property {@link #frameSize}.
         */
        frame: boolean;

        /**
         * The height of this component in pixels.
         */
        height: number;

        /**
         * 'true' to hide the component.
         * @since 2.3.0
         */
        hidden: boolean;

        /**
         * A String which specifies how this Component's encapsulating DOM element will be hidden. Values may be:
         *
         *   - ''display'' : The Component will be hidden using the 'display: none' style.
         *   - ''visibility'' : The Component will be hidden using the 'visibility: hidden' style.
         *   - ''offsets'' : The Component will be hidden by absolutely positioning it out of the visible area of the document.
         *     This is useful when a hidden Component must maintain measurable dimensions. Hiding using 'display' results in a
         *     Component having zero dimensions.
         *
         * @since 1.1.0
         */
        hideMode: string;

        /**
         * An HTML fragment, or a {@link Ext.DomHelper DomHelper} specification to use as the layout element content.
         * The HTML content is added after the component is rendered, so the document will not contain this HTML at the time
         * the {@link #event-render} event is fired. This content is inserted into the body _before_ any configured {@link #contentEl}
         * is appended.
         *
         * @since 3.4.0
         *
         * Optional, Defaults to: ''
         */
        html: string|any;

        /**
         * The **unique id of this component instance.**
         *
         * It should not be necessary to use this configuration except for singleton objects in your application. Components
         * created with an 'id' may be accessed globally using {@link Ext#getCmp Ext.getCmp}.
         *
         * Instead of using assigned ids, use the {@link #itemId} config, and {@link Ext.ComponentQuery ComponentQuery}
         * which provides selector-based searching for Sencha Components analogous to DOM querying. The {@link
         * Ext.container.Container Container} class contains {@link Ext.container.Container#down shortcut methods} to query
         * its descendant Components by selector.
         *
         * Note that this 'id' will also be used as the element id for the containing HTML element that is rendered to the
         * page for this component. This allows you to write id-based CSS rules to style the specific instance of this
         * component uniquely, and also to select sub-elements using this component's 'id' as the parent.
         *
         * **Note:** To avoid complications imposed by a unique 'id' also see '{@link #itemId}'.
         *
         * **Note:** To access the container of a Component see '{@link #ownerCt}'.
         *
         * Defaults to an {@link #getId auto-assigned id}.
         *
         * @since 1.1.0
         */
        id: string;

        /**
         * An 'itemId' can be used as an alternative way to get a reference to a component when no object reference is
         * available. Instead of using an '{@link #id}' with {@link Ext}.{@link Ext#getCmp getCmp}, use 'itemId' with
         * {@link Ext.container.Container}.{@link Ext.container.Container#getComponent getComponent} which will retrieve
         * 'itemId''s or {@link #id}'s. Since 'itemId''s are an index to the container's internal MixedCollection, the
         * 'itemId' is scoped locally to the container -- avoiding potential conflicts with {@link Ext.ComponentManager}
         * which requires a **unique** '{@link #id}'.
         *
         *     var c = new Ext.panel.Panel({ //
         *         {@link Ext.Component#height height}: 300,
         *         {@link #renderTo}: document.body,
         *         {@link Ext.container.Container#layout layout}: 'auto',
         *         {@link Ext.container.Container#cfg-items items}: [
         *             {
         *                 itemId: 'p1',
         *                 {@link Ext.panel.Panel#title title}: 'Panel 1',
         *                 {@link Ext.Component#height height}: 150
         *             },
         *             {
         *                 itemId: 'p2',
         *                 {@link Ext.panel.Panel#title title}: 'Panel 2',
         *                 {@link Ext.Component#height height}: 150
         *             }
         *         ]
         *     })
         *     p1 = c.{@link Ext.container.Container#getComponent getComponent}('p1'); // not the same as {@link Ext#getCmp Ext.getCmp()}
         *     p2 = p1.{@link #ownerCt}.{@link Ext.container.Container#getComponent getComponent}('p2'); // reference via a sibling
         *
         * Also see {@link #id}, '{@link Ext.container.Container#query}', '{@link Ext.container.Container#down}' and
         * '{@link Ext.container.Container#child}'.
         *
         * **Note**: to access the container of an item see {@link #ownerCt}.
         *
         * @since 3.4.0
         */
        itemId: string;

        /**
         * A configuration object or an instance of a {@link Ext.ComponentLoader} to load remote content
         * for this Component.
         *
         *     Ext.create('Ext.Component', {
         *         loader: {
         *             url: 'content.html',
         *             autoLoad: true
         *         },
         *         renderTo: Ext.getBody()
         *     });
         */
        loader: Ext.ComponentLoader|any;

        /**
         * Specifies the margin for this component. The margin can be a single numeric value to apply to all sides or it can
         * be a CSS style specification for each style, for example: '10 5 3 10' (top, right, bottom, left).
         */
        margin: number|string;

        /**
         * The maximum value in pixels which this Component will set its height to.
         *
         * **Warning:** This will override any size management applied by layout managers.
         */
        maxHeight: number;

        /**
         * The maximum value in pixels which this Component will set its width to.
         *
         * **Warning:** This will override any size management applied by layout managers.
         */
        maxWidth: number;

        /**
         * The minimum value in pixels which this Component will set its height to.
         *
         * **Warning:** This will override any size management applied by layout managers.
         */
        minHeight: number;

        /**
         * The minimum value in pixels which this Component will set its width to.
         *
         * **Warning:** This will override any size management applied by layout managers.
         */
        minWidth: number;

        /**
         * An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element,
         * and removed when the mouse moves out. This can be useful for adding customized 'active' or 'hover' styles to the
         * component or any of its children using standard CSS rules.
         *
         * @since 2.3.0
         *
         * Optional, Defaults to: ''
         */
        overCls: string;

        /**
         * Specifies the padding for this component. The padding can be a single numeric value to apply to all sides or it
         * can be a CSS style specification for each style, for example: '10 5 3 10' (top, right, bottom, left).
         */
        padding: number|string;

        /**
         * An array of plugins to be added to this component. Can also be just a single plugin instead of array.
         *
         * Plugins provide custom functionality for a component. The only requirement for
         * a valid plugin is that it contain an 'init' method that accepts a reference of type Ext.Component. When a component
         * is created, if any plugins are available, the component will call the init method on each plugin, passing a
         * reference to itself. Each plugin can then call methods or respond to events on the component as needed to provide
         * its functionality.
         *
         * Plugins can be added to component by either directly referencing the plugin instance:
         *
         *     plugins: [Ext.create('Ext.grid.plugin.CellEditing', {clicksToEdit: 1})],
         *
         * By using config object with ptype:
         *
         *     plugins: [{ptype: 'cellediting', clicksToEdit: 1}],
         *
         * Or with just a ptype:
         *
         *     plugins: ['cellediting', 'gridviewdragdrop'],
         *
         * See {@link Ext.enums.Plugin} for list of all ptypes.
         *
         * @since 2.3.0
         */
        plugins: Ext.AbstractPlugin|any|Ext.enums.Plugin;

        /**
         * The data used by {@link #renderTpl} in addition to the following property values of the component:
         *
         * - id
         * - ui
         * - uiCls
         * - baseCls
         * - componentCls
         * - frame
         *
         * See {@link #renderSelectors} and {@link #cfg-childEls} for usage examples.
         */
        renderData: any;

        /**
         * An object containing properties specifying {@link Ext.DomQuery DomQuery} selectors which identify child elements
         * created by the render process.
         *
         * After the Component's internal structure is rendered according to the {@link #renderTpl}, this object is iterated through,
         * and the found Elements are added as properties to the Component using the 'renderSelector' property name.
         *
         * For example, a Component which renders a title and description into its element:
         *
         *     Ext.create('Ext.Component', {
         *         renderTo: Ext.getBody(),
         *         renderTpl: [
         *             '<h1 class="title">{title}</h1>',
         *             '<p>{desc}</p>'
         *         ],
         *         renderData: {
         *             title: "Error",
         *             desc: "Something went wrong"
         *         },
         *         renderSelectors: {
         *             titleEl: 'h1.title',
         *             descEl: 'p'
         *         },
         *         listeners: {
         *             afterrender: function(cmp){
         *                 // After rendering the component will have a titleEl and descEl properties
         *                 cmp.titleEl.setStyle({color: "red"});
         *             }
         *         }
         *     });
         *
         * For a faster, but less flexible, alternative that achieves the same end result (properties for child elements on the
         * Component after render), see {@link #cfg-childEls} and {@link #addChildEls}.
         */
        renderSelectors: any;

        /**
         * Specify the 'id' of the element, a DOM element or an existing Element that this component will be rendered into.
         *
         * **Notes:**
         *
         * Do *not* use this option if the Component is to be a child item of a {@link Ext.container.Container Container}.
         * It is the responsibility of the {@link Ext.container.Container Container}'s
         * {@link Ext.container.Container#layout layout manager} to render and manage its child items.
         *
         * When using this config, a call to 'render()' is not required.
         *
         * See also: {@link #method-render}.
         *
         * @since 2.3.0
         */
        renderTo: string|HTMLElement|Ext.dom.Element;

        /**
         * An {@link Ext.XTemplate XTemplate} used to create the internal structure inside this Component's encapsulating
         * {@link #getEl Element}.
         *
         * You do not normally need to specify this. For the base classes {@link Ext.Component} and
         * {@link Ext.container.Container}, this defaults to **'null'** which means that they will be initially rendered
         * with no internal structure; they render their {@link #getEl Element} empty. The more specialized Ext JS and Sencha Touch
         * classes which use a more complex DOM structure, provide their own template definitions.
         *
         * This is intended to allow the developer to create application-specific utility Components with customized
         * internal structure.
         *
         * Upon rendering, any created child elements may be automatically imported into object properties using the
         * {@link #renderSelectors} and {@link #cfg-childEls} options.
         */
        protected renderTpl: Ext.XTemplate|string;

        /**
         * True to layout this component and its descendants in "rtl" (right-to-left) mode.
         * Can be explicitly set to false to override a true value inherited from an ancestor.
         */
        rtl: boolean;

        /**
         * If this property is a number, it is interpreted as follows:
         *
         *   - 0: Neither width nor height depend on content. This is equivalent to 'false'.
         *   - 1: Width depends on content (shrink wraps), but height does not.
         *   - 2: Height depends on content (shrink wraps), but width does not. The default.
         *   - 3: Both width and height depend on content (shrink wrap). This is equivalent to 'true'.
         *
         * In CSS terms, shrink-wrap width is analogous to an inline-block element as opposed
         * to a block-level element. Some container layouts always shrink-wrap their children,
         * effectively ignoring this property (e.g., {@link Ext.layout.container.HBox},
         * {@link Ext.layout.container.VBox}, {@link Ext.layout.component.Dock}).
         *
         * Optional, Defaults to: 2
         */
        shrinkWrap: boolean|number;

        /**
         * A custom style specification to be applied to this component's Element. Should be a valid argument to
         * {@link Ext.Element#applyStyles}.
         *
         *     new Ext.panel.Panel({
         *         title: 'Some Title',
         *         renderTo: Ext.getBody(),
         *         width: 400, height: 300,
         *         layout: 'form',
         *         items: [{
         *             xtype: 'textarea',
         *             style: {
         *                 width: '95%',
         *                 marginBottom: '10px'
         *             }
         *         },
         *         new Ext.button.Button({
         *             text: 'Send',
         *             minWidth: '100',
         *             style: {
         *                 marginBottom: '10px'
         *             }
         *         })
         *         ]
         *     });
         *
         * @since 1.1.0
         */
        style: string|any;

        /**
         * An {@link Ext.Template}, {@link Ext.XTemplate} or an array of strings to form an Ext.XTemplate. Used in
         * conjunction with the '{@link #data}' and '{@link #tplWriteMode}' configurations.
         *
         * @since 3.4.0
         */
        tpl: Ext.XTemplate|Ext.Template|string;

        /**
         * The Ext.(X)Template method to use when updating the content area of the Component.
         * See '{@link Ext.XTemplate#overwrite}' for information on default mode.
         *
         * @since 3.4.0
         */
        tplWriteMode: string;

        /**
         * A UI style for a component.
         */
        ui: string;

        /**
         * The width of this component in pixels.
         */
        width: number;

        /**
         * This property provides a shorter alternative to creating objects than using a full
         * class name. Using 'xtype' is the most common way to define component instances,
         * especially in a container. For example, the items in a form containing text fields
         * could be created explicitly like so:
         *
         *      items: [
         *          Ext.create('Ext.form.field.Text', {
         *              fieldLabel: 'Foo'
         *          }),
         *          Ext.create('Ext.form.field.Text', {
         *              fieldLabel: 'Bar'
         *          }),
         *          Ext.create('Ext.form.field.Number', {
         *              fieldLabel: 'Num'
         *          })
         *      ]
         *
         * But by using 'xtype', the above becomes:
         *
         *      items: [
         *          {
         *              xtype: 'textfield',
         *              fieldLabel: 'Foo'
         *          },
         *          {
         *              xtype: 'textfield',
         *              fieldLabel: 'Bar'
         *          },
         *          {
         *              xtype: 'numberfield',
         *              fieldLabel: 'Num'
         *          }
         *      ]
         *
         * When the 'xtype' is common to many items, {@link Ext.container.AbstractContainer#defaultType}
         * is another way to specify the 'xtype' for all items that don't have an explicit 'xtype':
         *
         *      defaultType: 'textfield',
         *      items: [
         *          { fieldLabel: 'Foo' },
         *          { fieldLabel: 'Bar' },
         *          { fieldLabel: 'Num', xtype: 'numberfield' }
         *      ]
         *
         * Each member of the 'items' array is now just a "configuration object". These objects
         * are used to create and configure component instances. A configuration object can be
         * manually used to instantiate a component using {@link Ext#widget}:
         *
         *      var text1 = Ext.create('Ext.form.field.Text', {
         *          fieldLabel: 'Foo'
         *      });
         *
         *      // or alternatively:
         *
         *      var text1 = Ext.widget({
         *          xtype: 'textfield',
         *          fieldLabel: 'Foo'
         *      });
         *
         * This conversion of configuration objects into instantiated components is done when
         * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
         * process. As part of the same process, the 'items' array is converted from its raw
         * array form into a {@link Ext.util.MixedCollection} instance.
         *
         * You can define your own 'xtype' on a custom {@link Ext.Component component} by specifying
         * the 'xtype' property in {@link Ext#define}. For example:
         *
         *     Ext.define('MyApp.PressMeButton', {
         *         extend: 'Ext.button.Button',
         *         xtype: 'pressmebutton',
         *         text: 'Press Me'
         *     });
         *
         * Care should be taken when naming an 'xtype' in a custom component because there is
         * a single, shared scope for all xtypes. Third part components should consider using
         * a prefix to avoid collisions.
         *
         *     Ext.define('Foo.form.CoolButton', {
         *         extend: 'Ext.button.Button',
         *         xtype: 'ux-coolbutton',
         *         text: 'Cool!'
         *     });
         *
         * See {@link Ext.enums.Widget} for list of all available xtypes.
         *
         * @since 2.3.0
         */
        xtype: Ext.enums.Widget;

        /**
         * @deprecated 4.1 Use {@link #addCls} instead.
         * @since 2.3.0
         */
        addClass();

        /**
         * Adds a CSS class to the top level element representing this component.
         * @param {String/String[]} cls The CSS class name to add.
         * @return {Ext.Component} Returns the Component to allow method chaining.
         */
        addCls(cls: string): Ext.Component;

        /**
         * Adds a 'cls' to the 'uiCls' array, which will also call {@link #addUIClsToElement} and adds to all elements of this
         * component.
         * @param {String/String[]} classes A string or an array of strings to add to the 'uiCls'.
         * @param {Object} skip (Boolean) skip 'true' to skip adding it to the class and do it later (via the return).
         */
        addClsWithUI(classes: string, skip: any);

        addListener(element: any, listeners: any, scope: any, options: any);

        /**
         * Save a property to the given state object if it is not its default or configured
         * value.
         *
         * @param {Object} state The state object.
         * @param {String} propName The name of the property on this object to save.
         * @param {String} [value] The value of the state property (defaults to 'this[propName]').
         * @return {Boolean} The state object or a new object if state was 'null' and the property
         * was saved.
         */
        protected addPropertyToState(state: any, propName: string, value?: string): boolean;

        /**
         * Method which adds a specified UI + 'uiCls' to the components element. Can be overridden to remove the UI from more
         * than just the components element.
         * @param {String} ui The UI to remove from the element.
         */
        addUIClsToElement(ui: string);

        /**
         * Called by the layout system after the Component has been laid out.
         *
         * @param {Number} width The width that was set
         * @param {Number} height The height that was set
         * @param {Number/undefined} oldWidth The old width, or 'undefined' if this was the initial layout.
         * @param {Number/undefined} oldHeight The old height, or 'undefined' if this was the initial layout.
         */
        protected afterComponentLayout(width: number, height: number, oldWidth?: number, oldHeight?: number);

        /**
         * Template method called after a Component has been positioned.
         */
        protected afterSetPosition(x: number, y: number);

        animate(animObj: any);

        /**
         * Template method to do any pre-blur processing.
         * @param {Ext.EventObject} e The event object
         */
        protected beforeBlur(e: Ext.EventObject);

        /**
         * Occurs before 'componentLayout' is run. Returning 'false' from this method will prevent the 'componentLayout' from
         * being executed.
         *
         * @param {Number} adjWidth The box-adjusted width that was set.
         * @param {Number} adjHeight The box-adjusted height that was set.
         */
        protected beforeComponentLayout(adjWidth: number, adjHeight: number);

        /**
         * Invoked before the Component is destroyed.
         */
        protected beforeDestroy();

        /**
         * Template method to do any pre-focus processing.
         * @param {Ext.EventObject} e The event object
         */
        protected beforeFocus(e: Ext.EventObject);

        /**
         * Occurs before componentLayout is run. In previous releases, this method could
         * return 'false' to prevent its layout but that is not supported in Ext JS 4.1 or
         * higher. This method is simply a notification of the impending layout to give the
         * component a chance to adjust the DOM. Ideally, DOM reads should be avoided at this
         * time to reduce expensive document reflows.
         */
        protected beforeLayout();

        /**
         * Creates new Component.
         * @param {Object} config  (optional) Config object.
         */
        constructor(config: Ext.AbstractComponentConfig);

        /**
         * Destroys the Component.
         * @since 1.1.0
         */
        destroy();

        /**
         * Disable the component.
         * @param {Boolean} [silent=false] Passing 'true' will suppress the 'disable' event from being fired.
         * @since 1.1.0
         */
        disable(silent?: boolean);

        /**
         * This method needs to be called whenever you change something on this component that requires the Component's
         * layout to be recalculated.
         * @return {Ext.container.Container} this
         */
        doComponentLayout(): Ext.container.Container;

        /**
         * Enable the component
         * @param {Boolean} [silent=false] Passing 'true' will suppress the 'enable' event from being fired.
         * @since 1.1.0
         */
        enable(silent?: boolean);

        /**
         * Retrieves plugin from this component's collection by its 'ptype'.
         * @param {String} ptype The Plugin's ptype as specified by the class's 'alias' configuration.
         * @return {Ext.AbstractPlugin} plugin instance.
         */
        findPlugin(ptype: string): Ext.AbstractPlugin;

        /**
         * Forces this component to redo its componentLayout.
         * @deprecated 4.1.0 Use {@link #updateLayout} instead.
         */
        forceComponentLayout();

        /**
         * Provides the link for Observable's 'fireEvent' method to bubble up the ownership hierarchy.
         * @return {Ext.container.Container} the Container which owns this Component.
         * @since 3.4.0
         */
        getBubbleTarget(): Ext.container.Container;

        /**
         * Retrieves the top level element representing this component.
         * @return {Ext.dom.Element}
         * @since 1.1.0
         */
        getEl(): Ext.dom.Element;

        /**
         * Gets the current height of the component's underlying element.
         * @return {Number}
         */
        getHeight(): number;

        /**
         * Retrieves the 'id' of this component. Will auto-generate an 'id' if one has not already been set.
         * @return {String}
         */
        getId(): string;

        /**
         * Returns the value of {@link #itemId} assigned to this component, or when that
         * is not set, returns the value of {@link #id}.
         * @return {String}
         */
        getItemId(): string;

        /**
         * Gets the {@link Ext.ComponentLoader} for this Component.
         * @return {Ext.ComponentLoader} The loader instance, null if it doesn't exist.
         */
        getLoader(): Ext.ComponentLoader;

        getLocalX();

        getLocalXY();

        getLocalY();

        /**
         * Retrieves a plugin from this component's collection by its 'pluginId'.
         * @return {Ext.AbstractPlugin} plugin instance.
         */
        getPlugin(pluginId: string): Ext.AbstractPlugin;

        /**
         * Gets the current size of the component's underlying element.
         * @return {Object} An object containing the element's size '{width: (element width), height: (element height)}'
         */
        getSize(): any;

        /**
         * Returns an object that describes how this component's width and height are managed.
         * All of these objects are shared and should not be modified.
         *
         * @return {Object} The size model for this component.
         * @return {Ext.layout.SizeModel} return.width The {@link Ext.layout.SizeModel size model}
         * for the width.
         * @return {Ext.layout.SizeModel} return.height The {@link Ext.layout.SizeModel size model}
         * for the height.
         */
        getSizeModel(): any;

        /**
         * The supplied default state gathering method for the AbstractComponent class.
         *
         * This method returns dimension settings such as 'flex', 'anchor', 'width' and 'height' along with 'collapsed'
         * state.
         *
         * Subclasses which implement more complex state should call the superclass's implementation, and apply their state
         * to the result if this basic state is to be saved.
         *
         * Note that Component state will only be saved if the Component has a {@link #stateId} and there as a StateProvider
         * configured for the document.
         *
         * @return {Object}
         */
        getState(): any;

        /**
         * Gets the current width of the component's underlying element.
         * @return {Number}
         */
        getWidth(): number;

        getX();

        /**
         * Returns this Component's xtype hierarchy as a slash-delimited string. For a list of all available xtypes, see the
         * {@link Ext.Component} header.
         *
         * **If using your own subclasses, be aware that a Component must register its own xtype to participate in
         * determination of inherited xtypes.**
         *
         * Example usage:
         *
         *     @example
         *     var t = new Ext.form.field.Text();
         *     alert(t.getXTypes());  // alerts 'component/field/textfield'
         *
         * @return {String} The xtype hierarchy string
         *
         * @since 2.3.0
         */
        getXTypes(): string;

        getXY();

        getY();

        /**
         * Checks if the specified CSS class exists on this element's DOM node.
         * @param {String} className The CSS class to check for.
         * @return {Boolean} 'true' if the class exists, else 'false'.
         */
        hasCls(className: string): boolean;

        /**
         * Checks if there is currently a specified 'uiCls'.
         * @param {String} cls The 'cls' to check.
         */
        hasUICls(cls: string);

        /**
         * Initialize any events on this component
         */
        protected initEvents();

        /**
         * Tests whether this Component matches the selector string.
         * @param {String} selector The selector string to test against.
         * @return {Boolean} 'true' if this Component matches the selector.
         */
        is(selector: string): boolean;

        /**
         * Determines whether this component is the descendant of a particular container.
         * @return {Boolean} 'true' if the component is the descendant of a particular container, otherwise 'false'.
         */
        isDescendantOf(container: Ext.container.Container): boolean;

        /**
         * Method to determine whether this Component is currently disabled.
         * @return {Boolean} the disabled state of this Component.
         */
        isDisabled(): boolean;

        /**
         * Method to determine whether this Component is draggable.
         * @return {Boolean} the draggable state of this component.
         */
        isDraggable(): boolean;

        /**
         * Method to determine whether this Component is droppable.
         * @return {Boolean} the droppable state of this component.
         */
        isDroppable(): boolean;

        /**
         * Method to determine whether this Component is floating.
         * @return {Boolean} the floating state of this component.
         */
        isFloating(): boolean;

        /**
         * Method to determine whether this Component is currently set to hidden.
         * @return {Boolean} the hidden state of this Component.
         */
        isHidden(): boolean;

        /**
         * Determines whether this Component is the root of a layout. This returns 'true' if
         * this component can run its layout without assistance from or impact on its owner.
         * If this component cannot run its layout given these restrictions, 'false' is returned
         * and its owner will be considered as the next candidate for the layout root.
         *
         * Setting the {@link #_isLayoutRoot} property to 'true' causes this method to always
         * return 'true'. This may be useful when updating a layout of a Container which shrink
         * wraps content, and you know that it will not change size, and so can safely be the
         * topmost participant in the layout run.
         */
        protected isLayoutRoot();

        /**
         * Returns 'true' if layout is suspended for this component. This can come from direct
         * suspension of this component's layout activity ({@link Ext.Container#suspendLayout}) or if one
         * of this component's containers is suspended.
         *
         * @return {Boolean} 'true' layout of this component is suspended.
         */
        isLayoutSuspended(): boolean;

        /**
         * Returns 'true' if this component is visible.
         *
         * @param {Boolean} [deep=false] Pass 'true' to interrogate the visibility status of all parent Containers to
         * determine whether this Component is truly visible to the user.
         *
         * Generally, to determine whether a Component is hidden, the no argument form is needed. For example when creating
         * dynamically laid out UIs in a hidden Container before showing them.
         *
         * @return {Boolean} 'true' if this component is visible, 'false' otherwise.
         *
         * @since 1.1.0
         */
        isVisible(deep?: boolean): boolean;

        /**
         * Tests whether or not this Component is of a specific xtype. This can test whether this Component is descended
         * from the xtype (default) or whether it is directly of the xtype specified ('shallow = true').
         *
         * **If using your own subclasses, be aware that a Component must register its own xtype to participate in
         * determination of inherited xtypes.**
         *
         * For a list of all available xtypes, see the {@link Ext.Component} header.
         *
         * Example usage:
         *
         *     @example
         *     var t = new Ext.form.field.Text();
         *     var isText = t.isXType('textfield');        // true
         *     var isBoxSubclass = t.isXType('field');       // true, descended from Ext.form.field.Base
         *     var isBoxInstance = t.isXType('field', true); // false, not a direct Ext.form.field.Base instance
         *
         * @param {String} xtype The xtype to check for this Component
         * @param {Boolean} [shallow=false] 'true' to check whether this Component is directly of the specified xtype, 'false' to
         * check whether this Component is descended from the xtype.
         * @return {Boolean} 'true' if this component descends from the specified xtype, 'false' otherwise.
         *
         * @since 2.3.0
         */
        isXType(xtype: string, shallow?: boolean): boolean;

        /**
         * Returns the next node in the Component tree in tree traversal order.
         *
         * Note that this is not limited to siblings, and if invoked upon a node with no matching siblings, will walk the
         * tree to attempt to find a match. Contrast with {@link #nextSibling}.
         * @param {String} [selector] A {@link Ext.ComponentQuery ComponentQuery} selector to filter the following nodes.
         * @return {Ext.Component} The next node (or the next node which matches the selector).
         * Returns 'null' if there is no matching node.
         */
        nextNode(selector?: string): Ext.Component;

        /**
         * Returns the next sibling of this Component.
         *
         * Optionally selects the next sibling which matches the passed {@link Ext.ComponentQuery ComponentQuery} selector.
         *
         * May also be referred to as **'next()'**
         *
         * Note that this is limited to siblings, and if no siblings of the item match, 'null' is returned. Contrast with
         * {@link #nextNode}
         * @param {String} [selector] A {@link Ext.ComponentQuery ComponentQuery} selector to filter the following items.
         * @return {Ext.Component} The next sibling (or the next sibling which matches the selector).
         * Returns 'null' if there is no matching sibling.
         */
        nextSibling(selector?: string): Ext.Component;

        /**
         * Method to manage awareness of when components are added to their
         * respective Container, firing an #added event. References are
         * established at add time rather than at render time.
         *
         * Allows addition of behavior when a Component is added to a
         * Container. At this stage, the Component is in the parent
         * Container's collection of child items. After calling the
         * superclass's 'onAdded', the 'ownerCt' reference will be present,
         * and if configured with a ref, the 'refOwner' will be set.
         *
         * @param {Ext.container.Container} container Container which holds the component.
         * @param {Number} pos Position at which the component was added.
         *
         * @since 3.4.0
         */
        protected onAdded(container: Ext.container.Container, pos: number);

        /**
         * Allows addition of behavior to the disable operation.
         * After calling the superclass's 'onDisable', the Component will be disabled.
         */
        protected onDisable();

        /**
         * Allows addition of behavior to the enable operation.
         * After calling the superclass's 'onEnable', the Component will be enabled.
         */
        protected onEnable();

        /**
         * Called after the component is moved, this method is empty by default but can be implemented by any
         * subclass that needs to perform custom logic after a move occurs.
         *
         * @param {Number} x The new x position.
         * @param {Number} y The new y position.
         */
        protected onPosition(x: number, y: number);

        /**
         * Method to manage awareness of when components are removed from their
         * respective Container, firing a #removed event. References are properly
         * cleaned up after removing a component from its owning container.
         *
         * Allows addition of behavior when a Component is removed from
         * its parent Container. At this stage, the Component has been
         * removed from its parent Container's collection of child items,
         * but has not been destroyed (It will be destroyed if the parent
         * Container's 'autoDestroy' is 'true', or if the remove call was
         * passed a truthy second parameter). After calling the
         * superclass's 'onRemoved', the 'ownerCt' and the 'refOwner' will not
         * be present.
         * @param {Boolean} destroying Will be passed as 'true' if the Container performing the remove operation will delete this
         * Component upon remove.
         *
         * @since 3.4.0
         */
        protected onRemoved(destroying: boolean);

        /**
         * Allows addition of behavior to the resize operation.
         *
         * Called when Ext.resizer.Resizer#drag event is fired.
         */
        protected onResize();

        /**
         * Template method to do any post-blur processing.
         * @param {Ext.EventObject} e The event object
         */
        protected postBlur(e: Ext.EventObject);

        /**
         * Returns the previous node in the Component tree in tree traversal order.
         *
         * Note that this is not limited to siblings, and if invoked upon a node with no matching siblings, will walk the
         * tree in reverse order to attempt to find a match. Contrast with {@link #previousSibling}.
         * @param {String} [selector] A {@link Ext.ComponentQuery ComponentQuery} selector to filter the preceding nodes.
         * @return {Ext.Component} The previous node (or the previous node which matches the selector).
         * Returns 'null' if there is no matching node.
         */
        previousNode(selector?: string): Ext.Component;

        /**
         * Returns the previous sibling of this Component.
         *
         * Optionally selects the previous sibling which matches the passed {@link Ext.ComponentQuery ComponentQuery}
         * selector.
         *
         * May also be referred to as **'prev()'**
         *
         * Note that this is limited to siblings, and if no siblings of the item match, 'null' is returned. Contrast with
         * {@link #previousNode}
         * @param {String} [selector] A {@link Ext.ComponentQuery ComponentQuery} selector to filter the preceding items.
         * @return {Ext.Component} The previous sibling (or the previous sibling which matches the selector).
         * Returns 'null' if there is no matching sibling.
         */
        previousSibling(selector?: string): Ext.Component;

        /**
         * Called by Component#doAutoRender
         *
         * Register a Container configured 'floating: true' with this Component's {@link Ext.ZIndexManager ZIndexManager}.
         *
         * Components added in this way will not participate in any layout, but will be rendered
         * upon first show in the way that {@link Ext.window.Window Window}s are.
         */
        registerFloatingItem();

        /**
         * Removes a CSS class from the top level element representing this component.
         * @param {String/String[]} cls The CSS class name to remove.
         * @returns {Ext.Component} Returns the Component to allow method chaining.
         */
        removeCls(cls: string);

        /**
         * Removes a 'cls' to the 'uiCls' array, which will also call {@link #removeUIClsFromElement} and removes it from all
         * elements of this component.
         * @param {String/String[]} cls A string or an array of strings to remove to the 'uiCls'.
         */
        removeClsWithUI(cls: string);

        /**
         * Method which removes a specified UI + 'uiCls' from the components element. The 'cls' which is added to the element
         * will be: 'this.baseCls + '-' + ui'.
         * @param {String} ui The UI to add to the element.
         */
        removeUIClsFromElement(ui: string);

        /**
         * @param {String/Number} border The border, see {@link #border}. If a falsey value is passed
         * the border will be removed.
         */
        setBorder(border: string|number);

        /**
         * Enable or disable the component.
         * @param {Boolean} disabled 'true' to disable.
         */
        setDisabled(disabled: boolean);

        /**
         * Sets the dock position of this component in its parent panel. Note that this only has effect if this item is part
         * of the 'dockedItems' collection of a parent that has a DockLayout (note that any Panel has a DockLayout by default)
         * @param {Object} dock The dock position.
         * @param {Boolean} [layoutParent=false] 'true' to re-layout parent.
         * @return {Ext.Component} this
         */
        setDocked(dock: any, layoutParent?: boolean): Ext.Component;

        /**
         * Sets the height of the component. This method fires the {@link #resize} event.
         *
         * @param {Number} height The new height to set. This may be one of:
         *
         *   - A Number specifying the new height in the {@link #getEl Element}'s {@link Ext.Element#defaultUnit}s (by default, pixels).
         *   - A String used to set the CSS height style.
         *   - _undefined_ to leave the height unchanged.
         *
         * @return {Ext.Component} this
         */
        setHeight(height: number): Ext.Component;

        setLocalX(x: any);

        setLocalXY(x: any, y: any);

        setLocalY(y: any);

        /**
         * Sets the margin on the target element.
         * @param {Number/String} margin The margin to set. See the {@link #margin} config.
         */
        setMargin(margin: number|string);

        /**
         * Sets the width and height of this Component. This method fires the {@link #resize} event. This method can accept
         * either width and height as separate arguments, or you can pass a size object like '{width:10, height:20}'.
         *
         * @param {Number/String/Object} width The new width to set. This may be one of:
         *
         *   - A Number specifying the new width in the {@link #getEl Element}'s {@link Ext.Element#defaultUnit}s (by default, pixels).
         *   - A String used to set the CSS width style.
         *   - A size object in the format '{width: widthValue, height: heightValue}'.
         *   - 'undefined' to leave the width unchanged.
         *
         * @param {Number/String} height The new height to set (not required if a size object is passed as the first arg).
         * This may be one of:
         *
         *   - A Number specifying the new height in the {@link #getEl Element}'s {@link Ext.Element#defaultUnit}s (by default, pixels).
         *   - A String used to set the CSS height style. Animation may **not** be used.
         *   - 'undefined' to leave the height unchanged.
         *
         * @return {Ext.Component} this
         */
        setSize(width: number|string|any, height: number|string): Ext.Component;

        /**
         * Sets the UI for the component. This will remove any existing UIs on the component. It will also loop through any
         * 'uiCls' set on the component and rename them so they include the new UI.
         * @param {String} ui The new UI for the component.
         */
        setUI(ui: string);

        /**
         * Convenience function to hide or show this component by Boolean.
         * @param {Boolean} visible 'true' to show, 'false' to hide.
         * @return {Ext.Component} this
         * @since 1.1.0
         */
        setVisible(visible: boolean): Ext.Component;

        /**
         * Sets the width of the component. This method fires the {@link #resize} event.
         *
         * @param {Number} width The new width to setThis may be one of:
         *
         *   - A Number specifying the new width in the {@link #getEl Element}'s {@link Ext.Element#defaultUnit}s (by default, pixels).
         *   - A String used to set the CSS width style.
         *
         * @return {Ext.Component} this
         */
        setWidth(width: number): Ext.Component;

        setX(x: any, animate: any);

        setXY(xy: any, animate: any);

        setY(y: any, animate: any);

        /**
         * Navigates up the ownership hierarchy searching for an ancestor Container which matches any passed simple selector or component.
         *
         * *Important.* There is not a universal upwards navigation pointer. There are several upwards relationships
         * such as the {@link Ext.button.Button button} which activates a {@link Ext.button.Button#cfg-menu menu}, or the
         * {@link Ext.menu.Item menu item} which activated a {@link Ext.menu.Item#cfg-menu submenu}, or the
         * {@link Ext.grid.column.Column column header} which activated the column menu.
         *
         * These differences are abstracted away by this method.
         *
         * Example:
         *
         *     var owningTabPanel = grid.up('tabpanel');
         *
         * @param {String/Ext.Component} [selector] The simple selector component or actual component to test. If not passed the immediate owner/activater is returned.
         * @param {String/Number/Ext.Component} [limit] This may be a selector upon which to stop the upward scan, or a limit of teh number of steps, or Component reference to stop on.
         * @return {Ext.container.Container} The matching ancestor Container (or 'undefined' if no match was found).
         */
        up(selector?: string|Ext.Component, limit?: string|number|Ext.Component): Ext.container.Container;

        /**
         * Update the content area of a component.
         * @param {String/Object} htmlOrData If this component has been configured with a template via the tpl config then
         * it will use this argument as data to populate the template. If this component was not configured with a template,
         * the components content area will be updated via Ext.Element update.
         * @param {Boolean} [loadScripts=false] Only legitimate when using the 'html' configuration.
         * @param {Function} [callback] Only legitimate when using the 'html' configuration. Callback to execute when
         * scripts have finished loading.
         *
         * @since 3.4.0
         */
        update(htmlOrData: string|any, loadScripts?: boolean, callback?: Function);

        /**
         * Fires after a Component has been visually activated.
         */
        activate(that: Ext.Component);

        /**
         * Fires after a Component had been added to a Container.
         * @param {Ext.container.Container} container Parent Container
         * @param {Number} pos position of Component
         * @since 3.4.0
         */
        added(that: Ext.Component, container: Ext.container.Container, pos: number);

        /**
         * Fires after the component rendering is finished.
         *
         * The 'afterrender' event is fired after this Component has been {@link #rendered}, been postprocessed by any
         * 'afterRender' method defined for the Component.
         * @since 3.4.0
         */
        afterrender(that: Ext.Component);

        /**
         * Fires before a Component has been visually activated. Returning 'false' from an event listener can prevent
         * the activate from occurring.
         */
        beforeactivate(that: Ext.Component);

        /**
         * Fires before a Component has been visually deactivated. Returning 'false' from an event listener can
         * prevent the deactivate from occurring.
         */
        beforedeactivate(that: Ext.Component);

        /**
         * Fires before the component is {@link #method-destroy}ed. Return 'false' from an event handler to stop the
         * {@link #method-destroy}.
         * @since 1.1.0
         */
        beforedestroy(that: Ext.Component);

        /**
         * Fires before the component is hidden when calling the {@link Ext.Component#method-hide hide} method. Return 'false' from an event
         * handler to stop the hide.
         * @since 1.1.0
         */
        beforehide(that: Ext.Component);

        /**
         * Fires before the component is {@link #rendered}. Return 'false' from an event handler to stop the
         * {@link #method-render}.
         * @since 1.1.0
         */
        beforerender(that: Ext.Component);

        /**
         * Fires before the component is shown when calling the {@link Ext.Component#method-show show} method. Return 'false' from an event
         * handler to stop the show.
         * @since 1.1.0
         */
        beforeshow(that: Ext.Component);

        /**
         * Fires when this Component loses focus.
         * @param {Ext.EventObject} The blur event.
         */
        blur(that: Ext.Component, The: Ext.EventObject);

        /**
         * Fires *one time* - after the component has been laid out for the first time at its initial size.
         * @param {Number} width The initial width.
         * @param {Number} height The initial height.
         */
        boxready(that: Ext.Component, width: number, height: number);

        /**
         * Fires after a Component has been visually deactivated.
         */
        deactivate(that: Ext.Component);

        /**
         * Fires when this Component receives focus.
         * @param {Ext.EventObject} The focus event.
         */
        focus(that: Ext.Component, The: Ext.EventObject);

        /**
         * Fires after the component is hidden. Fires after the component is hidden when calling the {@link Ext.Component#method-hide hide}
         * method.
         * @since 1.1.0
         */
        hide(that: Ext.Component);

        /**
         * Fires after the component is moved.
         * @param {Number} x The new x position.
         * @param {Number} y The new y position.
         */
        move(that: Ext.Component, x: number, y: number);

        /**
         * Fires when a component is removed from an Ext.container.Container
         * @param {Ext.container.Container} ownerCt Container which holds the component
         * @since 3.4.0
         */
        removed(that: Ext.Component, ownerCt: Ext.container.Container);

        /**
         * Fires after the component markup is {@link #rendered}.
         * @since 1.1.0
         */
        render(that: Ext.Component);

        /**
         * Fires after the component is resized. Note that this does *not* fire when the component is first laid out at its initial
         * size. To hook that point in the life cycle, use the {@link #boxready} event.
         * @param {Number} width The new width that was set.
         * @param {Number} height The new height that was set.
         * @param {Number} oldWidth The previous width.
         * @param {Number} oldHeight The previous height.
         */
        resize(that: Ext.Component, width: number, height: number, oldWidth: number, oldHeight: number);

        /**
         * Fires after the component is shown when calling the {@link Ext.Component#method-show show} method.
         * @since 1.1.0
         */
        show(that: Ext.Component);

        /**
         * Cancels layout of a component.
         */
        static cancelLayout(comp: Ext.Component);

        /**
         * Performs all pending layouts that were scheduled while
         * {@link Ext.AbstractComponent#suspendLayouts suspendLayouts} was in effect.
         */
        static flushLayouts();

        /**
         * Resumes layout activity in the whole framework.
         *
         * {@link Ext#suspendLayouts} is alias of {@link Ext.AbstractComponent#suspendLayouts}.
         *
         * @param {Boolean} [flush=false] 'true' to perform all the pending layouts. This can also be
         * achieved by calling {@link Ext.AbstractComponent#flushLayouts flushLayouts} directly.
         */
        static resumeLayouts(flush?: boolean);

        /**
         * Stops layouts from happening in the whole framework.
         *
         * It's useful to suspend the layout activity while updating multiple components and
         * containers:
         *
         *     Ext.suspendLayouts();
         *     // batch of updates...
         *     Ext.resumeLayouts(true);
         *
         * {@link Ext#suspendLayouts} is alias of {@link Ext.AbstractComponent#suspendLayouts}.
         *
         * See also {@link Ext#batchLayouts} for more abstract way of doing this.
         */
        static suspendLayouts();

        /**
         * Updates layout of a component.
         *
         * @param {Ext.Component} comp The component to update.
         * @param {Boolean} [defer=false] 'true' to just queue the layout if this component.
         */
        static updateLayout(comp: Ext.Component, defer?: boolean);
    }

    /**
     * Base Manager class
     */
    export class AbstractManager extends Ext.Base {
        /**
         * Contains all of the items currently managed
         */
        all: Ext.util.HashMap;

        constructor(config: any);

        /**
         * Executes the specified function once for each item in the collection.
         * @param {Function} fn The function to execute.
         * @param {String} fn.key The key of the item
         * @param {Number} fn.value The value of the item
         * @param {Number} fn.length The total number of items in the collection
         * @param {Boolean} fn.return False to cease iteration.
         * @param {Object} scope The scope to execute in. Defaults to 'this'.
         */
        each(fn: Function, fn_key: string, fn_value: number, fn_length: number, fn_return: boolean, scope: any);

        /**
         * Returns an item by id.
         * For additional details see {@link Ext.util.HashMap#get}.
         * @param {String} id The id of the item
         * @return {Object} The item, undefined if not found.
         */
        get(id: string): any;

        /**
         * Gets the number of items in the collection.
         * @return {Number} The number of items in the collection.
         */
        getCount(): number;

        /**
         * Checks if an item type is registered.
         * @param {String} type The mnemonic string by which the class may be looked up
         * @return {Boolean} Whether the type is registered.
         */
        isRegistered(type: string): boolean;

        /**
         * Registers a function that will be called when an item with the specified id is added to the manager.
         * This will happen on instantiation.
         * @param {String} id The item id
         * @param {Function} fn The callback function. Called with a single parameter, the item.
         * @param {Object} scope The scope (this reference) in which the callback is executed.
         * Defaults to the item.
         */
        onAvailable(id: string, fn: Function, scope: any);

        /**
         * Registers an item to be managed
         * @param {Object} item The item to register
         */
        register(item: any);

        /**
         * Registers a new item constructor, keyed by a type key.
         * @param {String} type The mnemonic string by which the class may be looked up.
         * @param {Function} cls The new instance class.
         */
        registerType(type: string, cls: Function);

        /**
         * Unregisters an item by removing it from this manager
         * @param {Object} item The item to unregister
         */
        unregister(item: any);
    }

    interface AbstractPluginConfig {
        /**
         * A name for the plugin that can be set at creation time to then retrieve the plugin
         * through {@link Ext.AbstractComponent#getPlugin getPlugin} method.  For example:
         *
         *     var grid = Ext.create('Ext.grid.Panel', {
         *         plugins: [{
         *             ptype: 'cellediting',
         *             clicksToEdit: 2,
         *             pluginId: 'cellplugin'
         *         }]
         *     });
         *
         *     // later on:
         *     var plugin = grid.getPlugin('cellplugin');
         */
        pluginId?: string;
    }

    /**
     * The AbstractPlugin class is the base class from which user-implemented plugins should inherit.
     *
     * This class defines the essential API of plugins as used by Components by defining the following methods:
     *
     *   - 'init' : The plugin initialization method which the owning Component calls at Component initialization time.
     *
     *     The Component passes itself as the sole parameter.
     *
     *     Subclasses should set up bidirectional links between the plugin and its client Component here.
     *
     *   - 'destroy' : The plugin cleanup method which the owning Component calls at Component destruction time.
     *
     *     Use this method to break links between the plugin and the Component and to free any allocated resources.
     *
     *   - 'enable' : The base implementation just sets the plugin's 'disabled' flag to 'false'
     *
     *   - 'disable' : The base implementation just sets the plugin's 'disabled' flag to 'true'
     */
    export class AbstractPlugin extends Ext.Base implements Ext.AbstractPluginConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Plugin, or subclass thereof.
         */
        isPlugin: boolean;

        /**
         * A name for the plugin that can be set at creation time to then retrieve the plugin
         * through {@link Ext.AbstractComponent#getPlugin getPlugin} method.  For example:
         *
         *     var grid = Ext.create('Ext.grid.Panel', {
         *         plugins: [{
         *             ptype: 'cellediting',
         *             clicksToEdit: 2,
         *             pluginId: 'cellplugin'
         *         }]
         *     });
         *
         *     // later on:
         *     var plugin = grid.getPlugin('cellplugin');
         */
        pluginId: string;

        /**
         * Creates clone of the plugin.
         * @param {Object} [overrideCfg] Additional config for the derived plugin.
         */
        clonePlugin(overrideCfg?: any);

        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.AbstractPluginConfig);

        /**
         * The destroy method is invoked by the owning Component at the time the Component is being destroyed.
         *
         * The supplied implementation is empty. Subclasses should perform plugin cleanup in their own implementation of
         * this method.
         */
        destroy();

        /**
         * The base implementation just sets the plugin's 'disabled' flag to 'true'
         *
         * Plugin subclasses which need more complex processing may implement an overriding implementation.
         */
        disable();

        /**
         * The base implementation just sets the plugin's 'disabled' flag to 'false'
         *
         * Plugin subclasses which need more complex processing may implement an overriding implementation.
         */
        enable();

        /**
         * Returns the component to which this plugin is attached.
         * @return {Ext.Component} Owner component.
         */
        getCmp(): Ext.Component;

        /**
         * The init method is invoked after initComponent method has been run for the client Component.
         *
         * The supplied implementation is empty. Subclasses should perform plugin initialization, and set up bidirectional
         * links between the plugin and its client Component in their own implementation of this method.
         * @param {Ext.Component} client The client Component which owns this plugin.
         */
        init(client: Ext.Component);

        /**
         * Sets the component to which this plugin is attached.
         * @param {Ext.Component} cmp Owner component.
         */
        setCmp(cmp: Ext.Component);
    }

    interface ActionConfig {
        /**
         * True to disable all components configured by this Action, false to enable them.
         *
         * Optional, Defaults to: false
         */
        disabled?: boolean;

        /**
         * The function that will be invoked by each component tied to this Action
         * when the component's primary event is triggered.
         */
        handler?: Function;

        /**
         * True to hide all components configured by this Action, false to show them.
         *
         * Optional, Defaults to: false
         */
        hidden?: boolean;

        /**
         * The CSS class selector that specifies a background image to be used as the header icon for
         * all components configured by this Action.
         *
         * An example of specifying a custom icon class would be something like:
         *
         *     // specify the property in the config for the class:
         *          ...
         *          iconCls: 'do-something'
         *
         *     // css class that specifies background image to be used as the icon image:
         *     .do-something { background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }
         *
         * Optional, Defaults to: ''
         */
        iconCls?: string;

        /**
         * See {@link Ext.Component}.{@link Ext.Component#itemId itemId}.
         */
        itemId?: string;

        /**
         * The scope (this reference) in which the {@link #handler} is executed.
         * Defaults to the browser window.
         */
        scope?: any;

        /**
         * The text to set for all components configured by this Action.
         *
         * Optional, Defaults to: ''
         */
        text?: string;
    }

    /**
     * An Action is a piece of reusable functionality that can be abstracted out of any particular component so that it
     * can be usefully shared among multiple components.  Actions let you share handlers, configuration options and UI
     * updates across any components that support the Action interface (primarily {@link Ext.toolbar.Toolbar},
     * {@link Ext.button.Button} and {@link Ext.menu.Menu} components).
     *
     * Use a single Action instance as the config object for any number of UI Components which share the same configuration. The
     * Action not only supplies the configuration, but allows all Components based upon it to have a common set of methods
     * called at once through a single call to the Action.
     *
     * Any Component that is to be configured with an Action must also support
     * the following methods:
     *
     * - setText(string)
     * - setIconCls(string)
     * - setDisabled(boolean)
     * - setVisible(boolean)
     * - setHandler(function)
     *
     * This allows the Action to control its associated Components.
     *
     * Example usage:
     *
     *     // Define the shared Action.  Each Component below will have the same
     *     // display text and icon, and will display the same message on click.
     *     var action = new Ext.Action({
     *         {@link #text}: 'Do something',
     *         {@link #handler}: function(){
     *             Ext.Msg.alert('Click', 'You did something.');
     *         },
     *         {@link #iconCls}: 'do-something',
     *         {@link #itemId}: 'myAction'
     *     });
     *
     *     var panel = new Ext.panel.Panel({
     *         title: 'Actions',
     *         width: 500,
     *         height: 300,
     *         tbar: [
     *             // Add the Action directly to a toolbar as a menu button
     *             action,
     *             {
     *                 text: 'Action Menu',
     *                 // Add the Action to a menu as a text item
     *                 menu: [action]
     *             }
     *         ],
     *         items: [
     *             // Add the Action to the panel body as a standard button
     *             new Ext.button.Button(action)
     *         ],
     *         renderTo: Ext.getBody()
     *     });
     *
     *     // Change the text for all components using the Action
     *     action.setText('Something else');
     *
     *     // Reference an Action through a container using the itemId
     *     var btn = panel.getComponent('myAction');
     *     var aRef = btn.baseAction;
     *     aRef.setText('New text');
     */
    export class Action extends Ext.Base implements Ext.ActionConfig {
        /**
         * True to disable all components configured by this Action, false to enable them.
         *
         * Optional, Defaults to: false
         */
        disabled: boolean;

        /**
         * The function that will be invoked by each component tied to this Action
         * when the component's primary event is triggered.
         */
        handler: Function;

        /**
         * True to hide all components configured by this Action, false to show them.
         *
         * Optional, Defaults to: false
         */
        hidden: boolean;

        /**
         * The CSS class selector that specifies a background image to be used as the header icon for
         * all components configured by this Action.
         *
         * An example of specifying a custom icon class would be something like:
         *
         *     // specify the property in the config for the class:
         *          ...
         *          iconCls: 'do-something'
         *
         *     // css class that specifies background image to be used as the icon image:
         *     .do-something { background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }
         *
         * Optional, Defaults to: ''
         */
        iconCls: string;

        /**
         * See {@link Ext.Component}.{@link Ext.Component#itemId itemId}.
         */
        itemId: string;

        /**
         * The scope (this reference) in which the {@link #handler} is executed.
         * Defaults to the browser window.
         */
        scope: any;

        /**
         * The text to set for all components configured by this Action.
         *
         * Optional, Defaults to: ''
         */
        text: string;

        /**
         * Creates new Action.
         * @param {Object} config Config object.
         */
        constructor(config: Ext.ActionConfig);

        /**
         * Disables all components configured by this Action.
         */
        disable();

        /**
         * Executes the specified function once for each Component currently tied to this Action.  The function passed
         * in should accept a single argument that will be an object that supports the basic Action config/method interface.
         * @param {Function} fn The function to execute for each component
         * @param {Object} scope The scope (this reference) in which the function is executed.
         * Defaults to the Component.
         */
        each(fn: Function, scope: any);

        /**
         * Enables all components configured by this Action.
         */
        enable();

        /**
         * Executes this Action manually using the handler function specified in the original config object
         * or the handler function set with {@link #setHandler}.  Any arguments passed to this
         * function will be passed on to the handler function.
         * @param {Object...} args Variable number of arguments passed to the handler function
         */
        execute(args: any);

        /**
         * Gets the icon CSS class currently used by all components configured by this Action.
         */
        getIconCls();

        /**
         * Gets the text currently displayed by all components configured by this Action.
         */
        getText();

        /**
         * Hides all components configured by this Action.
         */
        hide();

        /**
         * Returns true if the components using this Action are currently disabled, else returns false.
         */
        isDisabled();

        /**
         * Returns true if the components configured by this Action are currently hidden, else returns false.
         */
        isHidden();

        /**
         * Sets the disabled state of all components configured by this Action.  Shortcut method
         * for {@link #enable} and {@link #disable}.
         * @param {Boolean} disabled True to disable the component, false to enable it
         */
        setDisabled(disabled: boolean);

        /**
         * Sets the function that will be called by each Component using this action when its primary event is triggered.
         * @param {Function} fn The function that will be invoked by the action's components.  The function
         * will be called with no arguments.
         * @param {Object} scope The scope (this reference) in which the function is executed. Defaults to the Component
         * firing the event.
         */
        setHandler(fn: Function, scope: any);

        /**
         * Sets the hidden state of all components configured by this Action.  Shortcut method
         * for '{@link #hide}' and '{@link #show}'.
         * @param {Boolean} hidden True to hide the component, false to show it.
         */
        setHidden(hidden: boolean);

        /**
         * Sets the icon CSS class for all components configured by this Action.  The class should supply
         * a background image that will be used as the icon image.
         * @param {String} cls The CSS class supplying the icon image
         */
        setIconCls(cls: string);

        /**
         * Sets the text to be displayed by all components configured by this Action.
         * @param {String} text The text to display
         */
        setText(text: string);

        /**
         * Shows all components configured by this Action.
         */
        show();
    }

    /**
     * @markdown
     A singleton instance of an {@link Ext.data.Connection}. This class
     is used to communicate with your server side code. It can be used as follows:
     Ext.Ajax.request({
     url: 'page.php',
     params: {
     id: 1
     },
     success: function(response){
     var text = response.responseText;
     // process server response here
     }
     });
     Default options for all requests can be set by changing a property on the Ext.Ajax class:
     Ext.Ajax.timeout = 60000; // 60 seconds
     Any options specified in the request method for the Ajax request will override any
     defaults set on the Ext.Ajax class. In the code sample below, the timeout for the
     request will be 60 seconds.
     Ext.Ajax.timeout = 120000; // 120 seconds
     Ext.Ajax.request({
     url: 'page.aspx',
     timeout: 60000
     });
     In general, this class will be used for all Ajax requests in your application.
     The main reason for creating a separate {@link Ext.data.Connection} is for a
     series of requests that share common settings that are different to all other
     requests in the application.
     */
    export class Ajax {
        constructor(config: Ext.data.ConnectionConfig);

        /**
         * The default URL to be used for requests to the server.
         * If the server receives all requests through one URL, setting this once is easier than
         * entering it on every request.
         */
        static url: string;
    }

    /**
     * @author Jacky Nguyen <jacky@sencha.com>
     * @docauthor Jacky Nguyen <jacky@sencha.com>
     *
     * A set of useful static methods to deal with arrays; provide missing methods for older browsers.
     */
    export class Array {
        /**
         * Filter through an array and remove empty item as defined in {@link Ext#isEmpty Ext.isEmpty}
         *
         * See {@link Ext.Array#filter}
         *
         * @return {Array} results
         */
        static clean(array: any[]): any[];

        /**
         * Clone a flat array without referencing the previous one. Note that this is different
         * from Ext.clone since it doesn't handle recursive cloning. It's simply a convenient, easy-to-remember method
         * for Array.prototype.slice.call(array)
         *
         * @param {Array} array The array
         * @return {Array} The clone array
         */
        static clone(array: any[]): any[];

        /**
         * Checks whether or not the given 'array' contains the specified 'item'
         *
         * @param {Array} array The array to check
         * @param {Object} item The item to look for
         * @return {Boolean} True if the array contains the item, false otherwise
         */
        static contains(array: any[], item: any): boolean;

        /**
         * Perform a set difference A-B by subtracting all items in array B from array A.
         *
         * @return {Array} difference
         */
        static difference(arrayA: any[], arrayB: any[]): any[];

        /**
         * Iterates an array or an iterable value and invoke the given callback function for each item.
         *
         *     var countries = ['Vietnam', 'Singapore', 'United States', 'Russia'];
         *
         *     Ext.Array.each(countries, function(name, index, countriesItSelf) {
         *         console.log(name);
         *     });
         *
         *     var sum = function() {
         *         var sum = 0;
         *
         *         Ext.Array.each(arguments, function(value) {
         *             sum += value;
         *         });
         *
         *         return sum;
         *     };
         *
         *     sum(1, 2, 3); // returns 6
         *
         * The iteration can be stopped by returning false in the function callback.
         *
         *     Ext.Array.each(countries, function(name, index, countriesItSelf) {
         *         if (name === 'Singapore') {
         *             return false; // break here
         *         }
         *     });
         *
         * {@link Ext#each Ext.each} is alias for {@link Ext.Array#each Ext.Array.each}
         *
         * @param {Array/NodeList/Object} iterable The value to be iterated. If this
         * argument is not iterable, the callback function is called once.
         * @param {Function} fn The callback function. If it returns false, the iteration stops and this method returns
         * the current 'index'.
         * @param {Object} fn.item The item at the current 'index' in the passed 'array'
         * @param {Number} fn.index The current 'index' within the 'array'
         * @param {Array} fn.allItems The 'array' itself which was passed as the first argument
         * @param {Boolean} fn.return Return false to stop iteration.
         * @param {Object} scope (Optional) The scope ('this' reference) in which the specified function is executed.
         * @param {Boolean} reverse (Optional) Reverse the iteration order (loop from the end to the beginning)
         * Defaults false
         * @return {Boolean} See description for the 'fn' parameter.
         */
        static each(iterable: any[]|any, fn: Function, fn_item: any, fn_index: number, fn_allItems: any[], fn_return: boolean, scope: any, reverse: boolean): boolean;

        /**
         * Shallow compares the contents of 2 arrays using strict equality.
         * @return {Boolean} 'true' if the arrays are equal.
         */
        static equals(array1: any[], array2: any[]): boolean;

        /**
         * Removes items from an array. This is functionally equivalent to the splice method
         * of Array, but works around bugs in IE8's splice method and does not copy the
         * removed elements in order to return them (because very often they are ignored).
         *
         * @param {Array} array The Array on which to replace.
         * @param {Number} index The index in the array at which to operate.
         * @param {Number} removeCount The number of items to remove at index.
         * @return {Array} The array passed.
         */
        static erase(array: any[], index: number, removeCount: number): any[];

        /**
         * Executes the specified function for each array element until the function returns a falsy value.
         * If such an item is found, the function will return false immediately.
         * Otherwise, it will return true.
         *
         * @param {Function} fn Callback function for each item
         * @param {Mixed} fn.item Current item.
         * @param {Number} fn.index Index of the item.
         * @param {Array} fn.array The whole array that's being iterated.
         * @param {Object} scope Callback function scope
         * @return {Boolean} True if no false value is returned by the callback function.
         */
        static every(array: any[], fn: Function, fn_item: any, fn_index: number, fn_array: any[], scope: any): boolean;

        /**
         * Creates a new array with all of the elements of this array for which
         * the provided filtering function returns true.
         *
         * @param {Function} fn Callback function for each item
         * @param {Mixed} fn.item Current item.
         * @param {Number} fn.index Index of the item.
         * @param {Array} fn.array The whole array that's being iterated.
         * @param {Object} scope Callback function scope
         * @return {Array} results
         */
        static filter(array: any[], fn: Function, fn_item: any, fn_index: number, fn_array: any[], scope: any): any[];

        /**
         * Returns the first item in the array which elicits a true return value from the
         * passed selection function.
         * @param {Array} array The array to search
         * @param {Function} fn The selection function to execute for each item.
         * @param {Mixed} fn.item The array item.
         * @param {String} fn.index The index of the array item.
         * @param {Object} scope (optional) The scope (<code>this</code> reference) in which the
         * function is executed. Defaults to the array
         * @return {Object} The first item in the array which returned true from the selection
         * function, or null if none was found.
         */
        static findBy(array: any[], fn: Function, fn_item: any, fn_index: string, scope: any): any;

        /**
         * Recursively flattens into 1-d Array. Injects Arrays inline.
         *
         * @param {Array} array The array to flatten
         * @return {Array} The 1-d array.
         */
        static flatten(array: any[]): any[];

        /**
         * Iterates an array and invoke the given callback function for each item. Note that this will simply
         * delegate to the native Array.prototype.forEach method if supported. It doesn't support stopping the
         * iteration by returning false in the callback function like {@link Ext.Array#each}. However, performance
         * could be much better in modern browsers comparing with {@link Ext.Array#each}
         *
         * @param {Array} array The array to iterate
         * @param {Function} fn The callback function.
         * @param {Object} fn.item The item at the current 'index' in the passed 'array'
         * @param {Number} fn.index The current 'index' within the 'array'
         * @param {Array}  fn.allItems The 'array' itself which was passed as the first argument
         * @param {Object} scope (Optional) The execution scope ('this') in which the specified function is executed.
         */
        static forEach(array: any[], fn: Function, fn_item: any, fn_index: number, fn_allItems: any[], scope: any);

        /**
         * Converts a value to an array if it's not already an array; returns:
         *
         * - An empty array if given value is 'undefined' or 'null'
         * - Itself if given value is already an array
         * - An array copy if given value is {@link Ext#isIterable iterable} (arguments, NodeList and alike)
         * - An array with one item which is the given value, otherwise
         *
         * @param {Object} value The value to convert to an array if it's not already is an array
         * @param {Boolean} newReference (Optional) True to clone the given array and return a new reference if necessary,
         * defaults to false
         * @return {Array} array
         */
        static from(value: any, newReference: boolean): any[];

        /**
         * Push an item into the array only if the array doesn't contain it yet
         *
         * @param {Array} array The array
         * @param {Object} item The item to include
         */
        static include(array: any[], item: any);

        /**
         * Get the index of the provided 'item' in the given 'array', a supplement for the
         * missing arrayPrototype.indexOf in Internet Explorer.
         *
         * @param {Array} array The array to check
         * @param {Object} item The item to look for
         * @param {Number} from (Optional) The index at which to begin the search
         * @return {Number} The index of item in the array (or -1 if it is not found)
         */
        static indexOf(array: any[], item: any, from: number): number;

        /**
         * Inserts items in to an array.
         *
         * @param {Array} array The Array in which to insert.
         * @param {Number} index The index in the array at which to operate.
         * @param {Array} items The array of items to insert at index.
         * @return {Array} The array passed.
         */
        static insert(array: any[], index: number, items: any[]): any[];

        /**
         * Merge multiple arrays into one with unique items that exist in all of the arrays.
         *
         * @return {Array} intersect
         */
        static intersect(array1: any[], array2: any[], etc: any[]): any[];

        /**
         * Creates a new array with the results of calling a provided function on every element in this array.
         *
         * @param {Function} fn Callback function for each item
         * @param {Mixed} fn.item Current item.
         * @param {Number} fn.index Index of the item.
         * @param {Array} fn.array The whole array that's being iterated.
         * @param {Object} [scope] Callback function scope
         * @return {Array} results
         */
        static map(array: any[], fn: Function, fn_item: any, fn_index: number, fn_array: any[], scope?: any): any[];

        /**
         * Returns the maximum value in the Array.
         *
         * @param {Array/NodeList} array The Array from which to select the maximum value.
         * @param {Function} comparisonFn (optional) a function to perform the comparision which determines maximization.
         * If omitted the ">" operator will be used. Note: gt = 1; eq = 0; lt = -1
         * @param {Mixed} comparisonFn.max Current maximum value.
         * @param {Mixed} comparisonFn.item The value to compare with the current maximum.
         * @return {Object} maxValue The maximum value
         */
        static max(array: any[]|any, comparisonFn: Function, comparisonFn_max: any, comparisonFn_item: any): any;

        /**
         * Calculates the mean of all items in the array.
         *
         * @param {Array} array The Array to calculate the mean value of.
         * @return {Number} The mean.
         */
        static mean(array: any[]): number;

        /**
         * Merge multiple arrays into one with unique items.
         *
         * {@link Ext.Array#union} is alias for {@link Ext.Array#merge}
         *
         * @return {Array} merged
         */
        static merge(array1: any[], array2: any[], etc: any[]): any[];

        /**
         * Returns the minimum value in the Array.
         *
         * @param {Array/NodeList} array The Array from which to select the minimum value.
         * @param {Function} comparisonFn (optional) a function to perform the comparision which determines minimization.
         * If omitted the "<" operator will be used. Note: gt = 1; eq = 0; lt = -1
         * @param {Mixed} comparisonFn.min Current minimum value.
         * @param {Mixed} comparisonFn.item The value to compare with the current minimum.
         * @return {Object} minValue The minimum value
         */
        static min(array: any[]|any, comparisonFn: Function, comparisonFn_min: any, comparisonFn_item: any): any;

        /**
         * Plucks the value of a property from each item in the Array. Example:
         *
         *     Ext.Array.pluck(Ext.query("p"), "className"); // [el1.className, el2.className, ..., elN.className]
         *
         * @param {Array/NodeList} array The Array of items to pluck the value from.
         * @param {String} propertyName The property name to pluck from each element.
         * @return {Array} The value from each item in the Array.
         */
        static pluck(array: any[]|any, propertyName: string): any[];

        /**
         * Pushes new items onto the end of an Array.
         *
         * Passed parameters may be single items, or arrays of items. If an Array is found in the argument list, all its
         * elements are pushed into the end of the target Array.
         *
         * @param {Array} target The Array onto which to push new items
         * @param {Object...} elements The elements to add to the array. Each parameter may
         * be an Array, in which case all the elements of that Array will be pushed into the end of the
         * destination Array.
         * @return {Array} An array containing all the new items push onto the end.
         */
        static push(target: any[], elements: any): any[];

        /**
         * Removes the specified item from the array if it exists
         *
         * @param {Array} array The array
         * @param {Object} item The item to remove
         * @return {Array} The passed array itself
         */
        static remove(array: any[], item: any): any[];

        /**
         * Replaces items in an array. This is functionally equivalent to the splice method
         * of Array, but works around bugs in IE8's splice method and is often more convenient
         * to call because it accepts an array of items to insert rather than use a variadic
         * argument list.
         *
         * @param {Array} array The Array on which to replace.
         * @param {Number} index The index in the array at which to operate.
         * @param {Number} removeCount The number of items to remove at index (can be 0).
         * @param {Array} insert (optional) An array of items to insert at index.
         * @return {Array} The array passed.
         */
        static replace(array: any[], index: number, removeCount: number, insert: any[]): any[];

        /**
         * Returns a shallow copy of a part of an array. This is equivalent to the native
         * call "Array.prototype.slice.call(array, begin, end)". This is often used when "array"
         * is "arguments" since the arguments object does not supply a slice method but can
         * be the context object to Array.prototype.slice.
         *
         * @param {Array} array The array (or arguments object).
         * @param {Number} begin The index at which to begin. Negative values are offsets from
         * the end of the array.
         * @param {Number} end The index at which to end. The copied items do not include
         * end. Negative values are offsets from the end of the array. If end is omitted,
         * all items up to the end of the array are copied.
         * @return {Array} The copied piece of the array.
         */
        static slice(array: any[], begin: number, end: number): any[];

        /**
         * Executes the specified function for each array element until the function returns a truthy value.
         * If such an item is found, the function will return true immediately. Otherwise, it will return false.
         *
         * @param {Function} fn Callback function for each item
         * @param {Mixed} fn.item Current item.
         * @param {Number} fn.index Index of the item.
         * @param {Array} fn.array The whole array that's being iterated.
         * @param {Object} scope Callback function scope
         * @return {Boolean} True if the callback function returns a truthy value.
         */
        static some(array: any[], fn: Function, fn_item: any, fn_index: number, fn_array: any[], scope: any): boolean;

        /**
         * Sorts the elements of an Array.
         * By default, this method sorts the elements alphabetically and ascending.
         *
         * @param {Array} array The array to sort.
         * @param {Function} sortFn (optional) The comparison function.
         * @param {Mixed} sortFn.a An item to compare.
         * @param {Mixed} sortFn.b Another item to compare.
         * @return {Array} The sorted array.
         */
        static sort(array: any[], sortFn: Function, sortFn_a: any, sortFn_b: any): any[];

        /**
         * Replaces items in an array. This is equivalent to the splice method of Array, but
         * works around bugs in IE8's splice method. The signature is exactly the same as the
         * splice method except that the array is the first argument. All arguments following
         * removeCount are inserted in the array at index.
         *
         * @param {Array} array The Array on which to replace.
         * @param {Number} index The index in the array at which to operate.
         * @param {Number} removeCount The number of items to remove at index (can be 0).
         * @param {Object...} elements The elements to add to the array. If you don't specify
         * any elements, splice simply removes elements from the array.
         * @return {Array} An array containing the removed items.
         */
        static splice(array: any[], index: number, removeCount: number, elements: any): any[];

        /**
         * Calculates the sum of all items in the given array.
         *
         * @param {Array} array The Array to calculate the sum value of.
         * @return {Number} The sum.
         */
        static sum(array: any[]): number;

        /**
         * Converts any iterable (numeric indices and a length property) into a true array.
         *
         *     function test() {
         *         var args = Ext.Array.toArray(arguments),
         *             fromSecondToLastArgs = Ext.Array.toArray(arguments, 1);
         *
         *         alert(args.join(' '));
         *         alert(fromSecondToLastArgs.join(' '));
         *     }
         *
         *     test('just', 'testing', 'here'); // alerts 'just testing here';
         *                                      // alerts 'testing here';
         *
         *     Ext.Array.toArray(document.getElementsByTagName('div')); // will convert the NodeList into an array
         *     Ext.Array.toArray('splitted'); // returns ['s', 'p', 'l', 'i', 't', 't', 'e', 'd']
         *     Ext.Array.toArray('splitted', 0, 3); // returns ['s', 'p', 'l']
         *
         * {@link Ext#toArray Ext.toArray} is alias for {@link Ext.Array#toArray Ext.Array.toArray}
         *
         * @param {Object} iterable the iterable object to be turned into a true Array.
         * @param {Number} start (Optional) a zero-based index that specifies the start of extraction. Defaults to 0
         * @param {Number} end (Optional) a 1-based index that specifies the end of extraction. Defaults to the last
         * index of the iterable value
         * @return {Array} array
         */
        static toArray(iterable: any, start: number, end: number): any[];

        /**
         * Creates a map (object) keyed by the elements of the given array. The values in
         * the map are the index+1 of the array element. For example:
         *
         *      var map = Ext.Array.toMap(['a','b','c']);
         *
         *      // map = { a: 1, b: 2, c: 3 };
         *
         * Or a key property can be specified:
         *
         *      var map = Ext.Array.toMap([
         *              { name: 'a' },
         *              { name: 'b' },
         *              { name: 'c' }
         *          ], 'name');
         *
         *      // map = { a: 1, b: 2, c: 3 };
         *
         * Lastly, a key extractor can be provided:
         *
         *      var map = Ext.Array.toMap([
         *              { name: 'a' },
         *              { name: 'b' },
         *              { name: 'c' }
         *          ], function (obj) { return obj.name.toUpperCase(); });
         *
         *      // map = { A: 1, B: 2, C: 3 };
         *
         * @param {Array} array The Array to create the map from.
         * @param {String/Function} [getKey] Name of the object property to use
         * as a key or a function to extract the key.
         * @param {Object} [scope] Value of this inside callback.
         * @return {Object} The resulting map.
         */
        static toMap(array: any[], getKey?: string|Function, scope?: any): any;

        /**
         * Creates a map (object) keyed by a property of elements of the given array. The values in
         * the map are the array element. For example:
         *
         *      var map = Ext.Array.toMap(['a','b','c']);
         *
         *      // map = { a: 'a', b: 'b', c: 'c' };
         *
         * Or a key property can be specified:
         *
         *      var map = Ext.Array.toMap([
         *              { name: 'a' },
         *              { name: 'b' },
         *              { name: 'c' }
         *          ], 'name');
         *
         *      // map = { a: {name: 'a'}, b: {name: 'b'}, c: {name: 'c'} };
         *
         * Lastly, a key extractor can be provided:
         *
         *      var map = Ext.Array.toMap([
         *              { name: 'a' },
         *              { name: 'b' },
         *              { name: 'c' }
         *          ], function (obj) { return obj.name.toUpperCase(); });
         *
         *      // map = { A: {name: 'a'}, B: {name: 'b'}, C: {name: 'c'} };
         *
         * @param {Array} array The Array to create the map from.
         * @param {String/Function} [getKey] Name of the object property to use
         * as a key or a function to extract the key.
         * @param {Object} [scope] Value of this inside callback.
         * @return {Object} The resulting map.
         */
        static toValueMap(array: any[], getKey?: string|Function, scope?: any): any;

        static union();

        /**
         * Returns a new array with unique items
         *
         * @return {Array} results
         */
        static unique(array: any[]): any[];
    }

    /**
     * @author Jacky Nguyen <jacky@sencha.com>
     * @docauthor Jacky Nguyen <jacky@sencha.com>
     *
     * The root of all classes created with {@link Ext#define}.
     *
     * Ext.Base is the building block of all Ext classes. All classes in Ext inherit from Ext.Base.
     * All prototype and static members of this class are inherited by all other classes.
     */
    export class Base {
        /**
         * Get the reference to the current class from which this object was instantiated. Unlike {@link Ext.Base#statics},
         * 'this.self' is scope-dependent and it's meant to be used for dynamic inheritance. See {@link Ext.Base#statics}
         * for a detailed comparison
         *
         *     Ext.define('My.Cat', {
         *         statics: {
         *             speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
         *         },
         *
         *         constructor: function() {
         *             alert(this.self.speciesName); // dependent on 'this'
         *         },
         *
         *         clone: function() {
         *             return new this.self();
         *         }
         *     });
         *
         *
         *     Ext.define('My.SnowLeopard', {
         *         extend: 'My.Cat',
         *         statics: {
         *             speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
         *         }
         *     });
         *
         *     var cat = new My.Cat();                     // alerts 'Cat'
         *     var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
         *
         *     var clone = snowLeopard.clone();
         *     alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
         */
        protected self: Ext.Class;

        /**
         * Call the original method that was previously overridden with {@link Ext.Base#override}
         *
         *     Ext.define('My.Cat', {
         *         constructor: function() {
         *             alert("I'm a cat!");
         *         }
         *     });
         *
         *     My.Cat.override({
         *         constructor: function() {
         *             alert("I'm going to be a cat!");
         *
         *             this.callOverridden();
         *
         *             alert("Meeeeoooowwww");
         *         }
         *     });
         *
         *     var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
         *                               // alerts "I'm a cat!"
         *                               // alerts "Meeeeoooowwww"
         *
         * @param {Array/Arguments} args The arguments, either an array or the 'arguments' object
         * from the current method, for example: 'this.callOverridden(arguments)'
         * @return {Object} Returns the result of calling the overridden method
         * @deprecated as of 4.1. Use {@link #callParent} instead.
         */
        protected callOverridden(args: any[]): any;

        /**
         * Call the "parent" method of the current method. That is the method previously
         * overridden by derivation or by an override (see {@link Ext#define}).
         *
         *      Ext.define('My.Base', {
         *          constructor: function (x) {
         *              this.x = x;
         *          },
         *
         *          statics: {
         *              method: function (x) {
         *                  return x;
         *              }
         *          }
         *      });
         *
         *      Ext.define('My.Derived', {
         *          extend: 'My.Base',
         *
         *          constructor: function () {
         *              this.callParent([21]);
         *          }
         *      });
         *
         *      var obj = new My.Derived();
         *
         *      alert(obj.x);  // alerts 21
         *
         * This can be used with an override as follows:
         *
         *      Ext.define('My.DerivedOverride', {
         *          override: 'My.Derived',
         *
         *          constructor: function (x) {
         *              this.callParent([x*2]); // calls original My.Derived constructor
         *          }
         *      });
         *
         *      var obj = new My.Derived();
         *
         *      alert(obj.x);  // now alerts 42
         *
         * This also works with static methods.
         *
         *      Ext.define('My.Derived2', {
         *          extend: 'My.Base',
         *
         *          statics: {
         *              method: function (x) {
         *                  return this.callParent([x*2]); // calls My.Base.method
         *              }
         *          }
         *      });
         *
         *      alert(My.Base.method(10);     // alerts 10
         *      alert(My.Derived2.method(10); // alerts 20
         *
         * Lastly, it also works with overridden static methods.
         *
         *      Ext.define('My.Derived2Override', {
         *          override: 'My.Derived2',
         *
         *          statics: {
         *              method: function (x) {
         *                  return this.callParent([x*2]); // calls My.Derived2.method
         *              }
         *          }
         *      });
         *
         *      alert(My.Derived2.method(10); // now alerts 40
         *
         * To override a method and replace it and also call the superclass method, use
         * {@link #callSuper}. This is often done to patch a method to fix a bug.
         *
         * @param {Array/Arguments} args The arguments, either an array or the 'arguments' object
         * from the current method, for example: 'this.callParent(arguments)'
         * @return {Object} Returns the result of calling the parent method
         */
        protected callParent(args: any[]): any;

        /**
         * This method is used by an override to call the superclass method but bypass any
         * overridden method. This is often done to "patch" a method that contains a bug
         * but for whatever reason cannot be fixed directly.
         *
         * Consider:
         *
         *      Ext.define('Ext.some.Class', {
         *          method: function () {
         *              console.log('Good');
         *          }
         *      });
         *
         *      Ext.define('Ext.some.DerivedClass', {
         *          method: function () {
         *              console.log('Bad');
         *
         *              // ... logic but with a bug ...
         *
         *              this.callParent();
         *          }
         *      });
         *
         * To patch the bug in 'DerivedClass.method', the typical solution is to create an
         * override:
         *
         *      Ext.define('App.paches.DerivedClass', {
         *          override: 'Ext.some.DerivedClass',
         *
         *          method: function () {
         *              console.log('Fixed');
         *
         *              // ... logic but with bug fixed ...
         *
         *              this.callSuper();
         *          }
         *      });
         *
         * The patch method cannot use 'callParent' to call the superclass 'method' since
         * that would call the overridden method containing the bug. In other words, the
         * above patch would only produce "Fixed" then "Good" in the console log, whereas,
         * using 'callParent' would produce "Fixed" then "Bad" then "Good".
         *
         * @param {Array/Arguments} args The arguments, either an array or the 'arguments' object
         * from the current method, for example: 'this.callSuper(arguments)'
         * @return {Object} Returns the result of calling the superclass method
         */
        protected callSuper(args: any[]): any;

        /**
         * Returns the initial configuration passed to constructor when instantiating
         * this class.
         * @param {String} [name] Name of the config option to return.
         * @return {Object/Mixed} The full config object or a single config value
         * when 'name' parameter specified.
         */
        getInitialConfig(name?: string): any;

        /**
         * Initialize configuration for this class. a typical example:
         *
         *     Ext.define('My.awesome.Class', {
         *         // The default config
         *         config: {
         *             name: 'Awesome',
         *             isAwesome: true
         *         },
         *
         *         constructor: function(config) {
         *             this.initConfig(config);
         *         }
         *     });
         *
         *     var awesome = new My.awesome.Class({
         *         name: 'Super Awesome'
         *     });
         *
         *     alert(awesome.getName()); // 'Super Awesome'
         *
         * @return {Ext.Base} this
         */
        protected initConfig(config: any): Ext.Base;

        /**
         * Get the reference to the class from which this object was instantiated. Note that unlike {@link Ext.Base#self},
         * 'this.statics()' is scope-independent and it always returns the class from which it was called, regardless of what
         * 'this' points to during run-time
         *
         *     Ext.define('My.Cat', {
         *         statics: {
         *             totalCreated: 0,
         *             speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
         *         },
         *
         *         constructor: function() {
         *             var statics = this.statics();
         *
         *             alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
         *                                             // equivalent to: My.Cat.speciesName
         *
         *             alert(this.self.speciesName);   // dependent on 'this'
         *
         *             statics.totalCreated++;
         *         },
         *
         *         clone: function() {
         *             var cloned = new this.self;                      // dependent on 'this'
         *
         *             cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
         *
         *             return cloned;
         *         }
         *     });
         *
         *
         *     Ext.define('My.SnowLeopard', {
         *         extend: 'My.Cat',
         *
         *         statics: {
         *             speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
         *         },
         *
         *         constructor: function() {
         *             this.callParent();
         *         }
         *     });
         *
         *     var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
         *
         *     var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
         *
         *     var clone = snowLeopard.clone();
         *     alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
         *     alert(clone.groupName);                 // alerts 'Cat'
         *
         *     alert(My.Cat.totalCreated);             // alerts 3
         *
         * @return {Ext.Class}
         */
        protected statics(): Ext.Class;

        /**
         * Add methods / properties to the prototype of this class.
         *
         *     Ext.define('My.awesome.Cat', {
         *         constructor: function() {
         *             ...
         *         }
         *     });
         *
         *      My.awesome.Cat.addMembers({
         *          meow: function() {
         *             alert('Meowww...');
         *          }
         *      });
         *
         *      var kitty = new My.awesome.Cat;
         *      kitty.meow();
         *
         * @inheritable
         */
        static addMembers(members: any);

        /**
         * Add / override static properties of this class.
         *
         *     Ext.define('My.cool.Class', {
         *         ...
         *     });
         *
         *     My.cool.Class.addStatics({
         *         someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
         *         method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
         *         method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
         *     });
         *
         * @return {Ext.Base} this
         * @inheritable
         */
        static addStatics(members: any): Ext.Base;

        /**
         * Create a new instance of this Class.
         *
         *     Ext.define('My.cool.Class', {
         *         ...
         *     });
         *
         *     My.cool.Class.create({
         *         someConfig: true
         *     });
         *
         * All parameters are passed to the constructor of the class.
         *
         * @return {Object} the created instance.
         * @inheritable
         */
        static create(): any;

        /**
         * Create aliases for existing prototype methods. Example:
         *
         *     Ext.define('My.cool.Class', {
         *         method1: function() { ... },
         *         method2: function() { ... }
         *     });
         *
         *     var test = new My.cool.Class();
         *
         *     My.cool.Class.createAlias({
         *         method3: 'method1',
         *         method4: 'method2'
         *     });
         *
         *     test.method3(); // test.method1()
         *
         *     My.cool.Class.createAlias('method5', 'method3');
         *
         *     test.method5(); // test.method3() -> test.method1()
         *
         * @param {String/Object} alias The new method name, or an object to set multiple aliases. See
         * {@link Ext.Function#flexSetter flexSetter}
         * @param {String/Object} origin The original method name
         * @inheritable
         */
        static createAlias(alias: string|any, origin: string|any);

        /**
         * Get the current class' name in string format.
         *
         *     Ext.define('My.cool.Class', {
         *         constructor: function() {
         *             alert(this.self.getName()); // alerts 'My.cool.Class'
         *         }
         *     });
         *
         *     My.cool.Class.getName(); // 'My.cool.Class'
         *
         * @return {String} className
         * @inheritable
         */
        static getName(): string;

        /**
         * Adds members to class.
         * @inheritable
         * @deprecated 4.1 Use {@link #addMembers} instead.
         */
        static implement();

        /**
         * Override members of this class. Overridden methods can be invoked via
         * {@link Ext.Base#callParent}.
         *
         *     Ext.define('My.Cat', {
         *         constructor: function() {
         *             alert("I'm a cat!");
         *         }
         *     });
         *
         *     My.Cat.override({
         *         constructor: function() {
         *             alert("I'm going to be a cat!");
         *
         *             this.callParent(arguments);
         *
         *             alert("Meeeeoooowwww");
         *         }
         *     });
         *
         *     var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
         *                               // alerts "I'm a cat!"
         *                               // alerts "Meeeeoooowwww"
         *
         * As of 4.1, direct use of this method is deprecated. Use {@link Ext#define Ext.define}
         * instead:
         *
         *     Ext.define('My.CatOverride', {
         *         override: 'My.Cat',
         *         constructor: function() {
         *             alert("I'm going to be a cat!");
         *
         *             this.callParent(arguments);
         *
         *             alert("Meeeeoooowwww");
         *         }
         *     });
         *
         * The above accomplishes the same result but can be managed by the {@link Ext.Loader}
         * which can properly order the override and its target class and the build process
         * can determine whether the override is needed based on the required state of the
         * target class (My.Cat).
         *
         * @param {Object} members The properties to add to this class. This should be
         * specified as an object literal containing one or more properties.
         * @return {Ext.Base} this class
         * @inheritable
         * @markdown
         * @deprecated 4.1.0 Use {@link Ext#define Ext.define} instead
         */
        static override(members: any): Ext.Base;
    }

    interface ClassConfig {
        /**
         * List of short aliases for class names.  Most useful for defining xtypes for widgets:
         *
         *     Ext.define('MyApp.CoolPanel', {
         *         extend: 'Ext.panel.Panel',
         *         alias: ['widget.coolpanel'],
         *         title: 'Yeah!'
         *     });
         *
         *     // Using Ext.create
         *     Ext.create('widget.coolpanel');
         *
         *     // Using the shorthand for defining widgets by xtype
         *     Ext.widget('panel', {
         *         items: [
         *             {xtype: 'coolpanel', html: 'Foo'},
         *             {xtype: 'coolpanel', html: 'Bar'}
         *         ]
         *     });
         *
         * Besides "widget" for xtype there are alias namespaces like "feature" for ftype and "plugin" for ptype.
         */
        alias?: string;

        /**
         * Defines alternate names for this class.  For example:
         *
         *     Ext.define('Developer', {
         *         alternateClassName: ['Coder', 'Hacker'],
         *         code: function(msg) {
         *             alert('Typing... ' + msg);
         *         }
         *     });
         *
         *     var joe = Ext.create('Developer');
         *     joe.code('stackoverflow');
         *
         *     var rms = Ext.create('Hacker');
         *     rms.code('hack hack');
         */
        alternateClassName?: string;

        /**
         * List of configuration options with their default values, for which automatically
         * accessor methods are generated.  For example:
         *
         *     Ext.define('SmartPhone', {
         *          config: {
         *              hasTouchScreen: false,
         *              operatingSystem: 'Other',
         *              price: 500
         *          },
         *          constructor: function(cfg) {
         *              this.initConfig(cfg);
         *          }
         *     });
         *
         *     var iPhone = new SmartPhone({
         *          hasTouchScreen: true,
         *          operatingSystem: 'iOS'
         *     });
         *
         *     iPhone.getPrice(); // 500;
         *     iPhone.getOperatingSystem(); // 'iOS'
         *     iPhone.getHasTouchScreen(); // true;
         *
         * NOTE for when configs are reference types, the getter and setter methods do not make copies.
         *
         * For example, when a config value is set, the reference is stored on the instance. All instances that set
         * the same reference type will share it.
         *
         * In the case of the getter, the value with either come from the prototype if the setter was never called or from
         * the instance as the last value passed to the setter.
         *
         * For some config properties, the value passed to the setter is transformed prior to being stored on the instance.
         */
        config?: any;

        /**
         * The parent class that this class extends. For example:
         *
         *     Ext.define('Person', {
         *         say: function(text) { alert(text); }
         *     });
         *
         *     Ext.define('Developer', {
         *         extend: 'Person',
         *         say: function(text) { this.callParent(["print "+text]); }
         *     });
         */
        extend?: string;

        /**
         * List of inheritable static methods for this class.
         * Otherwise just like {@link #statics} but subclasses inherit these methods.
         */
        inheritableStatics?: any;

        /**
         * List of classes to mix into this class. For example:
         *
         *     Ext.define('CanSing', {
         *          sing: function() {
         *              alert("I'm on the highway to hell...")
         *          }
         *     });
         *
         *     Ext.define('Musician', {
         *          mixins: ['CanSing']
         *     })
         *
         * In this case the Musician class will get a 'sing' method from CanSing mixin.
         *
         * But what if the Musician already has a 'sing' method? Or you want to mix
         * in two classes, both of which define 'sing'?  In such a cases it's good
         * to define mixins as an object, where you assign a name to each mixin:
         *
         *     Ext.define('Musician', {
         *          mixins: {
         *              canSing: 'CanSing'
         *          },
         *
         *          sing: function() {
         *              // delegate singing operation to mixin
         *              this.mixins.canSing.sing.call(this);
         *          }
         *     })
         *
         * In this case the 'sing' method of Musician will overwrite the
         * mixed in 'sing' method. But you can access the original mixed in method
         * through special 'mixins' property.
         */
        mixins?: string|any;

        /**
         * List of classes that have to be loaded before instantiating this class.
         * For example:
         *
         *     Ext.define('Mother', {
         *         requires: ['Child'],
         *         giveBirth: function() {
         *             // we can be sure that child class is available.
         *             return new Child();
         *         }
         *     });
         */
        requires?: string;

        /**
         * When set to true, the class will be instantiated as singleton.  For example:
         *
         *     Ext.define('Logger', {
         *         singleton: true,
         *         log: function(msg) {
         *             console.log(msg);
         *         }
         *     });
         *
         *     Logger.log('Hello');
         */
        singleton?: boolean;

        /**
         * List of static methods for this class. For example:
         *
         *     Ext.define('Computer', {
         *          statics: {
         *              factory: function(brand) {
         *                  // 'this' in static methods refer to the class itself
         *                  return new this(brand);
         *              }
         *          },
         *
         *          constructor: function() { ... }
         *     });
         *
         *     var dellComputer = Computer.factory('Dell');
         */
        statics?: any;

        /**
         * List of optional classes to load together with this class. These aren't neccessarily loaded before
         * this class is created, but are guaranteed to be available before Ext.onReady listeners are
         * invoked. For example:
         *
         *     Ext.define('Mother', {
         *         uses: ['Child'],
         *         giveBirth: function() {
         *             // This code might, or might not work:
         *             // return new Child();
         *
         *             // Instead use Ext.create() to load the class at the spot if not loaded already:
         *             return Ext.create('Child');
         *         }
         *     });
         */
        uses?: string;
    }

    /**
     * @author Jacky Nguyen <jacky@sencha.com>
     * @docauthor Jacky Nguyen <jacky@sencha.com>
     *
     * Handles class creation throughout the framework. This is a low level factory that is used by Ext.ClassManager and generally
     * should not be used directly. If you choose to use Ext.Class you will lose out on the namespace, aliasing and depency loading
     * features made available by Ext.ClassManager. The only time you would use Ext.Class directly is to create an anonymous class.
     *
     * If you wish to create a class you should use {@link Ext#define Ext.define} which aliases
     * {@link Ext.ClassManager#create Ext.ClassManager.create} to enable namespacing and dynamic dependency resolution.
     *
     * Ext.Class is the factory and **not** the superclass of everything. For the base class that **all** Ext classes inherit
     * from, see {@link Ext.Base}.
     */
    export class Class implements Ext.ClassConfig {
        /**
         * List of short aliases for class names.  Most useful for defining xtypes for widgets:
         *
         *     Ext.define('MyApp.CoolPanel', {
         *         extend: 'Ext.panel.Panel',
         *         alias: ['widget.coolpanel'],
         *         title: 'Yeah!'
         *     });
         *
         *     // Using Ext.create
         *     Ext.create('widget.coolpanel');
         *
         *     // Using the shorthand for defining widgets by xtype
         *     Ext.widget('panel', {
         *         items: [
         *             {xtype: 'coolpanel', html: 'Foo'},
         *             {xtype: 'coolpanel', html: 'Bar'}
         *         ]
         *     });
         *
         * Besides "widget" for xtype there are alias namespaces like "feature" for ftype and "plugin" for ptype.
         */
        alias: string;

        /**
         * Defines alternate names for this class.  For example:
         *
         *     Ext.define('Developer', {
         *         alternateClassName: ['Coder', 'Hacker'],
         *         code: function(msg) {
         *             alert('Typing... ' + msg);
         *         }
         *     });
         *
         *     var joe = Ext.create('Developer');
         *     joe.code('stackoverflow');
         *
         *     var rms = Ext.create('Hacker');
         *     rms.code('hack hack');
         */
        alternateClassName: string;

        /**
         * List of configuration options with their default values, for which automatically
         * accessor methods are generated.  For example:
         *
         *     Ext.define('SmartPhone', {
         *          config: {
         *              hasTouchScreen: false,
         *              operatingSystem: 'Other',
         *              price: 500
         *          },
         *          constructor: function(cfg) {
         *              this.initConfig(cfg);
         *          }
         *     });
         *
         *     var iPhone = new SmartPhone({
         *          hasTouchScreen: true,
         *          operatingSystem: 'iOS'
         *     });
         *
         *     iPhone.getPrice(); // 500;
         *     iPhone.getOperatingSystem(); // 'iOS'
         *     iPhone.getHasTouchScreen(); // true;
         *
         * NOTE for when configs are reference types, the getter and setter methods do not make copies.
         *
         * For example, when a config value is set, the reference is stored on the instance. All instances that set
         * the same reference type will share it.
         *
         * In the case of the getter, the value with either come from the prototype if the setter was never called or from
         * the instance as the last value passed to the setter.
         *
         * For some config properties, the value passed to the setter is transformed prior to being stored on the instance.
         */
        config: any;

        /**
         * The parent class that this class extends. For example:
         *
         *     Ext.define('Person', {
         *         say: function(text) { alert(text); }
         *     });
         *
         *     Ext.define('Developer', {
         *         extend: 'Person',
         *         say: function(text) { this.callParent(["print "+text]); }
         *     });
         */
        extend: string;

        /**
         * List of inheritable static methods for this class.
         * Otherwise just like {@link #statics} but subclasses inherit these methods.
         */
        inheritableStatics: any;

        /**
         * List of classes to mix into this class. For example:
         *
         *     Ext.define('CanSing', {
         *          sing: function() {
         *              alert("I'm on the highway to hell...")
         *          }
         *     });
         *
         *     Ext.define('Musician', {
         *          mixins: ['CanSing']
         *     })
         *
         * In this case the Musician class will get a 'sing' method from CanSing mixin.
         *
         * But what if the Musician already has a 'sing' method? Or you want to mix
         * in two classes, both of which define 'sing'?  In such a cases it's good
         * to define mixins as an object, where you assign a name to each mixin:
         *
         *     Ext.define('Musician', {
         *          mixins: {
         *              canSing: 'CanSing'
         *          },
         *
         *          sing: function() {
         *              // delegate singing operation to mixin
         *              this.mixins.canSing.sing.call(this);
         *          }
         *     })
         *
         * In this case the 'sing' method of Musician will overwrite the
         * mixed in 'sing' method. But you can access the original mixed in method
         * through special 'mixins' property.
         */
        mixins: string|any;

        /**
         * List of classes that have to be loaded before instantiating this class.
         * For example:
         *
         *     Ext.define('Mother', {
         *         requires: ['Child'],
         *         giveBirth: function() {
         *             // we can be sure that child class is available.
         *             return new Child();
         *         }
         *     });
         */
        requires: string;

        /**
         * When set to true, the class will be instantiated as singleton.  For example:
         *
         *     Ext.define('Logger', {
         *         singleton: true,
         *         log: function(msg) {
         *             console.log(msg);
         *         }
         *     });
         *
         *     Logger.log('Hello');
         */
        singleton: boolean;

        /**
         * List of static methods for this class. For example:
         *
         *     Ext.define('Computer', {
         *          statics: {
         *              factory: function(brand) {
         *                  // 'this' in static methods refer to the class itself
         *                  return new this(brand);
         *              }
         *          },
         *
         *          constructor: function() { ... }
         *     });
         *
         *     var dellComputer = Computer.factory('Dell');
         */
        statics: any;

        /**
         * List of optional classes to load together with this class. These aren't neccessarily loaded before
         * this class is created, but are guaranteed to be available before Ext.onReady listeners are
         * invoked. For example:
         *
         *     Ext.define('Mother', {
         *         uses: ['Child'],
         *         giveBirth: function() {
         *             // This code might, or might not work:
         *             // return new Child();
         *
         *             // Instead use Ext.create() to load the class at the spot if not loaded already:
         *             return Ext.create('Child');
         *         }
         *     });
         */
        uses: string;

        /**
         * Create a new anonymous class.
         *
         * @param {Object} data An object represent the properties of this class
         * @param {Function} onCreated Optional, the callback function to be executed when this class is fully created.
         * Note that the creation process can be asynchronous depending on the pre-processors used.
         *
         * @return {Ext.Base} The newly created class
         */
        constructor(data: any, onCreated: Function);
    }

    /**
     * @author Jacky Nguyen <jacky@sencha.com>
     * @docauthor Jacky Nguyen <jacky@sencha.com>
     *
     * Ext.ClassManager manages all classes and handles mapping from string class name to
     * actual class objects throughout the whole framework. It is not generally accessed directly, rather through
     * these convenient shorthands:
     *
     * - {@link Ext#define Ext.define}
     * - {@link Ext#create Ext.create}
     * - {@link Ext#widget Ext.widget}
     * - {@link Ext#getClass Ext.getClass}
     * - {@link Ext#getClassName Ext.getClassName}
     *
     * # Basic syntax:
     *
     *     Ext.define(className, properties);
     *
     * in which 'properties' is an object represent a collection of properties that apply to the class. See
     * {@link Ext.ClassManager#create} for more detailed instructions.
     *
     *     Ext.define('Person', {
     *          name: 'Unknown',
     *
     *          constructor: function(name) {
     *              if (name) {
     *                  this.name = name;
     *              }
     *          },
     *
     *          eat: function(foodType) {
     *              alert("I'm eating: " + foodType);
     *
     *              return this;
     *          }
     *     });
     *
     *     var aaron = new Person("Aaron");
     *     aaron.eat("Sandwich"); // alert("I'm eating: Sandwich");
     *
     * Ext.Class has a powerful set of extensible {@link Ext.Class#registerPreprocessor pre-processors} which takes care of
     * everything related to class creation, including but not limited to inheritance, mixins, configuration, statics, etc.
     *
     * # Inheritance:
     *
     *     Ext.define('Developer', {
     *          extend: 'Person',
     *
     *          constructor: function(name, isGeek) {
     *              this.isGeek = isGeek;
     *
     *              // Apply a method from the parent class' prototype
     *              this.callParent([name]);
     *          },
     *
     *          code: function(language) {
     *              alert("I'm coding in: " + language);
     *
     *              this.eat("Bugs");
     *
     *              return this;
     *          }
     *     });
     *
     *     var jacky = new Developer("Jacky", true);
     *     jacky.code("JavaScript"); // alert("I'm coding in: JavaScript");
     *                               // alert("I'm eating: Bugs");
     *
     * See {@link Ext.Base#callParent} for more details on calling superclass' methods
     *
     * # Mixins:
     *
     *     Ext.define('CanPlayGuitar', {
     *          playGuitar: function() {
     *             alert("F#...G...D...A");
     *          }
     *     });
     *
     *     Ext.define('CanComposeSongs', {
     *          composeSongs: function() { ... }
     *     });
     *
     *     Ext.define('CanSing', {
     *          sing: function() {
     *              alert("I'm on the highway to hell...")
     *          }
     *     });
     *
     *     Ext.define('Musician', {
     *          extend: 'Person',
     *
     *          mixins: {
     *              canPlayGuitar: 'CanPlayGuitar',
     *              canComposeSongs: 'CanComposeSongs',
     *              canSing: 'CanSing'
     *          }
     *     })
     *
     *     Ext.define('CoolPerson', {
     *          extend: 'Person',
     *
     *          mixins: {
     *              canPlayGuitar: 'CanPlayGuitar',
     *              canSing: 'CanSing'
     *          },
     *
     *          sing: function() {
     *              alert("Ahem....");
     *
     *              this.mixins.canSing.sing.call(this);
     *
     *              alert("[Playing guitar at the same time...]");
     *
     *              this.playGuitar();
     *          }
     *     });
     *
     *     var me = new CoolPerson("Jacky");
     *
     *     me.sing(); // alert("Ahem...");
     *                // alert("I'm on the highway to hell...");
     *                // alert("[Playing guitar at the same time...]");
     *                // alert("F#...G...D...A");
     *
     * # Config:
     *
     *     Ext.define('SmartPhone', {
     *          config: {
     *              hasTouchScreen: false,
     *              operatingSystem: 'Other',
     *              price: 500
     *          },
     *
     *          isExpensive: false,
     *
     *          constructor: function(config) {
     *              this.initConfig(config);
     *          },
     *
     *          applyPrice: function(price) {
     *              this.isExpensive = (price > 500);
     *
     *              return price;
     *          },
     *
     *          applyOperatingSystem: function(operatingSystem) {
     *              if (!(/^(iOS|Android|BlackBerry)$/i).test(operatingSystem)) {
     *                  return 'Other';
     *              }
     *
     *              return operatingSystem;
     *          }
     *     });
     *
     *     var iPhone = new SmartPhone({
     *          hasTouchScreen: true,
     *          operatingSystem: 'iOS'
     *     });
     *
     *     iPhone.getPrice(); // 500;
     *     iPhone.getOperatingSystem(); // 'iOS'
     *     iPhone.getHasTouchScreen(); // true;
     *     iPhone.hasTouchScreen(); // true
     *
     *     iPhone.isExpensive; // false;
     *     iPhone.setPrice(600);
     *     iPhone.getPrice(); // 600
     *     iPhone.isExpensive; // true;
     *
     *     iPhone.setOperatingSystem('AlienOS');
     *     iPhone.getOperatingSystem(); // 'Other'
     *
     * # Statics:
     *
     *     Ext.define('Computer', {
     *          statics: {
     *              factory: function(brand) {
     *                 // 'this' in static methods refer to the class itself
     *                  return new this(brand);
     *              }
     *          },
     *
     *          constructor: function() { ... }
     *     });
     *
     *     var dellComputer = Computer.factory('Dell');
     *
     * Also see {@link Ext.Base#statics} and {@link Ext.Base#self} for more details on accessing
     * static properties within class methods
     */
    export class ClassManager {
        /**
         * Adds a batch of class name to alias mappings
         * @param {Object} aliases The set of mappings of the form
         * className : [values...]
         */
        static addNameAliasMappings(aliases: any);

        /**
         * @param {Object} alternates The set of mappings of the form
         * className : [values...]
         */
        static addNameAlternateMappings(alternates: any);

        /**
         * Defines a class.
         * @deprecated 4.1.0 Use {@link Ext#define} instead, as that also supports creating overrides.
         */
        static create();

        /**
         * Retrieve a class by its name.
         *
         * @return {Ext.Class} class
         */
        static get(name: string): Ext.Class;

        /**
         * Get the aliases of a class by the class name
         *
         * @return {Array} aliases
         */
        static getAliasesByName(name: string): any[];

        /**
         * Get a reference to the class by its alias.
         *
         * @return {Ext.Class} class
         */
        static getByAlias(alias: string): Ext.Class;

        /**
         * Get the class of the provided object; returns null if it's not an instance
         * of any class created with Ext.define.
         *
         * {@link Ext.ClassManager#getClass} is usually invoked by the shorthand {@link Ext#getClass}.
         *
         *     var component = new Ext.Component();
         *
         *     Ext.getClass(component); // returns Ext.Component
         *
         * @return {Ext.Class} class
         */
        static getClass(object: any): Ext.Class;

        /**
         * Returns the displayName property or className or object. When all else fails, returns "Anonymous".
         * @return {String}
         */
        static getDisplayName(object: any): string;

        /**
         * Get the name of the class by its reference or its instance;
         *
         * {@link Ext.ClassManager#getName} is usually invoked by the shorthand {@link Ext#getClassName}.
         *
         *     Ext.getName(Ext.Action); // returns "Ext.Action"
         *
         * @return {String} className
         */
        static getName(object: Ext.Class|any): string;

        /**
         * Get the name of a class by its alias.
         *
         * @return {String} className
         */
        static getNameByAlias(alias: string): string;

        /**
         * Get the name of a class by its alternate name.
         *
         * @return {String} className
         */
        static getNameByAlternate(alternate: string): string;

        /**
         * Converts a string expression to an array of matching class names. An expression can either refers to class aliases
         * or class names. Expressions support wildcards:
         *
         *      // returns ['Ext.window.Window']
         *     var window = Ext.ClassManager.getNamesByExpression('widget.window');
         *
         *     // returns ['widget.panel', 'widget.window', ...]
         *     var allWidgets = Ext.ClassManager.getNamesByExpression('widget.*');
         *
         *     // returns ['Ext.data.Store', 'Ext.data.ArrayProxy', ...]
         *     var allData = Ext.ClassManager.getNamesByExpression('Ext.data.*');
         *
         * @return {String[]} classNames
         */
        static getNamesByExpression(expression: string): string;

        /**
         * Instantiate a class by its alias.
         *
         * {@link Ext.ClassManager#instantiateByAlias} is usually invoked by the shorthand {@link Ext#createByAlias}.
         *
         * If {@link Ext.Loader} is {@link Ext.Loader#setConfig enabled} and the class has not been defined yet, it will
         * attempt to load the class via synchronous loading.
         *
         *     var window = Ext.createByAlias('widget.window', { width: 600, height: 800, ... });
         *
         * @param {Object...} args Additional arguments after the alias will be passed to the
         * class constructor.
         * @return {Object} instance
         */
        static instantiateByAlias(alias: string, args: any): any;

        /**
         * Checks if a class has already been created.
         *
         * @return {Boolean} exist
         */
        static isCreated(className: string): boolean;

        /**
         * Sets a name reference to a class.
         *
         * @return {Ext.ClassManager} this
         */
        static set(name: string, value: any): Ext.ClassManager;

        /**
         * Register the alias for a class.
         *
         * @param {Ext.Class/String} cls a reference to a class or a className
         * @param {String} alias Alias to use when referring to this class
         */
        static setAlias(cls: Ext.Class|string, alias: string);

        /**
         * Creates a namespace and assign the 'value' to the created object
         *
         *     Ext.ClassManager.setNamespace('MyCompany.pkg.Example', someObject);
         *
         *     alert(MyCompany.pkg.Example === someObject); // alerts true
         */
        static setNamespace(name: string, value: any);
    }

    interface ComponentConfig extends Ext.AbstractComponentConfig {
        /**
         * 'true' to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary,
         * 'false' to clip any overflowing content.
         * This should not be combined with {@link #overflowX} or  {@link #overflowY}.
         *
         * Optional, Defaults to: false
         */
        autoScroll?: boolean;

        /**
         * Defines the column width inside {@link Ext.layout.container.Column column layout}.
         *
         * Can be specified as a number or as a percentage.
         *
         * Optional, Defaults to: undefined
         */
        columnWidth?: number|string;

        /**
         * A {@link Ext.util.Region Region} (or an element from which a Region measurement will be read) which is used
         * to constrain the component. Only applies when the component is floating.
         */
        constrainTo?: Ext.util.Region|Ext.dom.Element;

        /**
         * An object or a string (in TRBL order) specifying insets from the configured {@link #constrainTo constrain region}
         * within which this component must be constrained when positioning or sizing.
         * example:
         *
         *    constraintInsets: '10 10 10 10' // Constrain with 10px insets from parent
         */
        constraintInsets?: any|string;

        /**
         * The default {@link Ext.util.Positionable#getAlignToXY Ext.Element#getAlignToXY} anchor position value for this menu
         * relative to its element of origin. Used in conjunction with {@link #showBy}.
         *
         * Optional, Defaults to: "tl-bl?"
         */
        defaultAlign?: string;

        /**
         * Specify as true to float the Component outside of the document flow using CSS absolute positioning.
         *
         * Components such as {@link Ext.window.Window Window}s and {@link Ext.menu.Menu Menu}s are floating by default.
         *
         * Floating Components that are programatically {@link Ext.Component#method-render rendered} will register
         * themselves with the global {@link Ext.WindowManager ZIndexManager}
         *
         * ### Floating Components as child items of a Container
         *
         * A floating Component may be used as a child item of a Container. This just allows the floating Component to seek
         * a ZIndexManager by examining the ownerCt chain.
         *
         * When configured as floating, Components acquire, at render time, a {@link Ext.ZIndexManager ZIndexManager} which
         * manages a stack of related floating Components. The ZIndexManager brings a single floating Component to the top
         * of its stack when the Component's {@link #toFront} method is called.
         *
         * The ZIndexManager is found by traversing up the {@link #ownerCt} chain to find an ancestor which itself is
         * floating. This is so that descendant floating Components of floating _Containers_ (Such as a ComboBox dropdown
         * within a Window) can have its zIndex managed relative to any siblings, but always **above** that floating
         * ancestor Container.
         *
         * If no floating ancestor is found, a floating Component registers itself with the default {@link Ext.WindowManager
         * ZIndexManager}.
         *
         * Floating components _do not participate in the Container's layout_. Because of this, they are not rendered until
         * you explicitly {@link #method-show} them.
         *
         * After rendering, the ownerCt reference is deleted, and the {@link #floatParent} property is set to the found
         * floating ancestor Container. If no floating ancestor Container was found the {@link #floatParent} property will
         * not be set.
         */
        floating?: boolean;

        /**
         * When inside FormPanel, any component configured with 'formBind: true' will
         * be enabled/disabled depending on the validity state of the form.
         * See {@link Ext.form.Panel} for more information and example.
         *
         * Optional, Defaults to: false
         */
        formBind?: boolean;

        /**
         * Possible values are:
         *  * ''auto'' to enable automatic horizontal scrollbar (overflow-x: 'auto').
         *  * ''scroll'' to always enable horizontal scrollbar (overflow-x: 'scroll').
         * The default is overflow-x: 'hidden'. This should not be combined with {@link #autoScroll}.
         */
        overflowX?: string;

        /**
         * Possible values are:
         *  * ''auto'' to enable automatic vertical scrollbar (overflow-y: 'auto').
         *  * ''scroll'' to always enable vertical scrollbar (overflow-y: 'scroll').
         * The default is overflow-y: 'hidden'. This should not be combined with {@link #autoScroll}.
         */
        overflowY?: string;

        /**
         * Defines the region inside {@link Ext.layout.container.Border border layout}.
         *
         * Possible values:
         *
         * - north - Positions component at top.
         * - south - Positions component at bottom.
         * - east - Positions component at right.
         * - west - Positions component at left.
         * - center - Positions component at the remaining space.
         *   There **must** be a component with 'region: "center"' in every border layout.
         *
         * Optional, Defaults to: undefined
         */
        region?: any;

        /**
         * Specify as 'true' to apply a {@link Ext.resizer.Resizer Resizer} to this Component after rendering.
         *
         * May also be specified as a config object to be passed to the constructor of {@link Ext.resizer.Resizer Resizer}
         * to override any defaults. By default the Component passes its minimum and maximum size, and uses
         * '{@link Ext.resizer.Resizer#dynamic}: false'
         */
        resizable?: boolean|any;

        /**
         * A valid {@link Ext.resizer.Resizer} handles config string. Only applies when resizable = true.
         */
        resizeHandles?: string;

        /**
         * True to automatically call {@link #toFront} when the {@link #method-show} method is called on an already visible,
         * floating component.
         */
        toFrontOnShow?: boolean;
    }

    /**
     * Base class for all Ext components.
     *
     * The Component base class has built-in support for basic hide/show and enable/disable and size control behavior.
     *
     * ## xtypes
     *
     * Every component has a specific xtype, which is its Ext-specific type name, along with methods for checking the xtype
     * like {@link #getXType} and {@link #isXType}. See the [Component Guide][1] for more information on xtypes and the
     * Component hierarchy.
     *
     * ## Finding components
     *
     * All Components are registered with the {@link Ext.ComponentManager} on construction so that they can be referenced at
     * any time via {@link Ext#getCmp Ext.getCmp}, passing the {@link #id}.
     *
     * Additionally the {@link Ext.ComponentQuery} provides a CSS-selectors-like way to look up components by their xtype
     * and many other attributes.  For example the following code will find all textfield components inside component with
     * 'id: 'myform'':
     *
     *     Ext.ComponentQuery.query('#myform textfield');
     *
     * ## Extending Ext.Component
     *
     * All subclasses of Component may participate in the automated Ext component
     * lifecycle of creation, rendering and destruction which is provided by the {@link Ext.container.Container Container}
     * class. Components may be added to a Container through the {@link Ext.container.Container#cfg-items items} config option
     * at the time the Container is created, or they may be added dynamically via the
     * {@link Ext.container.Container#method-add add} method.
     *
     * All user-developed visual widgets that are required to participate in automated lifecycle and size management should
     * subclass Component.
     *
     * See the Creating new UI controls chapter in [Component Guide][1] for details on how and to either extend
     * or augment Ext JS base classes to create custom Components.
     *
     * ## The Ext.Component class by itself
     *
     * Usually one doesn't need to instantiate the Ext.Component class. There are subclasses which implement
     * specialized use cases, covering most application needs. However it is possible to instantiate a base
     * Component, and it can be rendered to document, or handled by layouts as the child item of a Container:
     *
     *     @example
     *     Ext.create('Ext.Component', {
     *         html: 'Hello world!',
     *         width: 300,
     *         height: 200,
     *         padding: 20,
     *         style: {
     *             color: '#FFFFFF',
     *             backgroundColor:'#000000'
     *         },
     *         renderTo: Ext.getBody()
     *     });
     *
     * The Component above creates its encapsulating 'div' upon render, and use the configured HTML as content. More complex
     * internal structure may be created using the {@link #renderTpl} configuration, although to display database-derived
     * mass data, it is recommended that an ExtJS data-backed Component such as a {@link Ext.view.View View},
     * {@link Ext.grid.Panel GridPanel}, or {@link Ext.tree.Panel TreePanel} be used.
     *
     * [1]: #!/guide/components
     */
    export class Component extends Ext.AbstractComponent implements Ext.ComponentConfig {
        /**
         * **Only present for {@link #floating} Components which were inserted as child items of Containers.**
         *
         * There are other similar relationships such as the {@link Ext.button.Button button} which activates a {@link Ext.button.Button#cfg-menu menu}, or the
         * {@link Ext.menu.Item menu item} which activated a {@link Ext.menu.Item#cfg-menu submenu}, or the
         * {@link Ext.grid.column.Column column header} which activated the column menu.
         *
         * These differences are abstracted away by the {@link #up} method.
         *
         * Floating Components that are programatically {@link Ext.Component#method-render rendered} will not have a 'floatParent'
         * property.
         *
         * See {@link #floating} and {@link #zIndexManager}
         * @readonly
         */
        floatParent: Ext.container.Container;

        /**
         * An object property which provides unified information as to which dimensions are scrollable based upon
         * the {@link #autoScroll}, {@link #overflowX} and {@link #overflowY} settings (And for *views* of trees and grids, the owning panel's {@link Ext.panel.Table#scroll scroll} setting).
         *
         * Note that if you set overflow styles using the {@link #style} config or {@link Ext.panel.Panel#bodyStyle bodyStyle} config, this object does not include that information;
         * it is best to use {@link #autoScroll}, {@link #overflowX} and {@link #overflowY} if you need to access these flags.
         *
         * This object has the following properties:
         * 'true' if this Component is scrollable horizontally - style setting may be ''auto'' or ''scroll''.
         * 'true' if this Component is scrollable vertically - style setting may be ''auto'' or ''scroll''.
         * 'true' if this Component is scrollable both horizontally and vertically.
         * The 'overflow-x' style setting, ''auto'' or ''scroll'' or ''''.
         * The 'overflow-y' style setting, ''auto'' or ''scroll'' or ''''.
         * @readonly
         */
        scrollFlags: any;

        /**
         * Only present for {@link #floating} Components after they have been rendered.
         *
         * A reference to the ZIndexManager which is managing this Component's z-index.
         *
         * The {@link Ext.ZIndexManager ZIndexManager} maintains a stack of floating Component z-indices, and also provides
         * a single modal mask which is insert just beneath the topmost visible modal floating Component.
         *
         * Floating Components may be {@link #toFront brought to the front} or {@link #toBack sent to the back} of the
         * z-index stack.
         *
         * This defaults to the global {@link Ext.WindowManager ZIndexManager} for floating Components that are
         * programatically {@link Ext.Component#method-render rendered}.
         *
         * For {@link #floating} Components which are added to a Container, the ZIndexManager is acquired from the first
         * ancestor Container found which is floating. If no floating ancestor is found, the global {@link Ext.WindowManager ZIndexManager} is
         * used.
         *
         * See {@link #floating} and {@link #zIndexParent}
         * @readonly
         */
        zIndexManager: Ext.ZIndexManager;

        /**
         * Only present for {@link #floating} Components which were inserted as child items of Containers, and which have a floating
         * Container in their containment ancestry.
         *
         * For {@link #floating} Components which are child items of a Container, the zIndexParent will be a floating
         * ancestor Container which is responsible for the base z-index value of all its floating descendants. It provides
         * a {@link Ext.ZIndexManager ZIndexManager} which provides z-indexing services for all its descendant floating
         * Components.
         *
         * Floating Components that are programatically {@link Ext.Component#method-render rendered} will not have a 'zIndexParent'
         * property.
         *
         * For example, the dropdown {@link Ext.view.BoundList BoundList} of a ComboBox which is in a Window will have the
         * Window as its 'zIndexParent', and will always show above that Window, wherever the Window is placed in the z-index stack.
         *
         * See {@link #floating} and {@link #zIndexManager}
         * @readonly
         */
        zIndexParent: Ext.container.Container;

        /**
         * 'true' to use overflow:'auto' on the components layout element and show scroll bars automatically when necessary,
         * 'false' to clip any overflowing content.
         * This should not be combined with {@link #overflowX} or  {@link #overflowY}.
         *
         * Optional, Defaults to: false
         */
        autoScroll: boolean;

        /**
         * Defines the column width inside {@link Ext.layout.container.Column column layout}.
         *
         * Can be specified as a number or as a percentage.
         *
         * Optional, Defaults to: undefined
         */
        columnWidth: number|string;

        /**
         * An object or a string (in TRBL order) specifying insets from the configured {@link #constrainTo constrain region}
         * within which this component must be constrained when positioning or sizing.
         * example:
         *
         *    constraintInsets: '10 10 10 10' // Constrain with 10px insets from parent
         */
        constraintInsets: any|string;

        /**
         * A {@link Ext.util.Region Region} (or an element from which a Region measurement will be read) which is used
         * to constrain the component. Only applies when the component is floating.
         */
        constrainTo: Ext.util.Region|Ext.dom.Element;

        /**
         * The default {@link Ext.util.Positionable#getAlignToXY Ext.Element#getAlignToXY} anchor position value for this menu
         * relative to its element of origin. Used in conjunction with {@link #showBy}.
         *
         * Optional, Defaults to: "tl-bl?"
         */
        defaultAlign: string;

        /**
         * Specify as true to float the Component outside of the document flow using CSS absolute positioning.
         *
         * Components such as {@link Ext.window.Window Window}s and {@link Ext.menu.Menu Menu}s are floating by default.
         *
         * Floating Components that are programatically {@link Ext.Component#method-render rendered} will register
         * themselves with the global {@link Ext.WindowManager ZIndexManager}
         *
         * ### Floating Components as child items of a Container
         *
         * A floating Component may be used as a child item of a Container. This just allows the floating Component to seek
         * a ZIndexManager by examining the ownerCt chain.
         *
         * When configured as floating, Components acquire, at render time, a {@link Ext.ZIndexManager ZIndexManager} which
         * manages a stack of related floating Components. The ZIndexManager brings a single floating Component to the top
         * of its stack when the Component's {@link #toFront} method is called.
         *
         * The ZIndexManager is found by traversing up the {@link #ownerCt} chain to find an ancestor which itself is
         * floating. This is so that descendant floating Components of floating _Containers_ (Such as a ComboBox dropdown
         * within a Window) can have its zIndex managed relative to any siblings, but always **above** that floating
         * ancestor Container.
         *
         * If no floating ancestor is found, a floating Component registers itself with the default {@link Ext.WindowManager
         * ZIndexManager}.
         *
         * Floating components _do not participate in the Container's layout_. Because of this, they are not rendered until
         * you explicitly {@link #method-show} them.
         *
         * After rendering, the ownerCt reference is deleted, and the {@link #floatParent} property is set to the found
         * floating ancestor Container. If no floating ancestor Container was found the {@link #floatParent} property will
         * not be set.
         */
        floating: boolean;

        /**
         * When inside FormPanel, any component configured with 'formBind: true' will
         * be enabled/disabled depending on the validity state of the form.
         * See {@link Ext.form.Panel} for more information and example.
         *
         * Optional, Defaults to: false
         */
        formBind: boolean;

        /**
         * Possible values are:
         *  * ''auto'' to enable automatic horizontal scrollbar (overflow-x: 'auto').
         *  * ''scroll'' to always enable horizontal scrollbar (overflow-x: 'scroll').
         * The default is overflow-x: 'hidden'. This should not be combined with {@link #autoScroll}.
         */
        overflowX: string;

        /**
         * Possible values are:
         *  * ''auto'' to enable automatic vertical scrollbar (overflow-y: 'auto').
         *  * ''scroll'' to always enable vertical scrollbar (overflow-y: 'scroll').
         * The default is overflow-y: 'hidden'. This should not be combined with {@link #autoScroll}.
         */
        overflowY: string;

        /**
         * Defines the region inside {@link Ext.layout.container.Border border layout}.
         *
         * Possible values:
         *
         * - north - Positions component at top.
         * - south - Positions component at bottom.
         * - east - Positions component at right.
         * - west - Positions component at left.
         * - center - Positions component at the remaining space.
         *   There **must** be a component with 'region: "center"' in every border layout.
         *
         * Optional, Defaults to: undefined
         */
        region: any;

        /**
         * Specify as 'true' to apply a {@link Ext.resizer.Resizer Resizer} to this Component after rendering.
         *
         * May also be specified as a config object to be passed to the constructor of {@link Ext.resizer.Resizer Resizer}
         * to override any defaults. By default the Component passes its minimum and maximum size, and uses
         * '{@link Ext.resizer.Resizer#dynamic}: false'
         */
        resizable: boolean|any;

        /**
         * A valid {@link Ext.resizer.Resizer} handles config string. Only applies when resizable = true.
         */
        resizeHandles: string;

        /**
         * True to automatically call {@link #toFront} when the {@link #method-show} method is called on an already visible,
         * floating component.
         */
        toFrontOnShow: boolean;

        /**
         * Invoked after the Component has been hidden.
         *
         * Gets passed the same 'callback' and 'scope' parameters that #onHide received.
         *
         * @param {Function} [callback]
         * @param {Object} [scope]
         */
        protected afterHide(callback?: Function, scope?: any);

        protected afterRender();

        /**
         * Invoked after the Component is shown (after #onShow is called).
         *
         * Gets passed the same parameters as #show.
         *
         * @param {String/Ext.Element} [animateTarget]
         * @param {Function} [callback]
         * @param {Object} [scope]
         */
        protected afterShow(animateTarget?: string|Ext.dom.Element, callback?: Function, scope?: any);

        protected beforeLayout();

        /**
         * Invoked before the Component is shown.
         */
        protected beforeShow();

        /**
         * Bubbles up the component/container heirarchy, calling the specified function with each component. The scope
         * (*this*) of function call will be the scope provided or the current component. The arguments to the function will
         * be the args provided or the current component. If the function returns false at any point, the bubble is stopped.
         *
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope of the function. Defaults to current node.
         * @param {Array} [args] The args to call the function with. Defaults to passing the current component.
         * @return {Ext.Component} this
         */
        bubble(fn: Function, scope?: any, args?: any[]): Ext.Component;

        /**
         * Cancel any deferred focus on this component
         */
        protected cancelFocus();

        /**
         * Clone the current component using the original config values passed into this instance by default.
         * @param {Object} overrides A new config containing any properties to override in the cloned version.
         * An id property can be passed on this object, otherwise one will be generated to avoid duplicates.
         * @return {Ext.Component} clone The cloned copy of this component
         */
        cloneConfig(overrides: any): Ext.Component;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Find a container above this component at any level by a custom function. If the passed function returns true, the
         * container will be returned.
         *
         * See also the {@link Ext.Component#up up} method.
         *
         * @param {Function} fn The custom function to call with the arguments (container, this component).
         * @return {Ext.container.Container} The first Container for which the custom function returns true
         */
        findParentBy(fn: Function): Ext.container.Container;

        /**
         * Find a container above this component at any level by xtype or class
         *
         * See also the {@link Ext.Component#up up} method.
         *
         * @param {String/Ext.Class} xtype The xtype string for a component, or the class of the component directly
         * @return {Ext.container.Container} The first Container which matches the given xtype or class
         */
        findParentByType(xtype: string|Ext.Class): Ext.container.Container;

        /**
         * Gets the current XY position of the component's underlying element.
         * @param {Boolean} [local=false] If true the element's left and top are returned instead of page XY.
         * @return {Number[]} The XY position of the element (e.g., [100, 200])
         */
        getPosition(local?: boolean): number;

        /**
         * Gets the xtype for this component as registered with {@link Ext.ComponentManager}. For a list of all available
         * xtypes, see the {@link Ext.Component} header. Example usage:
         *
         *     var t = new Ext.form.field.Text();
         *     alert(t.getXType());  // alerts 'textfield'
         *
         * @return {String} The xtype
         */
        getXType(): string;

        /**
         * The initComponent template method is an important initialization step for a Component. It is intended to be
         * implemented by each subclass of Ext.Component to provide any needed constructor logic. The
         * initComponent method of the class being created is called first, with each initComponent method
         * up the hierarchy to Ext.Component being called thereafter. This makes it easy to implement and,
         * if needed, override the constructor logic of the Component at any step in the hierarchy.
         *
         * The initComponent method **must** contain a call to {@link Ext.Base#callParent callParent} in order
         * to ensure that the parent class' initComponent method is also called.
         *
         * All config options passed to the constructor are applied to 'this' before initComponent is called,
         * so you can simply access them with 'this.someOption'.
         *
         * The following example demonstrates using a dynamic string for the text of a button at the time of
         * instantiation of the class.
         *
         *     Ext.define('DynamicButtonText', {
         *         extend: 'Ext.button.Button',
         *
         *         initComponent: function() {
         *             this.text = new Date();
         *             this.renderTo = Ext.getBody();
         *             this.callParent();
         *         }
         *     });
         *
         *     Ext.onReady(function() {
         *         Ext.create('DynamicButtonText');
         *     });
         *
         * @since 1.1.0
         */
        protected initComponent();

        /**
         * Allows addition of behavior to the destroy operation.
         * After calling the superclass's onDestroy, the Component will be destroyed.
         */
        protected onDestroy();

        /**
         * Possibly animates down to a target element.
         *
         * Allows addition of behavior to the hide operation. After
         * calling the superclasss onHide, the Component will be hidden.
         *
         * Gets passed the same parameters as #hide.
         *
         * @param {String/Ext.Element/Ext.Component} [animateTarget]
         * @param {Function} [callback]
         * @param {Object} [scope]
         */
        protected onHide(animateTarget?: string|Ext.dom.Element|Ext.Component, callback?: Function, scope?: any);

        /**
         * Allows addition of behavior to the show operation. After
         * calling the superclass's onShow, the Component will be visible.
         *
         * Override in subclasses where more complex behaviour is needed.
         *
         * Gets passed the same parameters as #show.
         *
         * @param {String/Ext.Element} [animateTarget]
         * @param {Function} [callback]
         * @param {Object} [scope]
         */
        protected onShow(animateTarget?: string|Ext.dom.Element, callback?: Function, scope?: any);

        /**
         * Invoked after the #afterShow method is complete.
         *
         * Gets passed the same 'callback' and 'scope' parameters that #afterShow received.
         *
         * @param {Function} [callback]
         * @param {Object} [scope]
         */
        protected onShowComplete(callback?: Function, scope?: any);

        /**
         * Scrolls this Component's {@link #getTargetEl target element} by the passed delta values, optionally animating.
         *
         * All of the following are equivalent:
         *
         *      comp.scrollBy(10, 10, true);
         *      comp.scrollBy([10, 10], true);
         *      comp.scrollBy({ x: 10, y: 10 }, true);
         *
         * @param {Number/Number[]/Object} deltaX Either the x delta, an Array specifying x and y deltas or
         * an object with "x" and "y" properties.
         * @param {Number/Boolean/Object} deltaY Either the y delta, or an animate flag or config object.
         * @param {Boolean/Object} animate Animate flag/config object if the delta values were passed separately.
         */
        scrollBy(deltaX: number|any, deltaY: number|boolean|any, animate: boolean|any);

        /**
         * Sets the overflow on the content element of the component.
         * @param {Boolean} scroll True to allow the Component to auto scroll.
         * @return {Ext.Component} this
         */
        setAutoScroll(scroll: boolean): Ext.Component;

        /**
         * This method changes the 'region' config property for this border region. This is
         * only valid if this component is in a 'border' layout ('Ext.layout.container.Border').
         * @param {String} region The new 'region' value ('"north"', '"south"', '"east"' or
         * '"west"').
         * @return {String} The previous value of the 'region' property.
         */
        setBorderRegion(region: string): string;

        /**
         * This method allows you to show or hide a LoadMask on top of this component.
         *
         * @param {Boolean/Object/String} load True to show the default LoadMask, a config object that will be passed to the
         * LoadMask constructor, or a message String to show. False to hide the current LoadMask.
         * @param {Boolean} [targetEl=false] True to mask the targetEl of this Component instead of the 'this.el'. For example,
         * setting this to true on a Panel will cause only the body to be masked.
         * @return {Ext.LoadMask} The LoadMask instance that has just been shown.
         */
        setLoading(load: boolean|any|string, targetEl?: boolean): Ext.LoadMask;

        /**
         * Sets the overflow x/y on the content element of the component. The x/y overflow
         * values can be any valid CSS overflow (e.g., 'auto' or 'scroll'). By default, the
         * value is 'hidden'. Passing null for one of the values will erase the inline style.
         * Passing 'undefined' will preserve the current value.
         *
         * @param {String} overflowX The overflow-x value.
         * @param {String} overflowY The overflow-y value.
         * @return {Ext.Component} this
         */
        setOverflowXY(overflowX: string, overflowY: string): Ext.Component;

        /**
         * Sets the page XY position of the component. To set the left and top instead, use {@link #setPosition}.
         * This method fires the {@link #event-move} event.
         * @param {Number/Number[]} x The new x position or an array of '[x,y]'.
         * @param {Number} [y] The new y position.
         * @param {Boolean/Object} [animate] True to animate the Component into its new position. You may also pass an
         * animation configuration.
         * @return {Ext.Component} this
         */
        setPagePosition(x: number, y?: number, animate?: boolean|any): Ext.Component;

        /**
         * Sets the left and top of the component. To set the page XY position instead, use {@link Ext.Component#setPagePosition setPagePosition}. This
         * method fires the {@link #event-move} event.
         * @param {Number/Number[]/Object} x The new left, an array of '[x,y]', or animation config object containing 'x' and 'y' properties.
         * @param {Number} [y] The new top.
         * @param {Boolean/Object} [animate] If 'true', the Component is _animated_ into its new position. You may also pass an
         * animation configuration.
         * @return {Ext.Component} this
         */
        setPosition(x: number|any, y?: number, animate?: boolean|any): Ext.Component;

        /**
         * Sets the 'weight' config property for this component. This is only valid if this
         * component is in a 'border' layout ('Ext.layout.container.Border').
         * @param {Number} weight The new 'weight' value.
         * @return {Number} The previous value of the 'weight' property.
         */
        setRegionWeight(weight: number): number;

        /**
         * Displays component at specific xy position.
         * A floating component (like a menu) is positioned relative to its ownerCt if any.
         * Useful for popping up a context menu:
         *
         *     listeners: {
         *         itemcontextmenu: function(view, record, item, index, event, options) {
         *             Ext.create('Ext.menu.Menu', {
         *                 width: 100,
         *                 height: 100,
         *                 margin: '0 0 10 0',
         *                 items: [{
         *                     text: 'regular item 1'
         *                 },{
         *                     text: 'regular item 2'
         *                 },{
         *                     text: 'regular item 3'
         *                 }]
         *             }).showAt(event.getXY());
         *         }
         *     }
         *
         * @param {Number/Number[]} x The new x position or array of '[x,y]'.
         * @param {Number} [y] The new y position
         * @param {Boolean/Object} [animate] True to animate the Component into its new position. You may also pass an
         * animation configuration.
         * @return {Ext.Component} this
         */
        showAt(x: number, y?: number, animate?: boolean|any): Ext.Component;

        /**
         * Shows this component by the specified {@link Ext.Component Component} or {@link Ext.Element Element}.
         * Used when this component is {@link #floating}.
         * @param {Ext.Component/Ext.dom.Element} component The {@link Ext.Component} or {@link Ext.Element} to show the component by.
         * @param {String} [position] Alignment position as used by {@link Ext.util.Positionable#getAlignToXY}.
         * Defaults to '{@link #defaultAlign}'.
         * @param {Number[]} [offsets] Alignment offsets as used by {@link Ext.util.Positionable#getAlignToXY}.
         * @return {Ext.Component} this
         */
        showBy(component: Ext.Component|Ext.dom.Element, position?: string, offsets?: number): Ext.Component;

        /**
         * Sets the current box measurements of the component's underlying element.
         * @param {Object} box An object in the format {x, y, width, height}
         * @return {Ext.Component} this
         */
        updateBox(box: any): Ext.Component;
    }

    interface ComponentLoaderConfig extends Ext.ElementLoaderConfig {
        /**
         * True to parse any inline script tags in the response. This only used when using the html
         * {@link #renderer}.
         */
        scripts?: boolean;
    }

    /**
     * This class is used to load content via Ajax into a {@link Ext.Component}. In general
     * this class will not be instanced directly, rather a loader configuration will be passed to the
     * constructor of the {@link Ext.Component}.
     *
     * ## HTML Renderer
     *
     * By default, the content loaded will be processed as raw html. The response text
     * from the request is taken and added to the component. This can be used in
     * conjunction with the {@link #scripts} option to execute any inline scripts in
     * the resulting content. Using this renderer has the same effect as passing the
     * {@link Ext.Component#html} configuration option.
     *
     * ## Data Renderer
     *
     * This renderer allows content to be added by using JSON data and a {@link Ext.XTemplate}.
     * The content received from the response is passed to the {@link Ext.Component#update} method.
     * This content is run through the attached {@link Ext.Component#tpl} and the data is added to
     * the Component. Using this renderer has the same effect as using the {@link Ext.Component#data}
     * configuration in conjunction with a {@link Ext.Component#tpl}.
     *
     * ## Component Renderer
     *
     * This renderer can only be used with a {@link Ext.container.Container} and subclasses. It allows for
     * Components to be loaded remotely into a Container. The response is expected to be a single/series of
     * {@link Ext.Component} configuration objects. When the response is received, the data is decoded
     * and then passed to {@link Ext.container.Container#method-add}. Using this renderer has the same effect as specifying
     * the {@link Ext.container.Container#cfg-items} configuration on a Container.
     *
     * ## Custom Renderer
     *
     * A custom function can be passed to handle any other special case, see the {@link #renderer} option.
     *
     * ## Example Usage
     *
     *     var cmp = Ext.create('Ext.Component', {
     *         renderTo: Ext.getBody(),
     *         tpl: '{firstName} - {lastName}',
     *         loader: {
     *             url: 'myPage.php',
     *             renderer: 'data',
     *             params: {
     *                 userId: 1
     *             }
     *         }
     *     });
     *
     *     // call the loader manually (or use autoLoad:true instead)
     *     cmp.getLoader().load();
     */
    export class ComponentLoader extends Ext.ElementLoader implements Ext.ComponentLoaderConfig {
        /**
         * True to parse any inline script tags in the response. This only used when using the html
         * {@link #renderer}.
         */
        scripts: boolean;

        constructor(config: Ext.ComponentLoaderConfig);
    }

    /**
     * <p>Provides a registry of all Components (instances of {@link Ext.Component} or any subclass
     * thereof) on a page so that they can be easily accessed by {@link Ext.Component component}
     * {@link Ext.Component#id id} (see {@link #get}, or the convenience method {@link Ext#getCmp Ext.getCmp}).</p>
     * <p>This object also provides a registry of available Component <i>classes</i>
     * indexed by a mnemonic code known as the Component's {@link Ext.Component#xtype xtype}.
     * The <code>xtype</code> provides a way to avoid instantiating child Components
     * when creating a full, nested config object for a complete Ext page.</p>
     * <p>A child Component may be specified simply as a <i>config object</i>
     * as long as the correct <code>{@link Ext.Component#xtype xtype}</code> is specified so that if and when the Component
     * needs rendering, the correct type can be looked up for lazy instantiation.</p>
     * <p>For a list of all available <code>{@link Ext.Component#xtype xtypes}</code>, see {@link Ext.Component}.</p>
     */
    export class ComponentManager {
        constructor(config: any);
    }

    /**
     * Provides searching of Components within Ext.ComponentManager (globally) or a specific
     * Ext.container.Container on the document with a similar syntax to a CSS selector.
     * Returns Array of matching Components, or empty Array.
     *
     * ## Basic Component lookup
     *
     * Components can be retrieved by using their {@link Ext.Component xtype}:
     *
     * - 'component'
     * - 'gridpanel'
     *
     * Matching by 'xtype' matches inherited types, so in the following code, the previous field
     * *of any type which inherits from 'TextField'* will be found:
     *
     *     prevField = myField.previousNode('textfield');
     *
     * To match only the exact type, pass the "shallow" flag by adding '(true)' to xtype
     * (See AbstractComponent's {@link Ext.AbstractComponent#isXType isXType} method):
     *
     *     prevTextField = myField.previousNode('textfield(true)');
     *
     * You can search Components by their 'id' or 'itemId' property, prefixed with a #:
     *
     *     #myContainer
     *
     * Component 'xtype' and 'id' or 'itemId' can be used together to avoid possible
     * id collisions between Components of different types:
     *
     *     panel#myPanel
     *
     * ## Traversing Component tree
     *
     * Components can be found by their relation to other Components. There are several
     * relationship operators, mostly taken from CSS selectors:
     *
     * - **'E F'** All descendant Components of E that match F
     * - **'E > F'** All direct children Components of E that match F
     * - **'E ^ F'** All parent Components of E that match F
     *
     * Expressions between relationship operators are matched left to right, i.e. leftmost
     * selector is applied first, then if one or more matches are found, relationship operator
     * itself is applied, then next selector expression, etc. It is possible to combine
     * relationship operators in complex selectors:
     *
     *     window[title="Input form"] textfield[name=login] ^ form > button[action=submit]
     *
     * That selector can be read this way: Find a window with title "Input form", in that
     * window find a TextField with name "login" at any depth (including subpanels and/or
     * FieldSets), then find an 'Ext.form.Panel' that is a parent of the TextField, and in
     * that form find a direct child that is a button with custom property 'action' set to
     * value "submit".
     *
     * Whitespace on both sides of '^' and '>' operators is non-significant, i.e. can be
     * omitted, but usually is used for clarity.
     *
     * ## Searching by Component attributes
     *
     * Components can be searched by their object property values (attributes). To do that,
     * use attribute matching expression in square brackets:
     *
     * - 'component[autoScroll]' - matches any Component that has 'autoScroll' property with
     * any truthy (non-empty, not 'false') value.
     * - 'panel[title="Test"]' - matches any Component that has 'title' property set to
     * "Test". Note that if the value does not contain spaces, the quotes are optional.
     *
     * Attributes can use any of the operators in {@link Ext.dom.Query DomQuery}'s
     * {@link Ext.dom.Query#operators operators} to compare values.
     *
     * Prefixing the attribute name with an at sign '@' means that the property must be
     * the object's 'ownProperty', not a property from the prototype chain.
     *
     * Specifications like '[propName]' check that the property is a truthy value. To check
     * that the object has an 'ownProperty' of a certain name, regardless of the value use
     * the form '[?propName]'.
     *
     * The specified value is coerced to match the type of the property found in the
     * candidate Component using {@link Ext#coerce}.
     *
     * If you need to find Components by their 'itemId' property, use '#id' form; it will
     * do the same but is easier to read.
     *
     * ## Attribute matching operators
     *
     * The '=' operator will return the results that **exactly** match the
     * specified object property (attribute):
     *
     *     Ext.ComponentQuery.query('panel[cls=my-cls]');
     *
     * Will match the following Component:
     *
     *     Ext.create('Ext.window.Window', {
     *         cls: 'my-cls'
     *     });
     *
     * But will not match the following Component, because 'my-cls' is one value
     * among others:
     *
     *      Ext.create('Ext.panel.Panel', {
     *          cls: 'foo-cls my-cls bar-cls'
     *      });
     *
     * You can use the '~=' operator instead, it will return Components with
     * the property that **exactly** matches one of the whitespace-separated
     * values. This is also true for properties that only have *one* value:
     *
     *     Ext.ComponentQuery.query('panel[cls~=my-cls]');
     *
     * Will match both Components:
     *
     *     Ext.create('Ext.panel.Panel', {
     *         cls: 'foo-cls my-cls bar-cls'
     *     });
     *
     *     Ext.create('Ext.window.Window', {
     *         cls: 'my-cls'
     *     });
     *
     * Generally, '=' operator is more suited for object properties other than
     * CSS classes, while '~=' operator will work best with properties that
     * hold lists of whitespace-separated CSS classes.
     *
     * The '^=' operator will return Components with specified attribute that
     * start with the passed value:
     *
     *     Ext.ComponentQuery.query('panel[title^=Sales]');
     *
     * Will match the following Component:
     *
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Sales estimate for Q4'
     *     });
     *
     * The '$=' operator will return Components with specified properties that
     * end with the passed value:
     *
     *     Ext.ComponentQuery.query('field[fieldLabel$=name]');
     *
     * Will match the following Component:
     *
     *     Ext.create('Ext.form.field.Text', {
     *         fieldLabel: 'Enter your name'
     *     });
     *
     * The following test will find panels with their 'ownProperty' collapsed being equal to
     * 'false'. It will **not** match a collapsed property from the prototype chain.
     *
     *     Ext.ComponentQuery.query('panel[@collapsed=false]');
     *
     * Member expressions from candidate Components may be tested. If the expression returns
     * a *truthy* value, the candidate Component will be included in the query:
     *
     *     var disabledFields = myFormPanel.query("{isDisabled()}");
     *
     * Such expressions are executed in Component's context, and the above expression is
     * similar to running this snippet for every Component in your application:
     *
     *      if (component.isDisabled()) {
     *          matches.push(component);
     *      }
     *
     * It is important to use only methods that are available in **every** Component instance
     * to avoid run time exceptions. If you need to match your Components with a custom
     * condition formula, you can augment 'Ext.Component' to provide custom matcher that
     * will return 'false' by default, and override it in your custom classes:
     *
     *      Ext.define('My.Component', {
     *          override: 'Ext.Component',
     *          myMatcher: function() { return false; }
     *      });
     *
     *      Ext.define('My.Panel', {
     *          extend: 'Ext.panel.Panel',
     *          requires: ['My.Component'],     // Ensure that Component override is applied
     *          myMatcher: function(selector) {
     *              return selector === 'myPanel';
     *          }
     *      });
     *
     * After that you can use a selector with your custom matcher to find all instances
     * of 'My.Panel':
     *
     *      Ext.ComponentQuery.query("{myMatcher('myPanel')}");
     *
     * However if you really need to use a custom matcher, you may find it easier to implement
     * a custom Pseudo class instead (see below).
     *
     * ## Conditional matching
     *
     * Attribute matchers can be combined to select only Components that match **all**
     * conditions (logical AND operator):
     *
     *     Ext.ComponentQuery.query('panel[cls~=my-cls][floating=true][title$="sales data"]');
     *
     * E.g., the query above will match only a Panel-descended Component that has 'my-cls'
     * CSS class *and* is floating *and* with a title that ends with "sales data".
     *
     * Expressions separated with commas will match any Component that satisfies
     * *either* expression (logical OR operator):
     *
     *     Ext.ComponentQuery.query('field[fieldLabel^=User], field[fieldLabel*=password]');
     *
     * E.g., the query above will match any field with field label starting with "User",
     * *or* any field that has "password" in its label.
     *
     * ## Pseudo classes
     *
     * Pseudo classes may be used to filter results in the same way as in
     * {@link Ext.dom.Query}. There are five default pseudo classes:
     *
     * * 'not' Negates a selector.
     * * 'first' Filters out all except the first matching item for a selector.
     * * 'last' Filters out all except the last matching item for a selector.
     * * 'focusable' Filters out all except Components which are currently able to recieve
     * focus.
     * * 'nth-child' Filters Components by ordinal position in the selection.
     *
     * These pseudo classes can be used with other matchers or without them:
     *
     *      // Select first direct child button in any panel
     *      Ext.ComponentQuery.query('panel > button:first');
     *
     *      // Select last field in Profile form
     *      Ext.ComponentQuery.query('form[title=Profile] field:last');
     *
     *      // Find first focusable Component in a panel and focus it
     *      panel.down(':focusable').focus();
     *
     *      // Select any field that is not hidden in a form
     *      form.query('field:not(hiddenfield)');
     *
     * Pseudo class 'nth-child' can be used to find any child Component by its
     * position relative to its siblings. This class' handler takes one argument
     * that specifies the selection formula as 'Xn' or 'Xn+Y':
     *
     *      // Find every odd field in a form
     *      form.query('field:nth-child(2n+1)'); // or use shortcut: :nth-child(odd)
     *
     *      // Find every even field in a form
     *      form.query('field:nth-child(2n)');   // or use shortcut: :nth-child(even)
     *
     *      // Find every 3rd field in a form
     *      form.query('field:nth-child(3n)');
     *
     * Pseudo classes can be combined to further filter the results, e.g., in the
     * form example above we can modify the query to exclude hidden fields:
     *
     *      // Find every 3rd non-hidden field in a form
     *      form.query('field:not(hiddenfield):nth-child(3n)');
     *
     * Note that when combining pseudo classes, whitespace is significant, i.e.
     * there should be no spaces between pseudo classes. This is a common mistake;
     * if you accidentally type a space between 'field' and ':not', the query
     * will not return any result because it will mean "find *field's children
     * Components* that are not hidden fields...".
     *
     * ## Custom pseudo classes
     *
     * It is possible to define your own custom pseudo classes. In fact, a
     * pseudo class is just a property in 'Ext.ComponentQuery.pseudos' object
     * that defines pseudo class name (property name) and pseudo class handler
     * (property value):
     *
     *     // Function receives array and returns a filtered array.
     *     Ext.ComponentQuery.pseudos.invalid = function(items) {
     *         var i = 0, l = items.length, c, result = [];
     *         for (; i < l; i++) {
     *             if (!(c = items[i]).isValid()) {
     *                 result.push(c);
     *             }
     *         }
     *         return result;
     *     };
     *
     *     var invalidFields = myFormPanel.query('field:invalid');
     *     if (invalidFields.length) {
     *         invalidFields[0].getEl().scrollIntoView(myFormPanel.body);
     *         for (var i = 0, l = invalidFields.length; i < l; i++) {
     *             invalidFields[i].getEl().frame("red");
     *         }
     *     }
     *
     * Pseudo class handlers can be even more flexible, with a selector
     * argument used to define the logic:
     *
     *      // Handler receives array of itmes and selector in parentheses
     *      Ext.ComponentQuery.pseudos.titleRegex = function(components, selector) {
     *          var i = 0, l = components.length, c, result = [], regex = new RegExp(selector);
     *          for (; i < l; i++) {
     *              c = components[i];
     *              if (c.title && regex.test(c.title)) {
     *                  result.push(c);
     *              }
     *          }
     *          return result;
     *      }
     *
     *      var salesTabs = tabPanel.query('panel:titleRegex("sales\\s+for\\s+201[123]")');
     *
     * Be careful when using custom pseudo classes with MVC Controllers: when
     * you use a pseudo class in Controller's 'control' or 'listen' component
     * selectors, the pseudo class' handler function will be called very often
     * and may slow down your application significantly. A good rule of thumb
     * is to always specify Component xtype with the pseudo class so that the
     * handlers are only called on Components that you need, and try to make
     * the condition checks as cheap in terms of execution time as possible.
     * Note how in the example above, handler function checks that Component
     * *has* a title first, before running regex test on it.
     *
     * ## Query examples
     *
     * Queries return an array of Components. Here are some example queries:
     *
     *     // retrieve all Ext.Panels in the document by xtype
     *     var panelsArray = Ext.ComponentQuery.query('panel');
     *
     *     // retrieve all Ext.Panels within the container with an id myCt
     *     var panelsWithinmyCt = Ext.ComponentQuery.query('#myCt panel');
     *
     *     // retrieve all direct children which are Ext.Panels within myCt
     *     var directChildPanel = Ext.ComponentQuery.query('#myCt > panel');
     *
     *     // retrieve all grids or trees
     *     var gridsAndTrees = Ext.ComponentQuery.query('gridpanel, treepanel');
     *
     *     // Focus first Component
     *     myFormPanel.child(':focusable').focus();
     *
     *     // Retrieve every odd text field in a form
     *     myFormPanel.query('textfield:nth-child(odd)');
     *
     *     // Retrieve every even field in a form, excluding hidden fields
     *     myFormPanel.query('field:not(hiddenfield):nth-child(even)');
     *
     * For easy access to queries based from a particular Container see the
     * {@link Ext.container.Container#query}, {@link Ext.container.Container#down} and
     * {@link Ext.container.Container#child} methods. Also see
     * {@link Ext.Component#up}.
     */
    export class ComponentQuery {
        /**
         * Tests whether the passed Component matches the selector string.
         * @param {Ext.Component} component The Component to test
         * @param {String} selector The selector string to test against.
         * @return {Boolean} True if the Component matches the selector.
         */
        static is(component: Ext.Component, selector: string): boolean;

        /**
         * Returns an array of matched Components from within the passed root object.
         *
         * This method filters returned Components in a similar way to how CSS selector based DOM
         * queries work using a textual selector string.
         *
         * See class summary for details.
         *
         * @param {String} selector The selector string to filter returned Components
         * @param {Ext.container.Container} [root] The Container within which to perform the query.
         * If omitted, all Components within the document are included in the search.
         *
         * This parameter may also be an array of Components to filter according to the selector.
         * @returns {Ext.Component[]} The matched Components.
         */
        static query(selector: string, root?: Ext.container.Container);
    }

    /**
     * A set of useful static methods to deal with date
     * Note that if Ext.Date is required and loaded, it will copy all methods / properties to
     * this object for convenience
     *
     * The date parsing and formatting syntax contains a subset of
     * [PHP's 'date()' function](http://www.php.net/date), and the formats that are
     * supported will provide results equivalent to their PHP versions.
     *
     * The following is a list of all currently supported formats:
     * <pre class="">
     Format      Description                                                               Example returned values
     ------      -----------------------------------------------------------------------   -----------------------
     d         Day of the month, 2 digits with leading zeros                             01 to 31
     D         A short textual representation of the day of the week                     Mon to Sun
     j         Day of the month without leading zeros                                    1 to 31
     l         A full textual representation of the day of the week                      Sunday to Saturday
     N         ISO-8601 numeric representation of the day of the week                    1 (for Monday) through 7 (for Sunday)
     S         English ordinal suffix for the day of the month, 2 characters             st, nd, rd or th. Works well with j
     w         Numeric representation of the day of the week                             0 (for Sunday) to 6 (for Saturday)
     z         The day of the year (starting from 0)                                     0 to 364 (365 in leap years)
     W         ISO-8601 week number of year, weeks starting on Monday                    01 to 53
     F         A full textual representation of a month, such as January or March        January to December
     m         Numeric representation of a month, with leading zeros                     01 to 12
     M         A short textual representation of a month                                 Jan to Dec
     n         Numeric representation of a month, without leading zeros                  1 to 12
     t         Number of days in the given month                                         28 to 31
     L         Whether it&#39;s a leap year                                                  1 if it is a leap year, 0 otherwise.
     o         ISO-8601 year number (identical to (Y), but if the ISO week number (W)    Examples: 1998 or 2004
     belongs to the previous or next year, that year is used instead)
     Y         A full numeric representation of a year, 4 digits                         Examples: 1999 or 2003
     y         A two digit representation of a year                                      Examples: 99 or 03
     a         Lowercase Ante meridiem and Post meridiem                                 am or pm
     A         Uppercase Ante meridiem and Post meridiem                                 AM or PM
     g         12-hour format of an hour without leading zeros                           1 to 12
     G         24-hour format of an hour without leading zeros                           0 to 23
     h         12-hour format of an hour with leading zeros                              01 to 12
     H         24-hour format of an hour with leading zeros                              00 to 23
     i         Minutes, with leading zeros                                               00 to 59
     s         Seconds, with leading zeros                                               00 to 59
     u         Decimal fraction of a second                                              Examples:
     (minimum 1 digit, arbitrary number of digits allowed)                     001 (i.e. 0.001s) or
     100 (i.e. 0.100s) or
     999 (i.e. 0.999s) or
     999876543210 (i.e. 0.999876543210s)
     O         Difference to Greenwich time (GMT) in hours and minutes                   Example: +1030
     P         Difference to Greenwich time (GMT) with colon between hours and minutes   Example: -08:00
     T         Timezone abbreviation of the machine running the code                     Examples: EST, MDT, PDT ...
     Z         Timezone offset in seconds (negative if west of UTC, positive if east)    -43200 to 50400
     c         ISO 8601 date
     Notes:                                                                    Examples:
     1) If unspecified, the month / day defaults to the current month / day,   1991 or
     the time defaults to midnight, while the timezone defaults to the      1992-10 or
     browser's timezone. If a time is specified, it must include both hours 1993-09-20 or
     and minutes. The "T" delimiter, seconds, milliseconds and timezone     1994-08-19T16:20+01:00 or
     are optional.                                                          1995-07-18T17:21:28-02:00 or
     2) The decimal fraction of a second, if specified, must contain at        1996-06-17T18:22:29.98765+03:00 or
     least 1 digit (there is no limit to the maximum number                 1997-05-16T19:23:30,12345-0400 or
     of digits allowed), and may be delimited by either a '.' or a ','      1998-04-15T20:24:31.2468Z or
     Refer to the examples on the right for the various levels of              1999-03-14T20:24:32Z or
     date-time granularity which are supported, or see                         2000-02-13T21:25:33
     http://www.w3.org/TR/NOTE-datetime for more info.                         2001-01-12 22:26:34
     U         Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)                1193432466 or -2138434463
     MS        Microsoft AJAX serialized dates                                           \/Date(1238606590509)\/ (i.e. UTC milliseconds since epoch) or
     \/Date(1238606590509+0800)\/
     time      A javascript millisecond timestamp                                        1350024476440
     timestamp A UNIX timestamp (same as U)                                              1350024866
     </pre>
     *
     * Example usage (note that you must escape format specifiers with '\\' to render them as character literals):
     *
     *     // Sample date:
     *     // 'Wed Jan 10 2007 15:05:01 GMT-0600 (Central Standard Time)'
     *
     *     var dt = new Date('1/10/2007 03:05:01 PM GMT-0600');
     *     console.log(Ext.Date.format(dt, 'Y-m-d'));                          // 2007-01-10
     *     console.log(Ext.Date.format(dt, 'F j, Y, g:i a'));                  // January 10, 2007, 3:05 pm
     *     console.log(Ext.Date.format(dt, 'l, \\t\\he jS \\of F Y h:i:s A')); // Wednesday, the 10th of January 2007 03:05:01 PM
     *
     * Here are some standard date/time patterns that you might find helpful.  They
     * are not part of the source of Ext.Date, but to use them you can simply copy this
     * block of code into any script that is included after Ext.Date and they will also become
     * globally available on the Date object.  Feel free to add or remove patterns as needed in your code.
     *
     *     Ext.Date.patterns = {
     *         ISO8601Long:"Y-m-d H:i:s",
     *         ISO8601Short:"Y-m-d",
     *         ShortDate: "n/j/Y",
     *         LongDate: "l, F d, Y",
     *         FullDateTime: "l, F d, Y g:i:s A",
     *         MonthDay: "F d",
     *         ShortTime: "g:i A",
     *         LongTime: "g:i:s A",
     *         SortableDateTime: "Y-m-d\\TH:i:s",
     *         UniversalSortableDateTime: "Y-m-d H:i:sO",
     *         YearMonth: "F, Y"
     *     };
     *
     * Example usage:
     *
     *     var dt = new Date();
     *     console.log(Ext.Date.format(dt, Ext.Date.patterns.ShortDate));
     *
     * Developer-written, custom formats may be used by supplying both a formatting and a parsing function
     * which perform to specialized requirements. The functions are stored in {@link #parseFunctions} and {@link #formatFunctions}.
     */
    export class Date {
        /**
         * Date interval constant
         */
        static DAY: string;

        /**
         * An array of textual day names.
         * Override these values for international dates.
         *
         * Example:
         *
         *     Ext.Date.dayNames = [
         *         'SundayInYourLang',
         *         'MondayInYourLang'
         *         // ...
         *     ];
         */
        static dayNames: string;

        /**
         * The date format string that the {@link Ext.util.Format#dateRenderer}
         * and {@link Ext.util.Format#date} functions use.  See {@link Ext.Date} for details.
         *
         * This may be overridden in a locale file.
         */
        static defaultFormat: string;

        /**
         * An object hash containing default date values used during date parsing.
         *
         * The following properties are available:<div class="mdetail-params"><ul>
         * <li><code>y</code> : Number<div class="sub-desc">The default year value. (defaults to undefined)</div></li>
         * <li><code>m</code> : Number<div class="sub-desc">The default 1-based month value. (defaults to undefined)</div></li>
         * <li><code>d</code> : Number<div class="sub-desc">The default day value. (defaults to undefined)</div></li>
         * <li><code>h</code> : Number<div class="sub-desc">The default hour value. (defaults to undefined)</div></li>
         * <li><code>i</code> : Number<div class="sub-desc">The default minute value. (defaults to undefined)</div></li>
         * <li><code>s</code> : Number<div class="sub-desc">The default second value. (defaults to undefined)</div></li>
         * <li><code>ms</code> : Number<div class="sub-desc">The default millisecond value. (defaults to undefined)</div></li>
         * </ul></div>
         *
         * Override these properties to customize the default date values used by the {@link #parse} method.
         *
         * __Note:__ In countries which experience Daylight Saving Time (i.e. DST), the 'h', 'i', 's'
         * and 'ms' properties may coincide with the exact time in which DST takes effect.
         * It is the responsibility of the developer to account for this.
         *
         * Example Usage:
         *
         *     // set default day value to the first day of the month
         *     Ext.Date.defaults.d = 1;
         *
         *     // parse a February date string containing only year and month values.
         *     // setting the default day value to 1 prevents weird date rollover issues
         *     // when attempting to parse the following date string on, for example, March 31st 2009.
         *     Ext.Date.parse('2009-02', 'Y-m'); // returns a Date object representing February 1st 2009
         */
        static defaults: any;

        /**
         * The base format-code to formatting-function hashmap used by the {@link #format} method.
         * Formatting functions are strings (or functions which return strings) which
         * will return the appropriate value when evaluated in the context of the Date object
         * from which the {@link #format} method is called.
         * Add to / override these mappings for custom date formatting.
         *
         * __Note:__ Ext.Date.format() treats characters as literals if an appropriate mapping cannot be found.
         *
         * Example:
         *
         *     Ext.Date.formatCodes.x = "Ext.util.Format.leftPad(this.getDate(), 2, '0')";
         *     console.log(Ext.Date.format(new Date(), 'X'); // returns the current day of the month
         */
        static formatCodes: any;

        /**
         * An object hash in which each property is a date formatting function. The property name is the
         * format string which corresponds to the produced formatted date string.
         *
         * This object is automatically populated with date formatting functions as
         * date formats are requested for Ext standard formatting strings.
         *
         * Custom formatting functions may be inserted into this object, keyed by a name which from then on
         * may be used as a format string to {@link #format}.
         *
         * Example:
         *
         *     Ext.Date.formatFunctions['x-date-format'] = myDateFormatter;
         *
         * A formatting function should return a string representation of the passed Date object, and is passed the following parameters:<div class="mdetail-params"><ul>
         * <li><code>date</code> : Date<div class="sub-desc">The Date to format.</div></li>
         * </ul></div>
         *
         * To enable date strings to also be _parsed_ according to that format, a corresponding
         * parsing function must be placed into the {@link #parseFunctions} property.
         */
        static formatFunctions: any;

        static HOUR: string;

        /**
         * Date interval constant
         */
        static MILLI: string;

        /**
         * Date interval constant
         */
        static MINUTE: string;

        /**
         * Date interval constant
         */
        static MONTH: string;

        /**
         * An array of textual month names.
         * Override these values for international dates.
         *
         * Example:
         *
         *     Ext.Date.monthNames = [
         *         'JanInYourLang',
         *         'FebInYourLang'
         *         // ...
         *     ];
         */
        static monthNames: string;

        /**
         * An object hash of zero-based JavaScript month numbers (with short month names as keys. **Note:** keys are case-sensitive).
         * Override these values for international dates.
         *
         * Example:
         *
         *     Ext.Date.monthNumbers = {
         *         'LongJanNameInYourLang': 0,
         *         'ShortJanNameInYourLang':0,
         *         'LongFebNameInYourLang':1,
         *         'ShortFebNameInYourLang':1
         *         // ...
         *     };
         */
        static monthNumbers: any;

        /**
         * An object hash in which each property is a date parsing function. The property name is the
         * format string which that function parses.
         *
         * This object is automatically populated with date parsing functions as
         * date formats are requested for Ext standard formatting strings.
         *
         * Custom parsing functions may be inserted into this object, keyed by a name which from then on
         * may be used as a format string to {@link #parse}.
         *
         * Example:
         *
         *     Ext.Date.parseFunctions['x-date-format'] = myDateParser;
         *
         * A parsing function should return a Date object, and is passed the following parameters:<div class="mdetail-params"><ul>
         * <li><code>date</code> : String<div class="sub-desc">The date string to parse.</div></li>
         * <li><code>strict</code> : Boolean<div class="sub-desc">True to validate date strings while parsing
         * (i.e. prevent JavaScript Date "rollover") (The default must be 'false').
         * Invalid date strings should return 'null' when parsed.</div></li>
         * </ul></div>
         *
         * To enable Dates to also be _formatted_ according to that format, a corresponding
         * formatting function must be placed into the {@link #formatFunctions} property.
         */
        static parseFunctions: any;

        /**
         * Date interval constant
         */
        static SECOND: string;

        /**
         * Global flag which determines if strict date parsing should be used.
         * Strict date parsing will not roll-over invalid dates, which is the
         * default behavior of JavaScript Date objects.
         * (see {@link #parse} for more information)
         */
        static useStrict: boolean;

        /**
         * Date interval constant
         */
        static YEAR: string;

        /**
         * Provides a convenient method for performing basic date arithmetic. This method
         * does not modify the Date instance being called - it creates and returns
         * a new Date instance containing the resulting date value.
         *
         * Examples:
         *
         *     // Basic usage:
         *     var dt = Ext.Date.add(new Date('10/29/2006'), Ext.Date.DAY, 5);
         *     console.log(dt); // returns 'Fri Nov 03 2006 00:00:00'
         *
         *     // Negative values will be subtracted:
         *     var dt2 = Ext.Date.add(new Date('10/1/2006'), Ext.Date.DAY, -5);
         *     console.log(dt2); // returns 'Tue Sep 26 2006 00:00:00'
         *
         *      // Decimal values can be used:
         *     var dt3 = Ext.Date.add(new Date('10/1/2006'), Ext.Date.DAY, 1.25);
         *     console.log(dt3); // returns 'Mon Oct 02 2006 06:00:00'
         *
         * @param {Date} date The date to modify
         * @param {String} interval A valid date interval enum value.
         * @param {Number} value The amount to add to the current date.
         * @return {Date} The new Date instance.
         */
        static add(date: Date, interval: string, value: number): Date;

        /**
         * Checks if a date falls on or between the given start and end dates.
         * @param {Date} date The date to check
         * @param {Date} start Start date
         * @param {Date} end End date
         * @return {Boolean} 'true' if this date falls on or between the given start and end dates.
         */
        static between(date: Date, start: Date, end: Date): boolean;

        /**
         * Attempts to clear all time information from this Date by setting the time to midnight of the same day,
         * automatically adjusting for Daylight Saving Time (DST) where applicable.
         *
         * __Note:__ DST timezone information for the browser's host operating system is assumed to be up-to-date.
         * @param {Date} date The date
         * @param {Boolean} [clone=false] 'true' to create a clone of this date, clear the time and return it.
         * @return {Date} this or the clone.
         */
        static clearTime(date: Date, clone?: boolean): Date;

        /**
         * Creates and returns a new Date instance with the exact same date value as the called instance.
         * Dates are copied and passed by reference, so if a copied date variable is modified later, the original
         * variable will also be changed.  When the intention is to create a new variable that will not
         * modify the original instance, you should create a clone.
         *
         * Example of correctly cloning a date:
         *
         *     //wrong way:
         *     var orig = new Date('10/1/2006');
         *     var copy = orig;
         *     copy.setDate(5);
         *     console.log(orig);  // returns 'Thu Oct 05 2006'!
         *
         *     //correct way:
         *     var orig = new Date('10/1/2006'),
         *         copy = Ext.Date.clone(orig);
         *     copy.setDate(5);
         *     console.log(orig);  // returns 'Thu Oct 01 2006'
         *
         * @param {Date} date The date.
         * @return {Date} The new Date instance.
         */
        static clone(date: Date): Date;

        /**
         * Formats a date given the supplied format string.
         * @param {Date} date The date to format
         * @param {String} format The format string
         * @return {String} The formatted date or an empty string if date parameter is not a JavaScript Date object
         */
        static format(date: Date, format: string): string;

        /**
         * Checks if the specified format contains information about
         * anything other than the time.
         * @param {String} format The format to check
         * @return {Boolean} True if the format contains information about
         * date/day information.
         */
        static formatContainsDateInfo(format: string): boolean;

        /**
         * Checks if the specified format contains hour information
         * @param {String} format The format to check
         * @return {Boolean} True if the format contains hour information
         */
        static formatContainsHourInfo(format: string): boolean;

        /**
         * Get the numeric day number of the year, adjusted for leap year.
         * @param {Date} date The date
         * @return {Number} 0 to 364 (365 in leap years).
         */
        static getDayOfYear(date: Date): number;

        /**
         * Get the number of days in the current month, adjusted for leap year.
         * @param {Date} date The date
         * @return {Number} The number of days in the month.
         */
        static getDaysInMonth(date: Date): number;

        /**
         * Returns the number of milliseconds between two dates.
         * @param {Date} dateA The first date.
         * @param {Date} [dateB=new Date()] (optional) The second date.
         * @return {Number} The difference in milliseconds
         */
        static getElapsed(dateA: Date, dateB?: Date): number;

        /**
         * Get the date of the first day of the month in which this date resides.
         * @param {Date} date The date
         * @return {Date}
         */
        static getFirstDateOfMonth(date: Date): Date;

        /**
         * Get the first day of the current month, adjusted for leap year.  The returned value
         * is the numeric day index within the week (0-6) which can be used in conjunction with
         * the {@link #monthNames} array to retrieve the textual day name.
         *
         * Example:
         *
         *     var dt = new Date('1/10/2007'),
         *         firstDay = Ext.Date.getFirstDayOfMonth(dt);
         *     console.log(Ext.Date.dayNames[firstDay]); // output: 'Monday'
         *
         * @param {Date} date The date
         * @return {Number} The day number (0-6).
         */
        static getFirstDayOfMonth(date: Date): number;

        /**
         * Get the offset from GMT of the current date (equivalent to the format specifier 'O').
         * @param {Date} date The date
         * @param {Boolean} [colon=false] (optional) true to separate the hours and minutes with a colon.
         * @return {String} The 4-character offset string prefixed with + or - (e.g. '-0600').
         */
        static getGMTOffset(date: Date, colon?: boolean): string;

        /**
         * Get the date of the last day of the month in which this date resides.
         * @param {Date} date The date
         * @return {Date}
         */
        static getLastDateOfMonth(date: Date): Date;

        /**
         * Get the last day of the current month, adjusted for leap year.  The returned value
         * is the numeric day index within the week (0-6) which can be used in conjunction with
         * the {@link #monthNames} array to retrieve the textual day name.
         *
         * Example:
         *
         *     var dt = new Date('1/10/2007'),
         *         lastDay = Ext.Date.getLastDayOfMonth(dt);
         *     console.log(Ext.Date.dayNames[lastDay]); // output: 'Wednesday'
         *
         * @param {Date} date The date
         * @return {Number} The day number (0-6).
         */
        static getLastDayOfMonth(date: Date): number;

        /**
         * Get the zero-based JavaScript month number for the given short/full month name.
         * Override this function for international dates.
         * @param {String} name The short/full month name.
         * @return {Number} The zero-based JavaScript month number.
         */
        static getMonthNumber(name: string): number;

        /**
         * Get the short day name for the given day number.
         * Override this function for international dates.
         * @param {Number} day A zero-based JavaScript day number.
         * @return {String} The short day name.
         */
        static getShortDayName(day: number): string;

        /**
         * Get the short month name for the given month number.
         * Override this function for international dates.
         * @param {Number} month A zero-based JavaScript month number.
         * @return {String} The short month name.
         */
        static getShortMonthName(month: number): string;

        /**
         * Get the English ordinal suffix of the current day (equivalent to the format specifier 'S').
         * @param {Date} date The date
         * @return {String} 'st, 'nd', 'rd' or 'th'.
         */
        static getSuffix(date: Date): string;

        /**
         * Get the timezone abbreviation of the current date (equivalent to the format specifier 'T').
         *
         * __Note:__ The date string returned by the JavaScript Date object's 'toString()' method varies
         * between browsers (e.g. FF vs IE) and system region settings (e.g. IE in Asia vs IE in America).
         * For a given date string e.g. "Thu Oct 25 2007 22:55:35 GMT+0800 (Malay Peninsula Standard Time)",
         * getTimezone() first tries to get the timezone abbreviation from between a pair of parentheses
         * (which may or may not be present), failing which it proceeds to get the timezone abbreviation
         * from the GMT offset portion of the date string.
         * @param {Date} date The date
         * @return {String} The abbreviated timezone name (e.g. 'CST', 'PDT', 'EDT', 'MPST' ...).
         */
        static getTimezone(date: Date): string;

        /**
         * Get the numeric ISO-8601 week number of the year.
         * (equivalent to the format specifier 'W', but without a leading zero).
         * @param {Date} date The date
         * @return {Number} 1 to 53
         */
        static getWeekOfYear(date: Date): number;

        /**
         * Checks if the current date is affected by Daylight Saving Time (DST).
         * @param {Date} date The date
         * @return {Boolean} 'true' if the current date is affected by DST.
         */
        static isDST(date: Date): boolean;

        /**
         * Compares if two dates are equal by comparing their values.
         * @return {Boolean} 'true' if the date values are equal
         */
        static isEqual(date1: Date, date2: Date): boolean;

        /**
         * Checks if the current date falls within a leap year.
         * @param {Date} date The date
         * @return {Boolean} True if the current date falls within a leap year, false otherwise.
         */
        static isLeapYear(date: Date): boolean;

        /**
         * Checks if the passed Date parameters will cause a JavaScript Date "rollover".
         * @param {Number} year 4-digit year
         * @param {Number} month 1-based month-of-year
         * @param {Number} day Day of month
         * @param {Number} hour (optional) Hour
         * @param {Number} minute (optional) Minute
         * @param {Number} second (optional) Second
         * @param {Number} millisecond (optional) Millisecond
         * @return {Boolean} 'true' if the passed parameters do not cause a Date "rollover", 'false' otherwise.
         */
        static isValid(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number): boolean;

        /**
         * Returns the current timestamp.
         * @return {Number} Milliseconds since UNIX epoch.
         */
        static now(): number;

        /**
         * Parses the passed string using the specified date format.
         * Note that this function expects normal calendar dates, meaning that months are 1-based (i.e. 1 = January).
         * The {@link #defaults} hash will be used for any date value (i.e. year, month, day, hour, minute, second or millisecond)
         * which cannot be found in the passed string. If a corresponding default date value has not been specified in the {@link #defaults} hash,
         * the current date's year, month, day or DST-adjusted zero-hour time value will be used instead.
         * Keep in mind that the input date string must precisely match the specified format string
         * in order for the parse operation to be successful (failed parse operations return a null value).
         *
         * Example:
         *
         *     //dt = Fri May 25 2007 (current date)
         *     var dt = new Date();
         *
         *     //dt = Thu May 25 2006 (today&#39;s month/day in 2006)
         *     dt = Ext.Date.parse("2006", "Y");
         *
         *     //dt = Sun Jan 15 2006 (all date parts specified)
         *     dt = Ext.Date.parse("2006-01-15", "Y-m-d");
         *
         *     //dt = Sun Jan 15 2006 15:20:01
         *     dt = Ext.Date.parse("2006-01-15 3:20:01 PM", "Y-m-d g:i:s A");
         *
         *     // attempt to parse Sun Feb 29 2006 03:20:01 in strict mode
         *     dt = Ext.Date.parse("2006-02-29 03:20:01", "Y-m-d H:i:s", true); // returns null
         *
         * @param {String} input The raw date string.
         * @param {String} format The expected date string format.
         * @param {Boolean} [strict=false] (optional) 'true' to validate date strings while parsing (i.e. prevents JavaScript Date "rollover").
         * Invalid date strings will return 'null' when parsed.
         * @return {Date} The parsed Date.
         */
        static parse(input: string, format: string, strict?: boolean): Date;

        /**
         * Provides a convenient method for performing basic date arithmetic. This method
         * does not modify the Date instance being called - it creates and returns
         * a new Date instance containing the resulting date value.
         *
         * Examples:
         *
         *     // Basic usage:
         *     var dt = Ext.Date.subtract(new Date('10/29/2006'), Ext.Date.DAY, 5);
         *     console.log(dt); // returns 'Tue Oct 24 2006 00:00:00'
         *
         *     // Negative values will be added:
         *     var dt2 = Ext.Date.subtract(new Date('10/1/2006'), Ext.Date.DAY, -5);
         *     console.log(dt2); // returns 'Fri Oct 6 2006 00:00:00'
         *
         *      // Decimal values can be used:
         *     var dt3 = Ext.Date.subtract(new Date('10/1/2006'), Ext.Date.DAY, 1.25);
         *     console.log(dt3); // returns 'Fri Sep 29 2006 06:00:00'
         *
         * @param {Date} date The date to modify
         * @param {String} interval A valid date interval enum value.
         * @param {Number} value The amount to subtract from the current date.
         * @return {Date} The new Date instance.
         */
        static subtract(date: Date, interval: string, value: number): Date;

        /**
         * Removes all escaping for a date format string. In date formats,
         * using a '\' can be used to escape special characters.
         * @param {String} format The format to unescape
         * @return {String} The unescaped format
         */
        static unescapeFormat(format: string): string;
    }

    /**
     * @extends Ext.dom.Helper
     * @alternateClassName Ext.core.DomHelper
     *
     * The DomHelper class provides a layer of abstraction from DOM and transparently supports creating elements via DOM or
     * using HTML fragments. It also has the ability to create HTML fragment templates from your DOM building code.
     *
     * # DomHelper element specification object
     *
     * A specification object is used when creating elements. Attributes of this object are assumed to be element
     * attributes, except for 4 special attributes:
     *
     * - **tag** - The tag name of the element.
     * - **children** or **cn** - An array of the same kind of element definition objects to be created and appended.
     *   These can be nested as deep as you want.
     * - **cls** - The class attribute of the element. This will end up being either the "class" attribute on a HTML
     *   fragment or className for a DOM node, depending on whether DomHelper is using fragments or DOM.
     * - **html** - The innerHTML for the element.
     *
     * **NOTE:** For other arbitrary attributes, the value will currently **not** be automatically HTML-escaped prior to
     * building the element's HTML string. This means that if your attribute value contains special characters that would
     * not normally be allowed in a double-quoted attribute value, you **must** manually HTML-encode it beforehand (see
     * {@link Ext.String#htmlEncode}) or risk malformed HTML being created. This behavior may change in a future release.
     *
     * # Insertion methods
     *
     * Commonly used insertion methods:
     *
     * - **{@link #append}**
     * - **{@link #insertBefore}**
     * - **{@link #insertAfter}**
     * - **{@link #overwrite}**
     * - **{@link #createTemplate}**
     * - **{@link #insertHtml}**
     *
     * # Example
     *
     * This is an example, where an unordered list with 3 children items is appended to an existing element with
     * id 'my-div':
     *
     *     var dh = Ext.DomHelper; // create shorthand alias
     *     // specification object
     *     var spec = {
     *         id: 'my-ul',
     *         tag: 'ul',
     *         cls: 'my-list',
     *         // append children after creating
     *         children: [     // may also specify 'cn' instead of 'children'
     *             {tag: 'li', id: 'item0', html: 'List Item 0'},
     *             {tag: 'li', id: 'item1', html: 'List Item 1'},
     *             {tag: 'li', id: 'item2', html: 'List Item 2'}
     *         ]
     *     };
     *     var list = dh.append(
     *         'my-div', // the context element 'my-div' can either be the id or the actual node
     *         spec      // the specification object
     *     );
     *
     * Element creation specification parameters in this class may also be passed as an Array of specification objects. This
     * can be used to insert multiple sibling nodes into an existing container very efficiently. For example, to add more
     * list items to the example above:
     *
     *     dh.append('my-ul', [
     *         {tag: 'li', id: 'item3', html: 'List Item 3'},
     *         {tag: 'li', id: 'item4', html: 'List Item 4'}
     *     ]);
     *
     * # Templating
     *
     * The real power is in the built-in templating. Instead of creating or appending any elements, {@link #createTemplate}
     * returns a Template object which can be used over and over to insert new elements. Revisiting the example above, we
     * could utilize templating this time:
     *
     *     // create the node
     *     var list = dh.append('my-div', {tag: 'ul', cls: 'my-list'});
     *     // get template
     *     var tpl = dh.createTemplate({tag: 'li', id: 'item{0}', html: 'List Item {0}'});
     *
     *     for(var i = 0; i < 5, i++){
     *         tpl.append(list, [i]); // use template to append to the actual node
     *     }
     *
     * An example using a template:
     *
     *     var html = '<a id="{0}" href="{1}" class="nav">{2}</a>';
     *
     *     var tpl = new Ext.DomHelper.createTemplate(html);
     *     tpl.append('blog-roll', ['link1', 'http://www.edspencer.net/', "Ed's Site"]);
     *     tpl.append('blog-roll', ['link2', 'http://www.dustindiaz.com/', "Dustin's Site"]);
     *
     * The same example using named parameters:
     *
     *     var html = '<a id="{id}" href="{url}" class="nav">{text}</a>';
     *
     *     var tpl = new Ext.DomHelper.createTemplate(html);
     *     tpl.append('blog-roll', {
     *         id: 'link1',
     *         url: 'http://www.edspencer.net/',
     *         text: "Ed's Site"
     *     });
     *     tpl.append('blog-roll', {
     *         id: 'link2',
     *         url: 'http://www.dustindiaz.com/',
     *         text: "Dustin's Site"
     *     });
     *
     * # Compiling Templates
     *
     * Templates are applied using regular expressions. The performance is great, but if you are adding a bunch of DOM
     * elements using the same template, you can increase performance even further by {@link Ext.Template#compile
     * "compiling"} the template. The way "{@link Ext.Template#compile compile()}" works is the template is parsed and
     * broken up at the different variable points and a dynamic function is created and eval'ed. The generated function
     * performs string concatenation of these parts and the passed variables instead of using regular expressions.
     *
     *     var html = '<a id="{id}" href="{url}" class="nav">{text}</a>';
     *
     *     var tpl = new Ext.DomHelper.createTemplate(html);
     *     tpl.compile();
     *
     *     //... use template like normal
     *
     * # Performance Boost
     *
     * DomHelper will transparently create HTML fragments when it can. Using HTML fragments instead of DOM can significantly
     * boost performance.
     *
     * Element creation specification parameters may also be strings. If {@link #useDom} is false, then the string is used
     * as innerHTML. If {@link #useDom} is true, a string specification results in the creation of a text node. Usage:
     *
     *     Ext.DomHelper.useDom = true; // force it to use DOM; reduces performance
     */
    export class DomHelper {
    }

    interface EditorConfig extends Ext.container.ContainerConfig {
        /**
         * The position to align to (see {@link Ext.util.Positionable#alignTo} for more details).
         */
        alignment?: string;

        /**
         * True to {@link #completeEdit complete the editing process} if in edit mode when the
         * field is blurred.
         */
        allowBlur?: boolean;

        /**
         * True for the editor to automatically adopt the size of the underlying field. Otherwise, an object
         * can be passed to indicate where to get each dimension. The available properties are 'boundEl' and
         * 'field'. If a dimension is not specified, it will use the underlying height/width specified on
         * the editor object.
         * Examples:
         *
         *     autoSize: true // The editor will be sized to the height/width of the field
         *
         *     height: 21,
         *     autoSize: {
         *         width: 'boundEl' // The width will be determined by the width of the boundEl, the height from the editor (21)
         *     }
         *
         *     autoSize: {
         *         width: 'field', // Width from the field
         *         height: 'boundEl' // Height from the boundEl
         *     }
         */
        autoSize?: boolean|any;

        baseCls?: any;

        /**
         * True to cancel the edit when the escape key is pressed.
         */
        cancelOnEsc?: boolean;

        /**
         * True to complete the edit when the enter key is pressed.
         */
        completeOnEnter?: boolean;

        /**
         * True to constrain the editor to the viewport
         */
        constrain?: boolean;

        /**
         * The Field object (or descendant) or config object for field
         */
        field?: Ext.form.field.Field;

        focusOnToFront?: any;

        hidden?: any;

        /**
         * False to keep the bound element visible while the editor is displayed
         *
         * Optional, Defaults to: true
         */
        hideEl?: boolean;

        /**
         * True to skip the edit completion process (no save, no events fired) if the user completes an edit and
         * the value has not changed.  Applies only to string values - edits for other data types
         * will never be ignored.
         *
         * Optional, Defaults to: false
         */
        ignoreNoChange?: boolean;

        layout?: any;

        /**
         * The offsets to use when aligning (see {@link Ext.util.Positionable#alignTo} for more details.
         */
        offsets?: number;

        /**
         * An element to render to.
         *
         * Optional, Defaults to: document.body
         */
        parentEl?: string|HTMLElement|Ext.dom.Element;

        /**
         * True to automatically revert the field value and cancel the edit when the user completes an edit and the field
         * validation fails
         */
        revertInvalid?: boolean;

        /**
         * "sides" for sides/bottom only, "frame" for 4-way shadow, and "drop" for bottom-right shadow.
         */
        shadow?: boolean|string;

        /**
         * Handle the keydown/keypress events so they don't propagate
         */
        swallowKeys?: boolean;

        /**
         * True to update the innerHTML of the bound element when the update completes
         */
        updateEl?: boolean;

        /**
         * The data value of the underlying field
         */
        value?: any;
    }

    /**
     * The Editor class is used to provide inline editing for elements on the page. The editor
     * is backed by a {@link Ext.form.field.Field} that will be displayed to edit the underlying content.
     * The editor is a floating Component, when the editor is shown it is automatically aligned to
     * display over the top of the bound element it is editing. The Editor contains several options
     * for how to handle key presses:
     *
     * - {@link #completeOnEnter}
     * - {@link #cancelOnEsc}
     * - {@link #swallowKeys}
     *
     * It also has options for how to use the value once the editor has been activated:
     *
     * - {@link #revertInvalid}
     * - {@link #ignoreNoChange}
     * - {@link #updateEl}
     *
     * Sample usage:
     *
     *     var editor = new Ext.Editor({
     *         updateEl: true, // update the innerHTML of the bound element when editing completes
     *         field: {
     *             xtype: 'textfield'
     *         }
     *     });
     *     var el = Ext.get('my-text'); // The element to 'edit'
     *     editor.startEdit(el); // The value of the field will be taken as the innerHTML of the element.
     *
     * {@img Ext.Editor/Ext.Editor.png Ext.Editor component}
     */
    export class Editor extends Ext.container.Container implements Ext.EditorConfig {
        /**
         * The position to align to (see {@link Ext.util.Positionable#alignTo} for more details).
         */
        alignment: string;

        /**
         * True to {@link #completeEdit complete the editing process} if in edit mode when the
         * field is blurred.
         */
        allowBlur: boolean;

        /**
         * True for the editor to automatically adopt the size of the underlying field. Otherwise, an object
         * can be passed to indicate where to get each dimension. The available properties are 'boundEl' and
         * 'field'. If a dimension is not specified, it will use the underlying height/width specified on
         * the editor object.
         * Examples:
         *
         *     autoSize: true // The editor will be sized to the height/width of the field
         *
         *     height: 21,
         *     autoSize: {
         *         width: 'boundEl' // The width will be determined by the width of the boundEl, the height from the editor (21)
         *     }
         *
         *     autoSize: {
         *         width: 'field', // Width from the field
         *         height: 'boundEl' // Height from the boundEl
         *     }
         */
        autoSize: boolean|any;

        baseCls: string;

        /**
         * True to cancel the edit when the escape key is pressed.
         */
        cancelOnEsc: boolean;

        /**
         * True to complete the edit when the enter key is pressed.
         */
        completeOnEnter: boolean;

        /**
         * True to constrain the editor to the viewport
         */
        constrain: boolean;

        /**
         * The Field object (or descendant) or config object for field
         */
        field: Ext.form.field.Field;

        focusOnToFront: any;

        hidden: boolean;

        /**
         * False to keep the bound element visible while the editor is displayed
         *
         * Optional, Defaults to: true
         */
        hideEl: boolean;

        /**
         * True to skip the edit completion process (no save, no events fired) if the user completes an edit and
         * the value has not changed.  Applies only to string values - edits for other data types
         * will never be ignored.
         *
         * Optional, Defaults to: false
         */
        ignoreNoChange: boolean;

        layout: Ext.enums.Layout|any;

        /**
         * The offsets to use when aligning (see {@link Ext.util.Positionable#alignTo} for more details.
         */
        offsets: number;

        /**
         * An element to render to.
         *
         * Optional, Defaults to: document.body
         */
        parentEl: string|HTMLElement|Ext.dom.Element;

        /**
         * True to automatically revert the field value and cancel the edit when the user completes an edit and the field
         * validation fails
         */
        revertInvalid: boolean;

        /**
         * "sides" for sides/bottom only, "frame" for 4-way shadow, and "drop" for bottom-right shadow.
         */
        shadow: boolean|string;

        /**
         * Handle the keydown/keypress events so they don't propagate
         */
        swallowKeys: boolean;

        /**
         * True to update the innerHTML of the bound element when the update completes
         */
        updateEl: boolean;

        /**
         * The data value of the underlying field
         */
        value: any;

        protected afterRender();

        /**
         * Cancels the editing process and hides the editor without persisting any changes.  The field value will be
         * reverted to the original starting value.
         * @param {Boolean} [remainVisible=false] Override the default behavior and keep the editor visible after cancel
         */
        cancelEdit(remainVisible?: boolean);

        /**
         * Ends the editing process, persists the changed value to the underlying field, and hides the editor.
         * @param {Boolean} [remainVisible=false] Override the default behavior and keep the editor visible after edit
         */
        completeEdit(remainVisible?: boolean);

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Gets the data value of the editor
         * @return {Object} The data value
         */
        getValue(): any;

        /**
         * Realigns the editor to the bound field based on the current alignment config value.
         * @param {Boolean} autoSize (optional) True to size the field to the dimensions of the bound element.
         */
        realign(autoSize: boolean);

        /**
         * Sets the data value of the editor
         * @param {Object} value Any valid value supported by the underlying field
         */
        setValue(value: any);

        /**
         * Starts the editing process and shows the editor.
         * @param {String/HTMLElement/Ext.Element} el The element to edit
         * @param {String} value (optional) A value to initialize the editor with. If a value is not provided, it defaults
         * to the innerHTML of el.
         */
        startEdit(el: string|HTMLElement|Ext.dom.Element, value: string);

        /**
         * Fires after a change has been made to the field, but before the change is reflected in the underlying
         * field.  Saving the change to the field can be canceled by returning false from the handler of this event.
         * Note that if the value has not changed and ignoreNoChange = true, the editing will still end but this
         * event will not fire since no edit actually occurred.
         * @param {Object} value The current field value
         * @param {Object} startValue The original field value
         */
        beforecomplete(that: Ext.Editor, value: any, startValue: any);

        /**
         * Fires when editing is initiated, but before the value changes.  Editing can be canceled by returning
         * false from the handler of this event.
         * @param {Ext.Element} boundEl The underlying element bound to this editor
         * @param {Object} value The field value being set
         */
        beforestartedit(that: Ext.Editor, boundEl: Ext.dom.Element, value: any);

        /**
         * Fires after editing has been canceled and the editor's value has been reset.
         * @param {Object} value The user-entered field value that was discarded
         * @param {Object} startValue The original field value that was set back into the editor after cancel
         */
        canceledit(that: Ext.Editor, value: any, startValue: any);

        /**
         * Fires after editing is complete and any changed value has been written to the underlying field.
         * @param {Object} value The current field value
         * @param {Object} startValue The original field value
         */
        complete(that: Ext.Editor, value: any, startValue: any);

        /**
         * Fires when any key related to navigation (arrows, tab, enter, esc, etc.) is pressed.  You can check
         * {@link Ext.EventObject#getKey} to determine which key was pressed.
         * @param {Ext.form.field.Field} field The field attached to this editor
         * @param {Ext.EventObject} event The event object
         */
        specialkey(that: Ext.Editor, field: Ext.form.field.Field, event: Ext.EventObject);

        /**
         * Fires when this editor is displayed
         * @param {Ext.Element} boundEl The underlying element bound to this editor
         * @param {Object} value The starting field value
         */
        startedit(that: Ext.Editor, boundEl: Ext.dom.Element, value: any);
    }

    interface ElementLoaderConfig {
        /**
         * Any additional options to be passed to the request, for example timeout or headers.
         */
        ajaxOptions?: any;

        /**
         * True to have the loader make a request as soon as it is created.
         * This argument can also be a set of options that will be passed to {@link #method-load} is called.
         */
        autoLoad?: boolean|any;

        /**
         * Params that will be attached to every request. These parameters
         * will not be overridden by any params in the load options.
         */
        baseParams?: any;

        /**
         * A function to be called when a load request finishes.
         * Will be called with the following config parameters:
         *
         * - this - The ElementLoader instance.
         * - success - True if successful request.
         * - response - The response object.
         * - options - Ajax options.
         */
        callback?: Function;

        /**
         * A function to be called when a load request fails.
         * Will be called with the following config parameters:
         *
         * - this - The ElementLoader instance.
         * - response - The response object.
         * - options - Ajax options.
         */
        failure?: Function;

        /**
         * True or a string to show when the element is loading.
         */
        loadMask?: boolean|string;

        /**
         * Any params to be attached to the Ajax request. These parameters will
         * be overridden by any params in the load options.
         */
        params?: any;

        /**
         * A custom function to render the content to the element. The function should
         * return false if the renderer could not be applied. The passed parameters are:
         *
         * - The loader
         * - The response
         * - The active request
         */
        renderer?: Function;

        /**
         * The scope to execute the {@link #success} and {@link #failure} functions in.
         */
        scope?: any;

        /**
         * True to parse any inline script tags in the response.
         */
        scripts?: boolean;

        /**
         * A function to be called when a load request is successful.
         * Will be called with the following config parameters:
         *
         * - this - The ElementLoader instance.
         * - response - The response object.
         * - options - Ajax options.
         */
        success?: Function;

        /**
         * The target element for the loader. It can be the DOM element, the id or an {@link Ext.Element}.
         */
        target?: HTMLElement|Ext.dom.Element|string;

        /**
         * (required)
         * The url to retrieve the content from.
         */
        url?: string;
    }

    /**
     * A class used to load remote content to an Element. Sample usage:
     *
     *     Ext.get('el').load({
     *         url: 'myPage.php',
     *         scripts: true,
     *         params: {
     *             id: 1
     *         }
     *     });
     *
     * In general this class will not be instanced directly, rather the {@link Ext.Element#method-load} method
     * will be used.
     */
    export class ElementLoader extends Ext.Base implements Ext.ElementLoaderConfig {
        /**
         * 'true' in this class to identify an object as an instantiated ElementLoader, or subclass thereof.
         */
        isLoader: boolean;

        /**
         * Any additional options to be passed to the request, for example timeout or headers.
         */
        ajaxOptions: any;

        /**
         * True to have the loader make a request as soon as it is created.
         * This argument can also be a set of options that will be passed to {@link #method-load} is called.
         */
        autoLoad: boolean|any;

        /**
         * Params that will be attached to every request. These parameters
         * will not be overridden by any params in the load options.
         */
        baseParams: any;

        /**
         * A function to be called when a load request finishes.
         * Will be called with the following config parameters:
         *
         * - this - The ElementLoader instance.
         * - success - True if successful request.
         * - response - The response object.
         * - options - Ajax options.
         */
        callback: Function;

        /**
         * A function to be called when a load request fails.
         * Will be called with the following config parameters:
         *
         * - this - The ElementLoader instance.
         * - response - The response object.
         * - options - Ajax options.
         */
        failure: Function;

        /**
         * True or a string to show when the element is loading.
         */
        loadMask: boolean|string;

        /**
         * Any params to be attached to the Ajax request. These parameters will
         * be overridden by any params in the load options.
         */
        params: any;

        /**
         * A custom function to render the content to the element. The function should
         * return false if the renderer could not be applied. The passed parameters are:
         *
         * - The loader
         * - The response
         * - The active request
         */
        renderer: Function;

        /**
         * The scope to execute the {@link #success} and {@link #failure} functions in.
         */
        scope: any;

        /**
         * True to parse any inline script tags in the response.
         */
        scripts: boolean;

        /**
         * A function to be called when a load request is successful.
         * Will be called with the following config parameters:
         *
         * - this - The ElementLoader instance.
         * - response - The response object.
         * - options - Ajax options.
         */
        success: Function;

        /**
         * The target element for the loader. It can be the DOM element, the id or an {@link Ext.Element}.
         */
        target: HTMLElement|Ext.dom.Element|string;

        /**
         * (required)
         * The url to retrieve the content from.
         */
        url: string;

        /**
         * Aborts the active load request
         */
        abort();

        constructor(config: Ext.ComponentLoaderConfig);

        /**
         * Destroys the loader. Any active requests will be aborted.
         */
        destroy();

        /**
         * Returns the target of this loader.
         * @return {Ext.Component} The target or null if none exists.
         */
        getTarget(): Ext.Component;

        /**
         * Checks whether the loader is automatically refreshing. See {@link #startAutoRefresh}.
         * @return {Boolean} True if the loader is automatically refreshing
         */
        isAutoRefreshing(): boolean;

        /**
         * Loads new data from the server.
         * @param {Object} options The options for the request. They can be any configuration option that can be specified for
         * the class, with the exception of the target option. Note that any options passed to the method will override any
         * class defaults.
         */
        load(options: any);

        /**
         * Sets an {@link Ext.Element} as the target of this loader.
         * Note that if the target is changed, any active requests will be aborted.
         * @param {String/HTMLElement/Ext.Element} target The element or its ID.
         */
        setTarget(target: string|HTMLElement|Ext.dom.Element);

        /**
         * Automatically refreshes the content over a specified period.
         * @param {Number} interval The interval to refresh in ms.
         * @param {Object} options (optional) The options to pass to the load method. See {@link #method-load}
         */
        startAutoRefresh(interval: number, options: any);

        /**
         * Clears any auto refresh. See {@link #startAutoRefresh}.
         */
        stopAutoRefresh();

        /**
         * Fires before a load request is made to the server.
         * Returning false from an event listener can prevent the load
         * from occurring.
         * @param {Object} options The options passed to the request
         */
        beforeload(that: Ext.ElementLoader, options: any);

        /**
         * Fires after an unsuccessful load.
         * @param {Object} response The response from the server
         * @param {Object} options The options passed to the request
         */
        exception(that: Ext.ElementLoader, response: any, options: any);
    }

    /**
     * @author Brian Moeskau <brian@sencha.com>
     * @docauthor Brian Moeskau <brian@sencha.com>
     *
     * A wrapper class for the native JavaScript Error object that adds a few useful capabilities for handling
     * errors in an Ext application. When you use Ext.Error to {@link #raise} an error from within any class that
     * uses the Ext 4 class system, the Error class can automatically add the source class and method from which
     * the error was raised. It also includes logic to automatically log the error to the console, if available,
     * with additional metadata about the error. In all cases, the error will always be thrown at the end so that
     * execution will halt.
     *
     * Ext.Error also offers a global error {@link #handle handling} method that can be overridden in order to
     * handle application-wide errors in a single spot. You can optionally {@link #ignore} errors altogether,
     * although in a real application it's usually a better idea to override the handling function and perform
     * logging or some other method of reporting the errors in a way that is meaningful to the application.
     *
     * At its simplest you can simply raise an error as a simple string from within any code:
     *
     * Example usage:
     *
     *     Ext.Error.raise('Something bad happened!');
     *
     * If raised from plain JavaScript code, the error will be logged to the console (if available) and the message
     * displayed. In most cases however you'll be raising errors from within a class, and it may often be useful to add
     * additional metadata about the error being raised.  The {@link #raise} method can also take a config object.
     * In this form the 'msg' attribute becomes the error description, and any other data added to the config gets
     * added to the error object and, if the console is available, logged to the console for inspection.
     *
     * Example usage:
     *
     *     Ext.define('Ext.Foo', {
     *         doSomething: function(option){
     *             if (someCondition === false) {
     *                 Ext.Error.raise({
     *                     msg: 'You cannot do that!',
     *                     option: option,   // whatever was passed into the method
     *                     'error code': 100 // other arbitrary info
     *                 });
     *             }
     *         }
     *     });
     *
     * If a console is available (that supports the 'console.dir' function) you'll see console output like:
     *
     *     An error was raised with the following data:
     *     option:         Object { foo: "bar"}
     *         foo:        "bar"
     *     error code:     100
     *     msg:            "You cannot do that!"
     *     sourceClass:   "Ext.Foo"
     *     sourceMethod:  "doSomething"
     *
     *     uncaught exception: You cannot do that!
     *
     * As you can see, the error will report exactly where it was raised and will include as much information as the
     * raising code can usefully provide.
     *
     * If you want to handle all application errors globally you can simply override the static {@link #handle} method
     * and provide whatever handling logic you need. If the method returns true then the error is considered handled
     * and will not be thrown to the browser. If anything but true is returned then the error will be thrown normally.
     *
     * Example usage:
     *
     *     Ext.Error.handle = function(err) {
     *         if (err.someProperty == 'NotReallyAnError') {
     *             // maybe log something to the application here if applicable
     *             return true;
     *         }
     *         // any non-true return value (including none) will cause the error to be thrown
     *     }
     */
    export class Error {
        /**
         * Creates new Error object.
         * @param {String/Object} config The error message string, or an object containing the
         * attribute "msg" that will be used as the error message. Any other data included in
         * the object will be applied to the error instance and logged to the browser console, if available.
         */
        constructor(config: string|any);

        /**
         * Provides a custom string representation of the error object. This is an override of the base JavaScript
         * 'Object.toString' method, which is useful so that when logged to the browser console, an error object will
         * be displayed with a useful message instead of '[object Object]', the default 'toString' result.
         *
         * The default implementation will include the error message along with the raising class and method, if available,
         * but this can be overridden with a custom implementation either at the prototype level (for all errors) or on
         * a particular error instance, if you want to provide a custom description that will show up in the console.
         * @return {String} The error message. If raised from within the Ext 4 class system, the error message will also
         * include the raising class and method names, if available.
         */
        toString(): string;

        /**
         * Static flag that can be used to globally disable error reporting to the browser if set to true
         * (defaults to false). Note that if you ignore Ext errors it's likely that some other code may fail
         * and throw a native JavaScript error thereafter, so use with caution. In most cases it will probably
         * be preferable to supply a custom error {@link #handle handling} function instead.
         *
         * Example usage:
         *
         *     Ext.Error.ignore = true;
         */
        static ignore: boolean;

        /**
         * Static flag that can be used to globally control error notification to the user. Unlike
         * Ex.Error.ignore, this does not effect exceptions. They are still thrown. This value can be
         * set to false to disable the alert notification (default is true for IE6 and IE7).
         *
         * Only the first error will generate an alert. Internally this flag is set to false when the
         * first error occurs prior to displaying the alert.
         *
         * This flag is not used in a release build.
         *
         * Example usage:
         *
         *     Ext.Error.notify = false;
         */
        static notify: boolean;

        /**
         * Globally handle any Ext errors that may be raised, optionally providing custom logic to
         * handle different errors individually. Return true from the function to bypass throwing the
         * error to the browser, otherwise the error will be thrown and execution will halt.
         *
         * Example usage:
         *
         *     Ext.Error.handle = function(err) {
         *         if (err.someProperty == 'NotReallyAnError') {
         *             // maybe log something to the application here if applicable
         *             return true;
         *         }
         *         // any non-true return value (including none) will cause the error to be thrown
         *     }
         *
         * @param {Ext.Error} err The Ext.Error object being raised. It will contain any attributes that were originally
         * raised with it, plus properties about the method and class from which the error originated (if raised from a
         * class that uses the Ext 4 class system).
         */
        static handle(err: Ext.Error);

        /**
         * Raise an error that can include additional data and supports automatic console logging if available.
         * You can pass a string error message or an object with the 'msg' attribute which will be used as the
         * error message. The object can contain any other name-value attributes (or objects) to be logged
         * along with the error.
         *
         * Note that after displaying the error message a JavaScript error will ultimately be thrown so that
         * execution will halt.
         *
         * Example usage:
         *
         *     Ext.Error.raise('A simple string error message');
         *
         *     // or...
         *
         *     Ext.define('Ext.Foo', {
         *         doSomething: function(option){
         *             if (someCondition === false) {
         *                 Ext.Error.raise({
         *                     msg: 'You cannot do that!',
         *                     option: option,   // whatever was passed into the method
         *                     'error code': 100 // other arbitrary info
         *                 });
         *             }
         *         }
         *     });
         *
         * @param {String/Object} err The error message string, or an object containing the attribute "msg" that will be
         * used as the error message. Any other data included in the object will also be logged to the browser console,
         * if available.
         */
        static raise(err: string|any);
    }

    /**
     * Registers event handlers that want to receive a normalized EventObject instead of the standard browser event and provides
     * several useful events directly.
     *
     * See {@link Ext.EventObject} for more details on normalized event objects.
     */
    export class EventManager {
        /**
         * Fires when an event handler finishes its run, just before returning to browser control.
         *
         * This includes DOM event handlers, Ajax (including JSONP) event handlers, and {@link Ext.util.TaskRunner TaskRunners}
         *
         * This can be useful for performing cleanup, or update tasks which need to happen only
         * after all code in an event handler has been run, but which should not be executed in a timer
         * due to the intervening browser reflow/repaint which would take place.
         */
        static idleEvent: any;

        /**
         * Appends an event handler to an element.  The shorthand version {@link #on} is equivalent.
         * Typically you will use {@link Ext.Element#addListener} directly on an Element in favor of
         * calling this version.
         *
         * {@link Ext.EventManager#on} is an alias for {@link Ext.EventManager#addListener}.
         *
         * @param {String/Ext.Element/HTMLElement/Window} el The html element or id to assign the event handler to.
         *
         * @param {String} eventName The name of the event to listen for.
         *
         * @param {Function/String} handler The handler function the event invokes. A String parameter
         * is assumed to be method name in 'scope' object, or Element object if no scope is provided.
         * @param {Ext.EventObject} handler.event The {@link Ext.EventObject EventObject} describing the event.
         * @param {Ext.dom.Element} handler.target The Element which was the target of the event.
         * Note that this may be filtered by using the 'delegate' option.
         * @param {Object} handler.options The options object from the addListener call.
         *
         * @param {Object} [scope] The scope ('this' reference) in which the handler function is executed.
         * Defaults to the Element.
         *
         * @param {Object} [options] An object containing handler configuration properties.
         * This may contain any of the following properties (See {@link Ext.Element#addListener}
         * for examples of how to use these options.):
         * @param {Object} options.scope The scope ('this' reference) in which the handler function is executed. Defaults to the Element.
         * @param {String} options.delegate A simple selector to filter the target or look for a descendant of the target
         * @param {Boolean} options.stopEvent True to stop the event. That is stop propagation, and prevent the default action.
         * @param {Boolean} options.preventDefault True to prevent the default action
         * @param {Boolean} options.stopPropagation True to prevent event propagation
         * @param {Boolean} options.normalized False to pass a browser event to the handler function instead of an Ext.EventObject
         * @param {Number} options.delay The number of milliseconds to delay the invocation of the handler after te event fires.
         * @param {Boolean} options.single True to add a handler to handle just the next firing of the event, and then remove itself.
         * @param {Number} options.buffer Causes the handler to be scheduled to run in an {@link Ext.util.DelayedTask} delayed
         * by the specified number of milliseconds. If the event fires again within that time, the original
         * handler is *not* invoked, but the new handler is scheduled in its place.
         * @param {Ext.dom.Element} options.target Only call the handler if the event was fired on the target Element,
         * *not* if the event was bubbled up from a child node.
         */
        static addListener(el: string|Ext.dom.Element|HTMLElement|Window, eventName: string, handler: Function|string, handler_event: Ext.EventObject, handler_target: Ext.dom.Element, handler_options: any, scope?: any, options?: any, options_scope?: any, options_delegate?: string, options_stopEvent?: boolean, options_preventDefault?: boolean, options_stopPropagation?: boolean, options_normalized?: boolean, options_delay?: number, options_single?: boolean, options_buffer?: number, options_target?: Ext.dom.Element);

        /**
         * Get the id of the element. If one has not been assigned, automatically assign it.
         * @param {HTMLElement/Ext.Element} element The element to get the id for.
         * @return {String} id
         */
        static getId(element: HTMLElement|Ext.dom.Element): string;

        /**
         * Indicates which event to use for getting key presses.
         * @return {String} The appropriate event name.
         */
        static getKeyEvent(): string;

        /**
         * Gets the x coordinate from the event
         * @param {Object} event The event
         * @return {Number} The x coordinate
         */
        static getPageX(event: any): number;

        /**
         * Gets the x & y coordinate from the event
         * @param {Object} event The event
         * @return {Number[]} The x/y coordinate
         */
        static getPageXY(event: any): number;

        /**
         * Gets the y coordinate from the event
         * @param {Object} event The event
         * @return {Number} The y coordinate
         */
        static getPageY(event: any): number;

        /**
         * Gets the related target from the event.
         * @param {Object} event The event
         * @return {HTMLElement} The related target.
         */
        static getRelatedTarget(event: any): HTMLElement;

        /**
         * Gets the target of the event.
         * @param {Object} event The event
         * @return {HTMLElement} target
         */
        static getTarget(event: any): HTMLElement;

        static on();

        /**
         * Adds a listener to be notified when the document is ready (before onload and before images are loaded).
         *
         * {@link Ext#onDocumentReady} is an alias for {@link Ext.EventManager#onDocumentReady}.
         *
         * @param {Function} fn The method the event invokes.
         * @param {Object} [scope] The scope ('this' reference) in which the handler function executes.
         * Defaults to the browser window.
         * @param {Object} [options] Options object as passed to {@link Ext.Element#addListener}.
         */
        static onDocumentReady(fn: Function, scope?: any, options?: any);

        /**
         * Adds a listener to be notified when the browser window is resized and provides resize event buffering (100 milliseconds),
         * passes new viewport width and height to handlers.
         * @param {Function} fn      The handler function the window resize event invokes.
         * @param {Object}   scope   The scope (<code>this</code> reference) in which the handler function executes. Defaults to the browser window.
         * @param {Boolean}  [options] Options object as passed to {@link Ext.Element#addListener}
         */
        static onWindowResize(fn: Function, scope: any, options?: boolean);

        /**
         * Adds a listener to be notified when the browser window is unloaded.
         * @param {Function} fn      The handler function the window unload event invokes.
         * @param {Object}   scope   The scope (<code>this</code> reference) in which the handler function executes. Defaults to the browser window.
         * @param {Boolean}  options Options object as passed to {@link Ext.Element#addListener}
         */
        static onWindowUnload(fn: Function, scope: any, options: boolean);

        /**
         * This strategy has minimal benefits for Sencha solutions that build themselves (ie. minimal initial page markup).
         * However, progressively-enhanced pages (with image content and/or embedded frames) will benefit the most from it.
         * Browser timer resolution is too poor to ensure a doScroll check more than once on a page loaded with minimal
         * assets (the readystatechange event 'complete' usually beats the doScroll timer on a 'lightly-loaded' initial document).
         */
        static pollScroll();

        /**
         * Prevents the browsers default handling of the event.
         * @param {Event} event The event to prevent the default
         */
        static preventDefault(event: Event);

        /**
         * Recursively removes all previous added listeners from an element and its children. Typically you will use {@link Ext.Element#purgeAllListeners}
         * directly on an Element in favor of calling this version.
         * @param {String/Ext.Element/HTMLElement/Window} el The id or html element from which to remove all event handlers.
         * @param {String} eventName (optional) The name of the event.
         */
        static purgeElement(el: string|Ext.dom.Element|HTMLElement|Window, eventName: string);

        /**
         * Removes all event handers from an element.  Typically you will use {@link Ext.Element#removeAllListeners}
         * directly on an Element in favor of calling this version.
         * @param {String/Ext.Element/HTMLElement/Window} el The id or html element from which to remove all event handlers.
         */
        static removeAll(el: string|Ext.dom.Element|HTMLElement|Window);

        /**
         * Removes an event handler from an element.  The shorthand version {@link #un} is equivalent.  Typically
         * you will use {@link Ext.Element#removeListener} directly on an Element in favor of calling this version.
         *
         * {@link Ext.EventManager#on} is an alias for {@link Ext.EventManager#addListener}.
         *
         * @param {String/Ext.Element/HTMLElement/Window} el The id or html element from which to remove the listener.
         * @param {String} eventName The name of the event.
         * @param {Function} fn The handler function to remove. **This must be a reference to the function passed
         * into the {@link #addListener} call.**
         * @param {Object} scope If a scope ('this' reference) was specified when the listener was added,
         * then this must refer to the same object.
         */
        static removeListener(el: string|Ext.dom.Element|HTMLElement|Window, eventName: string, fn: Function, scope: any);

        /**
         * Removes the passed window resize listener.
         * @param {Function} fn        The method the event invokes
         * @param {Object}   scope    The scope of handler
         */
        static removeResizeListener(fn: Function, scope: any);

        /**
         * Removes the passed window unload listener.
         * @param {Function} fn        The method the event invokes
         * @param {Object}   scope    The scope of handler
         */
        static removeUnloadListener(fn: Function, scope: any);

        /**
         * Stop the event (preventDefault and stopPropagation)
         * @param {Event} event The event to stop
         */
        static stopEvent(event: Event);

        /**
         * Cancels bubbling of the event.
         * @param {Event} event The event to stop bubbling.
         */
        static stopPropagation(event: Event);

        static un();
    }

    /**
     Just as {@link Ext.Element} wraps around a native DOM node, Ext.EventObject
     wraps the browser's native event-object normalizing cross-browser differences,
     such as which mouse button is clicked, keys pressed, mechanisms to stop
     event-propagation along with a method to prevent default actions from taking place.
     For example:
     function handleClick(e, t){ // e is not a standard event object, it is a Ext.EventObject
     e.preventDefault();
     var target = e.getTarget(); // same as t (the target HTMLElement)
     ...
     }
     var myDiv = {@link Ext#get Ext.get}("myDiv");  // get reference to an {@link Ext.Element}
     myDiv.on(         // 'on' is shorthand for addListener
     "click",      // perform an action on click of myDiv
     handleClick   // reference to the action handler
     );
     // other methods to do the same:
     Ext.EventManager.on("myDiv", 'click', handleClick);
     Ext.EventManager.addListener("myDiv", 'click', handleClick);
     * @markdown
     */
    export class EventObject {
        /** Key constant @type Number */
        static A: any;

        /** Key constant @type Number */
        static ALT: any;

        /**
         * True if the alt key was down during the event.
         */
        static altKey: boolean;

        /** Key constant @type Number */
        static B: any;

        /** Key constant @type Number */
        static BACKSPACE: any;

        /** Key constant @type Number */
        static C: any;

        /** Key constant @type Number */
        static CAPS_LOCK: any;

        /** Key constant @type Number */
        static CONTEXT_MENU: any;

        /** Key constant @type Number */
        static CTRL: any;

        /**
         * True if the control key was down during the event.
         * In Mac this will also be true when meta key was down.
         */
        static ctrlKey: boolean;

        /** Key constant @type Number */
        static D: any;

        /** Key constant @type Number */
        static DELETE: any;

        /** Key constant @type Number */
        static DOWN: any;

        /** Key constant @type Number */
        static E: any;

        /** Key constant @type Number */
        static EIGHT: any;

        /** Key constant @type Number */
        static END: any;

        /** Key constant @type Number */
        static ENTER: any;

        /** Key constant @type Number */
        static ESC: any;

        /** Key constant @type Number */
        static F: any;

        /** Key constant @type Number */
        static F1: any;

        /** Key constant @type Number */
        static F10: any;

        /** Key constant @type Number */
        static F11: any;

        /** Key constant @type Number */
        static F12: any;

        /** Key constant @type Number */
        static F2: any;

        /** Key constant @type Number */
        static F3: any;

        /** Key constant @type Number */
        static F4: any;

        /** Key constant @type Number */
        static F5: any;

        /** Key constant @type Number */
        static F6: any;

        /** Key constant @type Number */
        static F7: any;

        /** Key constant @type Number */
        static F8: any;

        /** Key constant @type Number */
        static F9: any;

        /** Key constant @type Number */
        static FIVE: any;

        /** Key constant @type Number */
        static FOUR: any;

        /** Key constant @type Number */
        static G: any;

        /** Key constant @type Number */
        static H: any;

        /** Key constant @type Number */
        static HOME: any;

        /** Key constant @type Number */
        static I: any;

        /** Key constant @type Number */
        static INSERT: any;

        /** Key constant @type Number */
        static J: any;

        /** Key constant @type Number */
        static K: any;

        /** Key constant @type Number */
        static L: any;

        /** Key constant @type Number */
        static LEFT: any;

        /** Key constant @type Number */
        static M: any;

        /** Key constant @type Number */
        static N: any;

        /** Key constant @type Number */
        static NINE: any;

        /** Key constant @type Number */
        static NUM_CENTER: any;

        /** Key constant @type Number */
        static NUM_DIVISION: any;

        /** Key constant @type Number */
        static NUM_EIGHT: any;

        /** Key constant @type Number */
        static NUM_FIVE: any;

        /** Key constant @type Number */
        static NUM_FOUR: any;

        /** Key constant @type Number */
        static NUM_MINUS: any;

        /** Key constant @type Number */
        static NUM_MULTIPLY: any;

        /** Key constant @type Number */
        static NUM_NINE: any;

        /** Key constant @type Number */
        static NUM_ONE: any;

        /** Key constant @type Number */
        static NUM_PERIOD: any;

        /** Key constant @type Number */
        static NUM_PLUS: any;

        /** Key constant @type Number */
        static NUM_SEVEN: any;

        /** Key constant @type Number */
        static NUM_SIX: any;

        /** Key constant @type Number */
        static NUM_THREE: any;

        /** Key constant @type Number */
        static NUM_TWO: any;

        /** Key constant @type Number */
        static NUM_ZERO: any;

        /** Key constant @type Number */
        static O: any;

        /** Key constant @type Number */
        static ONE: any;

        /** Key constant @type Number */
        static P: any;

        /** Key constant @type Number */
        static PAGE_DOWN: any;

        /** Key constant @type Number */
        static PAGE_UP: any;

        /** Key constant @type Number */
        static PAUSE: any;

        /** Key constant @type Number */
        static PRINT_SCREEN: any;

        /** Key constant @type Number */
        static Q: any;

        /** Key constant @type Number */
        static R: any;

        /** Key constant @type Number */
        static RETURN: any;

        /** Key constant @type Number */
        static RIGHT: any;

        /** Key constant @type Number */
        static S: any;

        /** Key constant @type Number */
        static SEVEN: any;

        /** Key constant @type Number */
        static SHIFT: any;

        /**
         * True if the shift key was down during the event.
         */
        static shiftKey: boolean;

        /** Key constant @type Number */
        static SIX: any;

        /** Key constant @type Number */
        static SPACE: any;

        /** Key constant @type Number */
        static T: any;

        /** Key constant @type Number */
        static TAB: any;

        /** Key constant @type Number */
        static THREE: any;

        /** Key constant @type Number */
        static TWO: any;

        /** Key constant @type Number */
        static U: any;

        /** Key constant @type Number */
        static UP: any;

        /** Key constant @type Number */
        static V: any;

        /** Key constant @type Number */
        static W: any;

        /**
         * The mouse wheel delta scaling factor. This value depends on browser version and OS and
         * attempts to produce a similar scrolling experience across all platforms and browsers.
         *
         * To change this value:
         *
         *      Ext.EventObjectImpl.prototype.WHEEL_SCALE = 72;
         *
         * @markdown
         */
        static WHEEL_SCALE: number;

        /** Key constant @type Number */
        static X: any;

        /** Key constant @type Number */
        static Y: any;

        /** Key constant @type Number */
        static Z: any;

        /** Key constant @type Number */
        static ZERO: any;

        /**
         * Correctly scales a given wheel delta.
         * @param {Number} delta The delta value.
         */
        static correctWheelDelta(delta: number);

        /**
         * Gets the character code for the event.
         * @return {Number}
         */
        static getCharCode(): number;

        /**
         * Returns a normalized keyCode for the event.
         * @return {Number} The key code
         */
        static getKey(): number;

        /**
         * Gets the x coordinate of the event.
         * @return {Number}
         * @deprecated 4.0 Replaced by {@link #getX}
         */
        static getPageX(): number;

        /**
         * Gets the y coordinate of the event.
         * @return {Number}
         * @deprecated 4.0 Replaced by {@link #getY}
         */
        static getPageY(): number;

        /**
         * Returns a point object that consists of the object coordinates.
         * @return {Ext.util.Point} point
         */
        static getPoint(): Ext.util.Point;

        /**
         * Gets the related target.
         * @param {String} selector (optional) A simple selector to filter the target or look for an ancestor of the target
         * @param {Number/HTMLElement} maxDepth (optional) The max depth to search as a number or element (defaults to 10 || document.body)
         * @param {Boolean} returnEl (optional) True to return a Ext.Element object instead of DOM node
         * @return {HTMLElement}
         */
        static getRelatedTarget(selector: string, maxDepth: number|HTMLElement, returnEl: boolean): HTMLElement;

        /**
         * Gets the target for the event.
         * @param {String} selector (optional) A simple selector to filter the target or look for an ancestor of the target
         * @param {Number/HTMLElement} maxDepth (optional) The max depth to search as a number or element (defaults to 10 || document.body)
         * @param {Boolean} returnEl (optional) True to return a Ext.Element object instead of DOM node
         * @return {HTMLElement}
         */
        static getTarget(selector: string, maxDepth: number|HTMLElement, returnEl: boolean): HTMLElement;

        /**
         * Normalizes mouse wheel y-delta across browsers. To get x-delta information, use
         * {@link #getWheelDeltas} instead.
         * @return {Number} The mouse wheel y-delta
         */
        static getWheelDelta(): number;

        /**
         * Returns the mouse wheel deltas for this event.
         * @return {Object} An object with "x" and "y" properties holding the mouse wheel deltas.
         */
        static getWheelDeltas(): any;

        /**
         * Gets the x coordinate of the event.
         * @return {Number}
         */
        static getX(): number;

        /**
         * Gets the page coordinates of the event.
         * @return {Number[]} The xy values like [x, y]
         */
        static getXY(): number;

        /**
         * Gets the y coordinate of the event.
         * @return {Number}
         */
        static getY(): number;

        /**
         * Returns true if the control, meta, shift or alt key was pressed during this event.
         * @return {Boolean}
         */
        static hasModifier(): boolean;

        /**
         * Injects a DOM event using the data in this object and (optionally) a new target.
         * This is a low-level technique and not likely to be used by application code. The
         * currently supported event types are:
         * <p><b>HTMLEvents</b></p>
         * <ul>
         * <li>load</li>
         * <li>unload</li>
         * <li>select</li>
         * <li>change</li>
         * <li>submit</li>
         * <li>reset</li>
         * <li>resize</li>
         * <li>scroll</li>
         * </ul>
         * <p><b>MouseEvents</b></p>
         * <ul>
         * <li>click</li>
         * <li>dblclick</li>
         * <li>mousedown</li>
         * <li>mouseup</li>
         * <li>mouseover</li>
         * <li>mousemove</li>
         * <li>mouseout</li>
         * </ul>
         * <p><b>UIEvents</b></p>
         * <ul>
         * <li>focusin</li>
         * <li>focusout</li>
         * <li>activate</li>
         * <li>focus</li>
         * <li>blur</li>
         * </ul>
         * @param {Ext.Element/HTMLElement} target (optional) If specified, the target for the event. This
         * is likely to be used when relaying a DOM event. If not specified, {@link #getTarget}
         * is used to determine the target.
         */
        static injectEvent(target: Ext.dom.Element|HTMLElement);

        /**
         * Checks if the key pressed was a "navigation" key
         * @return {Boolean} True if the press is a navigation keypress
         */
        static isNavKeyPress(): boolean;

        /**
         * Checks if the key pressed was a "special" key
         * @return {Boolean} True if the press is a special keypress
         */
        static isSpecialKey(): boolean;

        /**
         * Prevents the browsers default handling of the event.
         */
        static preventDefault();

        /**
         * Stop the event (preventDefault and stopPropagation)
         */
        static stopEvent();

        /**
         * Cancels bubbling of the event.
         */
        static stopPropagation();

        /**
         * Returns true if the target of this event is a child of el.  Unless the allowEl parameter is set, it will return false if if the target is el.
         * Example usage:<pre><code>
         // Handle click on any child of an element
         Ext.getBody().on('click', function(e){
         if(e.within('some-el')){
         alert('Clicked on a child of some-el!');
         }
         });
         // Handle click directly on an element, ignoring clicks on child nodes
         Ext.getBody().on('click', function(e,t){
         if((t.id == 'some-el') && !e.within(t, true)){
         alert('Clicked directly on some-el!');
         }
         });
         </code></pre>
         * @param {String/HTMLElement/Ext.Element} el The id, DOM element or Ext.Element to check
         * @param {Boolean} [related] 'true' to test if the related target is within el instead of the target
         * @param {Boolean} [allowEl] 'true' to also check if the passed element is the target or related target
         * @return {Boolean}
         */
        static within(el: string|HTMLElement|Ext.dom.Element, related?: boolean, allowEl?: boolean): boolean;
    }

    /**
     * The FocusManager is responsible for globally:
     *
     * 1. Managing component focus
     * 2. Providing basic keyboard navigation
     * 3. (optional) Provide a visual cue for focused components, in the form of a focus ring/frame.
     *
     * To activate the FocusManager, simply call 'Ext.FocusManager.enable();'. In turn, you may
     * deactivate the FocusManager by subsequently calling 'Ext.FocusManager.disable();'.  The
     * FocusManager is disabled by default.
     *
     * To enable the optional focus frame, pass 'true' or '{focusFrame: true}' to {@link #method-enable}.
     *
     * Another feature of the FocusManager is to provide basic keyboard focus navigation scoped to any {@link Ext.container.Container}
     * that would like to have navigation between its child {@link Ext.Component}'s.
     *
     * @author Jarred Nicholls <jarred@sencha.com>
     * @docauthor Jarred Nicholls <jarred@sencha.com>
     */
    export class FocusManager {
        /**
         * Whether or not the FocusManager is currently enabled
         */
        static enabled: boolean;

        /**
         * The currently focused component.
         */
        static focusedCmp: Ext.Component;

        /**
         * A list of xtypes that should ignore certain navigation input keys and
         * allow for the default browser event/behavior. These input keys include:
         *
         * 1. Backspace
         * 2. Delete
         * 3. Left
         * 4. Right
         * 5. Up
         * 6. Down
         *
         * The FocusManager will not attempt to navigate when a component is an xtype (or descendents thereof)
         * that belongs to this whitelist. E.g., an {@link Ext.form.field.Text} should allow
         * the user to move the input cursor left and right, and to delete characters, etc.
         */
        static whitelist: string;

        /**
         * Adds the specified xtype to the {@link #whitelist}.
         * @param {String/String[]} xtype Adds the xtype(s) to the {@link #whitelist}.
         */
        static addXTypeToWhitelist(xtype: string);

        /**
         * Disables the FocusManager by turning of all automatic focus management and keyboard navigation
         */
        static disable();

        /**
         * Enables the FocusManager by turning on all automatic focus management and keyboard navigation
         * @param {Boolean/Object} options Either 'true'/'false' to turn on the focus frame, or an object
         * with the following options:
         * @param {Boolean} [options.focusFrame=false] 'true' to show the focus frame around a component when it is focused.
         */
        static enable(options: boolean|any, options_focusFrame?: boolean);

        /**
         * Removes the specified xtype from the {@link #whitelist}.
         * @param {String/String[]} xtype Removes the xtype(s) from the {@link #whitelist}.
         */
        static removeXTypeFromWhitelist(xtype: string);

        /**
         * Fires before a component becomes focused. Return 'false' to prevent
         * the component from gaining focus.
         * @param {Ext.FocusManager} fm A reference to the FocusManager singleton
         * @param {Ext.Component} cmp The component that is being focused
         * @param {Ext.Component} previousCmp The component that was previously focused,
         * or 'undefined' if there was no previously focused component.
         */
        static beforecomponentfocus(fm: Ext.FocusManager, cmp: Ext.Component, previousCmp: Ext.Component);

        /**
         * Fires after a component becomes focused.
         * @param {Ext.FocusManager} fm A reference to the FocusManager singleton
         * @param {Ext.Component} cmp The component that has been focused
         * @param {Ext.Component} previousCmp The component that was previously focused,
         * or 'undefined' if there was no previously focused component.
         */
        static componentfocus(fm: Ext.FocusManager, cmp: Ext.Component, previousCmp: Ext.Component);
    }

    /**
     * A collection of useful static methods to deal with function callbacks
     * @alternateClassName Ext.util.Functions
     */
    export class Function {
        /**
         * Create an alias to the provided method property with name 'methodName' of 'object'.
         * Note that the execution scope will still be bound to the provided 'object' itself.
         *
         * @return {Function} aliasFn
         */
        static alias(object: any|Function, methodName: string): Function;

        /**
         * Create a new function from the provided 'fn', change 'this' to the provided scope, optionally
         * overrides arguments for the call. (Defaults to the arguments passed by the caller)
         *
         * {@link Ext#bind Ext.bind} is alias for {@link Ext.Function#bind Ext.Function.bind}
         *
         * @param {Function} fn The function to delegate.
         * @param {Object} scope (optional) The scope ('this' reference) in which the function is executed.
         * **If omitted, defaults to the default global environment object (usually the browser window).**
         * @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
         * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
         * if a number the args are inserted at the specified position
         * @return {Function} The new function
         */
        static bind(fn: Function, scope: any, args: any[], appendArgs: boolean|number): Function;

        /**
         * Create a "clone" of the provided method. The returned method will call the given
         * method passing along all arguments and the "this" pointer and return its result.
         *
         * @return {Function} cloneFn
         */
        static clone(method: Function): Function;

        /**
         * Creates a delegate function, optionally with a bound scope which, when called, buffers
         * the execution of the passed function for the configured number of milliseconds.
         * If called again within that period, the impending invocation will be canceled, and the
         * timeout period will begin again.
         *
         * @param {Function} fn The function to invoke on a buffered timer.
         * @param {Number} buffer The number of milliseconds by which to buffer the invocation of the
         * function.
         * @param {Object} scope (optional) The scope ('this' reference) in which
         * the passed function is executed. If omitted, defaults to the scope specified by the caller.
         * @param {Array} args (optional) Override arguments for the call. Defaults to the arguments
         * passed by the caller.
         * @return {Function} A function which invokes the passed function after buffering for the specified time.
         */
        static createBuffered(fn: Function, buffer: number, scope: any, args: any[]): Function;

        /**
         * Creates a delegate (callback) which, when called, executes after a specific delay.
         *
         * @param {Function} fn The function which will be called on a delay when the returned function is called.
         * Optionally, a replacement (or additional) argument list may be specified.
         * @param {Number} delay The number of milliseconds to defer execution by whenever called.
         * @param {Object} scope (optional) The scope ('this' reference) used by the function at execution time.
         * @param {Array} args (optional) Override arguments for the call. (Defaults to the arguments passed by the caller)
         * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
         * if a number the args are inserted at the specified position.
         * @return {Function} A function which, when called, executes the original function after the specified delay.
         */
        static createDelayed(fn: Function, delay: number, scope: any, args: any[], appendArgs: boolean|number): Function;

        /**
         * Creates an interceptor function. The passed function is called before the original one. If it returns false,
         * the original one is not called. The resulting function returns the results of the original function.
         * The passed function is called with the parameters of the original function. Example usage:
         *
         *     var sayHi = function(name){
         *         alert('Hi, ' + name);
         *     }
         *
         *     sayHi('Fred'); // alerts "Hi, Fred"
         *
         *     // create a new function that validates input without
         *     // directly modifying the original function:
         *     var sayHiToFriend = Ext.Function.createInterceptor(sayHi, function(name){
         *         return name == 'Brian';
         *     });
         *
         *     sayHiToFriend('Fred');  // no alert
         *     sayHiToFriend('Brian'); // alerts "Hi, Brian"
         *
         * @param {Function} origFn The original function.
         * @param {Function} newFn The function to call before the original
         * @param {Object} [scope] The scope ('this' reference) in which the passed function is executed.
         * **If omitted, defaults to the scope in which the original function is called or the browser window.**
         * @param {Object} [returnValue=null] The value to return if the passed function return false.
         * @return {Function} The new function
         */
        static createInterceptor(origFn: Function, newFn: Function, scope?: any, returnValue?: any): Function;

        /**
         * Create a combined function call sequence of the original function + the passed function.
         * The resulting function returns the results of the original function.
         * The passed function is called with the parameters of the original function. Example usage:
         *
         *     var sayHi = function(name){
         *         alert('Hi, ' + name);
         *     }
         *
         *     sayHi('Fred'); // alerts "Hi, Fred"
         *
         *     var sayGoodbye = Ext.Function.createSequence(sayHi, function(name){
         *         alert('Bye, ' + name);
         *     });
         *
         *     sayGoodbye('Fred'); // both alerts show
         *
         * @param {Function} originalFn The original function.
         * @param {Function} newFn The function to sequence
         * @param {Object} scope (optional) The scope ('this' reference) in which the passed function is executed.
         * If omitted, defaults to the scope in which the original function is called or the default global environment object (usually the browser window).
         * @return {Function} The new function
         */
        static createSequence(originalFn: Function, newFn: Function, scope: any): Function;

        /**
         * Creates a throttled version of the passed function which, when called repeatedly and
         * rapidly, invokes the passed function only after a certain interval has elapsed since the
         * previous invocation.
         *
         * This is useful for wrapping functions which may be called repeatedly, such as
         * a handler of a mouse move event when the processing is expensive.
         *
         * @param {Function} fn The function to execute at a regular time interval.
         * @param {Number} interval The interval **in milliseconds** on which the passed function is executed.
         * @param {Object} scope (optional) The scope ('this' reference) in which
         * the passed function is executed. If omitted, defaults to the scope specified by the caller.
         * @returns {Function} A function which invokes the passed function at the specified interval.
         */
        static createThrottled(fn: Function, interval: number, scope: any);

        /**
         * Calls this function after the number of millseconds specified, optionally in a specific scope. Example usage:
         *
         *     var sayHi = function(name){
         *         alert('Hi, ' + name);
         *     }
         *
         *     // executes immediately:
         *     sayHi('Fred');
         *
         *     // executes after 2 seconds:
         *     Ext.Function.defer(sayHi, 2000, this, ['Fred']);
         *
         *     // this syntax is sometimes useful for deferring
         *     // execution of an anonymous function:
         *     Ext.Function.defer(function(){
         *         alert('Anonymous');
         *     }, 100);
         *
         * {@link Ext#defer Ext.defer} is alias for {@link Ext.Function#defer Ext.Function.defer}
         *
         * @param {Function} fn The function to defer.
         * @param {Number} millis The number of milliseconds for the setTimeout call
         * (if less than or equal to 0 the function is executed immediately)
         * @param {Object} scope (optional) The scope ('this' reference) in which the function is executed.
         * **If omitted, defaults to the browser window.**
         * @param {Array} args (optional) Overrides arguments for the call. (Defaults to the arguments passed by the caller)
         * @param {Boolean/Number} appendArgs (optional) if True args are appended to call args instead of overriding,
         * if a number the args are inserted at the specified position
         * @return {Number} The timeout id that can be used with clearTimeout
         */
        static defer(fn: Function, millis: number, scope: any, args: any[], appendArgs: boolean|number): number;

        /**
         * A very commonly used method throughout the framework. It acts as a wrapper around another method
         * which originally accepts 2 arguments for 'name' and 'value'.
         * The wrapped function then allows "flexible" value setting of either:
         *
         * - 'name' and 'value' as 2 arguments
         * - one single object argument with multiple key - value pairs
         *
         * For example:
         *
         *     var setValue = Ext.Function.flexSetter(function(name, value) {
         *         this[name] = value;
         *     });
         *
         *     // Afterwards
         *     // Setting a single name - value
         *     setValue('name1', 'value1');
         *
         *     // Settings multiple name - value pairs
         *     setValue({
         *         name1: 'value1',
         *         name2: 'value2',
         *         name3: 'value3'
         *     });
         *
         * @returns {Function} flexSetter
         */
        static flexSetter(setter: Function);

        /**
         * Adds behavior to an existing method that is executed after the
         * original behavior of the function.  For example:
         *
         *     var soup = {
         *         contents: [],
         *         add: function(ingredient) {
         *             this.contents.push(ingredient);
         *         }
         *     };
         *     Ext.Function.interceptAfter(soup, "add", function(ingredient){
         *         // Always add a bit of extra salt
         *         this.contents.push("salt");
         *     });
         *     soup.add("water");
         *     soup.add("onions");
         *     soup.contents; // will contain: water, salt, onions, salt
         *
         * @param {Object} object The target object
         * @param {String} methodName Name of the method to override
         * @param {Function} fn Function with the new behavior.  It will
         * be called with the same arguments as the original method.  The
         * return value of this function will be the return value of the
         * new method.
         * @param {Object} [scope] The scope to execute the interceptor function. Defaults to the object.
         * @return {Function} The new function just created.
         */
        static interceptAfter(object: any, methodName: string, fn: Function, scope?: any): Function;

        /**
         * Adds behavior to an existing method that is executed before the
         * original behavior of the function.  For example:
         *
         *     var soup = {
         *         contents: [],
         *         add: function(ingredient) {
         *             this.contents.push(ingredient);
         *         }
         *     };
         *     Ext.Function.interceptBefore(soup, "add", function(ingredient){
         *         if (!this.contents.length && ingredient !== "water") {
         *             // Always add water to start with
         *             this.contents.push("water");
         *         }
         *     });
         *     soup.add("onions");
         *     soup.add("salt");
         *     soup.contents; // will contain: water, onions, salt
         *
         * @param {Object} object The target object
         * @param {String} methodName Name of the method to override
         * @param {Function} fn Function with the new behavior.  It will
         * be called with the same arguments as the original method.  The
         * return value of this function will be the return value of the
         * new method.
         * @param {Object} [scope] The scope to execute the interceptor function. Defaults to the object.
         * @return {Function} The new function just created.
         */
        static interceptBefore(object: any, methodName: string, fn: Function, scope?: any): Function;

        /**
         * Create a new function from the provided 'fn', the arguments of which are pre-set to 'args'.
         * New arguments passed to the newly created callback when it's invoked are appended after the pre-set ones.
         * This is especially useful when creating callbacks.
         *
         * For example:
         *
         *     var originalFunction = function(){
         *         alert(Ext.Array.from(arguments).join(' '));
         *     };
         *
         *     var callback = Ext.Function.pass(originalFunction, ['Hello', 'World']);
         *
         *     callback(); // alerts 'Hello World'
         *     callback('by Me'); // alerts 'Hello World by Me'
         *
         * {@link Ext#pass Ext.pass} is alias for {@link Ext.Function#pass Ext.Function.pass}
         *
         * @param {Function} fn The original function
         * @param {Array} args The arguments to pass to new callback
         * @param {Object} scope (optional) The scope ('this' reference) in which the function is executed.
         * @return {Function} The new callback function
         */
        static pass(fn: Function, args: any[], scope: any): Function;
    }

    interface ImgConfig extends Ext.ComponentConfig {
        /**
         * The descriptive text for non-visual UI description.
         */
        alt?: string;

        autoEl?: any;

        baseCls?: any;

        /**
         * A numeric unicode character code to serve as the image.  If this option is used
         * The image will be rendered using a div with innerHTML set to the html entity
         * for the given character code.  The default font-family for glyphs can be set
         * globally using {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()}. Alternatively,
         * this config option accepts a string with the charCode and font-family separated by
         * the '@' symbol. For example '65@My Font Family'.
         */
        glyph?: number|string;

        /**
         * Optional CSS classes to add to the img element.
         */
        imgCls?: string;

        /**
         * The image src.
         */
        src?: string;

        /**
         * Specifies addtional information about the image.
         */
        title?: string;
    }

    /**
     * Simple helper class for easily creating image components. This renders an image tag to
     * the DOM with the configured src.
     *
     * {@img Ext.Img/Ext.Img.png Ext.Img component}
     *
     * ## Example usage:
     *
     *     var changingImage = Ext.create('Ext.Img', {
     *         src: 'http://www.sencha.com/img/20110215-feat-html5.png',
     *         renderTo: Ext.getBody()
     *     });
     *
     *     // change the src of the image programmatically
     *     changingImage.setSrc('http://www.sencha.com/img/20110215-feat-perf.png');
     *
     * By default, only an img element is rendered and that is this component's primary
     * {@link Ext.AbstractComponent#getEl element}. If the {@link Ext.AbstractComponent#autoEl} property
     * is other than 'img' (the default), the a child img element will be added to the primary
     * element. This can be used to create a wrapper element around the img.
     *
     * ## Wrapping the img in a div:
     *
     *     var wrappedImage = Ext.create('Ext.Img', {
     *         src: 'http://www.sencha.com/img/20110215-feat-html5.png',
     *         autoEl: 'div', // wrap in a div
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Img extends Ext.Component implements Ext.ImgConfig {
        /**
         * The descriptive text for non-visual UI description.
         */
        alt: string;

        autoEl: string|any;

        baseCls: string;

        /**
         * A numeric unicode character code to serve as the image.  If this option is used
         * The image will be rendered using a div with innerHTML set to the html entity
         * for the given character code.  The default font-family for glyphs can be set
         * globally using {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()}. Alternatively,
         * this config option accepts a string with the charCode and font-family separated by
         * the '@' symbol. For example '65@My Font Family'.
         */
        glyph: number|string;

        /**
         * Optional CSS classes to add to the img element.
         */
        imgCls: string;

        /**
         * The image src.
         */
        src: string;

        /**
         * Specifies addtional information about the image.
         */
        title: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected onDestroy();

        protected onRender();

        /**
         * Updates the {@link #src} of the image.
         */
        setSrc(src: string);
    }

    /**
     * Determines information about the current platform the application is running on.
     */
    export class is {
        /**
         * when the browser is running on an Android device
         */
        static Android: boolean;

        /**
         * when the browser is running on a Blackberry
         */
        static Blackberry: boolean;

        /**
         * if the browser is running on a desktop machine
         */
        static Desktop: boolean;

        /**
         * if the browser is running on iOS
         */
        static iOS: boolean;

        /**
         * when the browser is running on a iPad
         */
        static iPad: boolean;

        /**
         * when the browser is running on a iPhone
         */
        static iPhone: boolean;

        /**
         * when the browser is running on a iPod
         */
        static iPod: boolean;

        /**
         * when the browser is running on Linux
         */
        static Linux: boolean;

        /**
         * when the browser is running on a Mac
         */
        static Mac: boolean;

        /**
         * if the browser is running on a phone.
         */
        static Phone: boolean;

        /**
         * when application has been saved to homescreen.
         */
        static Standalone: boolean;

        /**
         * if the browser is running on a tablet (iPad)
         */
        static Tablet: any;

        /**
         * when the browser is running on Windows
         */
        static Windows: boolean;
    }

    /**
     * Modified version of [Douglas Crockford's JSON.js][dc] that doesn't
     * mess with the Object prototype.
     *
     * [dc]: http://www.json.org/js.html
     */
    export class JSON {
        /**
         * Decodes (parses) a JSON string to an object. If the JSON is invalid, this function throws
         * a SyntaxError unless the safe option is set.
         *
         * @param {String} json The JSON string
         * @param {Boolean} [safe=false] True to return null, false to throw an exception if the JSON is invalid.
         * @return {Object} The resulting object
         */
        static decode(json: string, safe?: boolean): any;

        /**
         * Encodes an Object, Array or other value.
         *
         * If the environment's native JSON encoding is not being used ({@link Ext#USE_NATIVE_JSON} is not set,
         * or the environment does not support it), then ExtJS's encoding will be used. This allows the developer
         * to add a 'toJSON' method to their classes which need serializing to return a valid JSON representation
         * of the object.
         *
         * @param {Object} o The variable to encode
         * @return {String} The JSON string
         */
        static encode(o: any): string;

        /**
         * Encodes a Date. This returns the actual string which is inserted into the JSON string as the literal
         * expression. **The returned value includes enclosing double quotation marks.**
         *
         * The default return format is '"yyyy-mm-ddThh:mm:ss"'.
         *
         * To override this:
         *
         *     Ext.JSON.encodeDate = function(d) {
         *         return Ext.Date.format(d, '"Y-m-d"');
         *     };
         *
         * @param {Date} d The Date to encode
         * @return {String} The string literal to use in a JSON string.
         */
        static encodeDate(d: Date): string;

        /**
         * Encodes a String. This returns the actual string which is inserted into the JSON string as the literal
         * expression. **The returned value includes enclosing double quotation marks.**
         *
         * To override this:
         *
         *     Ext.JSON.encodeString = function(s) {
         *         return 'Foo' + s;
         *     };
         *
         * @param {String} s The String to encode
         * @return {String} The string literal to use in a JSON string.
         */
        static encodeString(s: string): string;

        /**
         * The function which {@link #encode} uses to encode all javascript values to their JSON representations
         * when {@link Ext#USE_NATIVE_JSON} is 'false'.
         *
         * This is made public so that it can be replaced with a custom implementation.
         *
         * @param {Object} o Any javascript value to be converted to its JSON representation
         * @return {String} The JSON representation of the passed value.
         */
        static encodeValue(o: any): string;
    }

    /**
     * @author Jacky Nguyen <jacky@sencha.com>
     * @docauthor Jacky Nguyen <jacky@sencha.com>
     *
     * Ext.Loader is the heart of the new dynamic dependency loading capability in Ext JS 4+. It is most commonly used
     * via the {@link Ext#require} shorthand. Ext.Loader supports both asynchronous and synchronous loading
     * approaches, and leverage their advantages for the best development flow. We'll discuss about the pros and cons of each approach:
     *
     * # Asynchronous Loading #
     *
     * - Advantages:
     *     + Cross-domain
     *     + No web server needed: you can run the application via the file system protocol (i.e: 'file://path/to/your/index
     *  .html')
     *     + Best possible debugging experience: error messages come with the exact file name and line number
     *
     * - Disadvantages:
     *     + Dependencies need to be specified before-hand
     *
     * ### Method 1: Explicitly include what you need: ###
     *
     *     // Syntax
     *     Ext.require({String/Array} expressions);
     *
     *     // Example: Single alias
     *     Ext.require('widget.window');
     *
     *     // Example: Single class name
     *     Ext.require('Ext.window.Window');
     *
     *     // Example: Multiple aliases / class names mix
     *     Ext.require(['widget.window', 'layout.border', 'Ext.data.Connection']);
     *
     *     // Wildcards
     *     Ext.require(['widget.*', 'layout.*', 'Ext.data.*']);
     *
     * ### Method 2: Explicitly exclude what you don't need: ###
     *
     *     // Syntax: Note that it must be in this chaining format.
     *     Ext.exclude({String/Array} expressions)
     *        .require({String/Array} expressions);
     *
     *     // Include everything except Ext.data.*
     *     Ext.exclude('Ext.data.*').require('*');
     *
     *     // Include all widgets except widget.checkbox*,
     *     // which will match widget.checkbox, widget.checkboxfield, widget.checkboxgroup, etc.
     *     Ext.exclude('widget.checkbox*').require('widget.*');
     *
     * # Synchronous Loading on Demand #
     *
     * - Advantages:
     *     + There's no need to specify dependencies before-hand, which is always the convenience of including ext-all.js
     *  before
     *
     * - Disadvantages:
     *     + Not as good debugging experience since file name won't be shown (except in Firebug at the moment)
     *     + Must be from the same domain due to XHR restriction
     *     + Need a web server, same reason as above
     *
     * There's one simple rule to follow: Instantiate everything with Ext.create instead of the 'new' keyword
     *
     *     Ext.create('widget.window', { ... }); // Instead of new Ext.window.Window({...});
     *
     *     Ext.create('Ext.window.Window', {}); // Same as above, using full class name instead of alias
     *
     *     Ext.widget('window', {}); // Same as above, all you need is the traditional 'xtype'
     *
     * Behind the scene, {@link Ext.ClassManager} will automatically check whether the given class name / alias has already
     *  existed on the page. If it's not, Ext.Loader will immediately switch itself to synchronous mode and automatic load the given
     *  class and all its dependencies.
     *
     * # Hybrid Loading - The Best of Both Worlds #
     *
     * It has all the advantages combined from asynchronous and synchronous loading. The development flow is simple:
     *
     * ### Step 1: Start writing your application using synchronous approach.
     *
     * Ext.Loader will automatically fetch all dependencies on demand as they're needed during run-time. For example:
     *
     *     Ext.onReady(function(){
     *         var window = Ext.widget('window', {
     *             width: 500,
     *             height: 300,
     *             layout: {
     *                 type: 'border',
     *                 padding: 5
     *             },
     *             title: 'Hello Dialog',
     *             items: [{
     *                 title: 'Navigation',
     *                 collapsible: true,
     *                 region: 'west',
     *                 width: 200,
     *                 html: 'Hello',
     *                 split: true
     *             }, {
     *                 title: 'TabPanel',
     *                 region: 'center'
     *             }]
     *         });
     *
     *         window.show();
     *     })
     *
     * ### Step 2: Along the way, when you need better debugging ability, watch the console for warnings like these: ###
     *
     *     [Ext.Loader] Synchronously loading 'Ext.window.Window'; consider adding Ext.require('Ext.window.Window') before your application's code
     *     ClassManager.js:432
     *     [Ext.Loader] Synchronously loading 'Ext.layout.container.Border'; consider adding Ext.require('Ext.layout.container.Border') before your application's code
     *
     * Simply copy and paste the suggested code above 'Ext.onReady', i.e:
     *
     *     Ext.require('Ext.window.Window');
     *     Ext.require('Ext.layout.container.Border');
     *
     *     Ext.onReady(...);
     *
     * Everything should now load via asynchronous mode.
     *
     * # Deployment #
     *
     * It's important to note that dynamic loading should only be used during development on your local machines.
     * During production, all dependencies should be combined into one single JavaScript file. Ext.Loader makes
     * the whole process of transitioning from / to between development / maintenance and production as easy as
     * possible. Internally {@link Ext.Loader#history Ext.Loader.history} maintains the list of all dependencies your application
     * needs in the exact loading sequence. It's as simple as concatenating all files in this array into one,
     * then include it on top of your application.
     *
     * This process will be automated with Sencha Command, to be released and documented towards Ext JS 4 Final.
     */
    export class Loader {
        /**
         * An array of class names to keep track of the dependency loading order.
         * This is not guaranteed to be the same everytime due to the asynchronous
         * nature of the Loader.
         */
        static history: any[];

        /**
         * Appends current timestamp to script files to prevent caching.
         */
        static disableCaching: boolean;

        /**
         * The get parameter name for the cache buster's timestamp.
         */
        static disableCachingParam: string;

        /**
         * Whether or not to enable the dynamic dependency loading feature.
         */
        static enabled: boolean;

        /**
         * True to prepare an asynchronous script tag for garbage collection (effective only
         * if {@link #preserveScripts preserveScripts} is false)
         */
        static garbageCollect: boolean;

        /**
         * The mapping from namespaces to file paths
         *
         *     {
         *         'Ext': '.', // This is set by default, Ext.layout.container.Container will be
         *                     // loaded from ./layout/Container.js
         *
         *         'My': './src/my_own_folder' // My.layout.Container will be loaded from
         *                                     // ./src/my_own_folder/layout/Container.js
         *     }
         *
         * Note that all relative paths are relative to the current HTML document.
         * If not being specified, for example, <code>Other.awesome.Class</code>
         * will simply be loaded from <code>./Other/awesome/Class.js</code>
         */
        static paths: any;

        /**
         * False to remove and optionally {@link #garbageCollect garbage-collect} asynchronously loaded scripts,
         * True to retain script element for browser debugger compatibility and improved load performance.
         */
        static preserveScripts: boolean;

        /**
         * millisecond delay between asynchronous script injection (prevents stack overflow on some user agents)
         * 'false' disables delay but potentially increases stack load.
         */
        static scriptChainDelay: boolean;

        /**
         * Optional charset to specify encoding of dynamic script content.
         */
        static scriptCharset: string;

        /**
         * Sets a batch of path entries
         *
         * @param {Object } paths a set of className: path mappings
         * @return {Ext.Loader} this
         */
        static addClassPathMappings(paths: any): Ext.Loader;

        /**
         * Explicitly exclude files from being loaded. Useful when used in conjunction with a broad include expression.
         * Can be chained with more 'require' and 'exclude' methods, eg:
         *
         *     Ext.exclude('Ext.data.*').require('*');
         *
         *     Ext.exclude('widget.button*').require('widget.*');
         *
         * {@link Ext#exclude} is alias for {@link Ext.Loader#exclude}.
         *
         * @return {Object} object contains 'require' method for chaining
         */
        static exclude(excludes: any[]): any;

        /**
         * Get the config value corresponding to the specified name. If no name is given, will return the config object
         * @param {String} name The config property name
         * @return {Object}
         */
        static getConfig(name: string): any;

        /**
         * Translates a className to a file path by adding the
         * the proper prefix and converting the .'s to /'s. For example:
         *
         *     Ext.Loader.setPath('My', '/path/to/My');
         *
         *     alert(Ext.Loader.getPath('My.awesome.Class')); // alerts '/path/to/My/awesome/Class.js'
         *
         * Note that the deeper namespace levels, if explicitly set, are always resolved first. For example:
         *
         *     Ext.Loader.setPath({
         *         'My': '/path/to/lib',
         *         'My.awesome': '/other/path/for/awesome/stuff',
         *         'My.awesome.more': '/more/awesome/path'
         *     });
         *
         *     alert(Ext.Loader.getPath('My.awesome.Class')); // alerts '/other/path/for/awesome/stuff/Class.js'
         *
         *     alert(Ext.Loader.getPath('My.awesome.more.Class')); // alerts '/more/awesome/path/Class.js'
         *
         *     alert(Ext.Loader.getPath('My.cool.Class')); // alerts '/path/to/lib/cool/Class.js'
         *
         *     alert(Ext.Loader.getPath('Unknown.strange.Stuff')); // alerts 'Unknown/strange/Stuff.js'
         *
         * @return {String} path
         */
        static getPath(className: string): string;

        /**
         * Loads the specified script URL and calls the supplied callbacks. If this method
         * is called before {@link Ext#isReady}, the script's load will delay the transition
         * to ready. This can be used to load arbitrary scripts that may contain further
         * {@link Ext#require Ext.require} calls.
         *
         * @param {Object/String} options The options object or simply the URL to load.
         * @param {String} options.url The URL from which to load the script.
         * @param {Function} [options.onLoad] The callback to call on successful load.
         * @param {Function} [options.onError] The callback to call on failure to load.
         * @param {Object} [options.scope] The scope ('this') for the supplied callbacks.
         */
        static loadScript(options: any|string, options_url: string, options_onLoad?: Function, options_onError?: Function, options_scope?: any);

        /**
         * Add a new listener to be executed when all required scripts are fully loaded
         *
         * @param {Function} fn The function callback to be executed
         * @param {Object} scope The execution scope (<code>this</code>) of the callback function
         * @param {Boolean} withDomReady Whether or not to wait for document dom ready as well
         */
        static onReady(fn: Function, scope: any, withDomReady: boolean);

        /**
         * Loads all classes by the given names and all their direct dependencies; optionally executes
         * the given callback function when finishes, within the optional scope.
         *
         * {@link Ext#require} is alias for {@link Ext.Loader#require}.
         *
         * @param {String/Array} expressions Can either be a string or an array of string
         * @param {Function} fn (Optional) The callback function
         * @param {Object} scope (Optional) The execution scope ('this') of the callback function
         * @param {String/Array} excludes (Optional) Classes to be excluded, useful when being used with expressions
         */
        static require(expressions: string|any[], fn: Function, scope: any, excludes: string|any[]);

        /**
         * Set the configuration for the loader. This should be called right after ext-(debug).js
         * is included in the page, and before Ext.onReady. i.e:
         *
         *     <script type="text/javascript" src="ext-core-debug.js"></script>
         *     <script type="text/javascript">
         *         Ext.Loader.setConfig({
         *           enabled: true,
         *           paths: {
         *               'My': 'my_own_path'
         *           }
         *         });
         *     </script>
         *     <script type="text/javascript">
         *         Ext.require(...);
         *
         *         Ext.onReady(function() {
         *           // application code here
         *         });
         *     </script>
         *
         * Refer to config options of {@link Ext.Loader} for the list of possible properties
         *
         * @param {Object} config The config object to override the default values
         * @return {Ext.Loader} this
         */
        static setConfig(config: any): Ext.Loader;

        /**
         * Sets the path of a namespace.
         * For Example:
         *
         *     Ext.Loader.setPath('Ext', '.');
         *
         * @param {String/Object} name See {@link Ext.Function#flexSetter flexSetter}
         * @param {String} [path] See {@link Ext.Function#flexSetter flexSetter}
         * @return {Ext.Loader} this
         */
        static setPath(name: string|any, path?: string): Ext.Loader;

        /**
         * Synchronously loads all classes by the given names and all their direct dependencies; optionally
         * executes the given callback function when finishes, within the optional scope.
         *
         * {@link Ext#syncRequire} is alias for {@link Ext.Loader#syncRequire}.
         *
         * @param {String/Array} expressions Can either be a string or an array of string
         * @param {Function} fn (Optional) The callback function
         * @param {Object} scope (Optional) The execution scope ('this') of the callback function
         * @param {String/Array} excludes (Optional) Classes to be excluded, useful when being used with expressions
         */
        static syncRequire(expressions: string|any[], fn: Function, scope: any, excludes: string|any[]);
    }

    interface LoadMaskConfig extends Ext.ComponentConfig {
        baseCls?: any;

        /**
         * The CSS class to apply to the mask element
         *
         * Optional, Defaults to: "x-mask"
         */
        maskCls?: string;

        /**
         * The text to display in a centered loading message box.
         *
         * Optional, Defaults to: "Loading..."
         */
        msg?: string;

        /**
         * The CSS class to apply to the loading message element.
         *
         * Optional, Defaults to: "x-mask-loading"
         */
        msgCls?: string;

        /**
         * Optional Store to which the mask is bound. The mask is displayed when a load request is issued, and
         * hidden on either load success, or load fail.
         */
        store?: Ext.data.Store;

        /**
         * The Component you wish to mask. The the mask will be automatically sized
         * upon Component resize, and the message box will be kept centered.
         */
        target?: Ext.Component;

        /**
         * Whether or not to use a loading message class or simply mask the bound element.
         *
         * Optional, Defaults to: true
         */
        useMsg?: boolean;

        /**
         * True to mask the {@link Ext.Component#getTargetEl targetEl} of the bound Component. By default,
         * the {@link Ext.Component#getEl el} will be masked.
         *
         * Optional, Defaults to: false
         */
        useTargetEl?: boolean;
    }

    /**
     * A modal, floating Component which may be shown above a specified {@link Ext.Component Component} while loading data.
     * When shown, the configured owning Component will be covered with a modality mask, and the LoadMask's {@link #msg} will be
     * displayed centered, accompanied by a spinner image.
     *
     * If the {@link #store} config option is specified, the masking will be automatically shown and then hidden synchronized with
     * the Store's loading process.
     *
     * Because this is a floating Component, its z-index will be managed by the global {@link Ext.WindowManager ZIndexManager}
     * object, and upon show, it will place itsef at the top of the hierarchy.
     *
     * Example usage:
     *
     *     // Basic mask:
     *     var myMask = new Ext.LoadMask(myPanel, {msg:"Please wait..."});
     *     myMask.show();
     */
    export class LoadMask extends Ext.Component implements Ext.LoadMaskConfig {
        baseCls: string;

        /**
         * The CSS class to apply to the mask element
         *
         * Optional, Defaults to: "x-mask"
         */
        maskCls: string;

        /**
         * The text to display in a centered loading message box.
         *
         * Optional, Defaults to: "Loading..."
         */
        msg: string;

        /**
         * The CSS class to apply to the loading message element.
         *
         * Optional, Defaults to: "x-mask-loading"
         */
        msgCls: string;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * Optional Store to which the mask is bound. The mask is displayed when a load request is issued, and
         * hidden on either load success, or load fail.
         */
        store: Ext.data.Store;

        /**
         * The Component you wish to mask. The the mask will be automatically sized
         * upon Component resize, and the message box will be kept centered.
         */
        target: Ext.Component;

        /**
         * Whether or not to use a loading message class or simply mask the bound element.
         *
         * Optional, Defaults to: true
         */
        useMsg: boolean;

        /**
         * True to mask the {@link Ext.Component#getTargetEl targetEl} of the bound Component. By default,
         * the {@link Ext.Component#getEl el} will be masked.
         *
         * Optional, Defaults to: false
         */
        useTargetEl: boolean;

        protected afterRender();

        /**
         * Changes the data store bound to this LoadMask.
         * @param {Ext.data.Store} store The store to bind to this LoadMask
         */
        bindStore(store: Ext.data.Store);

        /**
         * Creates new LoadMask.
         * @param {Object} [config] The config object.
         */
        constructor(config?: Ext.LoadMaskConfig);

        protected getStoreListeners(store: any);

        protected onDestroy();

        protected onDisable();
    }

    /**
     * @alternateClassName Ext.Msg
     * @extends Ext.window.MessageBox
     * Singleton instance of {@link Ext.window.MessageBox}.
     */
    export class MessageBox {
        constructor(cfg: any);
    }

    /**
     * @author Ed Spencer
     The ModelManager keeps track of all {@link Ext.data.Model} types defined in your application.
     __Creating Model Instances__
     Model instances can be created by using the {@link Ext#create Ext.create} method. Ext.create replaces
     the deprecated {@link #create Ext.ModelManager.create} method. It is also possible to create a model instance
     this by using the Model type directly. The following 3 snippets are equivalent:
     Ext.define('User', {
     extend: 'Ext.data.Model',
     fields: ['first', 'last']
     });
     // method 1, create using Ext.create (recommended)
     Ext.create('User', {
     first: 'Ed',
     last: 'Spencer'
     });
     // method 2, create through the manager (deprecated)
     Ext.ModelManager.create({
     first: 'Ed',
     last: 'Spencer'
     }, 'User');
     // method 3, create on the type directly
     new User({
     first: 'Ed',
     last: 'Spencer'
     });
     __Accessing Model Types__
     A reference to a Model type can be obtained by using the {@link #getModel} function. Since models types
     are normal classes, you can access the type directly. The following snippets are equivalent:
     Ext.define('User', {
     extend: 'Ext.data.Model',
     fields: ['first', 'last']
     });
     // method 1, access model type through the manager
     var UserType = Ext.ModelManager.getModel('User');
     // method 2, reference the type directly
     var UserType = User;
     * @markdown
     */
    export class ModelManager {
        constructor(config: any);

        /**
         * Private stack of associations that must be created once their associated model has been defined
         */
        static associationStack: Ext.data.association.Association;

        /**
         * Returns the {@link Ext.data.Model} class for a given model name
         * @param {String/Object} id The classname of the model or the model class itself.
         * @return {Ext.data.Model} a model class.
         */
        static getModel(id: string|any): Ext.data.Model;
    }

    /**
     * A collection of useful static methods to deal with numbers
     */
    export class Number {
        /**
         * Checks whether or not the passed number is within a desired range.  If the number is already within the
         * range it is returned, otherwise the min or max value is returned depending on which side of the range is
         * exceeded. Note that this method returns the constrained value but does not change the current number.
         * @param {Number} number The number to check
         * @param {Number} min The minimum number in the range
         * @param {Number} max The maximum number in the range
         * @return {Number} The constrained value if outside the range, otherwise the current value
         */
        static constrain(number: number, min: number, max: number): number;

        /**
         * Corrects floating point numbers that overflow to a non-precise
         * value because of their floating nature, for example '0.1 + 0.2'
         * @param {Number} The number
         * @return {Number} The correctly rounded number
         */
        static correctFloat(The: number): number;

        /**
         * Validate that a value is numeric and convert it to a number if necessary. Returns the specified default value if
         * it is not.
         Ext.Number.from('1.23', 1); // returns 1.23
         Ext.Number.from('abc', 1); // returns 1
         * @param {Number} defaultValue The value to return if the original value is non-numeric
         * @return {Number} value, if numeric, defaultValue otherwise
         */
        static from(value: any, defaultValue: number): number;

        /**
         * Returns a random integer between the specified range (inclusive)
         * @param {Number} from Lowest value to return.
         * @param {Number} to Highst value to return.
         * @return {Number} A random integer within the specified range.
         */
        static randomInt(from: number, to: number): number;

        /**
         * Snaps the passed number between stopping points based upon a passed increment value.
         *
         * The difference between this and {@link #snapInRange} is that {@link #snapInRange} uses the minValue
         * when calculating snap points:
         *
         *     r = Ext.Number.snap(56, 2, 55, 65);        // Returns 56 - snap points are zero based
         *
         *     r = Ext.Number.snapInRange(56, 2, 55, 65); // Returns 57 - snap points are based from minValue
         *
         * @param {Number} value The unsnapped value.
         * @param {Number} increment The increment by which the value must move.
         * @param {Number} minValue The minimum value to which the returned value must be constrained. Overrides the increment.
         * @param {Number} maxValue The maximum value to which the returned value must be constrained. Overrides the increment.
         * @return {Number} The value of the nearest snap target.
         */
        static snap(value: number, increment: number, minValue: number, maxValue: number): number;

        /**
         * Snaps the passed number between stopping points based upon a passed increment value.
         *
         * The difference between this and {@link #snap} is that {@link #snap} does not use the minValue
         * when calculating snap points:
         *
         *     r = Ext.Number.snap(56, 2, 55, 65);        // Returns 56 - snap points are zero based
         *
         *     r = Ext.Number.snapInRange(56, 2, 55, 65); // Returns 57 - snap points are based from minValue
         *
         * @param {Number} value The unsnapped value.
         * @param {Number} increment The increment by which the value must move.
         * @param {Number} [minValue=0] The minimum value to which the returned value must be constrained.
         * @param {Number} [maxValue=Infinity] The maximum value to which the returned value must be constrained.
         * @return {Number} The value of the nearest snap target.
         */
        static snapInRange(value: number, increment: number, minValue?: number, maxValue?: number): number;

        /**
         * Formats a number using fixed-point notation
         * @param {Number} value The number to format
         * @param {Number} precision The number of digits to show after the decimal point
         */
        static toFixed(value: number, precision: number);
    }

    /**
     * A collection of useful static methods to deal with objects.
     */
    export class Object {
        /**
         * Returns a new object with the given object as the prototype chain. This method is
         * designed to mimic the ECMA standard 'Object.create' method and is assigned to that
         * function when it is available.
         *
         * **NOTE** This method does not support the property definitions capability of the
         * 'Object.create' method. Only the first argument is supported.
         *
         * @param {Object} object The prototype chain for the new object.
         */
        static chain(object: any);

        /**
         * Iterates through an object and invokes the given callback function for each iteration.
         * The iteration can be stopped by returning 'false' in the callback function. For example:
         *
         *     var person = {
         *         name: 'Jacky'
         *         hairColor: 'black'
         *         loves: ['food', 'sleeping', 'wife']
         *     };
         *
         *     Ext.Object.each(person, function(key, value, myself) {
         *         console.log(key + ":" + value);
         *
         *         if (key === 'hairColor') {
         *             return false; // stop the iteration
         *         }
         *     });
         *
         * @param {Object} object The object to iterate
         * @param {Function} fn The callback function.
         * @param {Object} fn.object The object itself
         * @param {Object} [scope] The execution scope ('this') of the callback function
         */
        static each(object: any, fn: Function, fn_key: string, fn_value: any, fn_object: any, scope?: any);

        /**
         * Shallow compares the contents of 2 objects using strict equality. Objects are
         * considered equal if they both have the same set of properties and the
         * value for those properties equals the other in the corresponding object.
         *
         *     // Returns true
         *     Ext.Object.equals({
         *         foo: 1,
         *         bar: 2
         *     }, {
         *         foo: 1,
         *         bar: 2
         *     });
         *
         * @return {Boolean} 'true' if the objects are equal.
         */
        static equals(object1: any, object2: any): boolean;

        /**
         * Converts a query string back into an object.
         *
         * Non-recursive:
         *
         *     Ext.Object.fromQueryString("foo=1&bar=2"); // returns {foo: '1', bar: '2'}
         *     Ext.Object.fromQueryString("foo=&bar=2"); // returns {foo: null, bar: '2'}
         *     Ext.Object.fromQueryString("some%20price=%24300"); // returns {'some price': '$300'}
         *     Ext.Object.fromQueryString("colors=red&colors=green&colors=blue"); // returns {colors: ['red', 'green', 'blue']}
         *
         * Recursive:
         *
         *     Ext.Object.fromQueryString(
         *         "username=Jacky&"+
         *         "dateOfBirth[day]=1&dateOfBirth[month]=2&dateOfBirth[year]=1911&"+
         *         "hobbies[0]=coding&hobbies[1]=eating&hobbies[2]=sleeping&"+
         *         "hobbies[3][0]=nested&hobbies[3][1]=stuff", true);
         *
         *     // returns
         *     {
         *         username: 'Jacky',
         *         dateOfBirth: {
         *             day: '1',
         *             month: '2',
         *             year: '1911'
         *         },
         *         hobbies: ['coding', 'eating', 'sleeping', ['nested', 'stuff']]
         *     }
         *
         * @param {String} queryString The query string to decode
         * @param {Boolean} [recursive=false] Whether or not to recursively decode the string. This format is supported by
         * PHP / Ruby on Rails servers and similar.
         * @return {Object}
         */
        static fromQueryString(queryString: string, recursive?: boolean): any;

        /**
         * Returns the first matching key corresponding to the given value.
         * If no matching value is found, null is returned.
         *
         *     var person = {
         *         name: 'Jacky',
         *         loves: 'food'
         *     };
         *
         *     alert(Ext.Object.getKey(person, 'food')); // alerts 'loves'
         *
         * @param {Object} value The value to find
         */
        static getKey(object: any, value: any);

        /**
         * Gets all keys of the given object as an array.
         *
         *     var values = Ext.Object.getKeys({
         *         name: 'Jacky',
         *         loves: 'food'
         *     }); // ['name', 'loves']
         *
         * @return {String[]} An array of keys from the object
         */
        static getKeys(object: any): string;

        /**
         * Gets the total number of this object's own properties
         *
         *     var size = Ext.Object.getSize({
         *         name: 'Jacky',
         *         loves: 'food'
         *     }); // size equals 2
         *
         * @return {Number} size
         */
        static getSize(object: any): number;

        /**
         * Gets all values of the given object as an array.
         *
         *     var values = Ext.Object.getValues({
         *         name: 'Jacky',
         *         loves: 'food'
         *     }); // ['Jacky', 'food']
         *
         * @return {Array} An array of values from the object
         */
        static getValues(object: any): any[];

        /**
         * Checks if there are any properties on this object.
         * @return {Boolean} 'true' if there no properties on the object.
         */
        static isEmpty(object: any): boolean;

        /**
         * Merges any number of objects recursively without referencing them or their children.
         *
         *     var extjs = {
         *         companyName: 'Ext JS',
         *         products: ['Ext JS', 'Ext GWT', 'Ext Designer'],
         *         isSuperCool: true,
         *         office: {
         *             size: 2000,
         *             location: 'Palo Alto',
         *             isFun: true
         *         }
         *     };
         *
         *     var newStuff = {
         *         companyName: 'Sencha Inc.',
         *         products: ['Ext JS', 'Ext GWT', 'Ext Designer', 'Sencha Touch', 'Sencha Animator'],
         *         office: {
         *             size: 40000,
         *             location: 'Redwood City'
         *         }
         *     };
         *
         *     var sencha = Ext.Object.merge(extjs, newStuff);
         *
         *     // extjs and sencha then equals to
         *     {
         *         companyName: 'Sencha Inc.',
         *         products: ['Ext JS', 'Ext GWT', 'Ext Designer', 'Sencha Touch', 'Sencha Animator'],
         *         isSuperCool: true,
         *         office: {
         *             size: 40000,
         *             location: 'Redwood City',
         *             isFun: true
         *         }
         *     }
         *
         * @param {Object} destination The object into which all subsequent objects are merged.
         * @param {Object...} object Any number of objects to merge into the destination.
         * @return {Object} merged The destination object with all passed objects merged in.
         */
        static merge(destination: any, object: any): any;

        /**
         * Converts a 'name' - 'value' pair to an array of objects with support for nested structures. Useful to construct
         * query strings. For example:
         *
         *     var objects = Ext.Object.toQueryObjects('hobbies', ['reading', 'cooking', 'swimming']);
         *
         *     // objects then equals:
         *     [
         *         { name: 'hobbies', value: 'reading' },
         *         { name: 'hobbies', value: 'cooking' },
         *         { name: 'hobbies', value: 'swimming' },
         *     ];
         *
         *     var objects = Ext.Object.toQueryObjects('dateOfBirth', {
         *         day: 3,
         *         month: 8,
         *         year: 1987,
         *         extra: {
         *             hour: 4
         *             minute: 30
         *         }
         *     }, true); // Recursive
         *
         *     // objects then equals:
         *     [
         *         { name: 'dateOfBirth[day]', value: 3 },
         *         { name: 'dateOfBirth[month]', value: 8 },
         *         { name: 'dateOfBirth[year]', value: 1987 },
         *         { name: 'dateOfBirth[extra][hour]', value: 4 },
         *         { name: 'dateOfBirth[extra][minute]', value: 30 },
         *     ];
         *
         * @param {Boolean} [recursive=false] True to traverse object recursively
         * @return {Array}
         */
        static toQueryObjects(name: string, value: any|any[], recursive?: boolean): any[];

        /**
         * Takes an object and converts it to an encoded query string.
         *
         * Non-recursive:
         *
         *     Ext.Object.toQueryString({foo: 1, bar: 2}); // returns "foo=1&bar=2"
         *     Ext.Object.toQueryString({foo: null, bar: 2}); // returns "foo=&bar=2"
         *     Ext.Object.toQueryString({'some price': '$300'}); // returns "some%20price=%24300"
         *     Ext.Object.toQueryString({date: new Date(2011, 0, 1)}); // returns "date=%222011-01-01T00%3A00%3A00%22"
         *     Ext.Object.toQueryString({colors: ['red', 'green', 'blue']}); // returns "colors=red&colors=green&colors=blue"
         *
         * Recursive:
         *
         *     Ext.Object.toQueryString({
         *         username: 'Jacky',
         *         dateOfBirth: {
         *             day: 1,
         *             month: 2,
         *             year: 1911
         *         },
         *         hobbies: ['coding', 'eating', 'sleeping', ['nested', 'stuff']]
         *     }, true); // returns the following string (broken down and url-decoded for ease of reading purpose):
         *     // username=Jacky
         *     //    &dateOfBirth[day]=1&dateOfBirth[month]=2&dateOfBirth[year]=1911
         *     //    &hobbies[0]=coding&hobbies[1]=eating&hobbies[2]=sleeping&hobbies[3][0]=nested&hobbies[3][1]=stuff
         *
         * @param {Object} object The object to encode
         * @param {Boolean} [recursive=false] Whether or not to interpret the object in recursive format.
         * (PHP / Ruby on Rails servers and similar).
         * @return {String} queryString
         */
        static toQueryString(object: any, recursive?: boolean): string;
    }

    /**
     * Provides a registry of available Plugin classes indexed by a mnemonic code known as the Plugin's ptype.
     *
     * A plugin may be specified simply as a *config object* as long as the correct 'ptype' is specified:
     *
     *     {
     *         ptype: 'gridviewdragdrop',
     *         dragText: 'Drag and drop to reorganize'
     *     }
     *
     * Or just use the ptype on its own:
     *
     *     'gridviewdragdrop'
     *
     * Alternatively you can instantiate the plugin with Ext.create:
     *
     *     Ext.create('Ext.grid.plugin.DragDrop', {
     *         dragText: 'Drag and drop to reorganize'
     *     })
     */
    export class PluginManager {
        constructor(config: any);

        /**
         * Returns all plugins registered with the given type. Here, 'type' refers to the type of plugin, not its ptype.
         * @param {String} type The type to search for
         * @param {Boolean} defaultsOnly True to only return plugins of this type where the plugin's isDefault property is
         * truthy
         * @return {Ext.AbstractPlugin[]} All matching plugins
         */
        static findByType(type: string, defaultsOnly: boolean): Ext.AbstractPlugin;
    }

    interface ProgressBarConfig extends Ext.ComponentConfig {
        /**
         * The base CSS class to apply to the progress bar's wrapper element.
         *
         * Optional, Defaults to: 'x-progress'
         */
        baseCls?: string;

        componentLayout?: any;

        /**
         * The progress bar element's id (defaults to an auto-generated id)
         */
        id?: string;

        /**
         * The text shown in the progress bar.
         */
        text?: string;

        /**
         * The element to render the progress text to (defaults to the progress bar's internal text element)
         */
        textEl?: string|HTMLElement|Ext.dom.Element;

        /**
         * A floating point value between 0 and 1 (e.g., .5)
         *
         * Optional, Defaults to: 0
         */
        value?: number;
    }

    /**
     * An updateable progress bar component. The progress bar supports two different modes: manual and automatic.
     *
     * In manual mode, you are responsible for showing, updating (via {@link #updateProgress}) and clearing the progress bar
     * as needed from your own code. This method is most appropriate when you want to show progress throughout an operation
     * that has predictable points of interest at which you can update the control.
     *
     * In automatic mode, you simply call {@link #wait} and let the progress bar run indefinitely, only clearing it once the
     * operation is complete. You can optionally have the progress bar wait for a specific amount of time and then clear
     * itself. Automatic mode is most appropriate for timed operations or asynchronous operations in which you have no need
     * for indicating intermediate progress.
     *
     *     @example
     *     var p = Ext.create('Ext.ProgressBar', {
     *        renderTo: Ext.getBody(),
     *        width: 300
     *     });
     *
     *     // Wait for 5 seconds, then update the status el (progress bar will auto-reset)
     *     p.wait({
     *         interval: 500, //bar will move fast!
     *         duration: 50000,
     *         increment: 15,
     *         text: 'Updating...',
     *         scope: this,
     *         fn: function(){
     *             p.updateText('Done!');
     *         }
     *     });
     */
    export class ProgressBar extends Ext.Component implements Ext.ProgressBarConfig {
        /**
         * The base CSS class to apply to the progress bar's wrapper element.
         *
         * Optional, Defaults to: 'x-progress'
         */
        baseCls: string;

        componentLayout: string|any;

        /**
         * The progress bar element's id (defaults to an auto-generated id)
         */
        id: string;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The text shown in the progress bar.
         */
        text: string;

        /**
         * The element to render the progress text to (defaults to the progress bar's internal text element)
         */
        textEl: string|HTMLElement|Ext.dom.Element;

        /**
         * A floating point value between 0 and 1 (e.g., .5)
         *
         * Optional, Defaults to: 0
         */
        value: number;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected initComponent();

        protected initRenderData();

        /**
         * Returns true if the progress bar is currently in a {@link #wait} operation
         * @return {Boolean} True if waiting, else false
         */
        isWaiting(): boolean;

        protected onDestroy();

        protected onRender();

        /**
         * Resets the progress bar value to 0 and text to empty string. If hide = true, the progress bar will also be hidden
         * (using the {@link #hideMode} property internally).
         * @param {Boolean} [hide=false] True to hide the progress bar.
         * @return {Ext.ProgressBar} this
         */
        reset(hide?: boolean): Ext.ProgressBar;

        /**
         * Updates the progress bar value, and optionally its text. If the text argument is not specified, any existing text
         * value will be unchanged. To blank out existing text, pass ''. Note that even if the progress bar value exceeds 1,
         * it will never automatically reset -- you are responsible for determining when the progress is complete and
         * calling {@link #reset} to clear and/or hide the control.
         * @param {Number} [value=0] A floating point value between 0 and 1 (e.g., .5)
         * @param {String} [text=''] The string to display in the progress text element
         * @param {Boolean} [animate=false] Whether to animate the transition of the progress bar. If this value is not
         * specified, the default for the class is used
         * @return {Ext.ProgressBar} this
         */
        updateProgress(value?: number, text?: string, animate?: boolean): Ext.ProgressBar;

        /**
         * Updates the progress bar text. If specified, textEl will be updated, otherwise the progress bar itself will
         * display the updated text.
         * @param {String} [text=''] The string to display in the progress text element
         * @return {Ext.ProgressBar} this
         */
        updateText(text?: string): Ext.ProgressBar;

        /**
         * Initiates an auto-updating progress bar. A duration can be specified, in which case the progress bar will
         * automatically reset after a fixed amount of time and optionally call a callback function if specified. If no
         * duration is passed in, then the progress bar will run indefinitely and must be manually cleared by calling
         * {@link #reset}.
         *
         * Example usage:
         *
         *     var p = new Ext.ProgressBar({
         *        renderTo: 'my-el'
         *     });
         *
         *     //Wait for 5 seconds, then update the status el (progress bar will auto-reset)
         *     var p = Ext.create('Ext.ProgressBar', {
         *        renderTo: Ext.getBody(),
         *        width: 300
         *     });
         *
         *     //Wait for 5 seconds, then update the status el (progress bar will auto-reset)
         *     p.wait({
         *        interval: 500, //bar will move fast!
         *        duration: 50000,
         *        increment: 15,
         *        text: 'Updating...',
         *        scope: this,
         *        fn: function(){
         *           p.updateText('Done!');
         *        }
         *     });
         *
         *     //Or update indefinitely until some async action completes, then reset manually
         *     p.wait();
         *     myAction.on('complete', function(){
         *         p.reset();
         *         p.updateText('Done!');
         *     });
         *
         * @param {Object} config (optional) Configuration options
         * @param {Number} config.duration The length of time in milliseconds that the progress bar should
         * run before resetting itself (defaults to undefined, in which case it will run indefinitely
         * until reset is called)
         * @param {Number} config.interval The length of time in milliseconds between each progress update
         * (defaults to 1000 ms)
         * @param {Boolean} config.animate Whether to animate the transition of the progress bar. If this
         * value is not specified, the default for the class is used.
         * @param {Number} config.increment The number of progress update segments to display within the
         * progress bar (defaults to 10).  If the bar reaches the end and is still updating, it will
         * automatically wrap back to the beginning.
         * @param {String} config.text Optional text to display in the progress bar element (defaults to '').
         * @param {Function} config.fn A callback function to execute after the progress bar finishes auto-
         * updating.  The function will be called with no arguments.  This function will be ignored if
         * duration is not specified since in that case the progress bar can only be stopped programmatically,
         * so any required function should be called by the same code after it resets the progress bar.
         * @param {Object} config.scope The scope that is passed to the callback function (only applies when
         * duration and fn are both passed).
         * @return {Ext.ProgressBar} this
         */
        wait(config: Ext.ProgressBarConfig, config_duration: number, config_interval: number, config_animate: boolean, config_increment: number, config_text: string, config_fn: Function, config_scope: any): Ext.ProgressBar;
    }

    /**
     * A mixin for providing query related methods for {@link Ext.ComponentQuery} for components that
     * implement getRefItems.
     */
    export class Queryable extends Ext.Base {
        /**
         * Retrieves the first direct child of this container which matches the passed selector or component.
         * The passed in selector must comply with an Ext.ComponentQuery selector, or it can be an actual Ext.Component.
         * @param {String/Ext.Component} [selector] An Ext.ComponentQuery selector. If no selector is
         * specified, the first child will be returned.
         * @return Ext.Component The matching child Ext.Component (or 'null' if no match was found).
         */
        child(selector?: string|Ext.Component);

        /**
         * Retrieves the first descendant of this container which matches the passed selector.
         * The passed in selector must comply with an Ext.ComponentQuery selector, or it can be an actual Ext.Component.
         * @param {String/Ext.Component} [selector] An Ext.ComponentQuery selector or Ext.Component. If no selector is
         * specified, the first child will be returned.
         * @return Ext.Component The matching descendant Ext.Component (or 'null' if no match was found).
         */
        down(selector?: string|Ext.Component);

        /**
         * Retrieves all descendant components which match the passed selector.
         * Executes an Ext.ComponentQuery.query using this container as its root.
         * @param {String} [selector] Selector complying to an Ext.ComponentQuery selector.
         * If no selector is specified all items will be returned.
         * @return {Ext.Component[]} Components which matched the selector
         */
        query(selector?: string): Ext.Component;

        /**
         * Retrieves all descendant components which match the passed function.
         * The function should return false for components that are to be
         * excluded from the selection.
         * @param {Function} fn The matcher function. It will be called with a single argument,
         * the component being tested.
         * @param {Object} [scope] The scope in which to run the function. If not specified,
         * it will default to the active component.
         * @return {Ext.Component[]} Components matched by the passed function
         */
        queryBy(fn: Function, scope?: any): Ext.Component;

        /**
         * Finds a component at any level under this container matching the id/itemId.
         * This is a shorthand for calling ct.down('#' + id);
         * @param {String} id The id to find
         * @return {Ext.Component} The matching id, null if not found
         */
        queryById(id: string): Ext.Component;
    }

    interface ShadowConfig {
        /**
         * The shadow display mode.  Supports the following options:
         *
         * - sides : Shadow displays on both sides and bottom only
         * - frame : Shadow displays equally on all four sides
         * - drop : Traditional bottom-right drop shadow
         */
        mode?: string;

        /**
         * The number of pixels to offset the shadow from the element
         */
        offset?: number;
    }

    /**
     * Simple class that can provide a shadow effect for any element.  Note that the element
     * MUST be absolutely positioned, and the shadow does not provide any shimming.  This
     * should be used only in simple cases - for more advanced functionality that can also
     * provide the same shadow effect, see the {@link Ext.Layer} class.
     */
    export class Shadow extends Ext.Base implements Ext.ShadowConfig {
        /**
         * The shadow display mode.  Supports the following options:
         *
         * - sides : Shadow displays on both sides and bottom only
         * - frame : Shadow displays equally on all four sides
         * - drop : Traditional bottom-right drop shadow
         */
        mode: string;

        /**
         * The number of pixels to offset the shadow from the element
         */
        offset: number;

        /**
         * Creates new Shadow.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.ShadowConfig);

        /**
         * Hides this shadow
         */
        hide();

        /**
         * Returns true if the shadow is visible, else false
         */
        isVisible();

        /**
         * Direct alignment when values are already available. Show must be called at least once before
         * calling this method to ensure it is initialized.
         * @param {Number} left The target element left position
         * @param {Number} top The target element top position
         * @param {Number} width The target element width
         * @param {Number} height The target element height
         */
        realign(left: number, top: number, width: number, height: number);

        /**
         * Sets the opacity of the shadow
         * @param {Number} opacity The opacity
         */
        setOpacity(opacity: number);

        /**
         * Adjust the z-index of this shadow
         * @param {Number} zindex The new z-index
         */
        setZIndex(zindex: number);

        /**
         * Displays the shadow under the target element
         * @param {String/HTMLElement/Ext.Element} targetEl The id or element under which the shadow should display
         */
        show(targetEl: string|HTMLElement|Ext.dom.Element);
    }

    /**
     * Private utility class that manages the internal Shadow cache.
     */
    export class ShadowPool {
    }

    /**
     * A collection of useful static methods to deal with strings.
     */
    export class String {
        /**
         * Adds a set of character entity definitions to the set used by
         * {@link Ext.String#htmlEncode} and {@link Ext.String#htmlDecode}.
         *
         * This object should be keyed by the entity name sequence,
         * with the value being the textual representation of the entity.
         *
         *      Ext.String.addCharacterEntities({
         *          '&amp;Uuml;':'',
         *          '&amp;ccedil;':'',
         *          '&amp;ntilde;':'',
         *          '&amp;egrave;':''
         *      });
         *      var s = Ext.String.htmlEncode("A string with entities: ");
         *
         * __Note:__ the values of the character entities defined on this object are expected
         * to be single character values.  As such, the actual values represented by the
         * characters are sensitive to the character encoding of the JavaScript source
         * file when defined in string literal form. Script tags referencing server
         * resources with character entities must ensure that the 'charset' attribute
         * of the script node is consistent with the actual character encoding of the
         * server resource.
         *
         * The set of character entities may be reset back to the default state by using
         * the {@link Ext.String#resetCharacterEntities} method
         *
         * @param {Object} entities The set of character entities to add to the current
         * definitions.
         */
        static addCharacterEntities(entities: any);

        /**
         * Capitalize the given string
         * @return {String}
         */
        static capitalize(string: string): string;

        /**
         * Converts a string of characters into a legal, parse-able JavaScript 'var' name as long as the passed
         * string contains at least one alphabetic character. Non alphanumeric characters, and *leading* non alphabetic
         * characters will be removed.
         * @param {String} s A string to be converted into a 'var' name.
         * @return {String} A legal JavaScript 'var' name.
         */
        static createVarName(s: string): string;

        /**
         * Truncate a string and add an ellipsis ('...') to the end if it exceeds the specified length.
         * @param {String} value The string to truncate.
         * @param {Number} length The maximum length to allow before truncating.
         * @param {Boolean} [word=false] 'true' to try to find a common word break.
         * @return {String} The converted text.
         */
        static ellipsis(value: string, length: number, word?: boolean): string;

        /**
         * Checks if a string ends with a substring
         * @param {String} s The original string
         * @param {String} start The substring to check
         * @param {Boolean} [ignoreCase=false] True to ignore the case in the comparison
         */
        static endsWith(s: string, start: string, ignoreCase?: boolean);

        /**
         * Escapes the passed string for ' and \
         * @param {String} string The string to escape
         * @return {String} The escaped string
         */
        static escape(string: string): string;

        /**
         * Escapes the passed string for use in a regular expression.
         * @return {String}
         */
        static escapeRegex(string: string): string;

        /**
         * Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each
         * token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:
         *
         *     var cls = 'my-class',
         *         text = 'Some text';
         *     var s = Ext.String.format('<div class="{0}">{1}</div>', cls, text);
         *     // s now contains the string: '<div class="my-class">Some text</div>'
         *
         * @param {String} string The tokenized string to be formatted.
         * @param {Mixed...} values The values to replace tokens '{0}', '{1}', etc in order.
         * @return {String} The formatted string.
         */
        static format(string: string, values: any): string;

        /**
         * Convert certain characters (&, <, >, ', and ") from their HTML character equivalents.
         * @param {String} value The string to decode.
         * @return {String} The decoded text.
         */
        static htmlDecode(value: string): string;

        /**
         * Convert certain characters (&, <, >, ', and ") to their HTML character equivalents for literal display in web pages.
         * @param {String} value The string to encode.
         * @return {String} The encoded text.
         */
        static htmlEncode(value: string): string;

        /**
         * Inserts a substring into a string.
         * @param {String} s The original string.
         * @param {String} value The substring to insert.
         * @param {Number} index The index to insert the substring. Negative indexes will insert from the end of
         * the string. Example:
         *
         *     Ext.String.insert("abcdefg", "h", -1); // abcdefhg
         *
         * @return {String} The value with the inserted substring
         */
        static insert(s: string, value: string, index: number): string;

        /**
         * Pads the left side of a string with a specified character.  This is especially useful
         * for normalizing number and date strings.  Example usage:
         *
         *     var s = Ext.String.leftPad('123', 5, '0');
         *     // s now contains the string: '00123'
         *
         * @param {String} string The original string.
         * @param {Number} size The total length of the output string.
         * @param {String} [character=' '] (optional) The character with which to pad the original string.
         * @return {String} The padded string.
         */
        static leftPad(string: string, size: number, character?: string): string;

        /**
         * Returns a string with a specified number of repetitions a given string pattern.
         * The pattern be separated by a different string.
         *
         *      var s = Ext.String.repeat('---', 4); // = '------------'
         *      var t = Ext.String.repeat('--', 3, '/'); // = '--/--/--'
         *
         * @param {String} pattern The pattern to repeat.
         * @param {Number} count The number of times to repeat the pattern (may be 0).
         * @param {String} sep An option string to separate each pattern.
         */
        static repeat(pattern: string, count: number, sep: string);

        /**
         * Resets the set of character entity definitions used by
         * {@link Ext.String#htmlEncode} and {@link Ext.String#htmlDecode} back to the
         * default state.
         */
        static resetCharacterEntities();

        /**
         * Splits a string of space separated words into an array, trimming as needed. If the
         * words are already an array, it is returned.
         */
        static splitWords(words: string|any[]);

        /**
         * Checks if a string starts with a substring
         * @param {String} s The original string
         * @param {String} start The substring to check
         * @param {Boolean} [ignoreCase=false] True to ignore the case in the comparison
         */
        static startsWith(s: string, start: string, ignoreCase?: boolean);

        /**
         * Utility function that allows you to easily switch a string between two alternating values.  The passed value
         * is compared to the current string, and if they are equal, the other value that was passed in is returned.  If
         * they are already different, the first value passed in is returned.  Note that this method returns the new value
         * but does not change the current string.
         *
         *     // alternate sort directions
         *     sort = Ext.String.toggle(sort, 'ASC', 'DESC');
         *
         *     // instead of conditional logic:
         *     sort = (sort === 'ASC' ? 'DESC' : 'ASC');
         *
         * @param {String} string The current string.
         * @param {String} value The value to compare to the current string.
         * @param {String} other The new value to use if the string already equals the first value passed in.
         * @return {String} The new value.
         */
        static toggle(string: string, value: string, other: string): string;

        /**
         * Trims whitespace from either end of a string, leaving spaces within the string intact.  Example:
         *
         *     var s = '  foo bar  ';
         *     alert('-' + s + '-');                   //alerts "- foo bar -"
         *     alert('-' + Ext.String.trim(s) + '-');  //alerts "-foo bar-"
         *
         * @param {String} string The string to trim.
         * @return {String} The trimmed string.
         */
        static trim(string: string): string;

        /**
         * Uncapitalize the given string.
         * @return {String}
         */
        static uncapitalize(string: string): string;

        /**
         * Appends content to the query string of a URL, handling logic for whether to place
         * a question mark or ampersand.
         * @param {String} url The URL to append to.
         * @param {String} string The content to append to the URL.
         * @return {String} The resulting URL
         */
        static urlAppend(url: string, string: string): string;
    }

    /**
     * Determines information about features are supported in the current environment
     */
    export class supports {
        /**
         * if the Array sort native method isn't bugged.
         */
        static ArraySort: boolean;

        /**
         * if the device supports the HTML5 audio tag
         */
        static AudioTag: boolean;

        /**
         * if the browser supports the getBoundingClientRect method on elements
         */
        static BoundingClientRect: boolean;

        /**
         * if the device supports Canvas
         */
        static Canvas: boolean;

        /**
         * if document environment supports the HTML5 classList API.
         */
        static ClassList: boolean;

        /**
         * if the browser supports document.defaultView.getComputedStyle()
         */
        static ComputedStyle: boolean;

        /**
         * if browser support CreateContextualFragment range native methods.
         */
        static CreateContextualFragment: boolean;

        /**
         * if the device supports CSS3 border radius
         */
        static CSS3BorderRadius: boolean;

        /**
         * if document environment supports the CSS3 box-shadow style.
         */
        static CSS3BoxShadow: boolean;

        /**
         * if the device supports CSS3DTransform
         */
        static CSS3DTransform: boolean;

        /**
         * if the device supports CSS3 linear gradients
         */
        static CSS3LinearGradient: boolean;

        /**
         * if the device supports device motion (acceleration and rotation rate)
         */
        static DeviceMotion: boolean;

        /**
         * if when asking for an element's dimension via offsetWidth or offsetHeight,
         * getBoundingClientRect, etc. the browser returns the subpixel width rounded to the nearest pixel.
         */
        static Direct2DBug: boolean;

        /**
         * if INPUT elements lose their
         * selection when their display style is changed. Essentially, if a text input
         * has focus and its display style is changed, the I-beam disappears.
         *
         * This bug is encountered due to the work around in place for the {@link #RightMargin}
         * bug. This has been observed in Safari 4.0.4 and older, and appears to be fixed
         * in Safari 5. It's not clear if Safari 4.1 has the bug, but it has the same WebKit
         * version number as Safari 5 (according to http://unixpapa.com/js/gecko.html).
         */
        static DisplayChangeInputSelectionBug: any;

        /**
         * if TEXTAREA elements lose their
         * selection when their display style is changed. Essentially, if a text area has
         * focus and its display style is changed, the I-beam disappears.
         *
         * This bug is encountered due to the work around in place for the {@link #RightMargin}
         * bug. This has been observed in Chrome 10 and Safari 5 and older, and appears to
         * be fixed in Chrome 11.
         */
        static DisplayChangeTextAreaSelectionBug: any;

        /**
         * if the device supports CSS float
         */
        static Float: boolean;

        /**
         * if the device supports GeoLocation
         */
        static GeoLocation: boolean;

        /**
         * if the browser will return the left/top/right/bottom
         * position as a percentage when explicitly set as a percentage value.
         */
        static GetPositionPercentage: boolean;

        /**
         * if the device supports HTML5 history
         */
        static History: boolean;

        /**
         * if localStorage is supported
         */
        static LocalStorage: any;

        /**
         * if the browser supports mouseenter and mouseleave events
         */
        static MouseEnterLeave: boolean;

        /**
         * if the browser supports the mousewheel event
         */
        static MouseWheel: boolean;

        /**
         * if the browser supports normal css opacity
         */
        static Opacity: boolean;

        /**
         * if the device supports orientation change
         */
        static OrientationChange: boolean;

        /**
         * if the browser supports the HTML5 placeholder attribute on inputs
         */
        static Placeholder: boolean;

        /**
         * if document environment supports the CSS3 pointer-events style.
         */
        static PointerEvents: boolean;

        /**
         * if browser support document.createRange native method.
         */
        static Range: boolean;

        /**
         * if the device supports right margin.
         * See https://bugs.webkit.org/show_bug.cgi?id=13343 for why this is needed.
         */
        static RightMargin: boolean;

        /**
         * if the BoundingClientRect is
         * rotated when the element is rotated using a CSS transform.
         */
        static RotatedBoundingClientRect: boolean;

        /**
         * In some browsers the right padding of an overflowing element is not accounted
         * for in its scrollWidth.  The result can vary depending on whether or not
         * The element contains block-level children.  This method tests the effect
         * of padding on scrollWidth when there are no block-level children inside the
         * overflowing element.
         *
         * This method returns true if the browser is affected by this bug.
         */
        static ScrollWidthInlinePaddingBug: boolean;

        /**
         * if the device supports SVG
         */
        static Svg: boolean;

        /**
         * if the browser supports maxlength on textareas.
         */
        static TextAreaMaxLength: boolean;

        /**
         * if the browser passes the "actualLateness" parameter to
         * setTimeout. See: https://developer.mozilla.org/en/DOM/window.setTimeout
         */
        static TimeoutActualLateness: boolean;

        /**
         * if the device supports touch
         */
        static Touch: boolean;

        /**
         * if the device supports CSS3 Transitions
         */
        static Transitions: boolean;

        /**
         * if the device supports transparent color
         */
        static TransparentColor: boolean;

        /**
         * if the device supports VML
         */
        static Vml: boolean;

        /**
         * if browser supports window.onerror.
         */
        static WindowOnError: boolean;
    }

    interface TemplateConfig {
        /**
         * True to immediately compile the template. Defaults to false.
         */
        compiled?: boolean;

        /**
         * True to disable format functions in the template. If the template doesn't contain
         * format functions, setting disableFormats to true will reduce apply time. Defaults to false.
         */
        disableFormats?: boolean;
    }

    /**
     * Represents an HTML fragment template. Templates may be {@link #compile precompiled} for greater performance.
     *
     * An instance of this class may be created by passing to the constructor either a single argument, or multiple
     * arguments:
     *
     * # Single argument: String/Array
     *
     * The single argument may be either a String or an Array:
     *
     * - String:
     *
     *       var t = new Ext.Template("<div>Hello {0}.</div>");
     *       t.{@link #append}('some-element', ['foo']);
     *
     * - Array:
     *
     *   An Array will be combined with 'join('')'.
     *
     *       var t = new Ext.Template([
     *           '<div name="{id}">',
     *               '<span class="{cls}">{name:trim} {value:ellipsis(10)}</span>',
     *           '</div>',
     *       ]);
     *       t.{@link #compile}();
     *       t.{@link #append}('some-element', {id: 'myid', cls: 'myclass', name: 'foo', value: 'bar'});
     *
     * # Multiple arguments: String, Object, Array, ...
     *
     * Multiple arguments will be combined with 'join('')'.
     *
     *     var t = new Ext.Template(
     *         '<div name="{id}">',
     *             '<span class="{cls}">{name} {value}</span>',
     *         '</div>',
     *         // a configuration object:
     *         {
     *             compiled: true,      // {@link #compile} immediately
     *         }
     *     );
     *
     * # Notes
     *
     * - For a list of available format functions, see {@link Ext.util.Format}.
     * - 'disableFormats' reduces '{@link #apply}' time when no formatting is required.
     */
    export class Template extends Ext.Base implements Ext.TemplateConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Template, or subclass thereof.
         */
        isTemplate: boolean;

        /**
         * True to immediately compile the template. Defaults to false.
         */
        compiled: boolean;

        /**
         * True to disable format functions in the template. If the template doesn't contain
         * format functions, setting disableFormats to true will reduce apply time. Defaults to false.
         */
        disableFormats: boolean;

        /**
         * Applies the supplied 'values' to the template and appends the new node(s) to the specified 'el'.
         *
         * For example usage see {@link Ext.Template Ext.Template class docs}.
         *
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return an Ext.Element.
         * @return {HTMLElement/Ext.Element} The new node or Element
         */
        append(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Returns an HTML fragment of this template with the specified values applied.
         *
         * @param {Object/Array} values The template values. Can be an array if your params are numeric:
         *
         *     var tpl = new Ext.Template('Name: {0}, Age: {1}');
         *     tpl.apply(['John', 25]);
         *
         * or an object:
         *
         *     var tpl = new Ext.Template('Name: {name}, Age: {age}');
         *     tpl.apply({name: 'John', age: 25});
         *
         * @return {String} The HTML fragment
         */
        apply(values: any|any[]): string;

        /**
         * Appends the result of this template to the provided output array.
         * @param {Object/Array} values The template values. See {@link #apply}.
         * @param {Array} out The array to which output is pushed.
         * @return {Array} The given out array.
         */
        applyOut(values: any|any[], out: any[]): any[];

        /**
         * Alias for {@link #apply}.
         */
        applyTemplate();

        /**
         * Compiles the template into an internal function, eliminating the RegEx overhead.
         * @return {Ext.Template} this
         */
        compile(): Ext.Template;

        /**
         * Creates new template.
         *
         * @param {String...} html List of strings to be concatenated into template.
         * Alternatively an array of strings can be given, but then no config object may be passed.
         * @param {Object} config (optional) Config object
         */
        constructor(html: string, config: Ext.TemplateConfig);

        /**
         * Applies the supplied values to the template and inserts the new node(s) after el.
         *
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return a Ext.Element.
         * @return {HTMLElement/Ext.Element} The new node or Element
         */
        insertAfter(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Applies the supplied values to the template and inserts the new node(s) before el.
         *
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return a Ext.Element.
         * @return {HTMLElement/Ext.Element} The new node or Element
         */
        insertBefore(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Applies the supplied values to the template and inserts the new node(s) as the first child of el.
         *
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return a Ext.Element.
         * @return {HTMLElement/Ext.Element} The new node or Element
         */
        insertFirst(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Applies the supplied values to the template and overwrites the content of el with the new node(s).
         *
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/Array} values The template values. See {@link #applyTemplate} for details.
         * @param {Boolean} returnElement (optional) true to return a Ext.Element.
         * @return {HTMLElement/Ext.Element} The new node or Element
         */
        overwrite(el: string|HTMLElement|Ext.dom.Element, values: any|any[], returnElement: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Sets the HTML used as the template and optionally compiles it.
         * @param {Boolean} compile (optional) True to compile the template.
         * @return {Ext.Template} this
         */
        set(html: string, compile: boolean): Ext.Template;

        /**
         * Creates a template from the passed element's value (_display:none_ textarea, preferred) or innerHTML.
         * @param {String/HTMLElement} el A DOM element or its id
         * @param {Object} config (optional) Config object
         * @return {Ext.Template} The created template
         * @inheritable
         */
        static from(el: string|HTMLElement, config: Ext.TemplateConfig): Ext.Template;
    }

    /**
     * @author Jacky Nguyen <jacky@sencha.com>
     * @docauthor Jacky Nguyen <jacky@sencha.com>
     *
     * A utility class that wrap around a string version number and provide convenient
     * method to perform comparison. See also: {@link Ext.Version#compare compare}. Example:
     *
     *     var version = new Ext.Version('1.0.2beta');
     *     console.log("Version is " + version); // Version is 1.0.2beta
     *
     *     console.log(version.getMajor()); // 1
     *     console.log(version.getMinor()); // 0
     *     console.log(version.getPatch()); // 2
     *     console.log(version.getBuild()); // 0
     *     console.log(version.getRelease()); // beta
     *
     *     console.log(version.isGreaterThan('1.0.1')); // True
     *     console.log(version.isGreaterThan('1.0.2alpha')); // True
     *     console.log(version.isGreaterThan('1.0.2RC')); // False
     *     console.log(version.isGreaterThan('1.0.2')); // False
     *     console.log(version.isLessThan('1.0.2')); // True
     *
     *     console.log(version.match(1.0)); // True
     *     console.log(version.match('1.0.2')); // True
     */
    export class Version {
        /**
         * @param {String/Number} version The version number in the following standard format:
         *
         *     major[.minor[.patch[.build[release]]]]
         *
         * Examples:
         *
         *     1.0
         *     1.2.3beta
         *     1.2.3.4RC
         *
         * @return {Ext.Version} this
         */
        constructor(version: string|number);

        /**
         * Returns whether this version equals to the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} True if this version equals to the target, false otherwise
         */
        equals(target: string|number): boolean;

        /**
         * Returns the build component value
         * @return {Number} build
         */
        getBuild(): number;

        /**
         * Returns the major component value
         * @return {Number} major
         */
        getMajor(): number;

        /**
         * Returns the minor component value
         * @return {Number} minor
         */
        getMinor(): number;

        /**
         * Returns the patch component value
         * @return {Number} patch
         */
        getPatch(): number;

        /**
         * Returns the release component value
         * @return {Number} release
         */
        getRelease(): number;

        /**
         * Returns shortVersion version without dots and release
         * @return {String}
         */
        getShortVersion(): string;

        /**
         * Convenient alias to {@link Ext.Version#isGreaterThan isGreaterThan}
         * @return {Boolean}
         */
        gt(target: string|number): boolean;

        /**
         * Convenient alias to {@link Ext.Version#isGreaterThanOrEqual isGreaterThanOrEqual}
         * @return {Boolean}
         */
        gtEq(target: string|number): boolean;

        /**
         * Returns whether this version if greater than the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} True if this version if greater than the target, false otherwise
         */
        isGreaterThan(target: string|number): boolean;

        /**
         * Returns whether this version if greater than or equal to the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} True if this version if greater than or equal to the target, false otherwise
         */
        isGreaterThanOrEqual(target: string|number): boolean;

        /**
         * Returns whether this version if smaller than the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} True if this version if smaller than the target, false otherwise
         */
        isLessThan(target: string|number): boolean;

        /**
         * Returns whether this version if less than or equal to the supplied argument
         * @param {String/Number} target The version to compare with
         * @return {Boolean} True if this version if less than or equal to the target, false otherwise
         */
        isLessThanOrEqual(target: string|number): boolean;

        /**
         * Convenient alias to {@link Ext.Version#isLessThan isLessThan}
         * @return {Boolean}
         */
        lt(target: string|number): boolean;

        /**
         * Convenient alias to {@link Ext.Version#isLessThanOrEqual isLessThanOrEqual}
         * @return {Boolean}
         */
        ltEq(target: string|number): boolean;

        /**
         * Returns whether this version matches the supplied argument. Example:
         *
         *     var version = new Ext.Version('1.0.2beta');
         *     console.log(version.match(1)); // True
         *     console.log(version.match(1.0)); // True
         *     console.log(version.match('1.0.2')); // True
         *     console.log(version.match('1.0.2RC')); // False
         *
         * @param {String/Number} target The version to compare with
         * @return {Boolean} True if this version matches the target, false otherwise
         */
        match(target: string|number): boolean;

        /**
         * Returns this format: [major, minor, patch, build, release]. Useful for comparison
         * @return {Number[]}
         */
        toArray(): number;

        /**
         * Compare 2 specified versions, starting from left to right. If a part contains special version strings,
         * they are handled in the following order:
         * 'dev' < 'alpha' = 'a' < 'beta' = 'b' < 'RC' = 'rc' < '#' < 'pl' = 'p' < 'anything else'
         *
         * @param {String} current The current version to compare to
         * @param {String} target The target version to compare to
         * @return {Number} Returns -1 if the current version is smaller than the target version, 1 if greater, and 0 if they're equivalent
         */
        static compare(current: string, target: string): number;

        /**
         * Converts a version component to a comparable value
         *
         * @param {Object} value The value to convert
         * @return {Object}
         */
        static getComponentValue(value: any): any;
    }

    /**
     * @extends Ext.ZIndexManager
     *
     * The default global floating Component group that is available automatically.
     *
     * This manages instances of floating Components which were rendered programatically without
     * being added to a {@link Ext.container.Container Container}, and for floating Components
     * which were added into non-floating Containers.
     *
     * *Floating* Containers create their own instance of ZIndexManager, and floating Components
     * added at any depth below there are managed by that ZIndexManager.
     */
    export class WindowManager {
        constructor(container: any);
    }

    /**
     * This class compiles the XTemplate syntax into a function object. The function is used
     * like so:
     *
     *      function (out, values, parent, xindex, xcount) {
     *          // out is the output array to store results
     *          // values, parent, xindex and xcount have their historical meaning
     *      }
     *
     * @markdown
     */
    export class XTemplateCompiler extends Ext.XTemplateParser {
        constructor(config: any);

        doDefault();

        doElse();
    }

    interface XTemplateConfig extends Ext.TemplateConfig {
        /**
         * Optional. A statement, or array of statements which set up 'var's which may then
         * be accessed within the scope of the generated function.
         */
        definitions?: string|any[];
    }

    /**
     * A template class that supports advanced functionality like:
     *
     * - Autofilling arrays using templates and sub-templates
     * - Conditional processing with basic comparison operators
     * - Basic math function support
     * - Execute arbitrary inline code with special built-in template variables
     * - Custom member functions
     * - Many special tags and built-in operators that aren't defined as part of the API, but are supported in the templates that can be created
     *
     * XTemplate provides the templating mechanism built into {@link Ext.view.View}.
     *
     * The {@link Ext.Template} describes the acceptable parameters to pass to the constructor. The following examples
     * demonstrate all of the supported features.
     *
     * # Sample Data
     *
     * This is the data object used for reference in each code example:
     *
     *     var data = {
     *         name: 'Don Griffin',
     *         title: 'Senior Technomage',
     *         company: 'Sencha Inc.',
     *         drinks: ['Coffee', 'Water', 'More Coffee'],
     *         kids: [
     *             { name: 'Aubrey',  age: 17 },
     *             { name: 'Joshua',  age: 13 },
     *             { name: 'Cale',    age: 10 },
     *             { name: 'Nikol',   age: 5 },
     *             { name: 'Solomon', age: 0 }
     *         ]
     *     };
     *
     * # Auto filling of arrays
     *
     * The **tpl** tag and the **for** operator are used to process the provided data object:
     *
     * - If the value specified in for is an array, it will auto-fill, repeating the template block inside the tpl
     *   tag for each item in the array.
     * - If for="." is specified, the data object provided is examined.
     * - If between="..." is specified, the provided value will be inserted between the items.
     *   This is also supported in the "foreach" looping template.
     * - While processing an array, the special variable {#} will provide the current array index + 1 (starts at 1, not 0).
     *
     * Examples:
     *
     *     <tpl for=".">...</tpl>       // loop through array at root node
     *     <tpl for="foo">...</tpl>     // loop through array at foo node
     *     <tpl for="foo.bar">...</tpl> // loop through array at foo.bar node
     *     <tpl for="." between=",">...</tpl> // loop through array at root node and insert ',' between each item
     *
     * Using the sample data above:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Kids: ',
     *         '<tpl for=".">',       // process the data.kids node
     *             '<p>{#}. {name}</p>',  // use current array index to autonumber
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data.kids); // pass the kids property of the data object
     *
     * An example illustrating how the **for** property can be leveraged to access specified members of the provided data
     * object to populate the template:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Title: {title}</p>',
     *         '<p>Company: {company}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',     // interrogate the kids property within the data
     *             '<p>{name}</p>',
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data);  // pass the root node of the data object
     *
     * Flat arrays that contain values (and not objects) can be auto-rendered using the special **'{.}'** variable inside a
     * loop. This variable will represent the value of the array at the current index:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>{name}\'s favorite beverages:</p>',
     *         '<tpl for="drinks">',
     *             '<div> - {.}</div>',
     *         '</tpl>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * When processing a sub-template, for example while looping through a child array, you can access the parent object's
     * members via the **parent** object:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<tpl if="age &gt; 1">',
     *                 '<p>{name}</p>',
     *                 '<p>Dad: {parent.name}</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * The **foreach** operator is used to loop over an object's properties.  The following
     * example demonstrates looping over the main data object's properties:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<dl>',
     *             '<tpl foreach=".">',
     *                 '<dt>{$}</dt>', // the special **'{$}'** variable contains the property name
     *                 '<dd>{.}</dd>', // within the loop, the **'{.}'** variable is set to the property value
     *             '</tpl>',
     *         '</dl>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * # Conditional processing with basic comparison operators
     *
     * The **tpl** tag and the **if** operator are used to provide conditional checks for deciding whether or not to render
     * specific parts of the template.
     *
     * Using the sample data above:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<tpl if="age &gt; 1">',
     *                 '<p>{name}</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * More advanced conditionals are also supported:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<p>{name} is a ',
     *             '<tpl if="age &gt;= 13">',
     *                 '<p>teenager</p>',
     *             '<tpl elseif="age &gt;= 2">',
     *                 '<p>kid</p>',
     *             '<tpl else>',
     *                 '<p>baby</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<p>{name} is a ',
     *             '<tpl switch="name">',
     *                 '<tpl case="Aubrey" case="Nikol">',
     *                     '<p>girl</p>',
     *                 '<tpl default>',
     *                     '<p>boy</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *
     * A 'break' is implied between each case and default, however, multiple cases can be listed
     * in a single &lt;tpl&gt; tag.
     *
     * # Using double quotes
     *
     * Examples:
     *
     *     var tpl = new Ext.XTemplate(
     *         "<tpl if='age &gt; 1 && age &lt; 10'>Child</tpl>",
     *         "<tpl if='age &gt;= 10 && age &lt; 18'>Teenager</tpl>",
     *         "<tpl if='this.isGirl(name)'>...</tpl>",
     *         '<tpl if="id == \'download\'">...</tpl>',
     *         "<tpl if='needsIcon'><img src='{icon}' class='{iconCls}'/></tpl>",
     *         "<tpl if='name == \"Don\"'>Hello</tpl>"
     *     );
     *
     * # Basic math support
     *
     * The following basic math operators may be applied directly on numeric data values:
     *
     *     + - * /
     *
     * For example:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<tpl if="age &gt; 1">',  // <-- Note that the > is encoded
     *                 '<p>{#}: {name}</p>',  // <-- Auto-number each item
     *                 '<p>In 5 Years: {age+5}</p>',  // <-- Basic math
     *                 '<p>Dad: {parent.name}</p>',
     *             '</tpl>',
     *         '</tpl></p>'
     *     );
     *     tpl.overwrite(panel.body, data);
     *
     * # Execute arbitrary inline code with special built-in template variables
     *
     * Anything between '{[ ... ]}' is considered code to be executed in the scope of the template.
     * The expression is evaluated and the result is included in the generated result. There are
     * some special variables available in that code:
     *
     * - **out**: The output array into which the template is being appended (using 'push' to later
     *   'join').
     * - **values**: The values in the current scope. If you are using scope changing sub-templates,
     *   you can change what values is.
     * - **parent**: The scope (values) of the ancestor template.
     * - **xindex**: If you are in a "for" or "foreach" looping template, the index of the loop you are in (1-based).
     * - **xcount**: If you are in a "for" looping template, the total length of the array you are looping.
     * - **xkey**: If you are in a "foreach" looping template, the key of the current property
     * being examined.
     *
     * This example demonstrates basic row striping using an inline code block and the xindex variable:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Company: {[values.company.toUpperCase() + ", " + values.title]}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<div class="{[xindex % 2 === 0 ? "even" : "odd"]}">',
     *             '{name}',
     *             '</div>',
     *         '</tpl></p>'
     *      );
     *
     * Any code contained in "verbatim" blocks (using "{% ... %}") will be inserted directly in
     * the generated code for the template. These blocks are not included in the output. This
     * can be used for simple things like break/continue in a loop, or control structures or
     * method calls (when they don't produce output). The 'this' references the template instance.
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Company: {[values.company.toUpperCase() + ", " + values.title]}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '{% if (xindex % 2 === 0) continue; %}',
     *             '{name}',
     *             '{% if (xindex > 100) break; %}',
     *             '</div>',
     *         '</tpl></p>'
     *      );
     *
     * # Template member functions
     *
     * One or more member functions can be specified in a configuration object passed into the XTemplate constructor for
     * more complex processing:
     *
     *     var tpl = new Ext.XTemplate(
     *         '<p>Name: {name}</p>',
     *         '<p>Kids: ',
     *         '<tpl for="kids">',
     *             '<tpl if="this.isGirl(name)">',
     *                 '<p>Girl: {name} - {age}</p>',
     *             '<tpl else>',
     *                 '<p>Boy: {name} - {age}</p>',
     *             '</tpl>',
     *             '<tpl if="this.isBaby(age)">',
     *                 '<p>{name} is a baby!</p>',
     *             '</tpl>',
     *         '</tpl></p>',
     *         {
     *             // XTemplate configuration:
     *             disableFormats: true,
     *             // member functions:
     *             isGirl: function(name){
     *                return name == 'Aubrey' || name == 'Nikol';
     *             },
     *             isBaby: function(age){
     *                return age < 1;
     *             }
     *         }
     *     );
     *     tpl.overwrite(panel.body, data);
     */
    export class XTemplate extends Ext.Template implements Ext.XTemplateConfig {
        /**
         * Optional. A statement, or array of statements which set up 'var's which may then
         * be accessed within the scope of the generated function.
         */
        definitions: string|any[];

        /**
         * Creates new template.
         *
         * @param {String...} html List of strings to be concatenated into template.
         * Alternatively an array of strings can be given, but then no config object may be passed.
         * @param {Object} config (optional) Config object
         */
        constructor(html: string, config: Ext.TemplateConfig);

        /**
         * Gets an 'XTemplate' from an object (an instance of an {@link Ext#define}'d class).
         * Many times, templates are configured high in the class hierarchy and are to be
         * shared by all classes that derive from that base. To further complicate matters,
         * these templates are seldom actual instances but are rather configurations. For
         * example:
         *
         *      Ext.define('MyApp.Class', {
         *          extraCls: 'extra-class',
         *
         *          someTpl: [
         *              '<div class="{%this.emitClass(out)%}"></div>',
         *          {
         *              // Member fn - outputs the owing class's extra CSS class
         *              emitClass: function(out) {
         *                  out.push(this.owner.extraCls);
         *              }
         *          }]
         *      });
         *
         * The goal being to share that template definition with all instances and even
         * instances of derived classes, until 'someTpl' is overridden. This method will
         * "upgrade" these configurations to be real 'XTemplate' instances *in place* (to
         * avoid creating one instance per object).
         *
         * The resulting XTemplate will have an 'owner' reference injected which refers back
         * to the owning object whether that is an object which has an *own instance*, or a
         * class prototype. Through this link, XTemplate member functions will be able to access
         * prototype properties of its owning class.
         *
         * @param {Object} instance The object from which to get the 'XTemplate' (must be
         * an instance of an {@link Ext#define}'d class).
         * @param {String} name The name of the property by which to get the 'XTemplate'.
         * @return {Ext.XTemplate} The 'XTemplate' instance or null if not found.
         */
        protected static getTpl(instance: any, name: string): Ext.XTemplate;
    }

    /**
     * This class parses the XTemplate syntax and calls abstract methods to process the parts.
     */
    export class XTemplateParser extends Ext.Base {
        /**
         * The 'for' or 'foreach' loop context level. This is adjusted
         * up by one prior to calling {@link #doFor} or {@link #doForEach} and down by one after
         * calling the corresponding {@link #doEnd} that closes the loop. This will be 1 on the
         * first {@link #doFor} or {@link #doForEach} call.
         */
        level: number;

        constructor(config: any);

        /**
         * This method is called to process '<tpl case="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doCase(action: string, actions: any);

        /**
         * This method is called to process '<tpl default>'.
         */
        doDefault();

        /**
         * This method is called to process '<tpl else>'.
         */
        doElse();

        /**
         * This method is called to process '<tpl elseif="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doElseIf(action: string, actions: any);

        /**
         * This method is called to process '</tpl>'. It is given the action type that started
         * the tpl and the set of additional actions.
         * @param {String} type The type of action that is being ended.
         * @param {Object} actions The other actions keyed by the attribute name (such as 'exec').
         */
        doEnd(type: string, actions: any);

        /**
         * This method is called to process '{% text %}'.
         */
        doEval(text: string);

        /**
         * This method is called to process '<tpl exec="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name.
         */
        doExec(action: string, actions: any);

        /**
         * This method is called to process expressions (like '{[expr]}').
         * @param {String} expr The body of the expression (inside "{[" and "]}").
         */
        doExpr(expr: string);

        /**
         * This method is called to process '<tpl for="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doFor(action: string, actions: any);

        /**
         * This method is called to process '<tpl foreach="action">'. If there are other
         * attributes, these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doForEach(action: string, actions: any);

        /**
         * This method is called to process '<tpl if="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doIf(action: string, actions: any);

        /**
         * This method is called to process '<tpl switch="action">'. If there are other attributes,
         * these are passed in the actions object.
         * @param {Object} actions Other actions keyed by the attribute name (such as 'exec').
         */
        doSwitch(action: string, actions: any);

        /**
         * This method is called to process simple tags (like '{tag}').
         */
        doTag();

        /**
         * This method is called to process a piece of raw text from the tpl.
         */
        doText(text: string);

        /**
         * This method is called to process an empty '<tpl>'. This is unlikely to need to be
         * implemented, so a default (do nothing) version is provided.
         */
        doTpl();
    }

    /**
     * A class that manages a group of {@link Ext.Component#floating} Components and provides z-order management,
     * and Component activation behavior, including masking below the active (topmost) Component.
     *
     * {@link Ext.Component#floating Floating} Components which are rendered directly into the document (such as
     * {@link Ext.window.Window Window}s) which are {@link Ext.Component#method-show show}n are managed by a
     * {@link Ext.WindowManager global instance}.
     *
     * {@link Ext.Component#floating Floating} Components which are descendants of {@link Ext.Component#floating floating}
     * *Containers* (for example a {@link Ext.view.BoundList BoundList} within an {@link Ext.window.Window Window},
     * or a {@link Ext.menu.Menu Menu}), are managed by a ZIndexManager owned by that floating Container. Therefore
     * ComboBox dropdowns within Windows will have managed z-indices guaranteed to be correct, relative to the Window.
     */
    export class ZIndexManager extends Ext.Base {
        /**
         * Brings the specified Component to the front of any other active Components in this ZIndexManager.
         * @param {String/Object} comp The id of the Component or a {@link Ext.Component} instance
         * @return {Boolean} True if the dialog was brought to the front, else false
         * if it was already in front
         */
        bringToFront(comp: string|any): boolean;

        constructor(container: any);

        /**
         * Executes the specified function once for every Component in this ZIndexManager, passing each
         * Component as the only parameter. Returning false from the function will stop the iteration.
         * @param {Function} fn The function to execute for each item
         * @param {Object} [scope] The scope (this reference) in which the function
         * is executed. Defaults to the current Component in the iteration.
         */
        each(fn: Function, scope?: any);

        /**
         * Executes the specified function once for every Component in this ZIndexManager, passing each
         * Component as the only parameter. Returning false from the function will stop the iteration.
         * The components are passed to the function starting at the bottom and proceeding to the top.
         * @param {Function} fn The function to execute for each item
         * @param {Object} scope (optional) The scope (this reference) in which the function
         * is executed. Defaults to the current Component in the iteration.
         */
        eachBottomUp(fn: Function, scope: any);

        /**
         * Executes the specified function once for every Component in this ZIndexManager, passing each
         * Component as the only parameter. Returning false from the function will stop the iteration.
         * The components are passed to the function starting at the top and proceeding to the bottom.
         * @param {Function} fn The function to execute for each item
         * @param {Object} [scope] The scope (this reference) in which the function
         * is executed. Defaults to the current Component in the iteration.
         */
        eachTopDown(fn: Function, scope?: any);

        /**
         * Gets a registered Component by id.
         * @param {String/Object} id The id of the Component or a {@link Ext.Component} instance
         * @return {Ext.Component}
         */
        get(id: string|any): Ext.Component;

        /**
         * Gets the currently-active Component in this ZIndexManager.
         * @return {Ext.Component} The active Component
         */
        getActive(): Ext.Component;

        /**
         * Returns zero or more Components in this ZIndexManager using the custom search function passed to this method.
         * The function should accept a single {@link Ext.Component} reference as its only argument and should
         * return true if the Component matches the search criteria, otherwise it should return false.
         * @param {Function} fn The search function
         * @param {Object} [scope] The scope (this reference) in which the function is executed.
         * Defaults to the Component being tested. That gets passed to the function if not specified.
         * @return {Array} An array of zero or more matching windows
         */
        getBy(fn: Function, scope?: any): any[];

        /**
         * Hides all Components managed by this ZIndexManager.
         */
        hideAll();

        /**
         * Registers a floating {@link Ext.Component} with this ZIndexManager. This should not
         * need to be called under normal circumstances. Floating Components (such as Windows,
         * BoundLists and Menus) are automatically registered with a
         * {@link Ext.Component#zIndexManager zIndexManager} at render time.
         *
         * Where this may be useful is moving Windows between two ZIndexManagers. For example,
         * to bring the Ext.MessageBox dialog under the same manager as the Desktop's
         * ZIndexManager in the desktop sample app:
         *
         *     MyDesktop.getDesktop().getManager().register(Ext.MessageBox);
         *
         * @param {Ext.Component} comp The Component to register.
         */
        register(comp: Ext.Component);

        /**
         * Sends the specified Component to the back of other active Components in this ZIndexManager.
         * @param {String/Object} comp The id of the Component or a {@link Ext.Component} instance
         * @return {Ext.Component} The Component
         */
        sendToBack(comp: string|any): Ext.Component;

        /**
         * Unregisters a {@link Ext.Component} from this ZIndexManager. This should not
         * need to be called. Components are automatically unregistered upon destruction.
         * See {@link #register}.
         * @param {Ext.Component} comp The Component to unregister.
         */
        unregister(comp: Ext.Component);
    }
}

declare module Ext.app {
    interface ApplicationConfig extends Ext.app.ControllerConfig {
        /**
         * The path to the directory which contains all application's classes.
         * This path will be registered via {@link Ext.Loader#setPath} for the namespace specified
         * in the {@link #name name} config.
         */
        appFolder?: string;

        /**
         * The name of a property to be assigned to the main namespace to gain a reference to
         * this application. Can be set to an empty value to prevent the reference from
         * being created
         *
         *     Ext.application({
         *         name: 'MyApp',
         *         appProperty: 'myProp',
         *
         *         launch: function() {
         *             console.log(MyApp.myProp === this);
         *         }
         *     });
         */
        appProperty?: string;

        /**
         * True to automatically load and instantiate AppName.view.Viewport before firing the launch
         * function.
         *
         * Optional, Defaults to: false
         */
        autoCreateViewport?: boolean;

        /**
         * Names of controllers that the app uses.
         */
        controllers?: string;

        /**
         * True to automatically set up Ext.tip.QuickTip support.
         */
        enableQuickTips?: boolean;

        /**
         * The name of your application. This will also be the namespace for your views, controllers
         * models and stores. Don't use spaces or special characters in the name. **Application name
         * is mandatory**.
         */
        name?: string;

        /**
         * The list of namespace prefixes used in the application to resolve dependencies
         * like Views and Stores:
         *
         *      Ext.application({
         *          name: 'MyApp',
         *
         *          namespaces: ['Common.code'],
         *
         *          controllers: [ 'Common.code.controller.Foo', 'Bar' ]
         *      });
         *
         *      Ext.define('Common.code.controller.Foo', {
         *          extend: 'Ext.app.Controller',
         *
         *          models: ['Foo'],    // Loads Common.code.model.Foo
         *          views:  ['Bar']     // Loads Common.code.view.Bar
         *      });
         *
         *      Ext.define('MyApp.controller.Bar', {
         *          extend: 'Ext.app.Controller',
         *
         *          models: ['Foo'],    // Loads MyApp.model.Foo
         *          views:  ['Bar']     // Loads MyApp.view.Bar
         *      });
         *
         * You don't need to include main namespace (MyApp), it will be added to the list
         * automatically.
         *
         * Optional
         */
        namespaces?: string;

        /**
         * Additional load paths to add to Ext.Loader.
         * See {@link Ext.Loader#paths} config for more details.
         */
        paths?: any;

        /**
         * The scope to execute the {@link #launch} function in. Defaults to the Application instance.
         */
        scope?: any;
    }

    /**
     * Represents an Ext JS 4 application, which is typically a single page app using a {@link Ext.container.Viewport Viewport}.
     * A typical Ext.app.Application might look like this:
     *
     *     Ext.application({
     *         name: 'MyApp',
     *         launch: function() {
     *             Ext.create('Ext.container.Viewport', {
     *                 items: {
     *                     html: 'My App'
     *                 }
     *             });
     *         }
     *     });
     *
     * This does several things. First it creates a global variable called 'MyApp' - all of your Application's classes (such
     * as its Models, Views and Controllers) will reside under this single namespace, which drastically lowers the chances
     * of colliding global variables. The MyApp global will also have a getApplication method to get a reference to
     * the current application:
     *
     *     var app = MyApp.getApplication();
     *
     * When the page is ready and all of your JavaScript has loaded, your Application's {@link #launch} function is called,
     * at which time you can run the code that starts your app. Usually this consists of creating a Viewport, as we do in
     * the example above.
     *
     * # Telling Application about the rest of the app
     *
     * Because an Ext.app.Application represents an entire app, we should tell it about the other parts of the app - namely
     * the Models, Views and Controllers that are bundled with the application. Let's say we have a blog management app; we
     * might have Models and Controllers for Posts and Comments, and Views for listing, adding and editing Posts and Comments.
     * Here's how we'd tell our Application about all these things:
     *
     *     Ext.application({
     *         name: 'Blog',
     *         models: ['Post', 'Comment'],
     *         controllers: ['Posts', 'Comments'],
     *
     *         launch: function() {
     *             ...
     *         }
     *     });
     *
     * Note that we didn't actually list the Views directly in the Application itself. This is because Views are managed by
     * Controllers, so it makes sense to keep those dependencies there. The Application will load each of the specified
     * Controllers using the pathing conventions laid out in the [application architecture guide][mvc] - in this case
     * expecting the controllers to reside in app/controller/Posts.js and app/controller/Comments.js. In turn, each
     * Controller simply needs to list the Views it uses and they will be automatically loaded. Here's how our Posts
     * controller like be defined:
     *
     *     Ext.define('MyApp.controller.Posts', {
     *         extend: 'Ext.app.Controller',
     *         views: ['posts.List', 'posts.Edit'],
     *
     *         //the rest of the Controller here
     *     });
     *
     * Because we told our Application about our Models and Controllers, and our Controllers about their Views, Ext JS will
     * automatically load all of our app files for us. This means we don't have to manually add script tags into our html
     * files whenever we add a new class, but more importantly it enables us to create a minimized build of our entire
     * application using Sencha Cmd.
     *
     * # Deriving from Ext.app.Application
     *
     * Typically, applications do not derive directly from Ext.app.Application. Rather, the
     * configuration passed to 'Ext.application' mimics what you might do in a derived class.
     * In some cases, however, it can be desirable to share logic by using a derived class
     * from 'Ext.app.Application'.
     *
     * Derivation works as you would expect, but using the derived class should still be the
     * job of the 'Ext.application' method.
     *
     *     Ext.define('MyApp.app.Application', {
     *         extend: 'Ext.app.Application',
     *         name: 'MyApp',
     *         ...
     *     });
     *
     *     Ext.application('MyApp.app.Application');
     *
     * For more information about writing Ext JS 4 applications, please see the [application architecture guide][mvc].
     *
     * [mvc]: #/guide/application_architecture
     *
     * @docauthor Ed Spencer
     */
    export class Application extends Ext.app.Controller implements Ext.app.ApplicationConfig {
        /**
         * The path to the directory which contains all application's classes.
         * This path will be registered via {@link Ext.Loader#setPath} for the namespace specified
         * in the {@link #name name} config.
         */
        appFolder: string;

        /**
         * The name of a property to be assigned to the main namespace to gain a reference to
         * this application. Can be set to an empty value to prevent the reference from
         * being created
         *
         *     Ext.application({
         *         name: 'MyApp',
         *         appProperty: 'myProp',
         *
         *         launch: function() {
         *             console.log(MyApp.myProp === this);
         *         }
         *     });
         */
        appProperty: string;

        /**
         * True to automatically load and instantiate AppName.view.Viewport before firing the launch
         * function.
         *
         * Optional, Defaults to: false
         */
        autoCreateViewport: boolean;

        /**
         * Names of controllers that the app uses.
         */
        controllers: string;

        /**
         * True to automatically set up Ext.tip.QuickTip support.
         */
        enableQuickTips: boolean;

        /**
         * The name of your application. This will also be the namespace for your views, controllers
         * models and stores. Don't use spaces or special characters in the name. **Application name
         * is mandatory**.
         */
        name: string;

        /**
         * The list of namespace prefixes used in the application to resolve dependencies
         * like Views and Stores:
         *
         *      Ext.application({
         *          name: 'MyApp',
         *
         *          namespaces: ['Common.code'],
         *
         *          controllers: [ 'Common.code.controller.Foo', 'Bar' ]
         *      });
         *
         *      Ext.define('Common.code.controller.Foo', {
         *          extend: 'Ext.app.Controller',
         *
         *          models: ['Foo'],    // Loads Common.code.model.Foo
         *          views:  ['Bar']     // Loads Common.code.view.Bar
         *      });
         *
         *      Ext.define('MyApp.controller.Bar', {
         *          extend: 'Ext.app.Controller',
         *
         *          models: ['Foo'],    // Loads MyApp.model.Foo
         *          views:  ['Bar']     // Loads MyApp.view.Bar
         *      });
         *
         * You don't need to include main namespace (MyApp), it will be added to the list
         * automatically.
         *
         * Optional
         */
        namespaces: string;

        /**
         * Additional load paths to add to Ext.Loader.
         * See {@link Ext.Loader#paths} config for more details.
         */
        paths: any;

        /**
         * The scope to execute the {@link #launch} function in. Defaults to the Application instance.
         */
        scope: any;

        /**
         * Creates new Application.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.app.ApplicationConfig);

        /**
         * Called automatically when the page has completely loaded. This is an empty function that should be
         * overridden by each application that needs to take action on page load.
         * @param {String} profile The detected application profile
         * @return {Boolean} By default, the Application will dispatch to the configured startup controller and
         * action immediately after running the launch function. Return false to prevent this behavior.
         */
        launch(profile: string): boolean;
    }

    interface ControllerConfig {
        /**
         * The id of this controller. You can use this id when dispatching.
         */
        id?: string;

        /**
         * Array of models to require from AppName.model namespace. For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          models: ['User', 'Vehicle']
         *      });
         *
         * This is equivalent of:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          requires: ['MyApp.model.User', 'MyApp.model.Vehicle'],
         *
         *          getUserModel: function() {
         *              return this.getModel("User");
         *          },
         *
         *          getVehicleModel: function() {
         *              return this.getModel("Vehicle");
         *          }
         *      });
         */
        models?: string;

        /**
         * Array of configs to build up references to views on page. For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *
         *          refs: [{
         *              ref: 'list',
         *              selector: 'grid'
         *          }],
         *      });
         *
         * This will add method 'getList' to the controller which will internally use
         * Ext.ComponentQuery to reference the grid component on page.
         *
         * The following fields can be used in ref definition:
         *
         * - 'ref' - name of the reference.
         * - 'selector' - Ext.ComponentQuery selector to access the component.
         * - 'autoCreate' - True to create the component automatically if not found on page.
         * - 'forceCreate' - Forces the creation of the component every time reference is accessed
         *   (when 'get<REFNAME>' is called).
         * - 'xtype' - Used to create component by its xtype with autoCreate or forceCreate. If
         *   you don't provide xtype, an Ext.Component instance will be created.
         */
        refs?: any;

        /**
         * Array of stores to require from AppName.store namespace and to generate getter methods for.
         * For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          stores: ['Users', 'Vehicles']
         *      });
         *
         * This is equivalent to:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *
         *          requires: [
         *              'MyApp.store.Users',
         *              'MyApp.store.Vehicles'
         *          ]
         *
         *          getUsersStore: function() {
         *              return this.getStore("Users");
         *          },
         *
         *          getVehiclesStore: function() {
         *              return this.getStore("Vehicles");
         *          }
         *      });
         */
        stores?: string;

        /**
         * Array of views to require from AppName.view namespace and to generate getter methods for.
         * For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          views: ['List', 'Detail']
         *      });
         *
         * This is equivalent of:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          requires: ['MyApp.view.List', 'MyApp.view.Detail'],
         *
         *          getListView: function() {
         *              return this.getView("List");
         *          },
         *
         *          getDetailView: function() {
         *              return this.getView("Detail");
         *          }
         *      });
         */
        views?: string;
    }

    /**
     * Controllers are the glue that binds an application together. All they really do is listen for events (usually from
     * views) and take some action. Here's how we might create a Controller to manage Users:
     *
     *      Ext.define('MyApp.controller.Users', {
     *          extend: 'Ext.app.Controller',
     *
     *          init: function() {
     *              console.log('Initialized Users! This happens before ' +
     *                          'the Application launch() function is called');
     *          }
     *      });
     *
     * The init function is a special method that is called when your application boots. It is called before the
     * {@link Ext.app.Application Application}'s launch function is executed so gives a hook point to run any code before
     * your Viewport is created.
     *
     * The init function is a great place to set up how your controller interacts with the view, and is usually used in
     * conjunction with another Controller function - {@link Ext.app.Controller#control control}. The control function
     * makes it easy to listen to events on your view classes and take some action with a handler function. Let's update
     * our Users controller to tell us when the panel is rendered:
     *
     *      Ext.define('MyApp.controller.Users', {
     *          extend: 'Ext.app.Controller',
     *
     *          init: function() {
     *              this.control({
     *                  'viewport > panel': {
     *                      render: this.onPanelRendered
     *                  }
     *              });
     *          },
     *
     *          onPanelRendered: function() {
     *              console.log('The panel was rendered');
     *          }
     *      });
     *
     * We've updated the init function to use {@link Ext.app.Controller#control control method} to set up listeners on views
     * in our application. The control method uses the ComponentQuery engine to quickly and easily get references to components
     * on the page. If you are not familiar with ComponentQuery yet, be sure to check out the
     * {@link Ext.ComponentQuery documentation}. In brief though, it allows us to pass a CSS-like selector that will find
     * every matching component on the page.
     *
     * In our init function above we supplied 'viewport > panel', which translates to "find me every Panel that is a direct
     * child of a Viewport". We then supplied an object that maps event names (just 'render' in this case) to handler
     * functions. The overall effect is that whenever any component that matches our selector fires a 'render' event, our
     * onPanelRendered function is called.
     *
     * ## Event domains
     *
     * In Ext JS 4.2, we introduced the concept of event domains. In terms of MVC, an event domain
     * is one or more base classes that fire events to which a Controller wants to listen. Besides
     * Component event domain that encompass {@link Ext.Component}-descended Views, Controllers now
     * can listen to events from data Stores, Ext.Direct Providers, other Controllers, and Ext.globalEvents.
     * This feature provides a way to communicate between parts of the whole application without the need
     * to bind controllers together tightly, and allows to develop and test application parts in isolation.
     *
     * See usage examples in {@link #listen} method documentation.
     *
     * ## Using refs
     *
     * One of the most useful parts of Controllers is the ref system. These use the {@link Ext.ComponentQuery} to
     * make it really easy to get references to Views on your page. Let's look at an example of this now:
     *
     *      Ext.define('MyApp.controller.Users', {
     *          extend: 'Ext.app.Controller',
     *
     *          refs: [{
     *              ref: 'list',
     *              selector: 'grid'
     *          }],
     *
     *          init: function() {
     *              this.control({
     *                  'button': {
     *                      click: this.refreshGrid
     *                  }
     *              });
     *          },
     *
     *          refreshGrid: function() {
     *              this.getList().store.load();
     *          }
     *      });
     *
     * This example assumes the existence of a {@link Ext.grid.Panel Grid} on the page, which contains a single button to
     * refresh the Grid when clicked. In our refs array, we set up a reference to the grid. There are two parts to this -
     * the 'selector', which is a {@link Ext.ComponentQuery ComponentQuery} selector which finds any grid on the page and
     * assigns it to the reference 'list'.
     *
     * By giving the reference a name, we get a number of things for free. The first is the getList function that we use in
     * the refreshGrid method above. This is generated automatically by the Controller based on the name of our ref, which
     * was capitalized and prepended with get to go from 'list' to 'getList'.
     *
     * The way this works is that the first time getList is called by your code, the ComponentQuery selector is run and the
     * first component that matches the selector ('grid' in this case) will be returned. All future calls to getList will
     * use a cached reference to that grid. Usually it is advised to use a specific ComponentQuery selector that will only
     * match a single View in your application (in the case above our selector will match any grid on the page).
     *
     * Bringing it all together, our init function is called when the application boots, at which time we call this.control
     * to listen to any click on a {@link Ext.button.Button button} and call our refreshGrid function (again, this will
     * match any button on the page so we advise a more specific selector than just 'button', but have left it this way for
     * simplicity). When the button is clicked we use out getList function to refresh the grid.
     *
     * You can create any number of refs and control any number of components this way, simply adding more functions to
     * your Controller as you go. For an example of real-world usage of Controllers see the Feed Viewer example in the
     * examples/app/feed-viewer folder in the SDK download.
     *
     * ## Generated getter methods
     *
     * Refs aren't the only thing that generate convenient getter methods. Controllers often have to deal with Models and
     * Stores so the framework offers a couple of easy ways to get access to those too. Let's look at another example:
     *
     *      Ext.define('MyApp.controller.Users', {
     *          extend: 'Ext.app.Controller',
     *
     *          models: ['User'],
     *          stores: ['AllUsers', 'AdminUsers'],
     *
     *          init: function() {
     *              var User, allUsers, ed;
     *
     *              User = this.getUserModel();
     *              allUsers = this.getAllUsersStore();
     *
     *              ed = new User({ name: 'Ed' });
     *              allUsers.add(ed);
     *          }
     *      });
     *
     * By specifying Models and Stores that the Controller cares about, it again dynamically loads them from the appropriate
     * locations (app/model/User.js, app/store/AllUsers.js and app/store/AdminUsers.js in this case) and creates getter
     * functions for them all. The example above will create a new User model instance and add it to the AllUsers Store.
     * Of course, you could do anything in this function but in this case we just did something simple to demonstrate the
     * functionality.
     *
     * ## Further Reading
     *
     * For more information about writing Ext JS 4 applications, please see the
     * [application architecture guide](#/guide/application_architecture). Also see the {@link Ext.app.Application}
     * documentation.
     *
     * @docauthor Ed Spencer
     */
    export class Controller extends Ext.Base implements Ext.app.ControllerConfig {
        /**
         * The {@link Ext.app.Application} for this controller.
         *
         * @readonly
         */
        application: any;

        /**
         * The id of this controller. You can use this id when dispatching.
         */
        id: string;

        /**
         * Array of models to require from AppName.model namespace. For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          models: ['User', 'Vehicle']
         *      });
         *
         * This is equivalent of:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          requires: ['MyApp.model.User', 'MyApp.model.Vehicle'],
         *
         *          getUserModel: function() {
         *              return this.getModel("User");
         *          },
         *
         *          getVehicleModel: function() {
         *              return this.getModel("Vehicle");
         *          }
         *      });
         */
        models: string;

        /**
         * Array of configs to build up references to views on page. For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *
         *          refs: [{
         *              ref: 'list',
         *              selector: 'grid'
         *          }],
         *      });
         *
         * This will add method 'getList' to the controller which will internally use
         * Ext.ComponentQuery to reference the grid component on page.
         *
         * The following fields can be used in ref definition:
         *
         * - 'ref' - name of the reference.
         * - 'selector' - Ext.ComponentQuery selector to access the component.
         * - 'autoCreate' - True to create the component automatically if not found on page.
         * - 'forceCreate' - Forces the creation of the component every time reference is accessed
         *   (when 'get<REFNAME>' is called).
         * - 'xtype' - Used to create component by its xtype with autoCreate or forceCreate. If
         *   you don't provide xtype, an Ext.Component instance will be created.
         */
        refs: any;

        /**
         * Array of stores to require from AppName.store namespace and to generate getter methods for.
         * For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          stores: ['Users', 'Vehicles']
         *      });
         *
         * This is equivalent to:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *
         *          requires: [
         *              'MyApp.store.Users',
         *              'MyApp.store.Vehicles'
         *          ]
         *
         *          getUsersStore: function() {
         *              return this.getStore("Users");
         *          },
         *
         *          getVehiclesStore: function() {
         *              return this.getStore("Vehicles");
         *          }
         *      });
         */
        stores: string;

        /**
         * Array of views to require from AppName.view namespace and to generate getter methods for.
         * For example:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          views: ['List', 'Detail']
         *      });
         *
         * This is equivalent of:
         *
         *      Ext.define("MyApp.controller.Foo", {
         *          extend: "Ext.app.Controller",
         *          requires: ['MyApp.view.List', 'MyApp.view.Detail'],
         *
         *          getListView: function() {
         *              return this.getView("List");
         *          },
         *
         *          getDetailView: function() {
         *              return this.getView("Detail");
         *          }
         *      });
         */
        views: string;

        /**
         * Registers one or more {@link #refs references}.
         */
        addRef(refs: any);

        /**
         * Creates new Controller.
         *
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.app.ControllerConfig);

        /**
         * Adds listeners to components selected via {@link Ext.ComponentQuery}. Accepts an
         * object containing component paths mapped to a hash of listener functions.
         *
         * In the following example the 'updateUser' function is mapped to to the 'click'
         * event on a button component, which is a child of the 'useredit' component.
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.control({
         *                  'useredit button[action=save]': {
         *                      click: this.updateUser
         *                  }
         *              });
         *          },
         *
         *          updateUser: function(button) {
         *              console.log('clicked the Save button');
         *          }
         *      });
         *
         * Or alternatively one call 'control' with two arguments:
         *
         *      this.control('useredit button[action=save]', {
         *          click: this.updateUser
         *      });
         *
         * See {@link Ext.ComponentQuery} for more information on component selectors.
         *
         * @param {String/Object} selectors If a String, the second argument is used as the
         * listeners, otherwise an object of selectors -> listeners is assumed
         * @param {Object} [listeners] Config for listeners.
         */
        control(selectors: string|any, listeners?: any);

        /**
         * Returns the base {@link Ext.app.Application} for this controller.
         *
         * @return {Ext.app.Application} the application
         */
        getApplication(): Ext.app.Application;

        /**
         * Returns instance of a {@link Ext.app.Controller Controller} with the given id.
         * When controller doesn't exist yet, it's created. Note that this method depends
         * on Application instance and will return undefined when Application is not
         * accessible. The only exception is when this Controller instance's id is requested;
         * in that case we always return the instance even if Application is no available.
         *
         *
         * @return {Ext.app.Controller} controller instance or undefined.
         */
        getController(id: string): Ext.app.Controller;

        /**
         * Returns a {@link Ext.data.Model Model} class with the given name.
         * A shorthand for using {@link Ext.ModelManager#getModel}.
         *
         *
         * @return {Ext.data.Model} a model class.
         */
        getModel(name: string): Ext.data.Model;

        /**
         * Returns instance of a {@link Ext.data.Store Store} with the given name.
         * When store doesn't exist yet, it's created.
         *
         *
         * @return {Ext.data.Store} a store instance.
         */
        getStore(name: string): Ext.data.Store;

        /**
         * Returns a View class with the given name.  To create an instance of the view,
         * you can use it like it's used by Application to create the Viewport:
         *
         *     this.getView('Viewport').create();
         *
         *
         * @return {Ext.Base} a view class.
         */
        getView(name: string): Ext.Base;

        /**
         * Returns 'true' if a {@link #refs reference} is registered.
         *
         * @return {Boolean}
         */
        hasRef(): boolean;

        /**
         * A template method that is called when your application boots. It is called before the
         * {@link Ext.app.Application Application}'s launch function is executed so gives a hook point
         * to run any code before your Viewport is created.
         */
        init(application: Ext.app.Application);

        /**
         * Adds listeners to different event sources (also called "event domains"). The
         * primary event domain is that of components, but there are also other event domains:
         * {@link Ext.app.domain.Global Global} domain that intercepts events fired from
         * {@link Ext#globalEvents} Observable instance, {@link Ext.app.domain.Controller Controller}
         * domain can be used to listen to events fired by other Controllers,
         * {@link Ext.app.domain.Store Store} domain gives access to Store events, and
         * {@link Ext.app.domain.Direct Direct} domain can be used with Ext.Direct Providers
         * to listen to their events.
         *
         * To listen to "bar" events fired by a controller with id="foo":
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  controller: {
         *                      '#foo': {
         *                         bar: this.onFooBar
         *                      }
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * To listen to "bar" events fired by any controller, and "baz" events
         * fired by Store with storeId="baz":
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  controller: {
         *                      '*': {
         *                         bar: this.onAnyControllerBar
         *                      }
         *                  },
         *                  store: {
         *                      '#baz': {
         *                          baz: this.onStoreBaz
         *                      }
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * To listen to "idle" events fired by {@link Ext#globalEvents} when other event
         * processing is complete and Ext JS is about to return control to the browser:
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  global: {               // Global events are always fired
         *                      idle: this.onIdle   // from the same object, so there
         *                  }                       // are no selectors
         *              });
         *          }
         *      });
         *
         * As this relates to components, the following example:
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  component: {
         *                      'useredit button[action=save]': {
         *                         click: this.updateUser
         *                      }
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * Is equivalent to:
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.control({
         *                  'useredit button[action=save]': {
         *                     click: this.updateUser
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * Of course, these can all be combined in a single call and used instead of
         * 'control', like so:
         *
         *      Ext.define('AM.controller.Users', {
         *          init: function() {
         *              this.listen({
         *                  global: {
         *                      idle: this.onIdle
         *                  },
         *                  controller: {
         *                      '*': {
         *                         foobar: this.onAnyFooBar
         *                      },
         *                      '#foo': {
         *                         bar: this.onFooBar
         *                      }
         *                  },
         *                  component: {
         *                      'useredit button[action=save]': {
         *                         click: this.updateUser
         *                      }
         *                  },
         *                  store: {
         *                      '#qux': {
         *                          load: this.onQuxLoad
         *                      }
         *                  }
         *              });
         *          },
         *          ...
         *      });
         *
         * @param {Object} to Config object containing domains, selectors and listeners.
         */
        listen(to: any);

        /**
         * A template method like {@link #init}, but called after the viewport is created.
         * This is called after the {@link Ext.app.Application#launch launch} method of Application
         * is executed.
         */
        onLaunch(application: Ext.app.Application);
    }

    /**
     * This class manages event dispatching for Controllers. The details of connecting classes
     * to this dispatching mechanism is delegated to {@link Ext.app.EventDomain} instances.
     */
    export class EventBus {
        /**
         * Adds a set of component event listeners for a controller. To work with event domains
         * other than component, see {@link #listen}.
         *
         * @param {Object} selectors Config object containing selectors and listeners.
         * @param {Ext.app.Controller} controller The listening controller instance.
         */
        static control(selectors: any, controller: Ext.app.Controller);

        /**
         * Adds a set of event domain listeners for a controller. For more information on event
         * domains, see {@link Ext.app.EventDomain} and {@link Ext.app.Controller}.
         *
         * @param {Object} to Config object containing domains, selectors and listeners.
         * @param {Ext.app.Controller} controller The listening controller instance.
         */
        static listen(to: any, controller: Ext.app.Controller);

        /**
         * Removes all of a controller's attached listeners.
         *
         * @param {String} controllerId The id of the controller.
         */
        static unlisten(controllerId: string);
    }

    interface EventDomainConfig {
        /**
         * Name of the identifier property for this event domain.
         */
        idProperty?: string;
    }

    /**
     * This class is a base class for an event domain. In the context of MVC, an "event domain"
     * is one or more base classes that fire events to which a Controller wants to listen. A
     * controller listens to events by describing the selectors for events of interest to it.
     *
     * Matching selectors to the firer of an event is one key aspect that defines an event
     * domain. All event domain instances must provide a 'match' method that tests selectors
     * against the event firer.
     *
     * When an event domain instance is created (typically as a 'singleton'), its 'type'
     * property is used to catalog the domain in the
     * {@link Ext.app.EventDomain#instances Ext.app.EventDomain.instances} map.
     *
     * There are five event domains provided by default:
     *
     * -   {@link Ext.app.domain.Component Component domain}. This is the primary event domain that
     * has been available since Ext JS MVC was introduced. This domain is defined as any class that
     * extends {@link Ext.Component}, where the selectors use
     * {@link Ext.ComponentQuery#query Ext.ComponentQuery}.
     * -   {@link Ext.app.domain.Global Global domain}. This domain provides Controllers with access
     * to events fired from {@link Ext#globalEvents} Observable instance. These events represent
     * the state of the application as a whole, and are always anonymous. Because of this, Global
     * domain does not provide selectors at all.
     * -   {@link Ext.app.domain.Controller Controller domain}. This domain includes all classes
     * that extend {@link Ext.app.Controller}. Events fired by Controllers will be available
     * within this domain; selectors are either Controller's {@link Ext.app.Controller#id id} or
     * '*' wildcard for any Controller.
     * -   {@link Ext.app.domain.Store Store domain}. This domain is for classes extending
     * {@link Ext.data.AbstractStore}. Selectors are either Store's
     * {@link Ext.data.AbstractStore#storeId storeId} or '*' wildcard for any Store.
     * -   {@link Ext.app.domain.Direct Direct domain}. This domain includes all classes that extend
     * {@link Ext.direct.Provider}. Selectors are either Provider's {@link Ext.direct.Provider#id id}
     * or '*' wildcard for any Provider. This domain is optional and will be loaded only if
     * {@link Ext.direct.Manager} singleton is required in your application.
     */
    export class EventDomain extends Ext.Base implements Ext.app.EventDomainConfig {
        /**
         * Name of the identifier property for this event domain.
         */
        idProperty: string;

        constructor();

        /**
         * This method matches the firer of the event (the 'target') to the given 'selector'.
         * Default matching is very simple: a match is true when selector equals target's
         * {@link #cfg-idProperty idProperty}, or when selector is '*' wildcard to match any
         * target.
         *
         * @param {Object} target The firer of the event.
         * @param {String} selector The selector to which to match the 'target'.
         *
         * @return {Boolean} 'true' if the 'target' matches the 'selector'.
         */
        protected match(target: any, selector: string): boolean;

        /**
         * This method is called by the derived class to monitor 'fireEvent' calls. Any call
         * to 'fireEvent' on the target Observable will be intercepted and dispatched to any
         * listening Controllers. Assuming the original 'fireEvent' method does not return
         * 'false', the event is passed to the 'dispatch' method of this object.
         *
         * This is typically called in the 'constructor' of derived classes.
         *
         * @param {Ext.Class} observable The Observable to monitor for events.
         */
        protected monitor(observable: Ext.Class);

        /**
         * An object map containing 'Ext.app.EventDomain' instances keyed by the value
         * of their 'type' property.
         */
        static instances: any;
    }
}

declare module Ext.app.domain {
    /**
     * This class implements the component event domain. All classes extending from
     * {@link Ext.Component} are included in this domain. The matching criteria uses
     * {@link Ext.ComponentQuery}.
     */
    export class Component {
    }

    /**
     * This class implements the controller event domain. All classes extending from
     * {@link Ext.app.Controller} are included in this domain. The selectors are simply id's or the
     * wildcard "*" to match any controller.
     */
    export class Controller {
    }

    /**
     * This class implements the Ext.Direct event domain. All classes extending from
     * {@link Ext.direct.Provider} are included in this domain. The selectors are simply provider
     * id's or the wildcard "*" to match any provider.
     */
    export class Direct {
    }

    /**
     * This class implements the global event domain. This domain represents event fired from
     * {@link Ext#globalEvents} Observable instance. No selectors are supported for this domain.
     */
    export class Global {
    }

    /**
     * This class implements the data store event domain. All classes extending from
     * {@link Ext.data.AbstractStore} are included in this domain. The selectors are simply
     * store id's or the wildcard "*" to match any store.
     */
    export class Store {
    }
}

declare module Ext.button {
    interface ButtonConfig extends Ext.ComponentConfig {
        /**
         * False to not allow a pressed Button to be depressed. Only valid when {@link #enableToggle} is true.
         *
         * Optional, Defaults to: true
         */
        allowDepress?: boolean;

        /**
         * The side of the Button box to render the arrow if the button has an associated {@link #cfg-menu}. Two
         * values are allowed:
         *
         * - 'right'
         * - 'bottom'
         */
        arrowAlign?: string;

        /**
         * The className used for the inner arrow element if the button has a menu.
         */
        arrowCls?: string;

        /**
         * The base CSS class to add to all buttons.
         *
         * Optional, Defaults to: 'x-btn'
         */
        baseCls?: string;

        /**
         * An object literal of parameters to pass to the url when the {@link #href} property is specified.
         */
        baseParams?: any;

        /**
         * The DOM event that will fire the handler of the button. This can be any valid event name (dblclick, contextmenu).
         */
        clickEvent?: string;

        /**
         * A CSS class string to apply to the button's main element.
         */
        cls?: string;

        componentLayout?: any;

        /**
         * Whether or not to destroy any associated menu when this button is destroyed. The menu
         * will be destroyed unless this is explicitly set to false.
         */
        destroyMenu?: boolean;

        /**
         * True to enable pressed/not pressed toggling. If a {@link #toggleGroup} is specified, this
         * option will be set to true.
         *
         * Optional, Defaults to: false
         */
        enableToggle?: boolean;

        /**
         * The CSS class to add to a button when it is in the focussed state.
         */
        focusCls?: string;

        frame?: any;

        /**
         * A numeric unicode character code to use as the icon for this button. The default
         * font-family for glyphs can be set globally using
         * {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()}. Alternatively, this
         * config option accepts a string with the charCode and font-family separated by the
         * '@' symbol. For example '65@My Font Family'.
         */
        glyph?: number|string;

        /**
         * False to disable visual cues on mouseover, mouseout and mousedown.
         */
        handleMouseEvents?: boolean;

        /**
         * A function called when the button is clicked (can be used instead of click event).
         * This button.
         * The click event.
         */
        handler?: Function;

        /**
         * The URL to open when the button is clicked. Specifying this config causes the Button to be
         * rendered with the specified URL as the 'href' attribute of its '<a>' Element.
         *
         * This is better than specifying a click handler of
         *
         *     function() { window.location = "http://www.sencha.com" }
         *
         * because the UI will provide meaningful hints to the user as to what to expect upon clicking
         * the button, and will also allow the user to open in a new tab or window, bookmark or drag the URL, or directly save
         * the URL stream to disk.
         *
         * See also the {@link #hrefTarget} config.
         */
        href?: string;

        /**
         * The target attribute to use for the underlying anchor. Only used if the {@link #href}
         * property is specified.
         *
         * Optional, Defaults to: "_blank"
         */
        hrefTarget?: string;

        /**
         * The path to an image to display in the button.
         */
        icon?: string;

        /**
         * The side of the Button box to render the icon. Four values are allowed:
         *
         * - 'top'
         * - 'right'
         * - 'bottom'
         * - 'left'
         */
        iconAlign?: string;

        /**
         * A css class which sets a background image to be used as the icon for this button.
         */
        iconCls?: string;

        /**
         * The CSS class to add to a button when it's menu is active.
         */
        menuActiveCls?: string;

        /**
         * The position to align the menu to (see {@link Ext.util.Positionable#alignTo} for more details).
         */
        menuAlign?: string;

        /**
         * The minimum width for this button (used to give a set of buttons a common width).
         * See also {@link Ext.panel.Panel}.{@link Ext.panel.Panel#minButtonWidth minButtonWidth}.
         */
        minWidth?: number;

        /**
         * The CSS class to add to a button when it is in the over (hovered) state.
         */
        overCls?: string;

        /**
         * If used in a {@link Ext.toolbar.Toolbar Toolbar}, the text to be used if this item is shown in the overflow menu.
         * See also {@link Ext.toolbar.Item}.'{@link Ext.toolbar.Item#overflowText overflowText}'.
         */
        overflowText?: string;

        /**
         * An object literal of parameters to pass to the url when the {@link #href} property is specified. Any params
         * override {@link #baseParams}. New params can be set using the {@link #setParams} method.
         */
        params?: any;

        /**
         * The CSS class to add to a button when it is in the pressed state.
         */
        pressedCls?: string;

        /**
         * True to prevent the default action when the {@link #clickEvent} is processed.
         */
        preventDefault?: boolean;

        /**
         * True to repeat fire the click event while the mouse is down. This can also be a
         * {@link Ext.util.ClickRepeater ClickRepeater} config object.
         *
         * Optional, Defaults to: false
         */
        repeat?: boolean|any;

        /**
         * The size of the Button. Three values are allowed:
         *
         * - 'small' - Results in the button element being 16px high.
         * - 'medium' - Results in the button element being 24px high.
         * - 'large' - Results in the button element being 32px high.
         */
        scale?: any;

        /**
         * The scope (**this** reference) in which the '{@link #handler}' and '{@link #toggleHandler}' is executed.
         * Defaults to this Button.
         */
        scope?: any;

        /**
         * True to force an attached {@link #cfg-menu} with no items to be shown when clicking
         * this button. By default, the menu will not show if it is empty.
         */
        showEmptyMenu?: boolean;

        shrinkWrap?: any;

        /**
         * Set a DOM tabIndex for this button.
         */
        tabIndex?: number;

        /**
         * The button text to be used as innerHTML (html tags are accepted).
         */
        text?: string;

        /**
         * The text alignment for this button (center, left, right).
         */
        textAlign?: string;

        /**
         * The group this toggle button is a member of (only 1 per group can be pressed). If a toggleGroup
         * is specified, the {@link #enableToggle} configuration will automatically be set to true.
         */
        toggleGroup?: string;

        /**
         * Function called when a Button with {@link #enableToggle} set to true is clicked.
         * This button.
         * The next state of the Button, true means pressed.
         */
        toggleHandler?: Function;

        /**
         * The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or
         * QuickTips config object.
         */
        tooltip?: string|any;

        /**
         * The type of tooltip to use. Either 'qtip' for QuickTips or 'title' for title attribute.
         */
        tooltipType?: string;
    }

    /**
     * @docauthor Robert Dougan <rob@sencha.com>
     *
     * Create simple buttons with this component. Customisations include {@link #iconAlign aligned}
     * {@link #iconCls icons}, {@link #cfg-menu dropdown menus}, {@link #tooltip tooltips}
     * and {@link #scale sizing options}. Specify a {@link #handler handler} to run code when
     * a user clicks the button, or use {@link #listeners listeners} for other events such as
     * {@link #mouseover mouseover}. Example usage:
     *
     *     @example
     *     Ext.create('Ext.Button', {
     *         text: 'Click me',
     *         renderTo: Ext.getBody(),
     *         handler: function() {
     *             alert('You clicked the button!');
     *         }
     *     });
     *
     * The {@link #handler} configuration can also be updated dynamically using the {@link #setHandler}
     * method.  Example usage:
     *
     *     @example
     *     Ext.create('Ext.Button', {
     *         text    : 'Dynamic Handler Button',
     *         renderTo: Ext.getBody(),
     *         handler : function() {
     *             // this button will spit out a different number every time you click it.
     *             // so firstly we must check if that number is already set:
     *             if (this.clickCount) {
     *                 // looks like the property is already set, so lets just add 1 to that number and alert the user
     *                 this.clickCount++;
     *                 alert('You have clicked the button "' + this.clickCount + '" times.\n\nTry clicking it again..');
     *             } else {
     *                 // if the clickCount property is not set, we will set it and alert the user
     *                 this.clickCount = 1;
     *                 alert('You just clicked the button for the first time!\n\nTry pressing it again..');
     *             }
     *         }
     *     });
     *
     * A button within a container:
     *
     *     @example
     *     Ext.create('Ext.Container', {
     *         renderTo: Ext.getBody(),
     *         items   : [
     *             {
     *                 xtype: 'button',
     *                 text : 'My Button'
     *             }
     *         ]
     *     });
     *
     * A useful option of Button is the {@link #scale} configuration. This configuration has three different options:
     *
     * - ''small''
     * - ''medium''
     * - ''large''
     *
     * Example usage:
     *
     *     @example
     *     Ext.create('Ext.Button', {
     *         renderTo: document.body,
     *         text    : 'Click me',
     *         scale   : 'large'
     *     });
     *
     * Buttons can also be toggled. To enable this, you simple set the {@link #enableToggle} property to 'true'.
     * Example usage:
     *
     *     @example
     *     Ext.create('Ext.Button', {
     *         renderTo: Ext.getBody(),
     *         text: 'Click Me',
     *         enableToggle: true
     *     });
     *
     * You can assign a menu to a button by using the {@link #cfg-menu} configuration. This standard configuration
     * can either be a reference to a {@link Ext.menu.Menu menu} object, a {@link Ext.menu.Menu menu} id or a
     * {@link Ext.menu.Menu menu} config blob. When assigning a menu to a button, an arrow is automatically
     * added to the button.  You can change the alignment of the arrow using the {@link #arrowAlign} configuration
     * on button.  Example usage:
     *
     *     @example
     *     Ext.create('Ext.Button', {
     *         text      : 'Menu button',
     *         renderTo  : Ext.getBody(),
     *         arrowAlign: 'bottom',
     *         menu      : [
     *             {text: 'Item 1'},
     *             {text: 'Item 2'},
     *             {text: 'Item 3'},
     *             {text: 'Item 4'}
     *         ]
     *     });
     *
     * Using listeners, you can easily listen to events fired by any component, using the {@link #listeners}
     * configuration or using the {@link #addListener} method.  Button has a variety of different listeners:
     *
     * - 'click'
     * - 'toggle'
     * - 'mouseover'
     * - 'mouseout'
     * - 'mouseshow'
     * - 'menuhide'
     * - 'menutriggerover'
     * - 'menutriggerout'
     *
     * Example usage:
     *
     *     @example
     *     Ext.create('Ext.Button', {
     *         text     : 'Button',
     *         renderTo : Ext.getBody(),
     *         listeners: {
     *             click: function() {
     *                 // this == the button, as we are in the local scope
     *                 this.setText('I was clicked!');
     *             },
     *             mouseover: function() {
     *                 // set a new config which says we moused over, if not already set
     *                 if (!this.mousedOver) {
     *                     this.mousedOver = true;
     *                     alert('You moused over a button!\n\nI wont do this again.');
     *                 }
     *             }
     *         }
     *     });
     */
    export class Button extends Ext.Component implements Ext.button.ButtonConfig {
        /**
         * True if this button is disabled.
         * @readonly
         */
        disabled: boolean;

        /**
         * True if this button is hidden.
         * @readonly
         */
        hidden: boolean;

        isAction: any;

        /**
         * The {@link Ext.menu.Menu Menu} object associated with this Button when configured with the {@link #cfg-menu} config
         * option.
         */
        menu: Ext.menu.Menu;

        /**
         * True if this button is pressed (only if enableToggle = true).
         * @readonly
         */
        pressed: boolean;

        /**
         * A {@link Ext.Template Template} used to create the Button's DOM structure.
         *
         * Instances, or subclasses which need a different DOM structure may provide a different template layout in
         * conjunction with an implementation of {@link #getTemplateArgs}.
         */
        template: Ext.Template;

        /**
         * False to not allow a pressed Button to be depressed. Only valid when {@link #enableToggle} is true.
         *
         * Optional, Defaults to: true
         */
        allowDepress: boolean;

        /**
         * The side of the Button box to render the arrow if the button has an associated {@link #cfg-menu}. Two
         * values are allowed:
         *
         * - 'right'
         * - 'bottom'
         */
        arrowAlign: string;

        /**
         * The className used for the inner arrow element if the button has a menu.
         */
        arrowCls: string;

        /**
         * The base CSS class to add to all buttons.
         *
         * Optional, Defaults to: 'x-btn'
         */
        baseCls: string;

        /**
         * An object literal of parameters to pass to the url when the {@link #href} property is specified.
         */
        baseParams: any;

        /**
         * The DOM event that will fire the handler of the button. This can be any valid event name (dblclick, contextmenu).
         */
        clickEvent: string;

        /**
         * A CSS class string to apply to the button's main element.
         */
        cls: string;

        componentLayout: string|any;

        /**
         * Whether or not to destroy any associated menu when this button is destroyed. The menu
         * will be destroyed unless this is explicitly set to false.
         */
        destroyMenu: boolean;

        /**
         * True to enable pressed/not pressed toggling. If a {@link #toggleGroup} is specified, this
         * option will be set to true.
         *
         * Optional, Defaults to: false
         */
        enableToggle: boolean;

        /**
         * The CSS class to add to a button when it is in the focussed state.
         */
        focusCls: string;

        frame: boolean;

        /**
         * A numeric unicode character code to use as the icon for this button. The default
         * font-family for glyphs can be set globally using
         * {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()}. Alternatively, this
         * config option accepts a string with the charCode and font-family separated by the
         * '@' symbol. For example '65@My Font Family'.
         */
        glyph: number|string;

        /**
         * False to disable visual cues on mouseover, mouseout and mousedown.
         */
        handleMouseEvents: boolean;

        /**
         * A function called when the button is clicked (can be used instead of click event).
         * This button.
         * The click event.
         */
        handler: Function;

        /**
         * The URL to open when the button is clicked. Specifying this config causes the Button to be
         * rendered with the specified URL as the 'href' attribute of its '<a>' Element.
         *
         * This is better than specifying a click handler of
         *
         *     function() { window.location = "http://www.sencha.com" }
         *
         * because the UI will provide meaningful hints to the user as to what to expect upon clicking
         * the button, and will also allow the user to open in a new tab or window, bookmark or drag the URL, or directly save
         * the URL stream to disk.
         *
         * See also the {@link #hrefTarget} config.
         */
        href: string;

        /**
         * The target attribute to use for the underlying anchor. Only used if the {@link #href}
         * property is specified.
         *
         * Optional, Defaults to: "_blank"
         */
        hrefTarget: string;

        /**
         * The path to an image to display in the button.
         */
        icon: string;

        /**
         * The side of the Button box to render the icon. Four values are allowed:
         *
         * - 'top'
         * - 'right'
         * - 'bottom'
         * - 'left'
         */
        iconAlign: string;

        /**
         * A css class which sets a background image to be used as the icon for this button.
         */
        iconCls: string;

        /**
         * The CSS class to add to a button when it's menu is active.
         */
        menuActiveCls: string;

        /**
         * The position to align the menu to (see {@link Ext.util.Positionable#alignTo} for more details).
         */
        menuAlign: string;

        /**
         * The minimum width for this button (used to give a set of buttons a common width).
         * See also {@link Ext.panel.Panel}.{@link Ext.panel.Panel#minButtonWidth minButtonWidth}.
         */
        minWidth: number;

        /**
         * The CSS class to add to a button when it is in the over (hovered) state.
         */
        overCls: string;

        /**
         * If used in a {@link Ext.toolbar.Toolbar Toolbar}, the text to be used if this item is shown in the overflow menu.
         * See also {@link Ext.toolbar.Item}.'{@link Ext.toolbar.Item#overflowText overflowText}'.
         */
        overflowText: string;

        /**
         * An object literal of parameters to pass to the url when the {@link #href} property is specified. Any params
         * override {@link #baseParams}. New params can be set using the {@link #setParams} method.
         */
        params: any;

        /**
         * The CSS class to add to a button when it is in the pressed state.
         */
        pressedCls: string;

        /**
         * True to prevent the default action when the {@link #clickEvent} is processed.
         */
        preventDefault: boolean;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * True to repeat fire the click event while the mouse is down. This can also be a
         * {@link Ext.util.ClickRepeater ClickRepeater} config object.
         *
         * Optional, Defaults to: false
         */
        repeat: boolean|any;

        /**
         * The size of the Button. Three values are allowed:
         *
         * - 'small' - Results in the button element being 16px high.
         * - 'medium' - Results in the button element being 24px high.
         * - 'large' - Results in the button element being 32px high.
         */
        scale: any;

        /**
         * The scope (**this** reference) in which the '{@link #handler}' and '{@link #toggleHandler}' is executed.
         * Defaults to this Button.
         */
        scope: any;

        /**
         * True to force an attached {@link #cfg-menu} with no items to be shown when clicking
         * this button. By default, the menu will not show if it is empty.
         */
        showEmptyMenu: boolean;

        shrinkWrap: boolean|number;

        /**
         * Set a DOM tabIndex for this button.
         */
        tabIndex: number;

        /**
         * The button text to be used as innerHTML (html tags are accepted).
         */
        text: string;

        /**
         * The text alignment for this button (center, left, right).
         */
        textAlign: string;

        /**
         * The group this toggle button is a member of (only 1 per group can be pressed). If a toggleGroup
         * is specified, the {@link #enableToggle} configuration will automatically be set to true.
         */
        toggleGroup: string;

        /**
         * Function called when a Button with {@link #enableToggle} set to true is clicked.
         * This button.
         * The next state of the Button, true means pressed.
         */
        toggleHandler: Function;

        /**
         * The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or
         * QuickTips config object.
         */
        tooltip: string|any;

        /**
         * The type of tooltip to use. Either 'qtip' for QuickTips or 'title' for title attribute.
         */
        tooltipType: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * This method returns an object which provides substitution parameters for the {@link #renderTpl XTemplate} used to
         * create this Button's DOM structure.
         *
         * Instances or subclasses which use a different Template to create a different DOM structure may need to provide
         * their own implementation of this method.
         *
         * @return {Object} Substitution data for a Template. The default implementation which provides data for the default
         * {@link #template} returns an Object containing the following properties:
         * @return {String} return.innerCls A CSS class to apply to the button's text element.
         * @return {String} return.splitCls A CSS class to determine the presence and position of an arrow icon.
         * (''x-btn-arrow'' or ''x-btn-arrow-bottom'' or '''')
         * @return {String} return.iconUrl The url for the button icon.
         * @return {String} return.iconCls The CSS class for the button icon.
         * @return {String} return.glyph The glyph to use as the button icon.
         * @return {String} return.glyphCls The CSS class to use for the glyph element.
         * @return {String} return.glyphFontFamily The CSS font-family to use for the glyph element.
         * @return {String} return.text The {@link #text} to display ion the Button.
         */
        protected getTemplateArgs(): any;

        /**
         * Gets the text for this Button
         * @return {String} The button text
         */
        getText(): string;

        /**
         * Returns true if the button has a menu and it is visible
         * @return {Boolean}
         */
        hasVisibleMenu(): boolean;

        /**
         * Hides this button's menu (if it has one)
         */
        hideMenu();

        protected initComponent();

        protected onDisable();

        /**
         * Sets this button's glyph
         * @param {Number/String} glyph the numeric charCode or string charCode/font-family.
         * This parameter expects a format consistent with that of {@link #glyph}
         * @return {Ext.button.Button} this
         */
        setGlyph(glyph: number|string): Ext.button.Button;

        /**
         * Assigns this Button's click handler
         * @param {Function} handler The function to call when the button is clicked
         * @param {Object} [scope] The scope ('this' reference) in which the handler function is executed.
         * Defaults to this Button.
         * @return {Ext.button.Button} this
         */
        setHandler(handler: Function, scope?: any): Ext.button.Button;

        /**
         * Sets the href of the embedded anchor element to the passed URL.
         *
         * Also appends any configured {@link #cfg-baseParams} and parameters set through {@link #setParams}.
         * @param {String} href The URL to set in the anchor element.
         */
        setHref(href: string);

        /**
         * Sets the background image (inline style) of the button. This method also changes the value of the {@link #icon}
         * config internally.
         * @param {String} icon The path to an image to display in the button
         * @return {Ext.button.Button} this
         */
        setIcon(icon: string): Ext.button.Button;

        /**
         * Sets the CSS class that provides a background image to use as the button's icon. This method also changes the
         * value of the {@link #iconCls} config internally.
         * @param {String} cls The CSS class providing the icon image
         * @return {Ext.button.Button} this
         */
        setIconCls(cls: string): Ext.button.Button;

        /**
         * Sets the href of the link dynamically according to the params passed, and any {@link #baseParams} configured.
         *
         * **Only valid if the Button was originally configured with a {@link #href}**
         *
         * @param {Object} params Parameters to use in the href URL.
         */
        setParams(params: any);

        /**
         * Method to change the scale of the button. See {@link #scale} for allowed configurations.
         * @param {String} scale The scale to change to.
         */
        setScale(scale: string);

        /**
         * Sets this Button's text
         * @param {String} text The button text
         * @return {Ext.button.Button} this
         */
        setText(text: string): Ext.button.Button;

        /**
         * Sets the text alignment for this button.
         * @param {String} align The new alignment of the button text. See {@link #textAlign}.
         */
        setTextAlign(align: string);

        /**
         * Sets the tooltip for this Button.
         *
         * @param {String/Object} tooltip This may be:
         *
         *   - **String** : A string to be used as innerHTML (html tags are accepted) to show in a tooltip
         *   - **Object** : A configuration object for {@link Ext.tip.QuickTipManager#register}.
         *
         * @return {Ext.button.Button} this
         */
        setTooltip(tooltip: string|any): Ext.button.Button;

        /**
         * Shows this button's menu (if it has one)
         */
        showMenu();

        /**
         * If a state it passed, it becomes the pressed state otherwise the current state is toggled.
         * @param {Boolean} [state] Force a particular state
         * @param {Boolean} [suppressEvent=false] True to stop events being fired when calling this method.
         * @return {Ext.button.Button} this
         */
        toggle(state?: boolean, suppressEvent?: boolean): Ext.button.Button;

        /**
         * Fires when this button is clicked, before the configured {@link #handler} is invoked. Execution of the
         * {@link #handler} may be vetoed by returning <code>false</code> to this event.
         * @param {Event} e The click event
         */
        click(that: Ext.button.Button, e: Event);

        /**
         * Fired when the button's glyph is changed by the {@link #setGlyph} method.
         */
        glyphchange(that: Ext.button.Button, newGlyph: number|string, oldGlyph: number|string);

        /**
         * Fired when the button's icon is changed by the {@link #setIcon} or {@link #setIconCls} methods.
         */
        iconchange(that: Ext.button.Button, oldIcon: string, newIcon: string);

        /**
         * If this button has a menu, this event fires when it is hidden
         */
        menuhide(that: Ext.button.Button, menu: Ext.menu.Menu);

        /**
         * If this button has a menu, this event fires when it is shown
         */
        menushow(that: Ext.button.Button, menu: Ext.menu.Menu);

        /**
         * If this button has a menu, this event fires when the mouse leaves the menu triggering element
         */
        menutriggerout(that: Ext.button.Button, menu: Ext.menu.Menu, e: Event);

        /**
         * If this button has a menu, this event fires when the mouse enters the menu triggering element
         */
        menutriggerover(that: Ext.button.Button, menu: Ext.menu.Menu, e: Event);

        /**
         * Fires when the mouse exits the button
         * @param {Event} e The event object
         */
        mouseout(that: Ext.button.Button, e: Event);

        /**
         * Fires when the mouse hovers over the button
         * @param {Event} e The event object
         */
        mouseover(that: Ext.button.Button, e: Event);

        /**
         * Fired when the button's text is changed by the {@link #setText} method.
         */
        textchange(that: Ext.button.Button, oldText: string, newText: string);
    }

    interface CycleConfig extends Ext.button.SplitConfig {
        /**
         * A callback function that will be invoked each time the active menu item in the button's menu has changed. If this
         * callback is not supplied, the SplitButton will instead fire the {@link #change} event on active item change. The
         * changeHandler function will be called with the following argument list: (SplitButton this, Ext.menu.CheckItem
         * item)
         */
        changeHandler?: Function;

        /**
         * The charCode to be used as the static icon for this button.  This icon will always be
         * displayed regardless of which item is selected in the dropdown list. This override
         * the default behavior of changing the button's icon to match the selected item's icon
         * on change. This property expects a format consistent with that of {@link #glyph}
         */
        forceGlyph?: number|string;

        /**
         * A css class which sets an image to be used as the static icon for this button. This icon will always be displayed
         * regardless of which item is selected in the dropdown list. This overrides the default behavior of changing the
         * button's icon to match the selected item's icon on change.
         */
        forceIcon?: string;

        /**
         * An array of {@link Ext.menu.CheckItem} **config** objects to be used when creating the button's menu items (e.g.,
         * '{text:'Foo', iconCls:'foo-icon'}')
         *
         * @deprecated 4.0 Use the {@link #cfg-menu} config instead. All menu items will be created as
         * {@link Ext.menu.CheckItem CheckItems}.
         */
        items?: any;

        /**
         * A static string to prepend before the active item's text when displayed as the button's text (only applies when
         * showText = true).
         *
         * Optional, Defaults to: ''
         */
        prependText?: string;

        /**
         * True to display the active item's text as the button text. The Button will show its
         * configured {@link #text} if this config is omitted.
         *
         * Optional, Defaults to: false
         */
        showText?: boolean;
    }

    /**
     * A specialized SplitButton that contains a menu of {@link Ext.menu.CheckItem} elements. The button automatically
     * cycles through each menu item on click, raising the button's {@link #change} event (or calling the button's
     * {@link #changeHandler} function, if supplied) for the active menu item. Clicking on the arrow section of the
     * button displays the dropdown menu just like a normal SplitButton.  Example usage:
     *
     *     @example
     *     Ext.create('Ext.button.Cycle', {
     *         showText: true,
     *         prependText: 'View as ',
     *         renderTo: Ext.getBody(),
     *         menu: {
     *             id: 'view-type-menu',
     *             items: [{
     *                 text: 'text only',
     *                 iconCls: 'view-text',
     *                 checked: true
     *             },{
     *                 text: 'HTML',
     *                 iconCls: 'view-html'
     *             }]
     *         },
     *         changeHandler: function(cycleBtn, activeItem) {
     *             Ext.Msg.alert('Change View', activeItem.text);
     *         }
     *     });
     */
    export class Cycle extends Ext.button.Split implements Ext.button.CycleConfig {
        /**
         * The {@link Ext.menu.Menu Menu} object used to display the {@link Ext.menu.CheckItem CheckItems} representing the
         * available choices.
         */
        menu: Ext.menu.Menu;

        /**
         * A callback function that will be invoked each time the active menu item in the button's menu has changed. If this
         * callback is not supplied, the SplitButton will instead fire the {@link #change} event on active item change. The
         * changeHandler function will be called with the following argument list: (SplitButton this, Ext.menu.CheckItem
         * item)
         */
        changeHandler: Function;

        /**
         * The charCode to be used as the static icon for this button.  This icon will always be
         * displayed regardless of which item is selected in the dropdown list. This override
         * the default behavior of changing the button's icon to match the selected item's icon
         * on change. This property expects a format consistent with that of {@link #glyph}
         */
        forceGlyph: number|string;

        /**
         * A css class which sets an image to be used as the static icon for this button. This icon will always be displayed
         * regardless of which item is selected in the dropdown list. This overrides the default behavior of changing the
         * button's icon to match the selected item's icon on change.
         */
        forceIcon: string;

        /**
         * An array of {@link Ext.menu.CheckItem} **config** objects to be used when creating the button's menu items (e.g.,
         * '{text:'Foo', iconCls:'foo-icon'}')
         *
         * @deprecated 4.0 Use the {@link #cfg-menu} config instead. All menu items will be created as
         * {@link Ext.menu.CheckItem CheckItems}.
         */
        items: any;

        /**
         * A static string to prepend before the active item's text when displayed as the button's text (only applies when
         * showText = true).
         *
         * Optional, Defaults to: ''
         */
        prependText: string;

        /**
         * True to display the active item's text as the button text. The Button will show its
         * configured {@link #text} if this config is omitted.
         *
         * Optional, Defaults to: false
         */
        showText: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Gets the currently active menu item.
         * @return {Ext.menu.CheckItem} The active item
         */
        getActiveItem(): Ext.menu.CheckItem;

        /**
         * Sets the button's active menu item.
         * @param {Ext.menu.CheckItem} item The item to activate
         * @param {Boolean} [suppressEvent=false] True to prevent the button's change event from firing.
         */
        setActiveItem(item: Ext.menu.CheckItem, suppressEvent?: boolean);

        /**
         * This is normally called internally on button click, but can be called externally to advance the button's active
         * item programmatically to the next one in the menu. If the current item is the last one in the menu the active
         * item will be set to the first item in the menu.
         */
        toggleSelected();

        /**
         * Fires after the button's active menu item has changed. Note that if a {@link #changeHandler} function is
         * set on this CycleButton, it will be called instead on active item change and this change event will not
         * be fired.
         * @param {Ext.menu.CheckItem} item The menu item that was selected
         */
        change(that: Ext.button.Cycle, item: Ext.menu.CheckItem);
    }

    export class Manager {
    }

    interface SplitConfig extends Ext.button.ButtonConfig {
        /**
         * A function called when the arrow button is clicked (can be used instead of click event)
         * The click event.
         */
        arrowHandler?: Function;

        /**
         * The title attribute of the arrow.
         */
        arrowTooltip?: string;
    }

    /**
     * A split button that provides a built-in dropdown arrow that can fire an event separately from the default click event
     * of the button. Typically this would be used to display a dropdown menu that provides additional options to the
     * primary button action, but any custom handler can provide the arrowclick implementation.  Example usage:
     *
     *     @example
     *     // display a dropdown menu:
     *     Ext.create('Ext.button.Split', {
     *         renderTo: Ext.getBody(),
     *         text: 'Options',
     *         // handle a click on the button itself
     *         handler: function() {
     *             alert("The button was clicked");
     *         },
     *         menu: new Ext.menu.Menu({
     *             items: [
     *                 // these will render as dropdown menu items when the arrow is clicked:
     *                 {text: 'Item 1', handler: function(){ alert("Item 1 clicked"); }},
     *                 {text: 'Item 2', handler: function(){ alert("Item 2 clicked"); }}
     *             ]
     *         })
     *     });
     *
     * Instead of showing a menu, you can provide any type of custom functionality you want when the dropdown
     * arrow is clicked:
     *
     *     Ext.create('Ext.button.Split', {
     *         renderTo: 'button-ct',
     *         text: 'Options',
     *         handler: optionsHandler,
     *         arrowHandler: myCustomHandler
     *     });
     */
    export class Split extends Ext.button.Button implements Ext.button.SplitConfig {
        /**
         * A function called when the arrow button is clicked (can be used instead of click event)
         * The click event.
         */
        arrowHandler: Function;

        /**
         * The title attribute of the arrow.
         */
        arrowTooltip: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Sets this button's arrow click handler.
         * @param {Function} handler The function to call when the arrow is clicked.
         * @param {Object} scope (optional) Scope for the function passed above.
         */
        setArrowHandler(handler: Function, scope: any);

        /**
         * Fires when this button's arrow is clicked.
         * @param {Event} e The click event.
         */
        arrowclick(that: Ext.button.Split, e: Event);
    }
}

declare module Ext.chart {
    /**
     * A mixin providing callout functionality for Ext.chart.series.Series.
     */
    export class Callout extends Ext.Base {
        constructor();
    }

    interface ChartConfig extends Ext.draw.ComponentConfig {
        /**
         * Array of {@link Ext.chart.axis.Axis Axis} instances or config objects.  For example:
         *
         *     axes: [{
         *         type: 'Numeric',
         *         position: 'left',
         *         fields: ['data1'],
         *         title: 'Number of Hits',
         *         minimum: 0,
         *         //one minor tick between two major ticks
         *         minorTickSteps: 1
         *     }, {
         *         type: 'Category',
         *         position: 'bottom',
         *         fields: ['name'],
         *         title: 'Month of the Year'
         *     }]
         */
        axes?: Ext.chart.axis.Axis;

        /**
         * The chart background. This can be a gradient object, image, or color. Defaults to false for no
         * background. For example, if 'background' were to be a color we could set the object as
         *
         *     background: {
         *         //color string
         *         fill: '#ccc'
         *     }
         *
         * You can specify an image by using:
         *
         *     background: {
         *         image: 'http://path.to.image/'
         *     }
         *
         * Also you can specify a gradient by using the gradient object syntax:
         *
         *     background: {
         *         gradient: {
         *             id: 'gradientId',
         *             angle: 45,
         *             stops: {
         *                 0: {
         *                     color: '#555'
         *                 }
         *                 100: {
         *                     color: '#ddd'
         *                 }
         *             }
         *         }
         *     }
         */
        background?: any|boolean;

        /**
         * Define a set of gradients that can be used as 'fill' property in sprites. The gradients array is an
         * array of objects with the following properties:
         *
         * - **id** - string - The unique name of the gradient.
         * - **angle** - number, optional - The angle of the gradient in degrees.
         * - **stops** - object - An object with numbers as keys (from 0 to 100) and style objects as values
         *
         * For example:
         *
         *     gradients: [{
         *         id: 'gradientId',
         *         angle: 45,
         *         stops: {
         *             0: {
         *                 color: '#555'
         *             },
         *             100: {
         *                 color: '#ddd'
         *             }
         *         }
         *     }, {
         *         id: 'gradientId2',
         *         angle: 0,
         *         stops: {
         *             0: {
         *                 color: '#590'
         *             },
         *             20: {
         *                 color: '#599'
         *             },
         *             100: {
         *                 color: '#ddd'
         *             }
         *         }
         *     }]
         *
         * Then the sprites can use 'gradientId' and 'gradientId2' by setting the fill attributes to those ids, for example:
         *
         *     sprite.setAttributes({
         *         fill: 'url(#gradientId)'
         *     }, true);
         */
        gradients?: any;

        /**
         * The amount of inset padding in pixels for the chart. Defaults to 10.
         */
        insetPadding?: number;

        /**
         * True for the default legend display or a legend config object. Defaults to false.
         */
        legend?: boolean|any;

        /**
         * Array of {@link Ext.chart.series.Series Series} instances or config objects.  For example:
         *
         *     series: [{
         *         type: 'column',
         *         axis: 'left',
         *         listeners: {
         *             'afterrender': function() {
         *                 console('afterrender');
         *             }
         *         },
         *         xField: 'category',
         *         yField: 'data1'
         *     }]
         */
        series?: Ext.chart.series.Series;

        /**
         * The store that supplies data to this chart.
         */
        store?: Ext.data.Store;

        /**
         * The name of the theme to be used. A theme defines the colors and other visual displays of tick marks
         * on axis, text, title text, line colors, marker colors and styles, etc. Possible theme values are 'Base', 'Green',
         * 'Sky', 'Red', 'Purple', 'Blue', 'Yellow' and also six category themes 'Category1' to 'Category6'. Default value
         * is 'Base'.
         */
        theme?: string;
    }

    /**
     * Charts provide a flexible way to achieve a wide range of data visualization capablitities.
     * Each Chart gets its data directly from a {@link Ext.data.Store Store}, and automatically
     * updates its display whenever data in the Store changes. In addition, the look and feel
     * of a Chart can be customized using {@link Ext.chart.theme.Theme Theme}s.
     *
     * ## Creating a Simple Chart
     *
     * Every Chart has three key parts - a {@link Ext.data.Store Store} that contains the data,
     * an array of {@link Ext.chart.axis.Axis Axes} which define the boundaries of the Chart,
     * and one or more {@link Ext.chart.series.Series Series} to handle the visual rendering of the data points.
     *
     * ### 1. Creating a Store
     *
     * The first step is to create a {@link Ext.data.Model Model} that represents the type of
     * data that will be displayed in the Chart. For example the data for a chart that displays
     * a weather forecast could be represented as a series of "WeatherPoint" data points with
     * two fields - "temperature", and "date":
     *
     *     Ext.define('WeatherPoint', {
     *         extend: 'Ext.data.Model',
     *         fields: ['temperature', 'date']
     *     });
     *
     * Next a {@link Ext.data.Store Store} must be created.  The store contains a collection of "WeatherPoint" Model instances.
     * The data could be loaded dynamically, but for sake of ease this example uses inline data:
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'WeatherPoint',
     *         data: [
     *             { temperature: 58, date: new Date(2011, 1, 1, 8) },
     *             { temperature: 63, date: new Date(2011, 1, 1, 9) },
     *             { temperature: 73, date: new Date(2011, 1, 1, 10) },
     *             { temperature: 78, date: new Date(2011, 1, 1, 11) },
     *             { temperature: 81, date: new Date(2011, 1, 1, 12) }
     *         ]
     *     });
     *
     * For additional information on Models and Stores please refer to the [Data Guide](#/guide/data).
     *
     * ### 2. Creating the Chart object
     *
     * Now that a Store has been created it can be used in a Chart:
     *
     *     Ext.create('Ext.chart.Chart', {
     *        renderTo: Ext.getBody(),
     *        width: 400,
     *        height: 300,
     *        store: store
     *     });
     *
     * That's all it takes to create a Chart instance that is backed by a Store.
     * However, if the above code is run in a browser, a blank screen will be displayed.
     * This is because the two pieces that are responsible for the visual display,
     * the Chart's {@link #cfg-axes axes} and {@link #cfg-series series}, have not yet been defined.
     *
     * ### 3. Configuring the Axes
     *
     * {@link Ext.chart.axis.Axis Axes} are the lines that define the boundaries of the data points that a Chart can display.
     * This example uses one of the most common Axes configurations - a horizontal "x" axis, and a vertical "y" axis:
     *
     *     Ext.create('Ext.chart.Chart', {
     *         ...
     *         axes: [
     *             {
     *                 title: 'Temperature',
     *                 type: 'Numeric',
     *                 position: 'left',
     *                 fields: ['temperature'],
     *                 minimum: 0,
     *                 maximum: 100
     *             },
     *             {
     *                 title: 'Time',
     *                 type: 'Time',
     *                 position: 'bottom',
     *                 fields: ['date'],
     *                 dateFormat: 'ga'
     *             }
     *         ]
     *     });
     *
     * The "Temperature" axis is a vertical {@link Ext.chart.axis.Numeric Numeric Axis} and is positioned on the left edge of the Chart.
     * It represents the bounds of the data contained in the "WeatherPoint" Model's "temperature" field that was
     * defined above. The minimum value for this axis is "0", and the maximum is "100".
     *
     * The horizontal axis is a {@link Ext.chart.axis.Time Time Axis} and is positioned on the bottom edge of the Chart.
     * It represents the bounds of the data contained in the "WeatherPoint" Model's "date" field.
     * The {@link Ext.chart.axis.Time#cfg-dateFormat dateFormat}
     * configuration tells the Time Axis how to format it's labels.
     *
     * Here's what the Chart looks like now that it has its Axes configured:
     *
     * {@img Ext.chart.Chart/Ext.chart.Chart1.png Chart Axes}
     *
     * ### 4. Configuring the Series
     *
     * The final step in creating a simple Chart is to configure one or more {@link Ext.chart.series.Series Series}.
     * Series are responsible for the visual representation of the data points contained in the Store.
     * This example only has one Series:
     *
     *     Ext.create('Ext.chart.Chart', {
     *         ...
     *         axes: [
     *             ...
     *         ],
     *         series: [
     *             {
     *                 type: 'line',
     *                 xField: 'date',
     *                 yField: 'temperature'
     *             }
     *         ]
     *     });
     *
     * This Series is a {@link Ext.chart.series.Line Line Series}, and it uses the "date" and "temperature" fields
     * from the "WeatherPoint" Models in the Store to plot its data points:
     *
     * {@img Ext.chart.Chart/Ext.chart.Chart2.png Line Series}
     *
     * See the [Line Charts Example](#!/example/charts/Charts.html) for a live demo.
     *
     * ## Themes
     *
     * The color scheme for a Chart can be easily changed using the {@link #cfg-theme theme} configuration option:
     *
     *     Ext.create('Ext.chart.Chart', {
     *         ...
     *         theme: 'Green',
     *         ...
     *     });
     *
     * {@img Ext.chart.Chart/Ext.chart.Chart3.png Green Theme}
     *
     * For more information on Charts please refer to the [Charting Guide](#/guide/charting).
     */
    export class Chart extends Ext.draw.Component implements Ext.chart.ChartConfig {
        /**
         * Array of {@link Ext.chart.axis.Axis Axis} instances or config objects.  For example:
         *
         *     axes: [{
         *         type: 'Numeric',
         *         position: 'left',
         *         fields: ['data1'],
         *         title: 'Number of Hits',
         *         minimum: 0,
         *         //one minor tick between two major ticks
         *         minorTickSteps: 1
         *     }, {
         *         type: 'Category',
         *         position: 'bottom',
         *         fields: ['name'],
         *         title: 'Month of the Year'
         *     }]
         */
        axes: Ext.chart.axis.Axis;

        /**
         * The chart background. This can be a gradient object, image, or color. Defaults to false for no
         * background. For example, if 'background' were to be a color we could set the object as
         *
         *     background: {
         *         //color string
         *         fill: '#ccc'
         *     }
         *
         * You can specify an image by using:
         *
         *     background: {
         *         image: 'http://path.to.image/'
         *     }
         *
         * Also you can specify a gradient by using the gradient object syntax:
         *
         *     background: {
         *         gradient: {
         *             id: 'gradientId',
         *             angle: 45,
         *             stops: {
         *                 0: {
         *                     color: '#555'
         *                 }
         *                 100: {
         *                     color: '#ddd'
         *                 }
         *             }
         *         }
         *     }
         */
        background: any|boolean;

        /**
         * Define a set of gradients that can be used as 'fill' property in sprites. The gradients array is an
         * array of objects with the following properties:
         *
         * - **id** - string - The unique name of the gradient.
         * - **angle** - number, optional - The angle of the gradient in degrees.
         * - **stops** - object - An object with numbers as keys (from 0 to 100) and style objects as values
         *
         * For example:
         *
         *     gradients: [{
         *         id: 'gradientId',
         *         angle: 45,
         *         stops: {
         *             0: {
         *                 color: '#555'
         *             },
         *             100: {
         *                 color: '#ddd'
         *             }
         *         }
         *     }, {
         *         id: 'gradientId2',
         *         angle: 0,
         *         stops: {
         *             0: {
         *                 color: '#590'
         *             },
         *             20: {
         *                 color: '#599'
         *             },
         *             100: {
         *                 color: '#ddd'
         *             }
         *         }
         *     }]
         *
         * Then the sprites can use 'gradientId' and 'gradientId2' by setting the fill attributes to those ids, for example:
         *
         *     sprite.setAttributes({
         *         fill: 'url(#gradientId)'
         *     }, true);
         */
        gradients: any;

        /**
         * The amount of inset padding in pixels for the chart. Defaults to 10.
         */
        insetPadding: number;

        /**
         * True for the default legend display or a legend config object. Defaults to false.
         */
        legend: boolean|any;

        /**
         * Array of {@link Ext.chart.series.Series Series} instances or config objects.  For example:
         *
         *     series: [{
         *         type: 'column',
         *         axis: 'left',
         *         listeners: {
         *             'afterrender': function() {
         *                 console('afterrender');
         *             }
         *         },
         *         xField: 'category',
         *         yField: 'data1'
         *     }]
         */
        series: Ext.chart.series.Series;

        /**
         * The store that supplies data to this chart.
         */
        store: Ext.data.Store;

        /**
         * The name of the theme to be used. A theme defines the colors and other visual displays of tick marks
         * on axis, text, title text, line colors, marker colors and styles, etc. Possible theme values are 'Base', 'Green',
         * 'Sky', 'Red', 'Purple', 'Blue', 'Yellow' and also six category themes 'Category1' to 'Category6'. Default value
         * is 'Base'.
         */
        theme: string;

        bindStore(store: any, initial: any);

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected getStoreListeners();

        protected initComponent();

        /**
         * Redraws the chart. If animations are set this will animate the chart too.
         * @param {Boolean} resize (optional) flag which changes the default origin points of the chart for animations.
         */
        redraw(resize: boolean);

        /**
         * Saves the chart by either triggering a download or returning a string containing the chart data
         * as SVG.  The action depends on the export type specified in the passed configuration. The chart
         * will be exported using either the {@link Ext.draw.engine.SvgExporter} or the {@link Ext.draw.engine.ImageExporter}
         * classes.
         *
         * Possible export types:
         *
         * - 'image/png'
         * - 'image/jpeg',
         * - 'image/svg+xml'
         *
         * If 'image/svg+xml' is specified, the SvgExporter will be used.
         * If 'image/png' or 'image/jpeg' are specified, the ImageExporter will be used. This exporter
         * must post the SVG data to a remote server to have the data processed, see the {@link Ext.draw.engine.ImageExporter}
         * for more details.
         *
         * Example usage:
         *
         *     chart.save({
         *          type: 'image/png'
         *     });
         *
         * **Important**: By default, chart data is sent to a server operated
         * by Sencha to do data processing. You may change this default by
         * setting the {@link Ext.draw.engine.ImageExporter#defaultUrl defaultUrl} of the {@link Ext.draw.engine.ImageExporter} class.
         * In addition, please note that this service only creates PNG images.
         *
         * @param {Object} [config] The configuration to be passed to the exporter.
         * See the export method for the appropriate exporter for the relevant
         * configuration options
         * @return {Object} See the return types for the appropriate exporter
         */
        save(config?: Ext.chart.ChartConfig): any;

        /**
         * Fires before a refresh to the chart data is called. If the beforerefresh handler returns false the
         * {@link #event-refresh} action will be cancelled.
         */
        beforerefresh(that: Ext.chart.Chart);

        /**
         * Fires after the chart data has been refreshed.
         */
        refresh(that: Ext.chart.Chart);
    }

    interface HighlightConfig {
        /**
         * Set to 'true' to enable highlighting using the {@link #highlightCfg default highlight attributes}.
         *
         * Can also be an object with style properties (i.e fill, stroke, stroke-width, radius) which are may override the {@link #highlightCfg default highlight attributes}.
         *
         * Optional, Defaults to: false
         */
        highlight?: boolean|any;
    }

    /**
     * A mixin providing highlight functionality for Ext.chart.series.Series.
     */
    export class Highlight extends Ext.Base implements Ext.chart.HighlightConfig {
        /**
         * The default properties to apply as a highight. Value is
         *
         *    {
         *        fill: '#fdd',
         *        "stroke-width": 5,
         *        stroke: "#f55'
         *    }
         */
        highlightCfg: any;

        /**
         * Set to 'true' to enable highlighting using the {@link #highlightCfg default highlight attributes}.
         *
         * Can also be an object with style properties (i.e fill, stroke, stroke-width, radius) which are may override the {@link #highlightCfg default highlight attributes}.
         *
         * Optional, Defaults to: false
         */
        highlight: boolean|any;

        constructor(config: Ext.chart.HighlightConfig);

        /**
         * Highlight the given series item.
         * @param {Object} item Info about the item; same format as returned by #getItemForPoint.
         */
        highlightItem(item: any);

        /**
         * Un-highlight any existing highlights
         */
        unHighlightItem();
    }

    interface LabelConfig {
        /**
         * Object with the following properties:
         *
         *
         * Specifies the presence and position of the labels. The possible values depend on the chart type.
         * For Line and Scatter charts: "under" | "over" | "rotate".
         * For Bar and Column charts: "insideStart" | "insideEnd" | "outside".
         * For Pie charts: "outside" | "rotate".
         * For all charts: "none" hides the labels and "middle" is reserved for future use.
         * On stacked Bar and stacked Column charts, if 'stackedDisplay' is set, the values
         * "over" or "under" can be passed internally to {@link #onCreateLabel} and {@link #onPlaceLabel}
         * (however they cannot be used by the application as config values for label.display).
         *
         * Default value: 'none'.
         *
         *
         * The type of label we want to display as a summary on a stacked
         * bar or a stacked column.  If set to 'total', the total amount
         * of all the stacked values is displayed on top of the column.
         * If set to 'balances', the total amount of the positive values
         * is displayed on top of the column and the total amount of the
         * negative values is displayed at the bottom.
         *
         * Default value: 'none'.
         *
         *
         * The color of the label text.
         *
         * Default value: '#000' (black).
         *
         *
         * True to render the label in contrasting color with the backround of a column
         * in a Bar chart or of a slice in a Pie chart. The label color should be specified
         * in hex values (eg. '#f00' or '#ff0000'), not as a CSS color name (eg. 'red').
         *
         * Default value: false.
         *
         *
         * The name(s) of the field(s) to be displayed in the labels. If your chart has 3 series
         * that correspond to the fields 'a', 'b', and 'c' of your model and you only want to
         * display labels for the series 'c', you must still provide an array '[null, null, 'c']'.
         *
         * Default value: 'name'.
         *
         *
         * Specifies the minimum distance from a label to the origin of
         * the visualization.  This parameter is useful when using
         * PieSeries width variable pie slice lengths.
         *
         * Default value: 50.
         *
         *
         * The font used for the labels.
         *
         * Default value: '"11px Helvetica, sans-serif"'.
         *
         *
         * Either "horizontal" or "vertical".
         *
         * Default value: '"horizontal"'.
         *
         *
         * Optional function for formatting the label into a displayable value.
         *
         * The arguments to the method are:
         *
         *   - *'value'* The value
         *   - *'label'*, *'storeItem'*, *'item'*, *'i'*, *'display'*, *'animate'*, *'index'*
         *
         *     Same arguments as {@link #onPlaceLabel}.
         *
         *     Default value: 'function(v) { return v; }'
         */
        label?: any;
    }

    /**
     * Labels is a mixin to the Series class. Labels methods are implemented
     * in each of the Series (Pie, Bar, etc) for label creation and placement.
     *
     * The 2 methods that must be implemented by the Series are:
     *
     * - {@link #onCreateLabel}
     * - {@link #onPlaceLabel}
     *
     * The application can override these methods to control the style and
     * location of the labels. For instance, to display the labels in green and
     * add a '+' symbol when the value of a Line series exceeds 50:
     *
     *      Ext.define('Ext.chart.series.MyLine', {
     *          extend: 'Ext.chart.series.Line',
     *          alias: ['series.myline', 'Ext.chart.series.MyLine'],
     *          type: 'MYLINE',
     *
     *          onPlaceLabel: function(label, storeItem, item, i, display, animate){
     *              if (storeItem.data.y >= 50) {
     *                  label.setAttributes({
     *                      fill: '#080',
     *                      text: "+" + storeItem.data.y
     *                  }, true);
     *              }
     *              return this.callParent(arguments);
     *          }
     *      });
     *
     * Note that for simple effects, like the example above, it is simpler
     * for the application to provide a label.renderer function in the config:
     *
     *       label: {
     *           renderer: function(value, label, storeItem, item, i, display, animate, index) {
     *               if (value >= 50) {
     *                   label.setAttributes({fill:'#080'});
     *                   value = "+" + value;
     *               }
     *               return value;
     *           }
     *       }
     *
     * The rule of thumb is that to customize the value and modify simple visual attributes, it
     * is simpler to use a renderer function, while overridding 'onCreateLabel' and 'onPlaceLabel'
     * allows the application to take entire control over the labels.
     */
    export class Label extends Ext.Base implements Ext.chart.LabelConfig {
        /**
         * Object with the following properties:
         *
         *
         * Specifies the presence and position of the labels. The possible values depend on the chart type.
         * For Line and Scatter charts: "under" | "over" | "rotate".
         * For Bar and Column charts: "insideStart" | "insideEnd" | "outside".
         * For Pie charts: "outside" | "rotate".
         * For all charts: "none" hides the labels and "middle" is reserved for future use.
         * On stacked Bar and stacked Column charts, if 'stackedDisplay' is set, the values
         * "over" or "under" can be passed internally to {@link #onCreateLabel} and {@link #onPlaceLabel}
         * (however they cannot be used by the application as config values for label.display).
         *
         * Default value: 'none'.
         *
         *
         * The type of label we want to display as a summary on a stacked
         * bar or a stacked column.  If set to 'total', the total amount
         * of all the stacked values is displayed on top of the column.
         * If set to 'balances', the total amount of the positive values
         * is displayed on top of the column and the total amount of the
         * negative values is displayed at the bottom.
         *
         * Default value: 'none'.
         *
         *
         * The color of the label text.
         *
         * Default value: '#000' (black).
         *
         *
         * True to render the label in contrasting color with the backround of a column
         * in a Bar chart or of a slice in a Pie chart. The label color should be specified
         * in hex values (eg. '#f00' or '#ff0000'), not as a CSS color name (eg. 'red').
         *
         * Default value: false.
         *
         *
         * The name(s) of the field(s) to be displayed in the labels. If your chart has 3 series
         * that correspond to the fields 'a', 'b', and 'c' of your model and you only want to
         * display labels for the series 'c', you must still provide an array '[null, null, 'c']'.
         *
         * Default value: 'name'.
         *
         *
         * Specifies the minimum distance from a label to the origin of
         * the visualization.  This parameter is useful when using
         * PieSeries width variable pie slice lengths.
         *
         * Default value: 50.
         *
         *
         * The font used for the labels.
         *
         * Default value: '"11px Helvetica, sans-serif"'.
         *
         *
         * Either "horizontal" or "vertical".
         *
         * Default value: '"horizontal"'.
         *
         *
         * Optional function for formatting the label into a displayable value.
         *
         * The arguments to the method are:
         *
         *   - *'value'* The value
         *   - *'label'*, *'storeItem'*, *'item'*, *'i'*, *'display'*, *'animate'*, *'index'*
         *
         *     Same arguments as {@link #onPlaceLabel}.
         *
         *     Default value: 'function(v) { return v; }'
         */
        label: any;

        /**
         * Called each time a new label is created.
         *
         * **Note:** This method must be implemented in Series that mixes
         * in this Label mixin.
         *
         * @param {Ext.data.Model} storeItem The element of the store that is
         * related to the sprite.
         * @param {Object} item The item related to the sprite.
         * An item is an object containing the position of the shape
         * used to describe the visualization and also pointing to the
         * actual shape (circle, rectangle, path, etc).
         * @param {Number} i The index of the element created
         * (i.e the first created label, second created label, etc).
         * @param {String} display The label.display type.
         * May be 'false' if the label is hidden
         * @return {Ext.draw.Sprite} The created sprite that will draw the label.
         */
        onCreateLabel(storeItem: Ext.data.Model, item: any, i: number, display: string): Ext.draw.Sprite;

        /**
         * Called for updating the position of the label.
         *
         * **Note:** This method must be implemented in Series that mixes
         * in this Label mixin.
         *
         * @param {Ext.draw.Sprite} label The sprite that draws the label.
         * @param {Ext.data.Model} storeItem The element of the store
         * that is related to the sprite.
         * @param {Object} item The item related to the
         * sprite. An item is an object containing the position of
         * the shape used to describe the visualization and also
         * pointing to the actual shape (circle, rectangle, path, etc).
         * @param {Number} i The index of the element to be updated
         * (i.e. whether it is the first, second, third from the
         * labelGroup)
         * @param {String} display The label.display type.
         * May be 'false' if the label is hidden
         * @param {Boolean} animate A boolean value to set or unset
         * animations for the labels.
         * @param {Number} index The series index.
         */
        onPlaceLabel(label: Ext.draw.Sprite, storeItem: Ext.data.Model, item: any, i: number, display: string, animate: boolean, index: number);
    }

    interface LegendConfig {
        /**
         * Fill style for the legend box
         */
        boxFill?: string;

        /**
         * Style of the stroke for the legend box
         */
        boxStroke?: string;

        /**
         * Width of the stroke for the legend box
         */
        boxStrokeWidth?: string;

        /**
         * Sets the z-index for the legend. Defaults to 100.
         */
        boxZIndex?: number;

        /**
         * Amount of space between legend items
         */
        itemSpacing?: number;

        /**
         * Color to be used for the legend labels, eg '#000'
         */
        labelColor?: string;

        /**
         * Font to be used for the legend labels, eg '12px Helvetica'
         */
        labelFont?: string;

        /**
         * Amount of padding between the legend box's border and its items
         */
        padding?: number;

        /**
         * The position of the legend in relation to the chart. One of: "top",
         * "bottom", "left", "right", or "float". If set to "float", then the legend
         * box will be positioned at the point denoted by the x and y parameters.
         */
        position?: string;

        /**
         * If set to true the legend will be refreshed when the chart is.
         * This is useful to update the legend items if series are
         * added/removed/updated from the chart. Default is true.
         */
        update?: boolean;

        /**
         * Whether or not the legend should be displayed.
         */
        visible?: boolean;

        /**
         * X-position of the legend box. Used directly if position is set to "float", otherwise
         * it will be calculated dynamically.
         */
        x?: number;

        /**
         * Y-position of the legend box. Used directly if position is set to "float", otherwise
         * it will be calculated dynamically.
         */
        y?: number;
    }

    /**
     * Defines a legend for a chart's series.
     * The 'chart' member must be set prior to rendering.
     * The legend class displays a list of legend items each of them related with a
     * series being rendered. In order to render the legend item of the proper series
     * the series configuration object must have 'showInLegend' set to true.
     *
     * The legend configuration object accepts a 'position' as parameter.
     * The 'position' parameter can be 'left', 'right'
     * 'top' or 'bottom'. For example:
     *
     *     legend: {
     *         position: 'right'
     *     },
     *
     * ## Example
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['name', 'data1', 'data2', 'data3', 'data4', 'data5'],
     *         data: [
     *             { 'name': 'metric one',   'data1': 10, 'data2': 12, 'data3': 14, 'data4': 8,  'data5': 13 },
     *             { 'name': 'metric two',   'data1': 7,  'data2': 8,  'data3': 16, 'data4': 10, 'data5': 3  },
     *             { 'name': 'metric three', 'data1': 5,  'data2': 2,  'data3': 14, 'data4': 12, 'data5': 7  },
     *             { 'name': 'metric four',  'data1': 2,  'data2': 14, 'data3': 6,  'data4': 1,  'data5': 23 },
     *             { 'name': 'metric five',  'data1': 27, 'data2': 38, 'data3': 36, 'data4': 13, 'data5': 33 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 300,
     *         animate: true,
     *         store: store,
     *         shadow: true,
     *         theme: 'Category1',
     *         legend: {
     *             position: 'top'
     *         },
     *         axes: [
     *             {
     *                 type: 'Numeric',
     *                 position: 'left',
     *                 fields: ['data1', 'data2', 'data3', 'data4', 'data5'],
     *                 title: 'Sample Values',
     *                 grid: {
     *                     odd: {
     *                         opacity: 1,
     *                         fill: '#ddd',
     *                         stroke: '#bbb',
     *                         'stroke-width': 1
     *                     }
     *                 },
     *                 minimum: 0,
     *                 adjustMinimumByMajorUnit: 0
     *             },
     *             {
     *                 type: 'Category',
     *                 position: 'bottom',
     *                 fields: ['name'],
     *                 title: 'Sample Metrics',
     *                 grid: true,
     *                 label: {
     *                     rotate: {
     *                         degrees: 315
     *                     }
     *                 }
     *             }
     *         ],
     *         series: [{
     *             type: 'area',
     *             highlight: false,
     *             axis: 'left',
     *             xField: 'name',
     *             yField: ['data1', 'data2', 'data3', 'data4', 'data5'],
     *             style: {
     *                 opacity: 0.93
     *             }
     *         }]
     *     });
     */
    export class Legend extends Ext.Base implements Ext.chart.LegendConfig {
        /**
         * Whether the legend box is oriented vertically, i.e. if it is on the left or right side or floating.
         */
        isVertical: boolean;

        /**
         * Fill style for the legend box
         */
        boxFill: string;

        /**
         * Style of the stroke for the legend box
         */
        boxStroke: string;

        /**
         * Width of the stroke for the legend box
         */
        boxStrokeWidth: string;

        /**
         * Sets the z-index for the legend. Defaults to 100.
         */
        boxZIndex: number;

        /**
         * Amount of space between legend items
         */
        itemSpacing: number;

        /**
         * Color to be used for the legend labels, eg '#000'
         */
        labelColor: string;

        /**
         * Font to be used for the legend labels, eg '12px Helvetica'
         */
        labelFont: string;

        /**
         * Amount of padding between the legend box's border and its items
         */
        padding: number;

        /**
         * The position of the legend in relation to the chart. One of: "top",
         * "bottom", "left", "right", or "float". If set to "float", then the legend
         * box will be positioned at the point denoted by the x and y parameters.
         */
        position: string;

        /**
         * If set to true the legend will be refreshed when the chart is.
         * This is useful to update the legend items if series are
         * added/removed/updated from the chart. Default is true.
         */
        update: boolean;

        /**
         * Whether or not the legend should be displayed.
         */
        visible: boolean;

        /**
         * X-position of the legend box. Used directly if position is set to "float", otherwise
         * it will be calculated dynamically.
         */
        x: number;

        /**
         * Y-position of the legend box. Used directly if position is set to "float", otherwise
         * it will be calculated dynamically.
         */
        y: number;

        /**
         * Creates new Legend.
         * @param {Object} config  (optional) Config object.
         */
        constructor(config: Ext.chart.LegendConfig);

        /** toggle
         * @param {Boolean} show Whether to show or hide the legend.
         */
        toggle(show: boolean);
    }

    /**
     * A single item of a legend (marker plus label)
     */
    export class LegendItem extends Ext.draw.CompositeSprite {
        constructor(config: any);

        /**
         * Creates all the individual sprites for this legend item
         */
        createLegend();

        /**
         * Update the positions of all this item's sprites to match the root position
         * of the legend box.
         * @param {Object} relativeTo (optional) If specified, this object's 'x' and 'y' values will be used
         *                 as the reference point for the relative positioning. Defaults to the Legend.
         */
        updatePosition(relativeTo: any);
    }

    interface MaskConfig {
        /**
         * Enables selecting a region on chart. True to enable any selection,
         * 'horizontal' or 'vertical' to restrict the selection to X or Y axis.
         *
         * The mask in itself will do nothing but fire 'select' event.
         * See {@link Ext.chart.Mask} for example.
         */
        mask?: boolean|string;
    }

    /**
     * Defines a mask for a chart's series.
     * The 'chart' member must be set prior to rendering.
     *
     * A Mask can be used to select a certain region in a chart.
     * When enabled, the 'select' event will be triggered when a
     * region is selected by the mask, allowing the user to perform
     * other tasks like zooming on that region, etc.
     *
     * In order to use the mask one has to set the Chart 'mask' option to
     * 'true', 'vertical' or 'horizontal'. Then a possible configuration for the
     * listener could be:
     *
     *     items: {
     *         xtype: 'chart',
     *         animate: true,
     *         store: store1,
     *         mask: 'horizontal',
     *         listeners: {
     *             select: {
     *                 fn: function(me, selection) {
     *                     me.setZoom(selection);
     *                     me.mask.hide();
     *                 }
     *             }
     *         }
     *     }
     *
     * In this example we zoom the chart to that particular region. You can also get
     * a handle to a mask instance from the chart object. The 'chart.mask' element is a
     * 'Ext.Panel'.
     */
    export class Mask extends Ext.Base implements Ext.chart.MaskConfig {
        /**
         * Enables selecting a region on chart. True to enable any selection,
         * 'horizontal' or 'vertical' to restrict the selection to X or Y axis.
         *
         * The mask in itself will do nothing but fire 'select' event.
         * See {@link Ext.chart.Mask} for example.
         */
        mask: boolean|string;

        /**
         * Creates new Mask.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.chart.MaskConfig);
    }

    export class MaskLayer extends Ext.Component {
        constructor(config: any);

        protected initComponent();
    }

    /**
     * Handles panning and zooming capabilities.
     *
     * Used as mixin by Ext.chart.Chart.
     */
    export class Navigation extends Ext.Base {
        /**
         * Restores the zoom to the original value. This can be used to reset
         * the previous zoom state set by 'setZoom'. For example:
         *
         *     myChart.restoreZoom();
         */
        restoreZoom();

        /**
         * Zooms the chart to the specified selection range.
         * Can be used with a selection mask. For example:
         *
         *     items: {
         *         xtype: 'chart',
         *         animate: true,
         *         store: store1,
         *         mask: 'horizontal',
         *         listeners: {
         *             select: {
         *                 fn: function(me, selection) {
         *                     me.setZoom(selection);
         *                     me.mask.hide();
         *                 }
         *             }
         *         }
         *     }
         */
        setZoom();
    }

    export class Shape {
    }

    /**
     * Provides tips for Ext.chart.series.Series.
     */
    export class Tip extends Ext.Base {
        constructor();
    }

    export class TipSurface extends Ext.draw.Component {
        constructor(config: any);
    }
}

declare module Ext.chart.axis {
    interface AbstractConfig {
        /**
         * The fields of model to bind to this axis.
         *
         * For example if you have a data set of lap times per car, each having the fields:
         * ''carName'', ''avgSpeed'', ''maxSpeed''. Then you might want to show the data on chart
         * with '['carName']' on Name axis and '['avgSpeed', 'maxSpeed']' on Speed axis.
         */
        fields?: string;

        /**
         * The config for chart label.
         */
        label?: Ext.chart.Label;
    }

    /**
     * Base class for all axis classes.
     */
    export class Abstract extends Ext.Base implements Ext.chart.axis.AbstractConfig {
        /**
         * The fields of model to bind to this axis.
         *
         * For example if you have a data set of lap times per car, each having the fields:
         * ''carName'', ''avgSpeed'', ''maxSpeed''. Then you might want to show the data on chart
         * with '['carName']' on Name axis and '['avgSpeed', 'maxSpeed']' on Speed axis.
         */
        fields: string;

        /**
         * The config for chart label.
         */
        label: Ext.chart.Label;

        /**
         * Creates new Axis.
         * @param {Object} config (optional) Config options.
         */
        constructor(config: Ext.chart.axis.AbstractConfig);
    }

    interface AxisConfig extends Ext.chart.axis.AbstractConfig {
        /**
         * Whether to adjust the label at the end of the axis.
         */
        adjustEnd?: boolean;

        /**
         * The size of the dash marker. Default's 3.
         */
        dashSize?: number;

        /**
         * The grid configuration enables you to set a background grid for an axis.
         * If set to *true* on a vertical axis, vertical lines will be drawn.
         * If set to *true* on a horizontal axis, horizontal lines will be drawn.
         * If both are set, a proper grid with horizontal and vertical lines will be drawn.
         *
         * You can set specific options for the grid configuration for odd and/or even lines/rows.
         * Since the rows being drawn are rectangle sprites, you can set to an odd or even property
         * all styles that apply to {@link Ext.draw.Sprite}. For more information on all the style
         * properties you can set please take a look at {@link Ext.draw.Sprite}. Some useful style
         * properties are 'opacity', 'fill', 'stroke', 'stroke-width', etc.
         *
         * The possible values for a grid option are then *true*, *false*, or an object with '{ odd, even }' properties
         * where each property contains a sprite style descriptor object that is defined in {@link Ext.draw.Sprite}.
         *
         * For example:
         *
         *     axes: [{
         *         type: 'Numeric',
         *         position: 'left',
         *         fields: ['data1', 'data2', 'data3'],
         *         title: 'Number of Hits',
         *         grid: {
         *             odd: {
         *                 opacity: 1,
         *                 fill: '#ddd',
         *                 stroke: '#bbb',
         *                 'stroke-width': 1
         *             }
         *         }
         *     }, {
         *         type: 'Category',
         *         position: 'bottom',
         *         fields: ['name'],
         *         title: 'Month of the Year',
         *         grid: true
         *     }]
         */
        grid?: boolean|any;

        /**
         * 'true' to hide the axis.
         */
        hidden?: boolean;

        /**
         * Offset axis position. Default's 0.
         */
        length?: number;

        /**
         * If 'minimum' and 'maximum' are specified it forces the number of major ticks to the specified value.
         * If a number of major ticks is forced, it wont search for pretty numbers at the ticks.
         */
        majorTickSteps?: number;

        /**
         * The number of small ticks between two major ticks. Default is zero.
         */
        minorTickSteps?: number;

        /**
         * Where to set the axis. Available options are 'left', 'bottom', 'right', 'top'. Default's 'bottom'.
         */
        position?: string;

        /**
         * The title for the Axis
         */
        title?: string;

        /**
         * Offset axis width. Default's 0.
         */
        width?: number;
    }

    /**
     * Defines axis for charts. The axis position, type, style can be configured.
     * The axes are defined in an axes array of configuration objects where the type,
     * field, grid and other configuration options can be set. To know more about how
     * to create a Chart please check the Chart class documentation. Here's an example for the axes part:
     * An example of axis for a series (in this case for an area chart that has multiple layers of yFields) could be:
     *
     *     axes: [{
     *         type: 'Numeric',
     *         position: 'left',
     *         fields: ['data1', 'data2', 'data3'],
     *         title: 'Number of Hits',
     *         grid: {
     *             odd: {
     *                 opacity: 1,
     *                 fill: '#ddd',
     *                 stroke: '#bbb',
     *                 'stroke-width': 1
     *             }
     *         },
     *         minimum: 0
     *     }, {
     *         type: 'Category',
     *         position: 'bottom',
     *         fields: ['name'],
     *         title: 'Month of the Year',
     *         grid: true,
     *         label: {
     *             rotate: {
     *                 degrees: 315
     *             }
     *         }
     *     }]
     *
     * In this case we use a 'Numeric' axis for displaying the values of the Area series and a 'Category' axis for displaying the names of
     * the store elements. The numeric axis is placed on the left of the screen, while the category axis is placed at the bottom of the chart.
     * Both the category and numeric axes have 'grid' set, which means that horizontal and vertical lines will cover the chart background. In the
     * category axis the labels will be rotated so they can fit the space better.
     */
    export class Axis extends Ext.chart.axis.Abstract implements Ext.chart.axis.AxisConfig {
        /**
         * Whether to adjust the label at the end of the axis.
         */
        adjustEnd: boolean;

        /**
         * The size of the dash marker. Default's 3.
         */
        dashSize: number;

        /**
         * The grid configuration enables you to set a background grid for an axis.
         * If set to *true* on a vertical axis, vertical lines will be drawn.
         * If set to *true* on a horizontal axis, horizontal lines will be drawn.
         * If both are set, a proper grid with horizontal and vertical lines will be drawn.
         *
         * You can set specific options for the grid configuration for odd and/or even lines/rows.
         * Since the rows being drawn are rectangle sprites, you can set to an odd or even property
         * all styles that apply to {@link Ext.draw.Sprite}. For more information on all the style
         * properties you can set please take a look at {@link Ext.draw.Sprite}. Some useful style
         * properties are 'opacity', 'fill', 'stroke', 'stroke-width', etc.
         *
         * The possible values for a grid option are then *true*, *false*, or an object with '{ odd, even }' properties
         * where each property contains a sprite style descriptor object that is defined in {@link Ext.draw.Sprite}.
         *
         * For example:
         *
         *     axes: [{
         *         type: 'Numeric',
         *         position: 'left',
         *         fields: ['data1', 'data2', 'data3'],
         *         title: 'Number of Hits',
         *         grid: {
         *             odd: {
         *                 opacity: 1,
         *                 fill: '#ddd',
         *                 stroke: '#bbb',
         *                 'stroke-width': 1
         *             }
         *         }
         *     }, {
         *         type: 'Category',
         *         position: 'bottom',
         *         fields: ['name'],
         *         title: 'Month of the Year',
         *         grid: true
         *     }]
         */
        grid: boolean|any;

        /**
         * 'true' to hide the axis.
         */
        hidden: boolean;

        /**
         * Offset axis position. Default's 0.
         */
        length: number;

        /**
         * If 'minimum' and 'maximum' are specified it forces the number of major ticks to the specified value.
         * If a number of major ticks is forced, it wont search for pretty numbers at the ticks.
         */
        majorTickSteps: number;

        /**
         * The number of small ticks between two major ticks. Default is zero.
         */
        minorTickSteps: number;

        /**
         * Where to set the axis. Available options are 'left', 'bottom', 'right', 'top'. Default's 'bottom'.
         */
        position: string;

        /**
         * The title for the Axis
         */
        title: string;

        /**
         * Offset axis width. Default's 0.
         */
        width: number;

        /**
         * Creates new Axis.
         * @param {Object} config (optional) Config options.
         */
        constructor(config: Ext.chart.axis.AbstractConfig);

        /**
         * Renders the axis into the screen and updates its position.
         */
        drawAxis();

        /**
         * Renders an horizontal and/or vertical grid into the Surface.
         */
        drawGrid();

        /**
         * Renders the labels in the axes.
         */
        drawLabel();

        /**
         * Updates the {@link #title} of this axis.
         */
        setTitle(title: string);
    }

    interface CategoryConfig extends Ext.chart.axis.AxisConfig {
        /**
         * Indicates whether or not to calculate the number of categories (ticks and
         * labels) when there is not enough room to display all labels on the axis.
         * If set to true, the axis will determine the number of categories to plot.
         * If not, all categories will be plotted.
         */
        calculateCategoryCount?: boolean;

        /**
         * A list of category names to display along this axis.
         */
        categoryNames?: string;
    }

    /**
     * A type of axis that displays items in categories. This axis is generally used to
     * display categorical information like names of items, month names, quarters, etc.
     * but no quantitative values. For that other type of information 'Number'
     * axis are more suitable.
     *
     * As with other axis you can set the position of the axis and its title. For example:
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['name', 'data1', 'data2', 'data3', 'data4', 'data5'],
     *         data: [
     *             {'name':'metric one', 'data1':10, 'data2':12, 'data3':14, 'data4':8, 'data5':13},
     *             {'name':'metric two', 'data1':7, 'data2':8, 'data3':16, 'data4':10, 'data5':3},
     *             {'name':'metric three', 'data1':5, 'data2':2, 'data3':14, 'data4':12, 'data5':7},
     *             {'name':'metric four', 'data1':2, 'data2':14, 'data3':6, 'data4':1, 'data5':23},
     *             {'name':'metric five', 'data1':27, 'data2':38, 'data3':36, 'data4':13, 'data5':33}
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 300,
     *         store: store,
     *         axes: [{
     *             type: 'Numeric',
     *             position: 'left',
     *             fields: ['data1', 'data2', 'data3', 'data4', 'data5'],
     *             title: 'Sample Values',
     *             grid: {
     *                 odd: {
     *                     opacity: 1,
     *                     fill: '#ddd',
     *                     stroke: '#bbb',
     *                     'stroke-width': 1
     *                 }
     *             },
     *             minimum: 0,
     *             adjustMinimumByMajorUnit: 0
     *         }, {
     *             type: 'Category',
     *             position: 'bottom',
     *             fields: ['name'],
     *             title: 'Sample Metrics',
     *             grid: true,
     *             label: {
     *                 rotate: {
     *                     degrees: 315
     *                 }
     *             }
     *         }],
     *         series: [{
     *             type: 'area',
     *             highlight: false,
     *             axis: 'left',
     *             xField: 'name',
     *             yField: ['data1', 'data2', 'data3', 'data4', 'data5'],
     *             style: {
     *                 opacity: 0.93
     *             }
     *         }]
     *     });
     *
     * In this example with set the category axis to the bottom of the surface, bound the axis to
     * the 'name' property and set as title _Month of the Year_.
     */
    export class Category extends Ext.chart.axis.Axis implements Ext.chart.axis.CategoryConfig {
        /**
         * Indicates whether or not to calculate the number of categories (ticks and
         * labels) when there is not enough room to display all labels on the axis.
         * If set to true, the axis will determine the number of categories to plot.
         * If not, all categories will be plotted.
         */
        calculateCategoryCount: boolean;

        /**
         * A list of category names to display along this axis.
         */
        categoryNames: string;

        /**
         * Creates new Axis.
         * @param {Object} config (optional) Config options.
         */
        constructor(config: Ext.chart.axis.AbstractConfig);
    }

    interface GaugeConfig extends Ext.chart.axis.AbstractConfig {
        /**
         * The offset positioning of the tick marks and labels in pixels.
         *
         * Optional, Defaults to: 10
         */
        margin?: number;

        /**
         * (required)
         * The maximum value of the interval to be displayed in the axis.
         */
        maximum?: number;

        /**
         * (required)
         * The minimum value of the interval to be displayed in the axis.
         */
        minimum?: number;

        /**
         * (required)
         * The number of steps and tick marks to add to the interval.
         */
        steps?: number;

        /**
         * The title for the Axis.
         */
        title?: string;
    }

    /**
     * Gauge Axis is the axis to be used with a Gauge series. The Gauge axis
     * displays numeric data from an interval defined by the 'minimum', 'maximum' and
     * 'step' configuration properties. The placement of the numeric data can be changed
     * by altering the 'margin' option that is set to '10' by default.
     *
     * A possible configuration for this axis would look like:
     *
     *     axes: [{
     *         type: 'gauge',
     *         position: 'gauge',
     *         minimum: 0,
     *         maximum: 100,
     *         steps: 10,
     *         margin: 7
     *     }],
     */
    export class Gauge extends Ext.chart.axis.Abstract implements Ext.chart.axis.GaugeConfig {
        /**
         * The offset positioning of the tick marks and labels in pixels.
         *
         * Optional, Defaults to: 10
         */
        margin: number;

        /**
         * (required)
         * The maximum value of the interval to be displayed in the axis.
         */
        maximum: number;

        /**
         * (required)
         * The minimum value of the interval to be displayed in the axis.
         */
        minimum: number;

        /**
         * (required)
         * The number of steps and tick marks to add to the interval.
         */
        steps: number;

        /**
         * The title for the Axis.
         */
        title: string;

        /**
         * Creates new Axis.
         * @param {Object} config (optional) Config options.
         */
        constructor(config: Ext.chart.axis.AbstractConfig);

        /**
         * Updates the {@link #title} of this axis.
         */
        setTitle(title: string);
    }

    interface NumericConfig extends Ext.chart.axis.AxisConfig {
        /**
         * Indicates whether to extend maximum beyond data's maximum to the nearest
         * majorUnit.
         */
        adjustMaximumByMajorUnit?: boolean;

        /**
         * Indicates whether to extend the minimum beyond data's minimum to the
         * nearest majorUnit.
         */
        adjustMinimumByMajorUnit?: boolean;

        /**
         * If true, the values of the chart will be rendered only if they belong between minimum and maximum.
         * If false, all values of the chart will be rendered, regardless of whether they belong between minimum and maximum or not.
         * Default's true if maximum and minimum is specified. It is ignored for stacked charts.
         */
        constrain?: boolean;

        /**
         * The number of decimals to round the value to.
         */
        decimals?: number;

        /**
         * The maximum value drawn by the axis. If not set explicitly, the axis
         * maximum will be calculated automatically. It is ignored for stacked charts.
         */
        maximum?: number;

        /**
         * The minimum value drawn by the axis. If not set explicitly, the axis
         * minimum will be calculated automatically. It is ignored for stacked charts.
         */
        minimum?: number;

        /**
         * Indicates the position of the axis relative to the chart
         */
        position?: string;
    }

    /**
     * An axis to handle numeric values. This axis is used for quantitative data as
     * opposed to the category axis. You can set mininum and maximum values to the
     * axis so that the values are bound to that. If no values are set, then the
     * scale will auto-adjust to the values.
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *          fields: ['name', 'data1', 'data2', 'data3', 'data4', 'data5'],
     *          data: [
     *              {'name':'metric one', 'data1':10, 'data2':12, 'data3':14, 'data4':8, 'data5':13},
     *              {'name':'metric two', 'data1':7, 'data2':8, 'data3':16, 'data4':10, 'data5':3},
     *              {'name':'metric three', 'data1':5, 'data2':2, 'data3':14, 'data4':12, 'data5':7},
     *              {'name':'metric four', 'data1':2, 'data2':14, 'data3':6, 'data4':1, 'data5':23},
     *              {'name':'metric five', 'data1':27, 'data2':38, 'data3':36, 'data4':13, 'data5':33}
     *          ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 300,
     *         store: store,
     *         axes: [{
     *             type: 'Numeric',
     *             position: 'left',
     *             fields: ['data1', 'data2', 'data3', 'data4', 'data5'],
     *             title: 'Sample Values',
     *             grid: {
     *                 odd: {
     *                     opacity: 1,
     *                     fill: '#ddd',
     *                     stroke: '#bbb',
     *                     'stroke-width': 1
     *                 }
     *             },
     *             minimum: 0,
     *             adjustMinimumByMajorUnit: 0
     *         }, {
     *             type: 'Category',
     *             position: 'bottom',
     *             fields: ['name'],
     *             title: 'Sample Metrics',
     *             grid: true,
     *             label: {
     *                 rotate: {
     *                     degrees: 315
     *                 }
     *             }
     *         }],
     *         series: [{
     *             type: 'area',
     *             highlight: false,
     *             axis: 'left',
     *             xField: 'name',
     *             yField: ['data1', 'data2', 'data3', 'data4', 'data5'],
     *             style: {
     *                 opacity: 0.93
     *             }
     *         }]
     *     });
     *
     * In this example we create an axis of Numeric type. We set a minimum value so that
     * even if all series have values greater than zero, the grid starts at zero. We bind
     * the axis onto the left part of the surface by setting 'position' to 'left'.
     * We bind three different store fields to this axis by setting 'fields' to an array.
     * We set the title of the axis to _Number of Hits_ by using the 'title' property.
     * We use a 'grid' configuration to set odd background rows to a certain style and even rows
     * to be transparent/ignored.
     */
    export class Numeric extends Ext.chart.axis.Axis implements Ext.chart.axis.NumericConfig {
        /**
         * Indicates whether to extend maximum beyond data's maximum to the nearest
         * majorUnit.
         */
        adjustMaximumByMajorUnit: boolean;

        /**
         * Indicates whether to extend the minimum beyond data's minimum to the
         * nearest majorUnit.
         */
        adjustMinimumByMajorUnit: boolean;

        /**
         * If true, the values of the chart will be rendered only if they belong between minimum and maximum.
         * If false, all values of the chart will be rendered, regardless of whether they belong between minimum and maximum or not.
         * Default's true if maximum and minimum is specified. It is ignored for stacked charts.
         */
        constrain: boolean;

        /**
         * The number of decimals to round the value to.
         */
        decimals: number;

        /**
         * The maximum value drawn by the axis. If not set explicitly, the axis
         * maximum will be calculated automatically. It is ignored for stacked charts.
         */
        maximum: number;

        /**
         * The minimum value drawn by the axis. If not set explicitly, the axis
         * minimum will be calculated automatically. It is ignored for stacked charts.
         */
        minimum: number;

        /**
         * Indicates the position of the axis relative to the chart
         */
        position: string;

        constructor(config: Ext.chart.axis.NumericConfig);
    }

    interface RadialConfig extends Ext.chart.axis.NumericConfig {
        /**
         * The maximum value drawn by the axis. If not set explicitly, the axis
         * maximum will be calculated automatically.
         */
        maximum?: number;

        position?: any;

        /**
         * The number of circles to draw outward from the center.
         *
         * Optional, Defaults to: 10
         */
        steps?: number;
    }

    export class Radial extends Ext.chart.axis.Numeric implements Ext.chart.axis.RadialConfig {
        /**
         * The maximum value drawn by the axis. If not set explicitly, the axis
         * maximum will be calculated automatically.
         */
        maximum: number;

        position: string;

        /**
         * The number of circles to draw outward from the center.
         *
         * Optional, Defaults to: 10
         */
        steps: number;

        constructor(config: Ext.chart.axis.NumericConfig);

        drawLabel();
    }

    interface TimeConfig extends Ext.chart.axis.NumericConfig {
        /**
         * If true, the values of the chart will be rendered only if they belong between the fromDate and toDate.
         * If false, the time axis will adapt to the new values by adding/removing steps.
         */
        constrain?: boolean;

        /**
         * Indicates the format the date will be rendered on.
         * For example: 'M d' will render the dates as 'Jan 30', etc.
         * For a list of possible format strings see {@link Ext.Date Date}
         */
        dateFormat?: string|boolean;

        /**
         * The starting date for the time axis.
         */
        fromDate?: Date;

        /**
         * An array with two components: The first is the unit of the step (day, month, year, etc). The second one is a number.
         * If the number is an integer, it represents the number of units for the step ([Ext.Date.DAY, 2] means "Every other day").
         * If the number is a fraction, it represents the number of steps per unit ([Ext.Date.DAY, 1/2] means "Twice a day").
         * If the unit is the month, the steps may be adjusted depending on the month. For instance [Ext.Date.MONTH, 1/3], which means "Three times a month",
         * generates steps on the 1st, the 10th and the 20th of every month regardless of whether a month has 28 days or 31 days. The steps are generated
         * as follows:
         * - [Ext.Date.MONTH, n]: on the current date every 'n' months, maxed to the number of days in the month.
         * - [Ext.Date.MONTH, 1/2]: on the 1st and 15th of every month.
         * - [Ext.Date.MONTH, 1/3]: on the 1st, 10th and 20th of every month.
         * - [Ext.Date.MONTH, 1/4]: on the 1st, 8th, 15th and 22nd of every month.
         *
         * Defaults to: [Ext.Date.DAY, 1].
         */
        step?: any[];

        /**
         * The ending date for the time axis.
         */
        toDate?: Date;
    }

    /**
     * A type of axis whose units are measured in time values. Use this axis
     * for listing dates that you will want to group or dynamically change.
     * If you just want to display dates as categories then use the
     * Category class for axis instead.
     *
     * For example:
     *
     *     axes: [{
     *         type: 'Time',
     *         position: 'bottom',
     *         fields: 'date',
     *         title: 'Day',
     *         dateFormat: 'M d',
     *
     *         constrain: true,
     *         fromDate: new Date('1/1/11'),
     *         toDate: new Date('1/7/11')
     *     }]
     *
     * In this example we're creating a time axis that has as title *Day*.
     * The field the axis is bound to is 'date'.
     * The date format to use to display the text for the axis labels is 'M d'
     * which is a three letter month abbreviation followed by the day number.
     * The time axis will show values for dates between 'fromDate' and 'toDate'.
     * Since 'constrain' is set to true all other values for other dates not between
     * the fromDate and toDate will not be displayed.
     */
    export class Time extends Ext.chart.axis.Numeric implements Ext.chart.axis.TimeConfig {
        /**
         * If true, the values of the chart will be rendered only if they belong between the fromDate and toDate.
         * If false, the time axis will adapt to the new values by adding/removing steps.
         */
        constrain: boolean;

        /**
         * Indicates the format the date will be rendered on.
         * For example: 'M d' will render the dates as 'Jan 30', etc.
         * For a list of possible format strings see {@link Ext.Date Date}
         */
        dateFormat: string|boolean;

        /**
         * The starting date for the time axis.
         */
        fromDate: Date;

        /**
         * An array with two components: The first is the unit of the step (day, month, year, etc). The second one is a number.
         * If the number is an integer, it represents the number of units for the step ([Ext.Date.DAY, 2] means "Every other day").
         * If the number is a fraction, it represents the number of steps per unit ([Ext.Date.DAY, 1/2] means "Twice a day").
         * If the unit is the month, the steps may be adjusted depending on the month. For instance [Ext.Date.MONTH, 1/3], which means "Three times a month",
         * generates steps on the 1st, the 10th and the 20th of every month regardless of whether a month has 28 days or 31 days. The steps are generated
         * as follows:
         * - [Ext.Date.MONTH, n]: on the current date every 'n' months, maxed to the number of days in the month.
         * - [Ext.Date.MONTH, 1/2]: on the 1st and 15th of every month.
         * - [Ext.Date.MONTH, 1/3]: on the 1st, 10th and 20th of every month.
         * - [Ext.Date.MONTH, 1/4]: on the 1st, 8th, 15th and 22nd of every month.
         *
         * Defaults to: [Ext.Date.DAY, 1].
         */
        step: any[];

        /**
         * The ending date for the time axis.
         */
        toDate: Date;

        constructor(config: Ext.chart.axis.TimeConfig);
    }
}

declare module Ext.chart.series {
    interface AreaConfig extends Ext.chart.series.CartesianConfig {
        /**
         * Append styling properties to this object for it to override theme properties.
         */
        style?: any;

        type?: any;
    }

    /**
     * @extends Ext.chart.series.Cartesian
     *
     * Creates a Stacked Area Chart. The stacked area chart is useful when displaying multiple aggregated layers of information.
     * As with all other series, the Area Series must be appended in the *series* Chart array configuration. See the Chart
     * documentation for more information. A typical configuration object for the area series could be:
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['name', 'data1', 'data2', 'data3', 'data4', 'data5'],
     *         data: [
     *             { 'name': 'metric one',   'data1':10, 'data2':12, 'data3':14, 'data4':8,  'data5':13 },
     *             { 'name': 'metric two',   'data1':7,  'data2':8,  'data3':16, 'data4':10, 'data5':3  },
     *             { 'name': 'metric three', 'data1':5,  'data2':2,  'data3':14, 'data4':12, 'data5':7  },
     *             { 'name': 'metric four',  'data1':2,  'data2':14, 'data3':6,  'data4':1,  'data5':23 },
     *             { 'name': 'metric five',  'data1':27, 'data2':38, 'data3':36, 'data4':13, 'data5':33 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 300,
     *         store: store,
     *         axes: [
     *             {
     *                 type: 'Numeric',
     *                 position: 'left',
     *                 fields: ['data1', 'data2', 'data3', 'data4', 'data5'],
     *                 title: 'Sample Values',
     *                 grid: {
     *                     odd: {
     *                         opacity: 1,
     *                         fill: '#ddd',
     *                         stroke: '#bbb',
     *                         'stroke-width': 1
     *                     }
     *                 },
     *                 minimum: 0,
     *                 adjustMinimumByMajorUnit: 0
     *             },
     *             {
     *                 type: 'Category',
     *                 position: 'bottom',
     *                 fields: ['name'],
     *                 title: 'Sample Metrics',
     *                 grid: true,
     *                 label: {
     *                     rotate: {
     *                         degrees: 315
     *                     }
     *                 }
     *             }
     *         ],
     *         series: [{
     *             type: 'area',
     *             highlight: false,
     *             axis: 'left',
     *             xField: 'name',
     *             yField: ['data1', 'data2', 'data3', 'data4', 'data5'],
     *             style: {
     *                 opacity: 0.93
     *             }
     *         }]
     *     });
     *
     * In this configuration we set 'area' as the type for the series, set highlighting options to true for highlighting elements on hover,
     * take the left axis to measure the data in the area series, set as xField (x values) the name field of each element in the store,
     * and as yFields (aggregated layers) seven data fields from the same store. Then we override some theming styles by adding some opacity
     * to the style object.
     */
    export class Area extends Ext.chart.series.Cartesian implements Ext.chart.series.AreaConfig {
        /**
         * Append styling properties to this object for it to override theme properties.
         */
        style: any;

        type: string;

        constructor(config: Ext.chart.series.AreaConfig);

        /**
         * Draws the series for the current chart.
         */
        drawSeries();

        /**
         * Highlight the specified item. If no item is provided the whole series will be highlighted.
         * @param item {Object} Info about the item; same format as returned by #getItemForPoint
         */
        highlightItem();

        /**
         * Highlight this entire series.
         * @param {Object} item Info about the item; same format as returned by #getItemForPoint.
         */
        highlightSeries(item: any);

        /**
         * Un-highlights the specified item. If no item is provided it will un-highlight the entire series.
         * @param {Object} item Info about the item; same format as returned by #getItemForPoint
         */
        unHighlightItem(item: any);

        /**
         * UnHighlight this entire series.
         * @param {Object} item Info about the item; same format as returned by #getItemForPoint.
         */
        unHighlightSeries(item: any);
    }

    interface BarConfig extends Ext.chart.series.CartesianConfig {
        /**
         * Whether to set the visualization as column chart or horizontal bar chart.
         */
        column?: boolean;

        /**
         * The gutter space between groups of bars, as a percentage of the bar width
         */
        groupGutter?: number;

        /**
         * The gutter space between single bars, as a percentage of the bar width
         */
        gutter?: number;

        /**
         * If set to 'true' then bars for multiple 'yField' values will be rendered stacked on top of one another.
         * Otherwise, they will be rendered side-by-side. Defaults to 'false'.
         */
        stacked?: boolean;

        /**
         * properties that will override the theming series styles.
         */
        style?: any;

        type?: any;

        /**
         * Padding between the left/right axes and the bars.
         * The possible values are a number (the number of pixels for both left and right padding)
         * or an object with '{ left, right }' properties.
         */
        xPadding?: number|any;

        /**
         * Padding between the top/bottom axes and the bars.
         * The possible values are a number (the number of pixels for both top and bottom padding)
         * or an object with '{ top, bottom }' properties.
         */
        yPadding?: number|any;
    }

    /**
     * Creates a Bar Chart. A Bar Chart is a useful visualization technique to display quantitative information for
     * different categories that can show some progression (or regression) in the dataset. As with all other series, the Bar
     * Series must be appended in the *series* Chart array configuration. See the Chart documentation for more information.
     * A typical configuration object for the bar series could be:
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['name', 'data'],
     *         data: [
     *             { 'name': 'metric one',   'data':10 },
     *             { 'name': 'metric two',   'data': 7 },
     *             { 'name': 'metric three', 'data': 5 },
     *             { 'name': 'metric four',  'data': 2 },
     *             { 'name': 'metric five',  'data':27 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 300,
     *         animate: true,
     *         store: store,
     *         axes: [{
     *             type: 'Numeric',
     *             position: 'bottom',
     *             fields: ['data'],
     *             label: {
     *                 renderer: Ext.util.Format.numberRenderer('0,0')
     *             },
     *             title: 'Sample Values',
     *             grid: true,
     *             minimum: 0
     *         }, {
     *             type: 'Category',
     *             position: 'left',
     *             fields: ['name'],
     *             title: 'Sample Metrics'
     *         }],
     *         series: [{
     *             type: 'bar',
     *             axis: 'bottom',
     *             highlight: true,
     *             tips: {
     *               trackMouse: true,
     *               width: 140,
     *               height: 28,
     *               renderer: function(storeItem, item) {
     *                 this.setTitle(storeItem.get('name') + ': ' + storeItem.get('data') + ' views');
     *               }
     *             },
     *             label: {
     *               display: 'insideEnd',
     *                 field: 'data',
     *                 renderer: Ext.util.Format.numberRenderer('0'),
     *                 orientation: 'horizontal',
     *                 color: '#333',
     *                 'text-anchor': 'middle'
     *             },
     *             xField: 'name',
     *             yField: 'data'
     *         }]
     *     });
     *
     * In this configuration we set 'bar' as the series type, bind the values of the bar to the bottom axis and set the
     * xField or category field to the 'name' parameter of the store. We also set 'highlight' to true which enables smooth
     * animations when bars are hovered. We also set some configuration for the bar labels to be displayed inside the bar,
     * to display the information found in the 'data1' property of each element store, to render a formated text with the
     * 'Ext.util.Format' we pass in, to have an 'horizontal' orientation (as opposed to a vertical one) and we also set
     * other styles like 'color', 'text-anchor', etc.
     */
    export class Bar extends Ext.chart.series.Cartesian implements Ext.chart.series.BarConfig {
        /**
         * Whether to set the visualization as column chart or horizontal bar chart.
         */
        column: boolean;

        /**
         * The gutter space between groups of bars, as a percentage of the bar width
         */
        groupGutter: number;

        /**
         * The gutter space between single bars, as a percentage of the bar width
         */
        gutter: number;

        /**
         * If set to 'true' then bars for multiple 'yField' values will be rendered stacked on top of one another.
         * Otherwise, they will be rendered side-by-side. Defaults to 'false'.
         */
        stacked: boolean;

        /**
         * properties that will override the theming series styles.
         */
        style: any;

        type: string;

        /**
         * Padding between the left/right axes and the bars.
         * The possible values are a number (the number of pixels for both left and right padding)
         * or an object with '{ left, right }' properties.
         */
        xPadding: number|any;

        /**
         * Padding between the top/bottom axes and the bars.
         * The possible values are a number (the number of pixels for both top and bottom padding)
         * or an object with '{ top, bottom }' properties.
         */
        yPadding: number|any;

        /**
         * Draws the series for the current chart.
         */
        drawSeries();

        /**
         * Returns a string with the color to be used for the series legend item.
         */
        getLegendColor();

        highlightItem(item: any);

        unHighlightItem();
    }

    interface CartesianConfig extends Ext.chart.series.SeriesConfig {
        /**
         * The position of the axis to bind the values to. Possible values are 'left', 'bottom', 'top' and 'right'.
         * You must explicitly set this value to bind the values of the line series to the ones in the axis, otherwise a
         * relative scale will be used. For example, if you're using a Scatter or Line series and you'd like to have the
         * values in the chart relative to the bottom and left axes then 'axis' should be '['left', 'bottom']'.
         */
        axis?: string;

        /**
         * The name of the data Model field corresponding to the x-axis value.
         */
        xField?: string;

        /**
         * The name(s) of the data Model field(s) corresponding to the y-axis value(s).
         */
        yField?: string;
    }

    /**
     * Common base class for series implementations which plot values using x/y coordinates.
     */
    export class Cartesian extends Ext.chart.series.Series implements Ext.chart.series.CartesianConfig {
        /**
         * The position of the axis to bind the values to. Possible values are 'left', 'bottom', 'top' and 'right'.
         * You must explicitly set this value to bind the values of the line series to the ones in the axis, otherwise a
         * relative scale will be used. For example, if you're using a Scatter or Line series and you'd like to have the
         * values in the chart relative to the bottom and left axes then 'axis' should be '['left', 'bottom']'.
         */
        axis: string;

        /**
         * The name of the data Model field corresponding to the x-axis value.
         */
        xField: string;

        /**
         * The name(s) of the data Model field(s) corresponding to the y-axis value(s).
         */
        yField: string;

        /**
         * executing a given function for each value. Any yFields that have been combined
         * via legend drag-drop will be treated as a single value.
         */
        protected eachYValue(record: Ext.data.Model, fn: Function, scope: any);

        /**
         * Calculate the min and max values for this series's xField.
         * @return {Array} [min, max]
         */
        getMinMaxXValues(): any[];

        /**
         * Calculate the min and max values for this series's yField(s). Takes into account yField
         * combinations, exclusions, and stacking.
         * @return {Array} [min, max]
         */
        getMinMaxYValues(): any[];

        /**
         * corresponding to function's index in the array, for a given record (each function takes the
         * record as its only argument.) If yFields have been combined by the user via legend drag-drop,
         * this list of accessors will be kept in sync with those combinations.
         * @return {Array} array of accessor functions
         */
        protected getYValueAccessors(): any[];

        /**
         * via legend drag-drop.
         * @return {Number}
         */
        protected getYValueCount(): number;
    }

    interface ColumnConfig extends Ext.chart.series.BarConfig {
        /**
         * The position of the axis to bind the values to. Possible values are 'left', 'bottom', 'top' and 'right'.
         * You must explicitly set this value to bind the values of the column series to the ones in the axis, otherwise a
         * relative scale will be used.
         */
        axis?: string;

        column?: any;

        type?: any;

        /**
         * Padding between the left/right axes and the bars.
         * The possible values are a number (the number of pixels for both left and right padding)
         * or an object with '{ left, right }' properties.
         */
        xPadding?: number|any;

        /**
         * Padding between the top/bottom axes and the bars.
         * The possible values are a number (the number of pixels for both top and bottom padding)
         * or an object with '{ top, bottom }' properties.
         */
        yPadding?: number|any;
    }

    /**
     * Creates a Column Chart. Much of the methods are inherited from Bar. A Column Chart is a useful
     * visualization technique to display quantitative information for different categories that can
     * show some progression (or regression) in the data set. As with all other series, the Column Series
     * must be appended in the *series* Chart array configuration. See the Chart documentation for more
     * information. A typical configuration object for the column series could be:
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['name', 'data'],
     *         data: [
     *             { 'name': 'metric one',   'data':10 },
     *             { 'name': 'metric two',   'data': 7 },
     *             { 'name': 'metric three', 'data': 5 },
     *             { 'name': 'metric four',  'data': 2 },
     *             { 'name': 'metric five',  'data':27 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 300,
     *         animate: true,
     *         store: store,
     *         axes: [
     *             {
     *                 type: 'Numeric',
     *                 position: 'left',
     *                 fields: ['data'],
     *                 label: {
     *                     renderer: Ext.util.Format.numberRenderer('0,0')
     *                 },
     *                 title: 'Sample Values',
     *                 grid: true,
     *                 minimum: 0
     *             },
     *             {
     *                 type: 'Category',
     *                 position: 'bottom',
     *                 fields: ['name'],
     *                 title: 'Sample Metrics'
     *             }
     *         ],
     *         series: [
     *             {
     *                 type: 'column',
     *                 axis: 'left',
     *                 highlight: true,
     *                 tips: {
     *                   trackMouse: true,
     *                   width: 140,
     *                   height: 28,
     *                   renderer: function(storeItem, item) {
     *                     this.setTitle(storeItem.get('name') + ': ' + storeItem.get('data') + ' $');
     *                   }
     *                 },
     *                 label: {
     *                   display: 'insideEnd',
     *                   'text-anchor': 'middle',
     *                     field: 'data',
     *                     renderer: Ext.util.Format.numberRenderer('0'),
     *                     orientation: 'vertical',
     *                     color: '#333'
     *                 },
     *                 xField: 'name',
     *                 yField: 'data'
     *             }
     *         ]
     *     });
     *
     * In this configuration we set 'column' as the series type, bind the values of the bars to the bottom axis,
     * set 'highlight' to true so that bars are smoothly highlighted when hovered and bind the 'xField' or category
     * field to the data store 'name' property and the 'yField' as the data1 property of a store element.
     */
    export class Column extends Ext.chart.series.Bar implements Ext.chart.series.ColumnConfig {
        /**
         * The position of the axis to bind the values to. Possible values are 'left', 'bottom', 'top' and 'right'.
         * You must explicitly set this value to bind the values of the column series to the ones in the axis, otherwise a
         * relative scale will be used.
         */
        axis: string;

        column: boolean;

        type: string;

        /**
         * Padding between the left/right axes and the bars.
         * The possible values are a number (the number of pixels for both left and right padding)
         * or an object with '{ left, right }' properties.
         */
        xPadding: number|any;

        /**
         * Padding between the top/bottom axes and the bars.
         * The possible values are a number (the number of pixels for both top and bottom padding)
         * or an object with '{ top, bottom }' properties.
         */
        yPadding: number|any;
    }

    interface GaugeConfig extends Ext.chart.series.SeriesConfig {
        /**
         * (required)
         * The store record field name to be used for the pie angles.
         * The values bound to this field name must be positive real numbers.
         */
        angleField?: string;

        /**
         * Use the entire disk or just a fraction of it for the gauge. Default's false.
         */
        donut?: boolean|number;

        /**
         * The duration for the pie slice highlight effect.
         */
        highlightDuration?: number;

        /**
         * Use the Gauge Series as an area series or add a needle to it. Default's false.
         */
        needle?: boolean;

        /**
         * Whether to add the pie chart elements as legend items. Default's false.
         */
        showInLegend?: boolean;

        /**
         * An object containing styles for overriding series styles from Theming.
         */
        style?: any;

        type?: any;
    }

    /**
     * Creates a Gauge Chart. Gauge Charts are used to show progress in a certain variable. There are two ways of using the Gauge chart.
     * One is setting a store element into the Gauge and selecting the field to be used from that store. Another one is instantiating the
     * visualization and using the 'setValue' method to adjust the value you want.
     *
     * An example of Gauge visualization:
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['value'],
     *         data: [
     *             { 'value':80 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         store: store,
     *         width: 400,
     *         height: 250,
     *         animate: true,
     *         insetPadding: 30,
     *         axes: [{
     *             type: 'gauge',
     *             position: 'gauge',
     *             minimum: 0,
     *             maximum: 100,
     *             steps: 10,
     *             margin: 10
     *         }],
     *         series: [{
     *             type: 'gauge',
     *             field: 'value',
     *             donut: 30,
     *             colorSet: ['#F49D10', '#ddd']
     *         }]
     *     });
     *
     *     Ext.widget("button", {
     *         renderTo: Ext.getBody(),
     *         text: "Refresh",
     *         handler: function() {
     *             store.getAt(0).set('value', Math.round(Math.random()*100));
     *         }
     *     });
     *
     * In this example we create a special Gauge axis to be used with the gauge visualization (describing half-circle markers), and also we're
     * setting a maximum, minimum and steps configuration options into the axis. The Gauge series configuration contains the store field to be bound to
     * the visual display and the color set to be used with the visualization.
     */
    export class Gauge extends Ext.chart.series.Series implements Ext.chart.series.GaugeConfig {
        /**
         * (required)
         * The store record field name to be used for the pie angles.
         * The values bound to this field name must be positive real numbers.
         */
        angleField: string;

        /**
         * Use the entire disk or just a fraction of it for the gauge. Default's false.
         */
        donut: boolean|number;

        /**
         * The duration for the pie slice highlight effect.
         */
        highlightDuration: number;

        /**
         * Use the Gauge Series as an area series or add a needle to it. Default's false.
         */
        needle: boolean;

        /**
         * Whether to add the pie chart elements as legend items. Default's false.
         */
        showInLegend: boolean;

        /**
         * An object containing styles for overriding series styles from Theming.
         */
        style: any;

        type: string;

        constructor(config: Ext.chart.series.GaugeConfig);

        /**
         * Draws the series for the current chart.
         */
        drawSeries();

        /**
         * Returns the color of the series (to be displayed as color for the series legend item).
         * @param item {Object} Info about the item; same format as returned by #getItemForPoint
         */
        getLegendColor();

        /**
         * Sets the Gauge chart to the current specified value.
         */
        setValue();
    }

    interface LineConfig extends Ext.chart.series.CartesianConfig {
        /**
         * If true, the area below the line will be filled in using the {@link #style eefill} and
         * {@link #style opacity} config properties. Defaults to false.
         */
        fill?: boolean;

        /**
         * The display style for the markers. Only used if {@link #showMarkers} is true.
         * The markerConfig is a configuration object containing the same set of properties defined in
         * the Sprite class. For example, if we were to set red circles as markers to the line series we could
         * pass the object:
         *
         <pre><code>
         markerConfig: {
         type: 'circle',
         radius: 4,
         'fill': '#f00'
         }
         </code></pre>
         */
        markerConfig?: any;

        /**
         * The offset distance from the cursor position to the line series to trigger events (then used for highlighting series, etc).
         */
        selectionTolerance?: number;

        /**
         * Whether markers should be displayed at the data points along the line. If true,
         * then the {@link #markerConfig} config item will determine the markers' styling.
         */
        showMarkers?: boolean;

        /**
         * If set to 'true' or a non-zero number, the line will be smoothed/rounded around its points; otherwise
         * straight line segments will be drawn.
         *
         * A numeric value is interpreted as a divisor of the horizontal distance between consecutive points in
         * the line; larger numbers result in sharper curves while smaller numbers result in smoother curves.
         *
         * If set to 'true' then a default numeric value of 3 will be used. Defaults to 'false'.
         */
        smooth?: boolean|number;

        /**
         * An object containing style properties for the visualization lines and fill.
         * These styles will override the theme styles.  The following are valid style properties:
         *
         * - 'stroke' - an rgb or hex color string for the background color of the line
         * - 'stroke-width' - the width of the stroke (integer)
         * - 'fill' - the background fill color string (hex or rgb), only works if {@link #fill} is 'true'
         * - 'opacity' - the opacity of the line and the fill color (decimal)
         *
         * Example usage:
         *
         *     style: {
         *         stroke: '#00ff00',
         *         'stroke-width': 10,
         *         fill: '#80A080',
         *         opacity: 0.2
         *     }
         */
        style?: any;

        type?: any;
    }

    /**
     * @extends Ext.chart.series.Cartesian
     *
     * Creates a Line Chart. A Line Chart is a useful visualization technique to display quantitative information for different
     * categories or other real values (as opposed to the bar chart), that can show some progression (or regression) in the dataset.
     * As with all other series, the Line Series must be appended in the *series* Chart array configuration. See the Chart
     * documentation for more information. A typical configuration object for the line series could be:
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['name', 'data1', 'data2', 'data3', 'data4', 'data5'],
     *         data: [
     *             { 'name': 'metric one',   'data1': 10, 'data2': 12, 'data3': 14, 'data4': 8,  'data5': 13 },
     *             { 'name': 'metric two',   'data1': 7,  'data2': 8,  'data3': 16, 'data4': 10, 'data5': 3  },
     *             { 'name': 'metric three', 'data1': 5,  'data2': 2,  'data3': 14, 'data4': 12, 'data5': 7  },
     *             { 'name': 'metric four',  'data1': 2,  'data2': 14, 'data3': 6,  'data4': 1,  'data5': 23 },
     *             { 'name': 'metric five',  'data1': 4,  'data2': 4,  'data3': 36, 'data4': 13, 'data5': 33 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 300,
     *         animate: true,
     *         store: store,
     *         axes: [
     *             {
     *                 type: 'Numeric',
     *                 position: 'left',
     *                 fields: ['data1', 'data2'],
     *                 label: {
     *                     renderer: Ext.util.Format.numberRenderer('0,0')
     *                 },
     *                 title: 'Sample Values',
     *                 grid: true,
     *                 minimum: 0
     *             },
     *             {
     *                 type: 'Category',
     *                 position: 'bottom',
     *                 fields: ['name'],
     *                 title: 'Sample Metrics'
     *             }
     *         ],
     *         series: [
     *             {
     *                 type: 'line',
     *                 highlight: {
     *                     size: 7,
     *                     radius: 7
     *                 },
     *                 axis: 'left',
     *                 xField: 'name',
     *                 yField: 'data1',
     *                 markerConfig: {
     *                     type: 'cross',
     *                     size: 4,
     *                     radius: 4,
     *                     'stroke-width': 0
     *                 }
     *             },
     *             {
     *                 type: 'line',
     *                 highlight: {
     *                     size: 7,
     *                     radius: 7
     *                 },
     *                 axis: 'left',
     *                 fill: true,
     *                 xField: 'name',
     *                 yField: 'data2',
     *                 markerConfig: {
     *                     type: 'circle',
     *                     size: 4,
     *                     radius: 4,
     *                     'stroke-width': 0
     *                 }
     *             }
     *         ]
     *     });
     *
     * In this configuration we're adding two series (or lines), one bound to the 'data1'
     * property of the store and the other to 'data3'. The type for both configurations is
     * 'line'. The 'xField' for both series is the same, the name propert of the store.
     * Both line series share the same axis, the left axis. You can set particular marker
     * configuration by adding properties onto the markerConfig object. Both series have
     * an object as highlight so that markers animate smoothly to the properties in highlight
     * when hovered. The second series has 'fill=true' which means that the line will also
     * have an area below it of the same color.
     *
     * **Note:** In the series definition remember to explicitly set the axis to bind the
     * values of the line series to. This can be done by using the 'axis' configuration property.
     */
    export class Line extends Ext.chart.series.Cartesian implements Ext.chart.series.LineConfig {
        /**
         * If true, the area below the line will be filled in using the {@link #style eefill} and
         * {@link #style opacity} config properties. Defaults to false.
         */
        fill: boolean;

        /**
         * The display style for the markers. Only used if {@link #showMarkers} is true.
         * The markerConfig is a configuration object containing the same set of properties defined in
         * the Sprite class. For example, if we were to set red circles as markers to the line series we could
         * pass the object:
         *
         <pre><code>
         markerConfig: {
         type: 'circle',
         radius: 4,
         'fill': '#f00'
         }
         </code></pre>
         */
        markerConfig: any;

        /**
         * The offset distance from the cursor position to the line series to trigger events (then used for highlighting series, etc).
         */
        selectionTolerance: number;

        /**
         * Whether markers should be displayed at the data points along the line. If true,
         * then the {@link #markerConfig} config item will determine the markers' styling.
         */
        showMarkers: boolean;

        /**
         * If set to 'true' or a non-zero number, the line will be smoothed/rounded around its points; otherwise
         * straight line segments will be drawn.
         *
         * A numeric value is interpreted as a divisor of the horizontal distance between consecutive points in
         * the line; larger numbers result in sharper curves while smaller numbers result in smoother curves.
         *
         * If set to 'true' then a default numeric value of 3 will be used. Defaults to 'false'.
         */
        smooth: boolean|number;

        /**
         * An object containing style properties for the visualization lines and fill.
         * These styles will override the theme styles.  The following are valid style properties:
         *
         * - 'stroke' - an rgb or hex color string for the background color of the line
         * - 'stroke-width' - the width of the stroke (integer)
         * - 'fill' - the background fill color string (hex or rgb), only works if {@link #fill} is 'true'
         * - 'opacity' - the opacity of the line and the fill color (decimal)
         *
         * Example usage:
         *
         *     style: {
         *         stroke: '#00ff00',
         *         'stroke-width': 10,
         *         fill: '#80A080',
         *         opacity: 0.2
         *     }
         */
        style: any;

        type: string;

        constructor(config: Ext.chart.series.LineConfig);

        /**
         * Draws the series for the current chart.
         */
        drawSeries();
    }

    interface PieConfig extends Ext.chart.series.SeriesConfig {
        /**
         * (required)
         * The store record field name to be used for the pie angles.
         * The values bound to this field name must be positive real numbers.
         */
        angleField?: string;

        /**
         * An array of color values which will be used, in order, as the pie slice fill colors.
         */
        colorSet?: any[];

        /**
         * Whether to set the pie chart as donut chart.
         * Default's false. Can be set to a particular percentage to set the radius
         * of the donut chart.
         */
        donut?: boolean|number;

        /**
         * Alias for {@link #angleField}.
         */
        field?: string;

        /**
         * The duration for the pie slice highlight effect.
         */
        highlightDuration?: number;

        /**
         * The store record field name to be used for the pie slice lengths.
         * The values bound to this field name must be positive real numbers.
         */
        lengthField?: string;

        /**
         * Whether to add the pie chart elements as legend items. Default's false.
         */
        showInLegend?: boolean;

        /**
         * An object containing styles for overriding series styles from Theming.
         */
        style?: any;

        type?: any;

        /**
         * Alias for {@link #angleField}.
         */
        xField?: string;
    }

    /**
     * Creates a Pie Chart. A Pie Chart is a useful visualization technique to display quantitative information for different
     * categories that also have a meaning as a whole.
     * As with all other series, the Pie Series must be appended in the *series* Chart array configuration. See the Chart
     * documentation for more information. A typical configuration object for the pie series could be:
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['name', 'data'],
     *         data: [
     *             { 'name': 'metric one',   'data': 10 },
     *             { 'name': 'metric two',   'data':  7 },
     *             { 'name': 'metric three', 'data':  5 },
     *             { 'name': 'metric four',  'data':  2 },
     *             { 'name': 'metric five',  'data': 27 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 350,
     *         animate: true,
     *         store: store,
     *         theme: 'Base:gradients',
     *         series: [{
     *             type: 'pie',
     *             angleField: 'data',
     *             showInLegend: true,
     *             tips: {
     *                 trackMouse: true,
     *                 width: 140,
     *                 height: 28,
     *                 renderer: function(storeItem, item) {
     *                     // calculate and display percentage on hover
     *                     var total = 0;
     *                     store.each(function(rec) {
     *                         total += rec.get('data');
     *                     });
     *                     this.setTitle(storeItem.get('name') + ': ' + Math.round(storeItem.get('data') / total * 100) + '%');
     *                 }
     *             },
     *             highlight: {
     *                 segment: {
     *                     margin: 20
     *                 }
     *             },
     *             label: {
     *                 field: 'name',
     *                 display: 'rotate',
     *                 contrast: true,
     *                 font: '18px Arial'
     *             }
     *         }]
     *     });
     *
     * In this configuration we set 'pie' as the type for the series, set an object with specific style properties for highlighting options
     * (triggered when hovering elements). We also set true to 'showInLegend' so all the pie slices can be represented by a legend item.
     *
     * We set 'data' as the value of the field to determine the angle span for each pie slice. We also set a label configuration object
     * where we set the field name of the store field to be renderer as text for the label. The labels will also be displayed rotated.
     *
     * We set 'contrast' to 'true' to flip the color of the label if it is to similar to the background color. Finally, we set the font family
     * and size through the 'font' parameter.
     */
    export class Pie extends Ext.chart.series.Series implements Ext.chart.series.PieConfig {
        /**
         * (required)
         * The store record field name to be used for the pie angles.
         * The values bound to this field name must be positive real numbers.
         */
        angleField: string;

        /**
         * An array of color values which will be used, in order, as the pie slice fill colors.
         */
        colorSet: any[];

        /**
         * Whether to set the pie chart as donut chart.
         * Default's false. Can be set to a particular percentage to set the radius
         * of the donut chart.
         */
        donut: boolean|number;

        /**
         * Alias for {@link #angleField}.
         */
        field: string;

        /**
         * The duration for the pie slice highlight effect.
         */
        highlightDuration: number;

        /**
         * The store record field name to be used for the pie slice lengths.
         * The values bound to this field name must be positive real numbers.
         */
        lengthField: string;

        /**
         * Whether to add the pie chart elements as legend items. Default's false.
         */
        showInLegend: boolean;

        /**
         * An object containing styles for overriding series styles from Theming.
         */
        style: any;

        type: string;

        /**
         * Alias for {@link #angleField}.
         */
        xField: string;

        constructor(config: Ext.chart.series.PieConfig);

        /**
         * Draws the series for the current chart.
         */
        drawSeries();

        /**
         * Returns the color of the series (to be displayed as color for the series legend item).
         * @param item {Object} Info about the item; same format as returned by #getItemForPoint
         */
        getLegendColor();

        /**
         * Highlight the specified item. If no item is provided the whole series will be highlighted.
         * @param item {Object} Info about the item; same format as returned by #getItemForPoint
         */
        highlightItem();

        /**
         * Un-highlights the specified item. If no item is provided it will un-highlight the entire series.
         * @param item {Object} Info about the item; same format as returned by #getItemForPoint
         */
        unHighlightItem();
    }

    interface RadarConfig extends Ext.chart.series.SeriesConfig {
        /**
         * The display style for the markers. Only used if {@link #showMarkers} is true.
         * The markerConfig is a configuration object containing the same set of properties defined in
         * the Sprite class. For example, if we were to set red circles as markers to the series we could
         * pass the object:
         *
         *     @example
         *     markerConfig: {
         *         type: 'circle',
         *         radius: 4,
         *         'fill': '#f00'
         *     }
         */
        markerConfig?: any;

        showInLegend?: any;

        /**
         * Whether markers should be displayed at the data points of the series. If true,
         * then the {@link #markerConfig} config item will determine the markers' styling.
         */
        showMarkers?: boolean;

        /**
         * An object containing styles for overriding series styles from Theming.
         */
        style?: any;

        type?: any;

        /**
         * The name of the data Model field corresponding to the x-axis (angle) value.
         */
        xField?: string;

        /**
         * The name of the data Model field corresponding to the y-axis (radius) value.
         */
        yField?: string;
    }

    /**
     * Creates a Radar Chart. A Radar Chart is a useful visualization technique for comparing different quantitative values for
     * a constrained number of categories.
     *
     * As with all other series, the Radar series must be appended in the *series* Chart array configuration. See the Chart
     * documentation for more information. A typical configuration object for the radar series could be:
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['name', 'data1', 'data2', 'data3'],
     *         data: [
     *             { 'name': 'metric one',   'data1': 14, 'data2': 12, 'data3': 13 },
     *             { 'name': 'metric two',   'data1': 16, 'data2':  8, 'data3':  3 },
     *             { 'name': 'metric three', 'data1': 14, 'data2':  2, 'data3':  7 },
     *             { 'name': 'metric four',  'data1':  6, 'data2': 14, 'data3': 23 },
     *             { 'name': 'metric five',  'data1': 36, 'data2': 38, 'data3': 33 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 300,
     *         animate: true,
     *         theme:'Category2',
     *         store: store,
     *         axes: [{
     *             type: 'Radial',
     *             position: 'radial',
     *             label: {
     *                 display: true
     *             }
     *         }],
     *         series: [{
     *             type: 'radar',
     *             xField: 'name',
     *             yField: 'data1',
     *             showInLegend: true,
     *             showMarkers: true,
     *             markerConfig: {
     *                 radius: 5,
     *                 size: 5
     *             },
     *             style: {
     *                 'stroke-width': 2,
     *                 fill: 'none'
     *             }
     *         },{
     *             type: 'radar',
     *             xField: 'name',
     *             yField: 'data2',
     *             showMarkers: true,
     *             showInLegend: true,
     *             markerConfig: {
     *                 radius: 5,
     *                 size: 5
     *             },
     *             style: {
     *                 'stroke-width': 2,
     *                 fill: 'none'
     *             }
     *         },{
     *             type: 'radar',
     *             xField: 'name',
     *             yField: 'data3',
     *             showMarkers: true,
     *             showInLegend: true,
     *             markerConfig: {
     *                 radius: 5,
     *                 size: 5
     *             },
     *             style: {
     *                 'stroke-width': 2,
     *                 fill: 'none'
     *             }
     *         }]
     *     });
     *
     * In this configuration we add three series to the chart. Each of these series is bound to the same
     * categories field, 'name' but bound to different properties for each category, 'data1', 'data2' and
     * 'data3' respectively. All series display markers by having 'showMarkers' enabled. The configuration
     * for the markers of each series can be set by adding properties onto the markerConfig object.
     * Finally we override some theme styling properties by adding properties to the 'style' object.
     */
    export class Radar extends Ext.chart.series.Series implements Ext.chart.series.RadarConfig {
        /**
         * The display style for the markers. Only used if {@link #showMarkers} is true.
         * The markerConfig is a configuration object containing the same set of properties defined in
         * the Sprite class. For example, if we were to set red circles as markers to the series we could
         * pass the object:
         *
         *     @example
         *     markerConfig: {
         *         type: 'circle',
         *         radius: 4,
         *         'fill': '#f00'
         *     }
         */
        markerConfig: any;

        showInLegend: boolean;

        /**
         * Whether markers should be displayed at the data points of the series. If true,
         * then the {@link #markerConfig} config item will determine the markers' styling.
         */
        showMarkers: boolean;

        /**
         * An object containing styles for overriding series styles from Theming.
         */
        style: any;

        type: string;

        /**
         * The name of the data Model field corresponding to the x-axis (angle) value.
         */
        xField: string;

        /**
         * The name of the data Model field corresponding to the y-axis (radius) value.
         */
        yField: string;

        /**
         * Draws the series for the current chart.
         */
        drawSeries();
    }

    interface ScatterConfig extends Ext.chart.series.CartesianConfig {
        /**
         * The display style for the scatter series markers.
         */
        markerConfig?: any;

        /**
         * Append styling properties to this object for it to override theme properties.
         */
        style?: any;

        type?: any;
    }

    /**
     * @extends Ext.chart.series.Cartesian
     *
     * Creates a Scatter Chart. The scatter plot is useful when trying to display more than two variables in the same visualization.
     * These variables can be mapped into x, y coordinates and also to an element's radius/size, color, etc.
     * As with all other series, the Scatter Series must be appended in the *series* Chart array configuration. See the Chart
     * documentation for more information on creating charts. A typical configuration object for the scatter could be:
     *
     *     @example
     *     var store = Ext.create('Ext.data.JsonStore', {
     *         fields: ['name', 'data1', 'data2', 'data3', 'data4', 'data5'],
     *         data: [
     *             { 'name': 'metric one',   'data1': 10, 'data2': 12, 'data3': 14, 'data4': 8,  'data5': 13 },
     *             { 'name': 'metric two',   'data1': 7,  'data2': 8,  'data3': 16, 'data4': 10, 'data5': 3  },
     *             { 'name': 'metric three', 'data1': 5,  'data2': 2,  'data3': 14, 'data4': 12, 'data5': 7  },
     *             { 'name': 'metric four',  'data1': 2,  'data2': 14, 'data3': 6,  'data4': 1,  'data5': 23 },
     *             { 'name': 'metric five',  'data1': 27, 'data2': 38, 'data3': 36, 'data4': 13, 'data5': 33 }
     *         ]
     *     });
     *
     *     Ext.create('Ext.chart.Chart', {
     *         renderTo: Ext.getBody(),
     *         width: 500,
     *         height: 300,
     *         animate: true,
     *         theme:'Category2',
     *         store: store,
     *         axes: [{
     *             type: 'Numeric',
     *             position: 'left',
     *             fields: ['data2', 'data3'],
     *             title: 'Sample Values',
     *             grid: true,
     *             minimum: 0
     *         }, {
     *             type: 'Category',
     *             position: 'bottom',
     *             fields: ['name'],
     *             title: 'Sample Metrics'
     *         }],
     *         series: [{
     *             type: 'scatter',
     *             markerConfig: {
     *                 radius: 5,
     *                 size: 5
     *             },
     *             axis: 'left',
     *             xField: 'name',
     *             yField: 'data2'
     *         }, {
     *             type: 'scatter',
     *             markerConfig: {
     *                 radius: 5,
     *                 size: 5
     *             },
     *             axis: 'left',
     *             xField: 'name',
     *             yField: 'data3'
     *         }]
     *     });
     *
     * In this configuration we add three different categories of scatter series. Each of them is bound to a different field of the same data store,
     * 'data1', 'data2' and 'data3' respectively. All x-fields for the series must be the same field, in this case 'name'.
     * Each scatter series has a different styling configuration for markers, specified by the 'markerConfig' object. Finally we set the left axis as
     * axis to show the current values of the elements.
     */
    export class Scatter extends Ext.chart.series.Cartesian implements Ext.chart.series.ScatterConfig {
        /**
         * The display style for the scatter series markers.
         */
        markerConfig: any;

        /**
         * Append styling properties to this object for it to override theme properties.
         */
        style: any;

        type: string;

        /**
         * Draws the series for the current chart.
         */
        drawSeries();
    }

    interface SeriesConfig {
        /**
         * If set to 'true' it will highlight the markers or the series when hovering
         * with the mouse. This parameter can also be an object with the same style
         * properties you would apply to a {@link Ext.draw.Sprite} to apply custom
         * styles to markers and series.
         */
        highlight?: boolean|any;

        /**
         * An (optional) object with event callbacks. All event callbacks get the target *item* as first parameter. The callback functions are:
         *
         *  - itemclick
         *  - itemmouseover
         *  - itemmouseout
         *  - itemmousedown
         *  - itemmouseup
         */
        listeners?: any;

        /**
         * A function that can be overridden to set custom styling properties to each rendered element.
         * Passes in (sprite, record, attributes, index, store) to the function.
         */
        renderer?: Function;

        /**
         * An array with shadow attributes
         */
        shadowAttributes?: any[];

        /**
         * Whether to show this series in the legend.
         */
        showInLegend?: boolean;

        /**
         * Add tooltips to the visualization's markers. The options for the tips are the
         * same configuration used with {@link Ext.tip.ToolTip}. For example:
         *
         *     tips: {
         *       trackMouse: true,
         *       width: 140,
         *       height: 28,
         *       renderer: function(storeItem, item) {
         *         this.setTitle(storeItem.get('name') + ': ' + storeItem.get('data1') + ' views');
         *       }
         *     },
         */
        tips?: any;

        /**
         * The human-readable name of the series.
         */
        title?: string;

        /**
         * The type of series. Set in subclasses.
         */
        type?: string;
    }

    /**
     * Series is the abstract class containing the common logic to all chart series. Series includes
     * methods from Labels, Highlights, Tips and Callouts mixins. This class implements the logic of handling
     * mouse events, animating, hiding, showing all elements and returning the color of the series to be used as a legend item.
     *
     * ## Listeners
     *
     * The series class supports listeners via the Observable syntax. Some of these listeners are:
     *
     *  - 'itemclick' When the user interacts with a marker.
     *  - 'itemmouseup' When the user interacts with a marker.
     *  - 'itemmousedown' When the user interacts with a marker.
     *  - 'itemmousemove' When the user iteracts with a marker.
     *  - 'afterrender' Will be triggered when the animation ends or when the series has been rendered completely.
     *
     * For example:
     *
     *     series: [{
     *             type: 'column',
     *             axis: 'left',
     *             listeners: {
     *                     'afterrender': function() {
     *                             console('afterrender');
     *                     }
     *             },
     *             xField: 'category',
     *             yField: 'data1'
     *     }]
     */
    export class Series extends Ext.Base implements Ext.chart.series.SeriesConfig {
        /**
         * If set to 'true' it will highlight the markers or the series when hovering
         * with the mouse. This parameter can also be an object with the same style
         * properties you would apply to a {@link Ext.draw.Sprite} to apply custom
         * styles to markers and series.
         */
        highlight: boolean|any;

        /**
         * An (optional) object with event callbacks. All event callbacks get the target *item* as first parameter. The callback functions are:
         *
         *  - itemclick
         *  - itemmouseover
         *  - itemmouseout
         *  - itemmousedown
         *  - itemmouseup
         */
        listeners: any;

        /**
         * A function that can be overridden to set custom styling properties to each rendered element.
         * Passes in (sprite, record, attributes, index, store) to the function.
         */
        renderer: Function;

        /**
         * An array with shadow attributes
         */
        shadowAttributes: any[];

        /**
         * Whether to show this series in the legend.
         */
        showInLegend: boolean;

        /**
         * Add tooltips to the visualization's markers. The options for the tips are the
         * same configuration used with {@link Ext.tip.ToolTip}. For example:
         *
         *     tips: {
         *       trackMouse: true,
         *       width: 140,
         *       height: 28,
         *       renderer: function(storeItem, item) {
         *         this.setTitle(storeItem.get('name') + ': ' + storeItem.get('data1') + ' views');
         *       }
         *     },
         */
        tips: any;

        /**
         * The human-readable name of the series.
         */
        title: string;

        /**
         * The type of series. Set in subclasses.
         */
        type: string;

        /**
         * Iterate over each of the records for this series. The default implementation simply iterates
         * through the entire data store, but individual series implementations can override this to
         * provide custom handling, e.g. adding/removing records.
         * @param {Function} fn The function to execute for each record.
         * @param {Object} scope Scope for the fn.
         */
        eachRecord(fn: Function, scope: any);

        /**
         * For a given x/y point relative to the Surface, find a corresponding item from this
         * series, if any.
         * @return {Object} An object describing the item, or null if there is no matching item.
         * The exact contents of this object will vary by series type, but should always contain the following:
         * @return {Ext.chart.series.Series} return.series the Series object to which the item belongs
         * @return {Object} return.value the value(s) of the item's data point
         * @return {Array} return.point the x/y coordinates relative to the chart box of a single point
         * for this data item, which can be used as e.g. a tooltip anchor point.
         * @return {Ext.draw.Sprite} return.sprite the item's rendering Sprite.
         */
        getItemForPoint(x: number, y: number): any;

        /**
         * Returns a string with the color to be used for the series legend item.
         */
        getLegendColor();

        /**
         * Return the number of records being displayed in this series. Defaults to the number of
         * records in the store; individual series implementations can override to provide custom handling.
         */
        getRecordCount();

        /**
         * Hides all the elements in the series.
         */
        hideAll();

        /**
         * Determines whether the series item at the given index has been excluded, i.e. toggled off in the legend.
         */
        isExcluded();

        /**
         * Changes the value of the {@link #title} for the series.
         * Arguments can take two forms:
         * <ul>
         * <li>A single String value: this will be used as the new single title for the series (applies
         * to series with only one yField)</li>
         * <li>A numeric index and a String value: this will set the title for a single indexed yField.</li>
         * </ul>
         */
        setTitle(index: number, title: string);

        /**
         * Shows all the elements in the series.
         */
        showAll();

        /**
         * Fires when the series title is changed via {@link #setTitle}.
         * @param {String} title The new title value
         * @param {Number} index The index in the collection of titles
         */
        titlechange(title: string, index: number);
    }
}

declare module Ext.chart.theme {
    /**
     * Provides default colors for non-specified things. Should be sub-classed when creating new themes.
     */
    export class Base extends Ext.Base {
        constructor();
    }

    /**
     * Provides chart theming.
     *
     * Used as mixins by Ext.chart.Chart.
     */
    export class Theme {
    }
}

declare module Ext.container {
    interface AbstractContainerConfig extends Ext.ComponentConfig {
        /**
         * A string component id or the numeric index of the component that should be
         * initially activated within the container's layout on render.  For example,
         * activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the
         * container's collection).  activeItem only applies to layout styles that can
         * display items one at a time (like {@link Ext.layout.container.Card} and
         * {@link Ext.layout.container.Fit}).
         *
         * @since 2.3.0
         */
        activeItem?: string|number;

        /**
         * If true the container will automatically destroy any contained component that is removed
         * from it, else destruction must be handled manually.
         * @since 2.3.0
         *
         * Optional, Defaults to: true
         */
        autoDestroy?: boolean;

        baseCls?: any;

        /**
         * An array of events that, when fired, should be bubbled to any parent container.
         * See {@link Ext.util.Observable#enableBubble}.
         * @since 3.4.0
         */
        bubbleEvents?: string;

        /**
         * The default {@link Ext.Component xtype} of child Components to create in this Container when
         * a child item is specified as a raw configuration object, rather than as an instantiated Component.
         * @since 2.3.0
         *
         * Optional, Defaults to: "panel"
         */
        defaultType?: string;

        /**
         * This option is a means of applying default settings to all added items whether added
         * through the {@link #cfg-items} config or via the {@link #method-add} or {@link #insert} methods.
         *
         * Defaults are applied to both config objects and instantiated components conditionally
         * so as not to override existing properties in the item (see {@link Ext#applyIf}).
         *
         * If the defaults option is specified as a function, then the function will be called
         * using this Container as the scope ('this' reference) and passing the added item as
         * the first parameter. Any resulting object from that call is then applied to the item
         * as default properties.
         *
         * For example, to automatically apply padding to the body of each of a set of
         * contained {@link Ext.panel.Panel} items, you could pass:
         * 'defaults: {bodyStyle:'padding:15px'}'.
         *
         * Usage:
         *
         *     defaults: { // defaults are applied to items, not the container
         *         autoScroll: true
         *     },
         *     items: [
         *         // default will not be applied here, panel1 will be autoScroll: false
         *         {
         *             xtype: 'panel',
         *             id: 'panel1',
         *             autoScroll: false
         *         },
         *         // this component will have autoScroll: true
         *         new Ext.panel.Panel({
         *             id: 'panel2'
         *         })
         *     ]
         *
         * @since 2.3.0
         */
        defaults?: any|Function;

        /**
         * True to move any component to the {@link Ext#getDetachedBody detachedBody} when the component is
         * removed from this container. This option is only applicable when the component is not destroyed while
         * being removed, see {@link #autoDestroy} and {@link #method-remove}. If this option is set to false, the DOM
         * of the component will remain in the current place until it is explicitly moved.
         *
         * Optional, Defaults to: true
         */
        detachOnRemove?: boolean;

        /**
         * **Important**: In order for child items to be correctly sized and
         * positioned, typically a layout manager **must** be specified through
         * the 'layout' configuration option.
         *
         * The sizing and positioning of child {@link #cfg-items} is the responsibility of
         * the Container's layout manager which creates and manages the type of layout
         * you have in mind.  For example:
         *
         * If the layout configuration is not explicitly specified for
         * a general purpose container (e.g. Container or Panel) the
         * {@link Ext.layout.container.Auto default layout manager} will be used
         * which does nothing but render child components sequentially into the
         * Container (no sizing or positioning will be performed in this situation).
         *
         * **layout** may be specified as either as an Object or as a String:
         *
         * ## Specify as an Object
         *
         * Example usage:
         *
         *     layout: {
         *         type: 'vbox',
         *         align: 'left'
         *     }
         *
         *   - **type**
         *
         *     The layout type to be used for this container.  If not specified,
         *     a default {@link Ext.layout.container.Auto} will be created and used.
         *
         *     Valid layout <code>type</code> values are listed in {@link Ext.enums.Layout}.
         *
         *   - Layout specific configuration properties
         *
         *     Additional layout specific configuration properties may also be
         *     specified. For complete details regarding the valid config options for
         *     each layout type, see the layout class corresponding to the 'type'
         *     specified.
         *
         * ## Specify as a String
         *
         * Example usage:
         *
         *     layout: 'vbox'
         *
         *   - **layout**
         *
         *     The layout 'type' to be used for this container (see {@link Ext.enums.Layout}
         *     for list of valid values).
         *
         *     Additional layout specific configuration properties. For complete
         *     details regarding the valid config options for each layout type, see the
         *     layout class corresponding to the 'layout' specified.
         *
         * ## Configuring the default layout type
         *
         * If a certain Container class has a default layout (For example a {@link Ext.toolbar.Toolbar Toolbar}
         * with a default 'Box' layout), then to simply configure the default layout,
         * use an object, but without the 'type' property:
         *
         *
         *     xtype: 'toolbar',
         *     layout: {
         *         pack: 'center'
         *     }
         *
         * @since 2.3.0
         */
        layout?: Ext.enums.Layout|any;

        /**
         * If true, suspend calls to doLayout. Useful when batching multiple adds to a container
         * and not passing them as multiple arguments or an array.
         */
        suspendLayout?: boolean;
    }

    /**
     * An abstract base class which provides shared methods for Containers across the Sencha product line.
     *
     * Please refer to sub class's documentation
     */
    export class AbstractContainer extends Ext.Component implements Ext.container.AbstractContainerConfig {
        /**
         * The MixedCollection containing all the child items of this container.
         * @since 2.3.0
         */
        items: Ext.util.AbstractMixedCollection;

        /**
         * A string component id or the numeric index of the component that should be
         * initially activated within the container's layout on render.  For example,
         * activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the
         * container's collection).  activeItem only applies to layout styles that can
         * display items one at a time (like {@link Ext.layout.container.Card} and
         * {@link Ext.layout.container.Fit}).
         *
         * @since 2.3.0
         */
        activeItem: string|number;

        /**
         * If true the container will automatically destroy any contained component that is removed
         * from it, else destruction must be handled manually.
         * @since 2.3.0
         *
         * Optional, Defaults to: true
         */
        autoDestroy: boolean;

        baseCls: string;

        /**
         * An array of events that, when fired, should be bubbled to any parent container.
         * See {@link Ext.util.Observable#enableBubble}.
         * @since 3.4.0
         */
        bubbleEvents: string;

        /**
         * This option is a means of applying default settings to all added items whether added
         * through the {@link #cfg-items} config or via the {@link #method-add} or {@link #insert} methods.
         *
         * Defaults are applied to both config objects and instantiated components conditionally
         * so as not to override existing properties in the item (see {@link Ext#applyIf}).
         *
         * If the defaults option is specified as a function, then the function will be called
         * using this Container as the scope ('this' reference) and passing the added item as
         * the first parameter. Any resulting object from that call is then applied to the item
         * as default properties.
         *
         * For example, to automatically apply padding to the body of each of a set of
         * contained {@link Ext.panel.Panel} items, you could pass:
         * 'defaults: {bodyStyle:'padding:15px'}'.
         *
         * Usage:
         *
         *     defaults: { // defaults are applied to items, not the container
         *         autoScroll: true
         *     },
         *     items: [
         *         // default will not be applied here, panel1 will be autoScroll: false
         *         {
         *             xtype: 'panel',
         *             id: 'panel1',
         *             autoScroll: false
         *         },
         *         // this component will have autoScroll: true
         *         new Ext.panel.Panel({
         *             id: 'panel2'
         *         })
         *     ]
         *
         * @since 2.3.0
         */
        defaults: any|Function;

        /**
         * The default {@link Ext.Component xtype} of child Components to create in this Container when
         * a child item is specified as a raw configuration object, rather than as an instantiated Component.
         * @since 2.3.0
         *
         * Optional, Defaults to: "panel"
         */
        defaultType: string;

        /**
         * True to move any component to the {@link Ext#getDetachedBody detachedBody} when the component is
         * removed from this container. This option is only applicable when the component is not destroyed while
         * being removed, see {@link #autoDestroy} and {@link #method-remove}. If this option is set to false, the DOM
         * of the component will remain in the current place until it is explicitly moved.
         *
         * Optional, Defaults to: true
         */
        detachOnRemove: boolean;

        /**
         * **Important**: In order for child items to be correctly sized and
         * positioned, typically a layout manager **must** be specified through
         * the 'layout' configuration option.
         *
         * The sizing and positioning of child {@link #cfg-items} is the responsibility of
         * the Container's layout manager which creates and manages the type of layout
         * you have in mind.  For example:
         *
         * If the layout configuration is not explicitly specified for
         * a general purpose container (e.g. Container or Panel) the
         * {@link Ext.layout.container.Auto default layout manager} will be used
         * which does nothing but render child components sequentially into the
         * Container (no sizing or positioning will be performed in this situation).
         *
         * **layout** may be specified as either as an Object or as a String:
         *
         * ## Specify as an Object
         *
         * Example usage:
         *
         *     layout: {
         *         type: 'vbox',
         *         align: 'left'
         *     }
         *
         *   - **type**
         *
         *     The layout type to be used for this container.  If not specified,
         *     a default {@link Ext.layout.container.Auto} will be created and used.
         *
         *     Valid layout <code>type</code> values are listed in {@link Ext.enums.Layout}.
         *
         *   - Layout specific configuration properties
         *
         *     Additional layout specific configuration properties may also be
         *     specified. For complete details regarding the valid config options for
         *     each layout type, see the layout class corresponding to the 'type'
         *     specified.
         *
         * ## Specify as a String
         *
         * Example usage:
         *
         *     layout: 'vbox'
         *
         *   - **layout**
         *
         *     The layout 'type' to be used for this container (see {@link Ext.enums.Layout}
         *     for list of valid values).
         *
         *     Additional layout specific configuration properties. For complete
         *     details regarding the valid config options for each layout type, see the
         *     layout class corresponding to the 'layout' specified.
         *
         * ## Configuring the default layout type
         *
         * If a certain Container class has a default layout (For example a {@link Ext.toolbar.Toolbar Toolbar}
         * with a default 'Box' layout), then to simply configure the default layout,
         * use an object, but without the 'type' property:
         *
         *
         *     xtype: 'toolbar',
         *     layout: {
         *         pack: 'center'
         *     }
         *
         * @since 2.3.0
         */
        layout: Ext.enums.Layout|any;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * If true, suspend calls to doLayout. Useful when batching multiple adds to a container
         * and not passing them as multiple arguments or an array.
         */
        suspendLayout: boolean;

        /**
         * Adds {@link Ext.Component Component}(s) to this Container.
         *
         * ## Description:
         *
         * - Fires the {@link #beforeadd} event before adding.
         * - The Container's {@link #defaults default config values} will be applied
         *   accordingly (see '{@link #defaults}' for details).
         * - Fires the '{@link #event-add}' event after the component has been added.
         *
         * ## Notes:
         *
         * If the Container is __already rendered__ when 'add'
         * is called, it will render the newly added Component into its content area.
         *
         * **If** the Container was configured with a size-managing {@link #layout} manager,
         * the Container will recalculate its internal layout at this time too.
         *
         * Note that the default layout manager simply renders child Components sequentially
         * into the content area and thereafter performs no sizing.
         *
         * If adding multiple new child Components, pass them as an array to the 'add' method,
         * so that only one layout recalculation is performed.
         *
         *     tb = new {@link Ext.toolbar.Toolbar}({
         *         renderTo: document.body
         *     });  // toolbar is rendered
         *     // add multiple items.
         *     // ({@link #defaultType} for {@link Ext.toolbar.Toolbar Toolbar} is 'button')
         *     tb.add([{text:'Button 1'}, {text:'Button 2'}]);
         *
         * To inject components between existing ones, use the {@link #insert} method.
         *
         * ## Warning:
         *
         * Components directly managed by the BorderLayout layout manager may not be removed
         * or added.  See the Notes for {@link Ext.layout.container.Border BorderLayout} for
         * more details.
         *
         * Either one or more Components to add or an Array of Components to add.
         * See '{@link #cfg-items}' for additional information.
         *
         * @return {Ext.Component[]/Ext.Component} The Components that were added.
         *
         * @since 2.3.0
         */
        add(component: Ext.Component[]|any[]): Ext.Component;

        /**
         * Invoked after the Container has laid out (and rendered if necessary)
         * its child Components.
         */
        protected afterLayout(layout: Ext.layout.container.Container);

        /**
         * Cascades down the component/container heirarchy from this component (passed in
         * the first call), calling the specified function with each component. The scope
         * (this reference) of the function call will be the scope provided or the current
         * component. The arguments to the function will be the args provided or the current
         * component. If the function returns false at any point, the cascade is stopped on
         * that branch.
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope of the function (defaults to current component)
         * @param {Array} [args] The args to call the function with. The current component
         * always passed as the last argument.
         * @return {Ext.Container} this
         * @since 2.3.0
         */
        cascade(fn: Function, scope?: any, args?: any[]): Ext.container.Container;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Determines whether the passed Component is either an immediate child of this Container,
         * or whether it is a descendant.
         *
         * @param {Ext.Component} comp The Component to test.
         * @param {Boolean} [deep=false] Pass 'true' to test for the Component being a descendant at any level.
         * @return {Boolean} 'true' if the passed Component is contained at the specified level.
         */
        contains(comp: Ext.Component, deep?: boolean): boolean;

        /**
         * Manually force this container's layout to be recalculated. The framework uses this internally to refresh layouts
         * form most cases.
         * @return {Ext.container.Container} this
         * @since 2.3.0
         */
        doLayout(): Ext.container.Container;

        /**
         * Examines this container's {@link #property-items} **property** and gets a direct child
         * component of this container.
         *
         * @param {String/Number} comp This parameter may be any of the following:
         *
         * - a **String** : representing the {@link Ext.Component#itemId itemId}
         *   or {@link Ext.Component#id id} of the child component.
         * - a **Number** : representing the position of the child component
         *   within the {@link #property-items} **property**
         *
         * For additional information see {@link Ext.util.MixedCollection#get}.
         *
         * @return {Ext.Component} The component (if found).
         *
         * @since 2.3.0
         */
        getComponent(comp: string|number): Ext.Component;

        /**
         * Returns the {@link Ext.layout.container.Container layout} instance currently associated with this Container.
         * If a layout has not been instantiated yet, that is done first
         * @return {Ext.layout.container.Container} The layout
         */
        getLayout(): Ext.layout.container.Container;

        /**
         * Used by {@link Ext.ComponentQuery ComponentQuery}, {@link #child} and {@link #down} to retrieve all of the items
         * which can potentially be considered a child of this Container.
         *
         * This may be overriden by Components which have ownership of Components
         * that are not contained in the {@link #property-items} collection.
         *
         * NOTE: IMPORTANT note for maintainers:
         * Items are returned in tree traversal order. Each item is appended to the result array
         * followed by the results of that child's getRefItems call.
         * Floating child items are appended after internal child items.
         */
        protected getRefItems();

        /**
         * Inserts a Component into this Container at a specified index. Fires the
         * {@link #beforeadd} event before inserting, then fires the {@link #event-add}
         * event after the Component has been inserted.
         *
         * @param {Number} index The index at which the Component will be inserted
         * into the Container's items collection
         *
         * @param {Ext.Component/Object} component The child Component to insert.
         *
         * Ext uses lazy rendering, and will only render the inserted Component should
         * it become necessary.
         *
         * A Component config object may be passed in order to avoid the overhead of
         * constructing a real Component object if lazy rendering might mean that the
         * inserted Component will not be rendered immediately. To take advantage of
         * this 'lazy instantiation', set the {@link Ext.Component#xtype} config
         * property to the registered type of the Component wanted.
         *
         * For a list of all available xtypes, see {@link Ext.enums.Widget}.
         *
         * @return {Ext.Component} component The Component (or config object) that was
         * inserted with the Container's default config values applied.
         *
         * @since 2.3.0
         */
        insert(index: number, component: Ext.Component|any): Ext.Component;

        /**
         * Determines whether **this Container** is an ancestor of the passed Component.
         * This will return 'true' if the passed Component is anywhere within the subtree
         * beneath this Container.
         * @param {Ext.Component} possibleDescendant The Component to test for presence
         * within this Container's subtree.
         */
        isAncestor(possibleDescendant: Ext.Component);

        /**
         * This method is invoked after a new Component has been added. It
         * is passed the Component which has been added. This method may
         * be used to update any internal structure which may depend upon
         * the state of the child items.
         */
        protected onAdd(component: Ext.Component, position: number);

        /**
         * This method is invoked before adding a new child Component. It
         * is passed the new Component, and may be used to modify the
         * Component, or prepare the Container in some way. Returning
         * false aborts the add operation.
         */
        protected onBeforeAdd(item: Ext.Component);

        /**
         * This method is invoked after a new Component has been
         * removed. It is passed the Component which has been
         * removed. This method may be used to update any internal
         * structure which may depend upon the state of the child items.
         */
        protected onRemove(component: Ext.Component, autoDestroy: boolean);

        protected onResize();

        /**
         * Removes a component from this container.  Fires the {@link #beforeremove} event
         * before removing, then fires the {@link #event-remove} event after the component has
         * been removed.
         *
         * @param {Ext.Component/String} component The component reference or id to remove.
         *
         * @param {Boolean} [autoDestroy] True to automatically invoke the removed Component's
         * {@link Ext.Component#method-destroy} function.
         *
         * Defaults to the value of this Container's {@link #autoDestroy} config.
         *
         * @return {Ext.Component} component The Component that was removed.
         * @since 2.3.0
         */
        remove(component: Ext.Component|string, autoDestroy?: boolean): Ext.Component;

        /**
         * Removes all components from this container.
         * @param {Boolean} [autoDestroy] True to automatically invoke the removed
         * Component's {@link Ext.Component#method-destroy} function.
         * Defaults to the value of this Container's {@link #autoDestroy} config.
         * @return {Ext.Component[]} Array of the removed components
         * @since 2.3.0
         */
        removeAll(autoDestroy?: boolean): Ext.Component;

        /**
         * Fires when the components in this container are arranged by the associated layout manager.
         * @param {Ext.layout.container.Container} layout The ContainerLayout implementation for this container
         * @since 2.3.0
         */
        afterlayout(that: Ext.container.Container, layout: Ext.layout.container.Container);

        /**
         * Fires before any {@link Ext.Component} is added or inserted into the container.
         * A handler can return false to cancel the add.
         * @param {Ext.Component} component The component being added
         * @param {Number} index The index at which the component will be added to the container's items collection
         * @since 2.3.0
         */
        beforeadd(that: Ext.container.Container, component: Ext.Component, index: number);

        /**
         * Fires before any {@link Ext.Component} is removed from the container.  A handler can return
         * false to cancel the remove.
         * @param {Ext.Component} component The component being removed
         * @since 2.3.0
         */
        beforeremove(that: Ext.container.Container, component: Ext.Component);
    }

    interface ButtonGroupConfig extends Ext.panel.PanelConfig {
        baseCls?: string;

        /**
         * The 'columns' configuration property passed to the {@link #layout configured layout manager}.
         * See {@link Ext.layout.container.Table#columns}.
         */
        columns?: number;

        /**
         * A default {@link Ext.Component#ui ui} to use for {@link Ext.button.Button Button} items
         */
        defaultButtonUI?: string;

        defaultType?: any;

        frame?: boolean;

        layout?: Ext.enums.Layout|any;

        titleAlign?: any;
    }

    /**
     * Provides a container for arranging a group of related Buttons in a tabular manner.
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Panel with ButtonGroup',
     *         width: 300,
     *         height:200,
     *         renderTo: document.body,
     *         bodyPadding: 10,
     *         html: 'HTML Panel Content',
     *         tbar: [{
     *             xtype: 'buttongroup',
     *             columns: 3,
     *             title: 'Clipboard',
     *             items: [{
     *                 text: 'Paste',
     *                 scale: 'large',
     *                 rowspan: 3,
     *                 iconCls: 'add',
     *                 iconAlign: 'top',
     *                 cls: 'btn-as-arrow'
     *             },{
     *                 xtype:'splitbutton',
     *                 text: 'Menu Button',
     *                 scale: 'large',
     *                 rowspan: 3,
     *                 iconCls: 'add',
     *                 iconAlign: 'top',
     *                 arrowAlign:'bottom',
     *                 menu: [{ text: 'Menu Item 1' }]
     *             },{
     *                 xtype:'splitbutton', text: 'Cut', iconCls: 'add16', menu: [{text: 'Cut Menu Item'}]
     *             },{
     *                 text: 'Copy', iconCls: 'add16'
     *             },{
     *                 text: 'Format', iconCls: 'add16'
     *             }]
     *         }]
     *     });
     */
    export class ButtonGroup extends Ext.panel.Panel implements Ext.container.ButtonGroupConfig {
        /**
         * The base CSS class to apply to this panel's element.
         * @since 2.3.0
         *
         * Optional, Defaults to: x-panel
         */
        baseCls: string;

        /**
         * The 'columns' configuration property passed to the {@link #layout configured layout manager}.
         * See {@link Ext.layout.container.Table#columns}.
         */
        columns: number;

        /**
         * A default {@link Ext.Component#ui ui} to use for {@link Ext.button.Button Button} items
         */
        defaultButtonUI: string;

        defaultType: string;

        /**
         * True to apply a frame to the panel.
         */
        frame: boolean;

        /**
         * **Important**: In order for child items to be correctly sized and
         * positioned, typically a layout manager **must** be specified through
         * the 'layout' configuration option.
         *
         * The sizing and positioning of child {@link #cfg-items} is the responsibility of
         * the Container's layout manager which creates and manages the type of layout
         * you have in mind.  For example:
         *
         * If the layout configuration is not explicitly specified for
         * a general purpose container (e.g. Container or Panel) the
         * {@link Ext.layout.container.Auto default layout manager} will be used
         * which does nothing but render child components sequentially into the
         * Container (no sizing or positioning will be performed in this situation).
         *
         * **layout** may be specified as either as an Object or as a String:
         *
         * ## Specify as an Object
         *
         * Example usage:
         *
         *     layout: {
         *         type: 'vbox',
         *         align: 'left'
         *     }
         *
         *   - **type**
         *
         *     The layout type to be used for this container.  If not specified,
         *     a default {@link Ext.layout.container.Auto} will be created and used.
         *
         *     Valid layout <code>type</code> values are listed in {@link Ext.enums.Layout}.
         *
         *   - Layout specific configuration properties
         *
         *     Additional layout specific configuration properties may also be
         *     specified. For complete details regarding the valid config options for
         *     each layout type, see the layout class corresponding to the 'type'
         *     specified.
         *
         * ## Specify as a String
         *
         * Example usage:
         *
         *     layout: 'vbox'
         *
         *   - **layout**
         *
         *     The layout 'type' to be used for this container (see {@link Ext.enums.Layout}
         *     for list of valid values).
         *
         *     Additional layout specific configuration properties. For complete
         *     details regarding the valid config options for each layout type, see the
         *     layout class corresponding to the 'layout' specified.
         *
         * ## Configuring the default layout type
         *
         * If a certain Container class has a default layout (For example a {@link Ext.toolbar.Toolbar Toolbar}
         * with a default 'Box' layout), then to simply configure the default layout,
         * use an object, but without the 'type' property:
         *
         *
         *     xtype: 'toolbar',
         *     layout: {
         *         pack: 'center'
         *     }
         *
         * @since 2.3.0
         */
        layout: Ext.enums.Layout|any;

        titleAlign: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface ContainerConfig extends Ext.container.AbstractContainerConfig {
        /**
         * Defines the anchoring size of container.
         * Either a number to define the width of the container or an object with 'width' and 'height' fields.
         */
        anchorSize?: number|any;
    }

    /**
     * Base class for any Ext.Component that may contain other Components. Containers handle the basic behavior of
     * containing items, namely adding, inserting and removing items.
     *
     * The most commonly used Container classes are Ext.panel.Panel, Ext.window.Window and
     * Ext.tab.Panel. If you do not need the capabilities offered by the aforementioned classes you can create a
     * lightweight Container to be encapsulated by an HTML element to your specifications by using the
     * {@link Ext.Component#autoEl autoEl} config option.
     *
     * The code below illustrates how to explicitly create a Container:
     *
     *     @example
     *     // Explicitly create a Container
     *     Ext.create('Ext.container.Container', {
     *         layout: {
     *             type: 'hbox'
     *         },
     *         width: 400,
     *         renderTo: Ext.getBody(),
     *         border: 1,
     *         style: {borderColor:'#000000', borderStyle:'solid', borderWidth:'1px'},
     *         defaults: {
     *             labelWidth: 80,
     *             // implicitly create Container by specifying xtype
     *             xtype: 'datefield',
     *             flex: 1,
     *             style: {
     *                 padding: '10px'
     *             }
     *         },
     *         items: [{
     *             xtype: 'datefield',
     *             name: 'startDate',
     *             fieldLabel: 'Start date'
     *         },{
     *             xtype: 'datefield',
     *             name: 'endDate',
     *             fieldLabel: 'End date'
     *         }]
     *     });
     *
     * ## Layout
     *
     * Container classes delegate the rendering of child Components to a layout manager class which must be configured into
     * the Container using the '{@link #layout}' configuration property.
     *
     * When either specifying child '{@link #cfg-items}' of a Container, or dynamically {@link #method-add adding} Components to a
     * Container, remember to consider how you wish the Container to arrange those child elements, and whether those child
     * elements need to be sized using one of Ext's built-in '{@link #layout}' schemes. By default, Containers use the
     * {@link Ext.layout.container.Auto Auto} scheme which only renders child components, appending them one after the other
     * inside the Container, and **does not apply any sizing** at all.
     *
     * A common mistake is when a developer neglects to specify a '{@link #layout}' (e.g. widgets like GridPanels or
     * TreePanels are added to Containers for which no '{@link #layout}' has been specified). If a Container is left to
     * use the default {@link Ext.layout.container.Auto Auto} scheme, none of its child components will be resized, or changed in
     * any way when the Container is resized.
     *
     * Certain layout managers allow dynamic addition of child components. Those that do include
     * Ext.layout.container.Card, Ext.layout.container.Anchor, Ext.layout.container.VBox,
     * Ext.layout.container.HBox, and Ext.layout.container.Table. For example:
     *
     *     //  Create the GridPanel.
     *     var myNewGrid = Ext.create('Ext.grid.Panel', {
     *         store: myStore,
     *         headers: myHeaders,
     *         title: 'Results', // the title becomes the title of the tab
     *     });
     *
     *     myTabPanel.add(myNewGrid); // {@link Ext.tab.Panel} implicitly uses {@link Ext.layout.container.Card Card}
     *     myTabPanel.{@link Ext.tab.Panel#setActiveTab setActiveTab}(myNewGrid);
     *
     * The example above adds a newly created GridPanel to a TabPanel. Note that a TabPanel uses {@link
     * Ext.layout.container.Card} as its layout manager which means all its child items are sized to {@link
     * Ext.layout.container.Fit fit} exactly into its client area.
     *
     * **_Overnesting is a common problem_**. An example of overnesting occurs when a GridPanel is added to a TabPanel by
     * wrapping the GridPanel _inside_ a wrapping Panel (that has no '{@link #layout}' specified) and then add that
     * wrapping Panel to the TabPanel. The point to realize is that a GridPanel **is** a Component which can be added
     * directly to a Container. If the wrapping Panel has no '{@link #layout}' configuration, then the overnested
     * GridPanel will not be sized as expected.
     *
     * ## Adding via remote configuration
     *
     * A server side script can be used to add Components which are generated dynamically on the server. An example of
     * adding a GridPanel to a TabPanel where the GridPanel is generated by the server based on certain parameters:
     *
     *     // execute an Ajax request to invoke server side script:
     *     Ext.Ajax.request({
     *         url: 'gen-invoice-grid.php',
     *         // send additional parameters to instruct server script
     *         params: {
     *             startDate: Ext.getCmp('start-date').getValue(),
     *             endDate: Ext.getCmp('end-date').getValue()
     *         },
     *         // process the response object to add it to the TabPanel:
     *         success: function(xhr) {
     *             var newComponent = eval(xhr.responseText); // see discussion below
     *             myTabPanel.add(newComponent); // add the component to the TabPanel
     *             myTabPanel.setActiveTab(newComponent);
     *         },
     *         failure: function() {
     *             Ext.Msg.alert("Grid create failed", "Server communication failure");
     *         }
     *     });
     *
     * The server script needs to return a JSON representation of a configuration object, which, when decoded will return a
     * config object with an {@link Ext.Component#xtype xtype}. The server might return the following JSON:
     *
     *     {
     *         "xtype": 'grid',
     *         "title": 'Invoice Report',
     *         "store": {
     *             "model": 'Invoice',
     *             "proxy": {
     *                 "type": 'ajax',
     *                 "url": 'get-invoice-data.php',
     *                 "reader": {
     *                     "type": 'json'
     *                     "record": 'transaction',
     *                     "idProperty": 'id',
     *                     "totalRecords": 'total'
     *                 })
     *             },
     *             "autoLoad": {
     *                 "params": {
     *                     "startDate": '01/01/2008',
     *                     "endDate": '01/31/2008'
     *                 }
     *             }
     *         },
     *         "headers": [
     *             {"header": "Customer", "width": 250, "dataIndex": 'customer', "sortable": true},
     *             {"header": "Invoice Number", "width": 120, "dataIndex": 'invNo', "sortable": true},
     *             {"header": "Invoice Date", "width": 100, "dataIndex": 'date', "renderer": Ext.util.Format.dateRenderer('M d, y'), "sortable": true},
     *             {"header": "Value", "width": 120, "dataIndex": 'value', "renderer": 'usMoney', "sortable": true}
     *         ]
     *     }
     *
     * When the above code fragment is passed through the 'eval' function in the success handler of the Ajax request, the
     * result will be a config object which, when added to a Container, will cause instantiation of a GridPanel. **Be sure
     * that the Container is configured with a layout which sizes and positions the child items to your requirements.**
     *
     * **Note:** since the code above is _generated_ by a server script, the 'autoLoad' params for the Store, the user's
     * preferred date format, the metadata to allow generation of the Model layout, and the ColumnModel can all be generated
     * into the code since these are all known on the server.
     */
    export class Container extends Ext.container.AbstractContainer implements Ext.container.ContainerConfig {
        /**
         * Defines the anchoring size of container.
         * Either a number to define the width of the container or an object with 'width' and 'height' fields.
         */
        anchorSize: number|any;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Return the immediate child Component in which the passed element is located.
         * @param {Ext.Element/HTMLElement/String} el The element to test (or ID of element).
         * @param {Boolean} deep If 'true', returns the deepest descendant Component which contains the passed element.
         * @return {Ext.Component} The child item which contains the passed element.
         */
        getChildByElement(el: Ext.dom.Element|HTMLElement|string, deep: boolean): Ext.Component;
    }

    interface DockingContainerConfig {
        /**
         * This object holds the default weights applied to dockedItems that have no weight. These start with a
         * weight of 1, to allow negative weights to insert before top items and are odd numbers
         * so that even weights can be used to get between different dock orders.
         *
         * To make default docking order match border layout, do this:
         *
         *      Ext.panel.AbstractPanel.prototype.defaultDockWeights = { top: 1, bottom: 3, left: 5, right: 7 };
         *
         * Changing these defaults as above or individually on this object will effect all Panels.
         * To change the defaults on a single panel, you should replace the entire object:
         *
         *      initComponent: function () {
         *          // NOTE: Don't change members of defaultDockWeights since the object is shared.
         *          this.defaultDockWeights = { top: 1, bottom: 3, left: 5, right: 7 };
         *
         *          this.callParent();
         *      }
         *
         * To change only one of the default values, you do this:
         *
         *      initComponent: function () {
         *          // NOTE: Don't change members of defaultDockWeights since the object is shared.
         *          this.defaultDockWeights = Ext.applyIf({ top: 10 }, this.defaultDockWeights);
         *
         *          this.callParent();
         *      }
         */
        defaultDockWeights?: any;
    }

    export class DockingContainer extends Ext.Base implements Ext.container.DockingContainerConfig {
        /**
         * This object holds the default weights applied to dockedItems that have no weight. These start with a
         * weight of 1, to allow negative weights to insert before top items and are odd numbers
         * so that even weights can be used to get between different dock orders.
         *
         * To make default docking order match border layout, do this:
         *
         *      Ext.panel.AbstractPanel.prototype.defaultDockWeights = { top: 1, bottom: 3, left: 5, right: 7 };
         *
         * Changing these defaults as above or individually on this object will effect all Panels.
         * To change the defaults on a single panel, you should replace the entire object:
         *
         *      initComponent: function () {
         *          // NOTE: Don't change members of defaultDockWeights since the object is shared.
         *          this.defaultDockWeights = { top: 1, bottom: 3, left: 5, right: 7 };
         *
         *          this.callParent();
         *      }
         *
         * To change only one of the default values, you do this:
         *
         *      initComponent: function () {
         *          // NOTE: Don't change members of defaultDockWeights since the object is shared.
         *          this.defaultDockWeights = Ext.applyIf({ top: 10 }, this.defaultDockWeights);
         *
         *          this.callParent();
         *      }
         */
        defaultDockWeights: any;

        /**
         * Adds docked item(s) to the container.
         *
         * @param {Object/Object[]} component The Component or array of components to add. The components
         * must include a 'dock' parameter on each component to indicate where it should be docked
         * ('top', 'right', 'bottom', 'left').
         * @param {Number} [pos] The index at which the Component will be added
         * @return {Ext.Component[]} The added components.
         */
        addDocked(component: any, pos?: number): Ext.Component;

        /**
         * Finds a docked component by id, itemId or position. Also see {@link #getDockedItems}
         * @param {String/Number} comp The id, itemId or position of the docked component (see {@link Ext.panel.AbstractPanel#getComponent getComponent} for details)
         * @return {Ext.Component} The docked component (if found)
         */
        getDockedComponent(comp: string|number): Ext.Component;

        /**
         * Retrieves an array of all currently docked Components.
         *
         * For example to find a toolbar that has been docked at top:
         *
         *     panel.getDockedItems('toolbar[dock="top"]');
         *
         * @param {String} selector A {@link Ext.ComponentQuery ComponentQuery} selector string to filter the returned items.
         * @param {Boolean} beforeBody An optional flag to limit the set of items to only those
         *  before the body (true) or after the body (false). All components are returned by
         *  default.
         * @return {Ext.Component[]} The array of docked components meeting the specified criteria.
         */
        getDockedItems(selector: string, beforeBody: boolean): Ext.Component;

        /**
         * Inserts docked item(s) to the panel at the indicated position.
         * @param {Number} pos The index at which the Component will be inserted
         * @param {Object/Object[]} component The Component or array of components to add. The components
         * must include a 'dock' paramater on each component to indicate where it should be docked ('top', 'right',
         * 'bottom', 'left').
         */
        insertDocked(pos: number, component: any);

        /**
         * Invoked after a docked item is added to the Panel.
         */
        protected onDockedAdd(component: Ext.Component);

        /**
         * Invoked after a docked item is removed from the Panel.
         */
        protected onDockedRemove(component: Ext.Component);

        /**
         * Removes the docked item from the panel.
         * @param {Ext.Component} item The Component to remove.
         * @param {Boolean} autoDestroy (optional) Destroy the component after removal.
         */
        removeDocked(item: Ext.Component, autoDestroy: boolean);

        /**
         * Fires when any {@link Ext.Component} is added or inserted as a docked item.
         * @param {Ext.Component} component The component being added
         * @param {Number} index The index at which the component will be added docked items collection
         */
        dockedadd(that: Ext.panel.Panel, component: Ext.Component, index: number);

        /**
         * Fires when any {@link Ext.Component} is removed from the docked items.
         * @param {Ext.Component} component The component being removed
         */
        dockedremove(that: Ext.panel.Panel, component: Ext.Component);
    }

    /**
     * This is a utility class for being able to track all items of a particular type
     * inside any level at a container. This can be used in favour of bubbling add/remove events
     * which can add a large perf cost when implemented globally
     */
    export class Monitor extends Ext.Base {
        constructor(config: any);
    }

    /**
     * A specialized container representing the viewable application area (the browser viewport).
     *
     * The Viewport renders itself to the document body, and automatically sizes itself to the size of
     * the browser viewport and manages window resizing. There may only be one Viewport created
     * in a page.
     *
     * Like any {@link Ext.container.Container Container}, a Viewport will only perform sizing and positioning
     * on its child Components if you configure it with a {@link #layout}.
     *
     * A Common layout used with Viewports is {@link Ext.layout.container.Border border layout}, but if the
     * required layout is simpler, a different layout should be chosen.
     *
     * For example, to simply make a single child item occupy all available space, use
     * {@link Ext.layout.container.Fit fit layout}.
     *
     * To display one "active" item at full size from a choice of several child items, use
     * {@link Ext.layout.container.Card card layout}.
     *
     * Inner layouts are available because all {@link Ext.panel.Panel Panel}s
     * added to the Viewport, either through its {@link #cfg-items}, or the {@link #method-add}
     * method of any of its child Panels may themselves have a layout.
     *
     * The Viewport does not provide scrolling, so child Panels within the Viewport should provide
     * for scrolling if needed using the {@link #autoScroll} config.
     *
     * An example showing a classic application border layout:
     *
     *     @example
     *     Ext.create('Ext.container.Viewport', {
     *         layout: 'border',
     *         items: [{
     *             region: 'north',
     *             html: '<h1 class="x-panel-header">Page Title</h1>',
     *             border: false,
     *             margins: '0 0 5 0'
     *         }, {
     *             region: 'west',
     *             collapsible: true,
     *             title: 'Navigation',
     *             width: 150
     *             // could use a TreePanel or AccordionLayout for navigational items
     *         }, {
     *             region: 'south',
     *             title: 'South Panel',
     *             collapsible: true,
     *             html: 'Information goes here',
     *             split: true,
     *             height: 100,
     *             minHeight: 100
     *         }, {
     *             region: 'east',
     *             title: 'East Panel',
     *             collapsible: true,
     *             split: true,
     *             width: 150
     *         }, {
     *             region: 'center',
     *             xtype: 'tabpanel', // TabPanel itself has no title
     *             activeTab: 0,      // First tab active by default
     *             items: {
     *                 title: 'Default Tab',
     *                 html: 'The first tab\'s content. Others may be added dynamically'
     *             }
     *         }]
     *     });
     */
    export class Viewport extends Ext.container.Container {
        /**
         * 'true' in this class to identify an object as an instantiated Viewport, or subclass thereof.
         */
        isViewport: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected onRender();
    }
}

declare module Ext.data {
    interface AbstractStoreConfig {
        /**
         * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
         * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
         * @since 2.3.0
         */
        autoLoad?: boolean|any;

        /**
         * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
         */
        autoSync?: boolean;

        /**
         * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
         * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
         * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
         * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
         */
        batchUpdateMode?: string;

        /**
         * This may be used in place of specifying a {@link #model} configuration. The fields should be a
         * set of {@link Ext.data.Field} configuration objects. The store will automatically create a {@link Ext.data.Model}
         * with these fields. In general this configuration option should only be used for simple stores like
         * a two-field store of ComboBox. For anything more complicated, such as specifying a particular id property or
         * associations, a {@link Ext.data.Model} should be defined and specified for the {@link #model}
         * config.
         * @since 2.3.0
         */
        fields?: any;

        /**
         * If true, any filters attached to this Store will be run after loading data, before the datachanged event is fired.
         * Defaults to true, ignored if {@link Ext.data.Store#remoteFilter remoteFilter} is true
         */
        filterOnLoad?: boolean;

        /**
         * Name of the {@link Ext.data.Model Model} associated with this store.
         * The string is used as an argument for {@link Ext.ModelManager#getModel}.
         */
        model?: string;

        /**
         * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
         * see {@link #setProxy} for details.
         * @since 1.1.0
         */
        proxy?: string|Ext.data.proxy.Proxy|any;

        /**
         * True to defer any filtering operation to the server. If false, filtering is done locally on the client.
         */
        remoteFilter?: boolean;

        /**
         * True to defer any sorting operation to the server. If false, sorting is done locally on the client.
         */
        remoteSort?: boolean;

        /**
         * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
         * Defaults to true, igored if {@link Ext.data.Store#remoteSort remoteSort} is true
         */
        sortOnLoad?: boolean;

        /**
         * Configure as 'true' to have the filters saved when a client {@link Ext.grid.Panel grid} saves its state.
         *
         * Optional, Defaults to: false
         */
        statefulFilters?: boolean;

        /**
         * Unique identifier for this store. If present, this Store will be registered with the {@link Ext.data.StoreManager},
         * making it easy to reuse elsewhere.
         *
         * Note that when store is instatiated by Controller, the storeId will be overridden by the name of the store.
         */
        storeId?: string;
    }

    /**
     * @author Ed Spencer
     *
     * AbstractStore is a superclass of {@link Ext.data.Store} and {@link Ext.data.TreeStore}. It's never used directly,
     * but offers a set of methods used by both of those subclasses.
     *
     * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
     * you're probably looking for is {@link Ext.data.Store}. If you're still interested, here's a brief description of what
     * AbstractStore is and is not.
     *
     * AbstractStore provides the basic configuration for anything that can be considered a Store. It expects to be
     * given a {@link Ext.data.Model Model} that represents the type of data in the Store. It also expects to be given a
     * {@link Ext.data.proxy.Proxy Proxy} that handles the loading of data into the Store.
     *
     * AbstractStore provides a few helpful methods such as {@link #method-load} and {@link #sync}, which load and save data
     * respectively, passing the requests through the configured {@link #proxy}. Both built-in Store subclasses add extra
     * behavior to each of these functions. Note also that each AbstractStore subclass has its own way of storing data -
     * in {@link Ext.data.Store} the data is saved as a flat {@link Ext.util.MixedCollection MixedCollection}, whereas in
     * {@link Ext.data.TreeStore TreeStore} we use a {@link Ext.data.Tree} to maintain the data's hierarchy.
     *
     * The store provides filtering and sorting support. This sorting/filtering can happen on the client side
     * or can be completed on the server. This is controlled by the {@link Ext.data.Store#remoteSort remoteSort} and
     * {@link Ext.data.Store#remoteFilter remoteFilter} config options. For more information see the {@link #sort} and
     * {@link Ext.data.Store#filter filter} methods.
     */
    export class AbstractStore extends Ext.Base implements Ext.data.AbstractStoreConfig {
        /**
         * The string type of the Proxy to create if none is specified. This defaults to creating a
         * {@link Ext.data.proxy.Memory memory proxy}.
         */
        defaultProxyType: string;

        /**
         * The collection of {@link Ext.util.Filter Filters} currently applied to this Store
         */
        filters: Ext.util.MixedCollection;

        /**
         * True if the Store has already been destroyed. If this is true, the reference to Store should be deleted
         * as it will not function correctly any more.
         * @since 3.4.0
         */
        isDestroyed: boolean;

        /**
         * 'true' in this class to identify an object as an instantiated Store, or subclass thereof.
         */
        isStore: boolean;

        /**
         * Temporary cache in which removed model instances are kept until successfully synchronised with a Proxy,
         * at which point this is cleared.
         */
        protected removed: Ext.data.Model;

        /**
         * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
         * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
         * @since 2.3.0
         */
        autoLoad: boolean|any;

        /**
         * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
         */
        autoSync: boolean;

        /**
         * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
         * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
         * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
         * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
         */
        batchUpdateMode: string;

        /**
         * This may be used in place of specifying a {@link #model} configuration. The fields should be a
         * set of {@link Ext.data.Field} configuration objects. The store will automatically create a {@link Ext.data.Model}
         * with these fields. In general this configuration option should only be used for simple stores like
         * a two-field store of ComboBox. For anything more complicated, such as specifying a particular id property or
         * associations, a {@link Ext.data.Model} should be defined and specified for the {@link #model}
         * config.
         * @since 2.3.0
         */
        fields: any;

        /**
         * If true, any filters attached to this Store will be run after loading data, before the datachanged event is fired.
         * Defaults to true, ignored if {@link Ext.data.Store#remoteFilter remoteFilter} is true
         */
        filterOnLoad: boolean;

        /**
         * Name of the {@link Ext.data.Model Model} associated with this store.
         * The string is used as an argument for {@link Ext.ModelManager#getModel}.
         */
        model: string;

        /**
         * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
         * see {@link #setProxy} for details.
         * @since 1.1.0
         */
        proxy: string|Ext.data.proxy.Proxy|any;

        /**
         * True to defer any filtering operation to the server. If false, filtering is done locally on the client.
         */
        remoteFilter: boolean;

        /**
         * True to defer any sorting operation to the server. If false, sorting is done locally on the client.
         */
        remoteSort: boolean;

        /**
         * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
         * Defaults to true, igored if {@link Ext.data.Store#remoteSort remoteSort} is true
         */
        sortOnLoad: boolean;

        /**
         * Configure as 'true' to have the filters saved when a client {@link Ext.grid.Panel grid} saves its state.
         *
         * Optional, Defaults to: false
         */
        statefulFilters: boolean;

        /**
         * Unique identifier for this store. If present, this Store will be registered with the {@link Ext.data.StoreManager},
         * making it easy to reuse elsewhere.
         *
         * Note that when store is instatiated by Controller, the storeId will be overridden by the name of the store.
         */
        storeId: string;

        constructor();

        /**
         * Gets all {@link Ext.data.Model records} added or updated since the last commit. Note that the order of records
         * returned is not deterministic and does not indicate the order in which records were modified. Note also that
         * removed records are not included (use {@link #getRemovedRecords} for that).
         * @return {Ext.data.Model[]} The added and updated Model instances
         */
        getModifiedRecords(): Ext.data.Model;

        /**
         * Returns all Model instances that are either currently a phantom (e.g. have no id), or have an ID but have not
         * yet been saved on this Store (this happens when adding a non-phantom record from another Store into this one)
         * @return {Ext.data.Model[]} The Model instances
         */
        getNewRecords(): Ext.data.Model;

        /**
         * Returns the proxy currently attached to this proxy instance
         * @return {Ext.data.proxy.Proxy} The Proxy instance
         */
        getProxy(): Ext.data.proxy.Proxy;

        /**
         * Returns any records that have been removed from the store but not yet destroyed on the proxy.
         * @return {Ext.data.Model[]} The removed Model instances
         */
        getRemovedRecords(): Ext.data.Model;

        /**
         * Returns all Model instances that have been updated in the Store but not yet synchronized with the Proxy
         * @return {Ext.data.Model[]} The updated Model instances
         */
        getUpdatedRecords(): Ext.data.Model;

        /**
         * Returns true if the Store is currently performing a load operation
         * @return {Boolean} True if the Store is currently loading
         */
        isLoading(): boolean;

        /**
         * Loads the Store using its configured {@link #proxy}.
         * @param {Object} options (optional) config object. This is passed into the {@link Ext.data.Operation Operation}
         * object that is created and then sent to the proxy's {@link Ext.data.proxy.Proxy#read} function
         *
         * @return {Ext.data.Store} this
         * @since 1.1.0
         */
        load(options: any): Ext.data.Store;

        /**
         * Reloads the store using the last options passed to the {@link #method-load} method.
         * @param {Object} options A config object which contains options which may override the options passed to the previous load call.
         */
        reload(options: any);

        /**
         * Removes all records from the store. This method does a "fast remove",
         * individual remove events are not called. The {@link #clear} event is
         * fired upon completion.
         * @since 1.1.0
         */
        removeAll();

        /**
         * Resumes automatically syncing the Store with its Proxy.  Only applicable if {@link #autoSync} is 'true'
         */
        resumeAutoSync();

        /**
         * Saves all pending changes via the configured {@link #proxy}. Use {@link #sync} instead.
         * @deprecated 4.0.0 Will be removed in the next major version
         */
        save();

        /**
         * Sets the Store's Proxy by string, config object or Proxy instance
         * @param {String/Object/Ext.data.proxy.Proxy} proxy The new Proxy, which can be either a type string, a configuration object
         * or an Ext.data.proxy.Proxy instance
         * @return {Ext.data.proxy.Proxy} The attached Proxy object
         */
        setProxy(proxy: string|any|Ext.data.proxy.Proxy): Ext.data.proxy.Proxy;

        /**
         * Suspends automatically syncing the Store with its Proxy.  Only applicable if {@link #autoSync} is 'true'
         */
        suspendAutoSync();

        /**
         * Synchronizes the store with its {@link #proxy}. This asks the proxy to batch together any new, updated
         * and deleted records in the store, updating the store's internal representation of the records
         * as each operation completes.
         *
         * @param {Object} [options] Object containing one or more properties supported by the sync method (these get
         * passed along to the underlying proxy's {@link Ext.data.Proxy#batch batch} method):
         *
         * @param {Ext.data.Batch/Object} [options.batch] A {@link Ext.data.Batch} object (or batch config to apply
         * to the created batch). If unspecified a default batch will be auto-created as needed.
         *
         * @param {Function} [options.callback] The function to be called upon completion of the sync.
         * The callback is called regardless of success or failure and is passed the following parameters:
         * @param {Ext.data.Batch} options.callback.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.callback.options The options argument that was originally passed into sync
         *
         * @param {Function} [options.success] The function to be called upon successful completion of the sync. The
         * success function is called only if no exceptions were reported in any operations. If one or more exceptions
         * occurred then the failure function will be called instead. The success function is called
         * with the following parameters:
         * @param {Ext.data.Batch} options.success.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.success.options The options argument that was originally passed into sync
         *
         * @param {Function} [options.failure] The function to be called upon unsuccessful completion of the sync. The
         * failure function is called when one or more operations returns an exception during processing (even if some
         * operations were also successful). In this case you can check the batch's {@link Ext.data.Batch#exceptions
         * exceptions} array to see exactly which operations had exceptions. The failure function is called with the
         * following parameters:
         * @param {Ext.data.Batch} options.failure.batch The {@link Ext.data.Batch} that was processed, containing all
         * operations in their current state after processing
         * @param {Object} options.failure.options The options argument that was originally passed into sync
         *
         * @param {Object} [options.scope] The scope in which to execute any callbacks (i.e. the 'this' object inside
         * the callback, success and/or failure functions). Defaults to the store's proxy.
         *
         * @return {Ext.data.Store} this
         */
        sync(options?: any, options_batch?: Ext.data.Batch|any, options_callback?: Function, options_callback_batch?: Ext.data.Batch, options_callback_options?: any, options_success?: Function, options_success_batch?: Ext.data.Batch, options_success_options?: any, options_failure?: Function, options_failure_batch?: Ext.data.Batch, options_failure_options?: any, options_scope?: any): Ext.data.Store;

        /**
         * Fired when a Model instance has been added to this Store.
         * @param {Ext.data.Store} store The store
         * @param {Ext.data.Model[]} records The Model instances that were added
         * @param {Number} index The index at which the instances were inserted
         * @since 1.1.0
         */
        add(store: Ext.data.Store, records: Ext.data.Model, index: number);

        /**
         * Fires before a request is made for a new data object. If the beforeload handler returns false the load
         * action will be canceled.
         * @param {Ext.data.Store} store This Store
         * @param {Ext.data.Operation} operation The Ext.data.Operation object that will be passed to the Proxy to
         * load the Store
         * @since 1.1.0
         */
        beforeload(store: Ext.data.Store, operation: Ext.data.Operation);

        /**
         * Fired before a call to {@link #sync} is executed. Return false from any listener to cancel the sync
         * @param {Object} options Hash of all records to be synchronized, broken down into create, update and destroy
         */
        beforesync(options: any);

        /**
         * Fired at the *end* of the {@link Ext.data.Store#method-remove remove} method when all records in the passed array have been removed.
         *
         * If many records may be removed in one go, then it is more efficient to listen for this event
         * and perform any processing for a bulk remove than to listen for many {@link #event-remove} events.
         * @param {Ext.data.Store} store The Store object
         * @param {Ext.data.Model[]} records The array of records that were removed (In the order they appear in the Store)
         * @param {Number[]} indexes The indexes of the records that were removed
         * @param {Boolean} isMove 'true' if the child nodes are being removed so they can be moved to another position in this Store.
         */
        bulkremove(store: Ext.data.Store, records: Ext.data.Model, indexes: number, isMove: boolean);

        /**
         * Fired after the {@link #removeAll} method is called.
         * @since 1.1.0
         */
        clear(that: Ext.data.Store);

        /**
         * Fires whenever the records in the Store have changed in some way - this could include adding or removing
         * records, or updating the data in existing records
         * @param {Ext.data.Store} this The data store
         * @since 1.1.0
         */
        datachanged(that: Ext.data.Store);

        /**
         * Fires when this store's underlying reader (available via the proxy) provides new metadata.
         * Metadata usually consists of new field definitions, but can include any configuration data
         * required by an application, and can be processed as needed in the event handler.
         * This event is currently only fired for JsonReaders.
         * @param {Object} meta The JSON metadata
         * @since 1.1.0
         */
        metachange(that: Ext.data.Store, meta: any);

        /**
         * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
         * widget that is using this Store as a Record cache should refresh its view.
         * @param {Ext.data.Store} this The data store
         */
        refresh(that: Ext.data.Store);

        /**
         * Fired when a Model instance has been removed from this Store.
         *
         * **If many records may be removed in one go, then it is more efficient to listen for the {@link #event-bulkremove} event
         * and perform any processing for a bulk remove than to listen for this {@link #event-remove} event.**
         * @param {Ext.data.Store} store The Store object
         * @param {Ext.data.Model} record The record that was removed
         * @param {Number} index The index of the record that was removed
         * @param {Boolean} isMove 'true' if the child node is being removed so it can be moved to another position in this Store.
         * @since 1.1.0
         */
        remove(store: Ext.data.Store, record: Ext.data.Model, index: number, isMove: boolean);

        /**
         * Fires when a Model instance has been updated.
         * @param {Ext.data.Model} record The Model instance that was updated
         * @param {String} operation The update operation being performed. Value may be one of:
         *
         *     Ext.data.Model.EDIT
         *     Ext.data.Model.REJECT
         *     Ext.data.Model.COMMIT
         * @param {String[]} modifiedFieldNames Array of field names changed during edit.
         * @since 1.1.0
         */
        update(that: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string);

        /**
         * Fires whenever a successful write has been made via the configured {@link #proxy Proxy}
         * @param {Ext.data.Store} store This Store
         * @param {Ext.data.Operation} operation The {@link Ext.data.Operation Operation} object that was used in
         * the write
         * @since 3.4.0
         */
        write(store: Ext.data.Store, operation: Ext.data.Operation);
    }

    /**
     * @author Ed Spencer
     *
     * Small helper class to make creating {@link Ext.data.Store}s from Array data easier. An ArrayStore will be
     * automatically configured with a {@link Ext.data.reader.Array}.
     *
     * A store configuration would be something like:
     *
     *     var store = Ext.create('Ext.data.ArrayStore', {
     *         // store configs
     *         storeId: 'myStore',
     *         // reader configs
     *         fields: [
     *            'company',
     *            {name: 'price', type: 'float'},
     *            {name: 'change', type: 'float'},
     *            {name: 'pctChange', type: 'float'},
     *            {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
     *         ]
     *     });
     *
     * This store is configured to consume a returned object of the form:
     *
     *     var myData = [
     *         ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
     *         ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
     *         ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
     *         ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
     *         ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
     *     ];
     *
     * An object literal of this form could also be used as the {@link #cfg-data} config option.
     */
    export class ArrayStore extends Ext.data.Store {
        constructor(config: any);
    }

    interface BatchConfig {
        /**
         * True to immediately start processing the batch as soon as it is constructed (defaults to false)
         */
        autoStart?: boolean;

        /**
         * True to pause the execution of the batch if any operation encounters an exception
         * (defaults to false). If you set this to true you are responsible for implementing the appropriate
         * handling logic and restarting or discarding the batch as needed. There are different ways you could
         * do this, e.g. by handling the batch's {@link #exception} event directly, or perhaps by overriding
         * {@link Ext.data.AbstractStore#onBatchException onBatchException} at the store level. If you do pause
         * and attempt to handle the exception you can call {@link #retry} to process the same operation again.
         *
         * Note that {@link Ext.data.Operation operations} are atomic, so any operations that may have succeeded
         * prior to an exception (and up until pausing the batch) will be finalized at the server level and will
         * not be automatically reversible. Any transactional / rollback behavior that might be desired would have
         * to be implemented at the application level. Pausing on exception will likely be most beneficial when
         * used in coordination with such a scheme, where an exception might actually affect subsequent operations
         * in the same batch and so should be handled before continuing with the next operation.
         *
         * If you have not implemented transactional operation handling then this option should typically be left
         * to the default of false (e.g. process as many operations as possible, and handle any exceptions
         * asynchronously without holding up the rest of the batch).
         */
        pauseOnException?: boolean;
    }

    /**
     * @author Ed Spencer
     *
     * <p>Provides a mechanism to run one or more {@link Ext.data.Operation operations} in a given order. Fires the 'operationcomplete' event
     * after the completion of each Operation, and the 'complete' event when all Operations have been successfully executed. Fires an 'exception'
     * event if any of the Operations encounter an exception.</p>
     *
     * <p>Usually these are only used internally by {@link Ext.data.proxy.Proxy} classes</p>
     */
    export class Batch extends Ext.Base implements Ext.data.BatchConfig {
        /**
         * The index of the current operation being executed. Read only
         */
        current: number;

        /**
         * Ordered array of operations that raised an exception during the most recent
         * batch execution and did not successfully complete
         */
        exceptions: Ext.data.Operation;

        /**
         * True if this batch has encountered an exception. This is cleared at the start of each operation. Read only
         */
        hasException: boolean;

        /**
         * True if this batch has been executed completely. Read only
         */
        isComplete: boolean;

        /**
         * True if the batch is currently running. Read only
         */
        isRunning: boolean;

        /**
         * Ordered array of operations that will be executed by this batch
         */
        operations: Ext.data.Operation;

        /**
         * The total number of operations in this batch. Read only
         */
        total: number;

        /**
         * True to immediately start processing the batch as soon as it is constructed (defaults to false)
         */
        autoStart: boolean;

        /**
         * True to pause the execution of the batch if any operation encounters an exception
         * (defaults to false). If you set this to true you are responsible for implementing the appropriate
         * handling logic and restarting or discarding the batch as needed. There are different ways you could
         * do this, e.g. by handling the batch's {@link #exception} event directly, or perhaps by overriding
         * {@link Ext.data.AbstractStore#onBatchException onBatchException} at the store level. If you do pause
         * and attempt to handle the exception you can call {@link #retry} to process the same operation again.
         *
         * Note that {@link Ext.data.Operation operations} are atomic, so any operations that may have succeeded
         * prior to an exception (and up until pausing the batch) will be finalized at the server level and will
         * not be automatically reversible. Any transactional / rollback behavior that might be desired would have
         * to be implemented at the application level. Pausing on exception will likely be most beneficial when
         * used in coordination with such a scheme, where an exception might actually affect subsequent operations
         * in the same batch and so should be handled before continuing with the next operation.
         *
         * If you have not implemented transactional operation handling then this option should typically be left
         * to the default of false (e.g. process as many operations as possible, and handle any exceptions
         * asynchronously without holding up the rest of the batch).
         */
        pauseOnException: boolean;

        /**
         * Adds a new operation to this batch at the end of the {@link #operations} array
         * @param {Object} operation The {@link Ext.data.Operation Operation} object
         * @return {Ext.data.Batch} this
         */
        add(operation: any): Ext.data.Batch;

        /**
         * Creates new Batch object.
         * @param {Object} [config] Config object
         */
        constructor(config?: Ext.data.BatchConfig);

        /**
         * Pauses execution of the batch, but does not cancel the current operation
         * @return {Ext.data.Batch} this
         */
        pause(): Ext.data.Batch;

        /**
         * Kicks off execution of the batch, continuing from the current operation. This is intended
         * for restarting a {@link #pause paused} batch after an exception, and the operation that raised
         * the exception will now be retried. The batch will then continue with its normal processing until
         * all operations are complete or another exception is encountered.
         *
         * Note that if the batch is already running any call to retry will be ignored.
         *
         * @return {Ext.data.Batch} this
         */
        retry(): Ext.data.Batch;

        /**
         * Executes an operation by its numeric index in the {@link #operations} array
         * @param {Number} index The operation index to run
         * @return {Ext.data.Batch} this
         */
        runOperation(index: number): Ext.data.Batch;

        /**
         * Kicks off execution of the batch, continuing from the next operation if the previous
         * operation encountered an exception, or if execution was paused. Use this method to start
         * the batch for the first time or to restart a paused batch by skipping the current
         * unsuccessful operation.
         *
         * To retry processing the current operation before continuing to the rest of the batch (e.g.
         * because you explicitly handled the operation's exception), call {@link #retry} instead.
         *
         * Note that if the batch is already running any call to start will be ignored.
         *
         * @return {Ext.data.Batch} this
         */
        start(): Ext.data.Batch;

        /**
         * Fired when all operations of this batch have been completed
         * @param {Ext.data.Batch} batch The batch object
         * @param {Object} operation The last operation that was executed
         */
        complete(batch: Ext.data.Batch, operation: any);

        /**
         * Fired when a operation encountered an exception
         * @param {Ext.data.Batch} batch The batch object
         * @param {Object} operation The operation that encountered the exception
         */
        exception(batch: Ext.data.Batch, operation: any);

        /**
         * Fired when each operation of the batch completes
         * @param {Ext.data.Batch} batch The batch object
         * @param {Object} operation The operation that just completed
         */
        operationcomplete(batch: Ext.data.Batch, operation: any);
    }

    interface BufferStoreConfig extends Ext.data.StoreConfig {
        filterOnLoad?: any;

        sortOnLoad?: any;
    }

    export class BufferStore extends Ext.data.Store implements Ext.data.BufferStoreConfig {
        filterOnLoad: boolean;

        sortOnLoad: boolean;

        constructor();
    }

    interface ConnectionConfig {
        /**
         * Whether this request should abort any pending requests.
         *
         * Optional, Defaults to: false
         */
        autoAbort?: boolean;

        /**
         * True if the response should be treated as binary data.  If true, the binary
         * data will be accessible as a "responseBytes" property on the response object.
         */
        binary?: boolean;

        /**
         * True to enable CORS support on the XHR object. Currently the only effect of this option
         * is to use the XDomainRequest object instead of XMLHttpRequest if the browser is IE8 or above.
         */
        cors?: boolean;

        /**
         * An object containing request headers which are added to each request made by this object.
         */
        defaultHeaders?: any;

        /**
         * True to add a unique cache-buster param to GET requests.
         */
        disableCaching?: boolean;

        /**
         * Change the parameter which is sent went disabling caching through a cache buster.
         */
        disableCachingParam?: string;

        /**
         * Any parameters to be appended to the request.
         */
        extraParams?: any;

        /**
         * The default HTTP method to be used for requests.
         *
         * If not set, but {@link #request} params are present, POST will be used;
         * otherwise, GET will be used.
         */
        method?: string;

        /**
         * The timeout in milliseconds to be used for requests.
         */
        timeout?: number;

        /**
         * True to set 'withCredentials = true' on the XHR object
         */
        withCredentials?: boolean;
    }

    /**
     * The Connection class encapsulates a connection to the page's originating domain, allowing requests to be made either
     * to a configured URL, or to a URL specified at request time.
     *
     * Requests made by this class are asynchronous, and will return immediately. No data from the server will be available
     * to the statement immediately following the {@link #request} call. To process returned data, use a success callback
     * in the request options object, or an {@link #requestcomplete event listener}.
     *
     * # File Uploads
     *
     * File uploads are not performed using normal "Ajax" techniques, that is they are not performed using XMLHttpRequests.
     * Instead the form is submitted in the standard manner with the DOM &lt;form&gt; element temporarily modified to have its
     * target set to refer to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document but removed
     * after the return data has been gathered.
     *
     * The server response is parsed by the browser to create the document for the IFRAME. If the server is using JSON to
     * send the return object, then the Content-Type header must be set to "text/html" in order to tell the browser to
     * insert the text unchanged into the document body.
     *
     * Characters which are significant to an HTML parser must be sent as HTML entities, so encode '<' as '&lt;', '&' as
     * '&amp;' etc.
     *
     * The response text is retrieved from the document, and a fake XMLHttpRequest object is created containing a
     * responseText property in order to conform to the requirements of event handlers and callbacks.
     *
     * Be aware that file upload packets are sent with the content type multipart/form and some server technologies
     * (notably JEE) may require some custom processing in order to retrieve parameter names and parameter values from the
     * packet content.
     *
     * Also note that it's not possible to check the response code of the hidden iframe, so the success handler will ALWAYS fire.
     *
     * # Binary Posts
     *
     * The class supports posting binary data to the server by using native browser capabilities, or a flash polyfill plugin in browsers that do not support native binary posting (e.g. Internet Explorer version 9 or less). A number of limitations exist when the polyfill is used:
     *
     * - Only asynchronous connections are supported.
     * - Only the POST method can be used.
     * - The return data can only be binary for now. Set the {@link Ext.data.Connection#binary binary} parameter to <tt>true</tt>.
     * - Only the 0, 1 and 4 (complete) readyState values will be reported to listeners.
     * - The flash object will be injected at the bottom of the document and should be invisible.
     * - Important: See note about packaing the flash plugin with the app in the documenetation of {@link Ext.data.flash.BinaryXhr BinaryXhr}.
     */
    export class Connection extends Ext.Base implements Ext.data.ConnectionConfig {
        /**
         * Whether this request should abort any pending requests.
         *
         * Optional, Defaults to: false
         */
        autoAbort: boolean;

        /**
         * True if the response should be treated as binary data.  If true, the binary
         * data will be accessible as a "responseBytes" property on the response object.
         */
        binary: boolean;

        /**
         * True to enable CORS support on the XHR object. Currently the only effect of this option
         * is to use the XDomainRequest object instead of XMLHttpRequest if the browser is IE8 or above.
         */
        cors: boolean;

        /**
         * An object containing request headers which are added to each request made by this object.
         */
        defaultHeaders: any;

        /**
         * True to add a unique cache-buster param to GET requests.
         */
        disableCaching: boolean;

        /**
         * Change the parameter which is sent went disabling caching through a cache buster.
         */
        disableCachingParam: string;

        /**
         * Any parameters to be appended to the request.
         */
        extraParams: any;

        /**
         * The default HTTP method to be used for requests.
         *
         * If not set, but {@link #request} params are present, POST will be used;
         * otherwise, GET will be used.
         */
        method: string;

        /**
         * The timeout in milliseconds to be used for requests.
         */
        timeout: number;

        /**
         * True to set 'withCredentials = true' on the XHR object
         */
        withCredentials: boolean;

        /**
         * Aborts an active request.
         * @param {Object} [request] Defaults to the last request
         */
        abort(request?: any);

        /**
         * Aborts all active requests
         */
        abortAll();

        constructor(config: Ext.data.ConnectionConfig);

        /**
         * Determines whether this object has a request outstanding.
         * @param {Object} [request] Defaults to the last transaction
         * @return {Boolean} True if there is an outstanding request.
         */
        isLoading(request?: any): boolean;

        /**
         * Checks if the response status was successful
         * @param {Number} status The status code
         * @return {Object} An object containing success/status state
         */
        parseStatus(status: number): any;

        /**
         * Sends an HTTP request to a remote server.
         *
         * **Important:** Ajax server requests are asynchronous, and this call will
         * return before the response has been received. Process any returned data
         * in a callback function.
         *
         *     Ext.Ajax.request({
         *         url: 'ajax_demo/sample.json',
         *         success: function(response, opts) {
         *             var obj = Ext.decode(response.responseText);
         *             console.dir(obj);
         *         },
         *         failure: function(response, opts) {
         *             console.log('server-side failure with status code ' + response.status);
         *         }
         *     });
         *
         * To execute a callback function in the correct scope, use the 'scope' option.
         *
         * @param {Object} options An object which may contain the following properties:
         *
         * (The options object may also contain any other property which might be needed to perform
         * postprocessing in a callback because it is passed to callback functions.)
         *
         * @param {String/Function} options.url The URL to which to send the request, or a function
         * to call which returns a URL string. The scope of the function is specified by the 'scope' option.
         * Defaults to the configured 'url'.
         *
         * @param {Object/String/Function} options.params An object containing properties which are
         * used as parameters to the request, a url encoded string or a function to call to get either. The scope
         * of the function is specified by the 'scope' option.
         *
         * @param {String} options.method The HTTP method to use
         * for the request. Defaults to the configured method, or if no method was configured,
         * "GET" if no parameters are being sent, and "POST" if parameters are being sent.  Note that
         * the method name is case-sensitive and should be all caps.
         *
         * @param {Function} options.callback The function to be called upon receipt of the HTTP response.
         * The callback is called regardless of success or failure and is passed the following parameters:
         * @param {Object} options.callback.options The parameter to the request call.
         * @param {Boolean} options.callback.success True if the request succeeded.
         * @param {Object} options.callback.response The XMLHttpRequest object containing the response data.
         * See [www.w3.org/TR/XMLHttpRequest/](http://www.w3.org/TR/XMLHttpRequest/) for details about
         * accessing elements of the response.
         *
         * @param {Function} options.success The function to be called upon success of the request.
         * The callback is passed the following parameters:
         * @param {Object} options.success.response The XMLHttpRequest object containing the response data.
         * @param {Object} options.success.options The parameter to the request call.
         *
         * @param {Function} options.failure The function to be called upon failure of the request.
         * The callback is passed the following parameters:
         * @param {Object} options.failure.response The XMLHttpRequest object containing the response data.
         * @param {Object} options.failure.options The parameter to the request call.
         *
         * @param {Object} options.scope The scope in which to execute the callbacks: The "this" object for
         * the callback function. If the 'url', or 'params' options were specified as functions from which to
         * draw values, then this also serves as the scope for those function calls. Defaults to the browser
         * window.
         *
         * @param {Number} options.timeout The timeout in milliseconds to be used for this request.
         * Defaults to 30 seconds.
         *
         * @param {Ext.Element/HTMLElement/String} options.form The '<form>' Element or the id of the '<form>'
         * to pull parameters from.
         *
         * @param {Boolean} options.isUpload **Only meaningful when used with the 'form' option.**
         *
         * True if the form object is a file upload (will be set automatically if the form was configured
         * with **'enctype'** '"multipart/form-data"').
         *
         * File uploads are not performed using normal "Ajax" techniques, that is they are **not**
         * performed using XMLHttpRequests. Instead the form is submitted in the standard manner with the
         * DOM '<form>' element temporarily modified to have its [target][] set to refer to a dynamically
         * generated, hidden '<iframe>' which is inserted into the document but removed after the return data
         * has been gathered.
         *
         * The server response is parsed by the browser to create the document for the IFRAME. If the
         * server is using JSON to send the return object, then the [Content-Type][] header must be set to
         * "text/html" in order to tell the browser to insert the text unchanged into the document body.
         *
         * The response text is retrieved from the document, and a fake XMLHttpRequest object is created
         * containing a 'responseText' property in order to conform to the requirements of event handlers
         * and callbacks.
         *
         * Be aware that file upload packets are sent with the content type [multipart/form][] and some server
         * technologies (notably JEE) may require some custom processing in order to retrieve parameter names
         * and parameter values from the packet content.
         *
         * [target]: http://www.w3.org/TR/REC-html40/present/frames.html#adef-target
         * [Content-Type]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17
         * [multipart/form]: http://www.faqs.org/rfcs/rfc2388.html
         *
         * @param {Object} options.headers Request headers to set for the request.
         *
         * @param {Object} options.xmlData XML document to use for the post. Note: This will be used instead
         * of params for the post data. Any params will be appended to the URL.
         *
         * @param {Object/String} options.jsonData JSON data to use as the post. Note: This will be used
         * instead of params for the post data. Any params will be appended to the URL.
         *
         * @param {Array} options.binaryData An array of bytes to submit in binary form. Any params will be appended to the URL. If binaryData is present, you must set {@link Ext.data.Connection#binary binary} to <tt>true</tt> and options.method to <tt>POST</tt>.
         *
         * @param {Boolean} options.disableCaching True to add a unique cache-buster param to GET requests.
         *
         * @param {Boolean} options.withCredentials True to add the withCredentials property to the XHR object
         *
         * @param {Boolean} options.binary True if the response should be treated as binary data.  If true, the binary
         * data will be accessible as a "responseBytes" property on the response object.
         *
         * @return {Object} The request object. This may be used to cancel the request.
         */
        request(options: any, options_url: string|Function, options_params: any|string|Function, options_method: string, options_callback: Function, options_callback_options: any, options_callback_success: boolean, options_callback_response: any, options_success: Function, options_success_response: any, options_success_options: any, options_failure: Function, options_failure_response: any, options_failure_options: any, options_scope: any, options_timeout: number, options_form: Ext.dom.Element|HTMLElement|string, options_isUpload: boolean, options_headers: any, options_xmlData: any, options_jsonData: any|string, options_binaryData: any[], options_disableCaching: boolean, options_withCredentials: boolean, options_binary: boolean): any;

        /**
         * Sets various options such as the url, params for the request
         * @param {Object} options The initial options
         * @param {Object} scope The scope to execute in
         * @return {Object} The params for the request
         */
        setOptions(options: any, scope: any): any;

        /**
         * Uploads a form using a hidden iframe.
         * @param {String/HTMLElement/Ext.Element} form The form to upload
         * @param {String} url The url to post to
         * @param {String} params Any extra parameters to pass
         * @param {Object} options The initial options
         */
        upload(form: string|HTMLElement|Ext.dom.Element, url: string, params: string, options: any);

        /**
         * Fires before a network request is made to retrieve a data object.
         * @param {Ext.data.Connection} conn This Connection object.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        beforerequest(conn: Ext.data.Connection, options: any);

        /**
         * Fires if the request was successfully completed.
         * @param {Ext.data.Connection} conn This Connection object.
         * @param {Object} response The XHR object containing the response data.
         * See [The XMLHttpRequest Object](http://www.w3.org/TR/XMLHttpRequest/) for details.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        requestcomplete(conn: Ext.data.Connection, response: any, options: any);

        /**
         * Fires if an error HTTP status was returned from the server. This event may also
         * be listened to in the event that a request has timed out or has been aborted.
         * See [HTTP Status Code Definitions](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)
         * for details of HTTP status codes.
         * @param {Ext.data.Connection} conn This Connection object.
         * @param {Object} response The XHR object containing the response data.
         * See [The XMLHttpRequest Object](http://www.w3.org/TR/XMLHttpRequest/) for details.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        requestexception(conn: Ext.data.Connection, response: any, options: any);
    }

    /**
     * Small helper class to create an {@link Ext.data.Store} configured with an {@link Ext.data.proxy.Direct}
     * and {@link Ext.data.reader.Json} to make interacting with an {@link Ext.direct.Manager} server-side
     * {@link Ext.direct.Provider Provider} easier. To create a different proxy/reader combination create a basic
     * {@link Ext.data.Store} configured as needed.
     *
     * **Note:** Although they are not listed, this class inherits all of the config options of:
     *
     * - **{@link Ext.data.Store Store}**
     *
     * - **{@link Ext.data.reader.Json JsonReader}**
     *
     *   - **{@link Ext.data.reader.Json#cfg-root root}**
     *   - **{@link Ext.data.reader.Json#idProperty idProperty}**
     *   - **{@link Ext.data.reader.Json#totalProperty totalProperty}**
     *
     * - **{@link Ext.data.proxy.Direct DirectProxy}**
     *
     *   - **{@link Ext.data.proxy.Direct#directFn directFn}**
     *   - **{@link Ext.data.proxy.Direct#paramOrder paramOrder}**
     *   - **{@link Ext.data.proxy.Direct#paramsAsHash paramsAsHash}**
     */
    export class DirectStore extends Ext.data.Store {
        constructor();
    }

    /**
     * @author Ed Spencer
     *
     * <p>Wraps a collection of validation error responses and provides convenient functions for
     * accessing and errors for specific fields.</p>
     *
     * <p>Usually this class does not need to be instantiated directly - instances are instead created
     * automatically when {@link Ext.data.Model#validate validate} on a model instance:</p>
     *
     <pre><code>
     //validate some existing model instance - in this case it returned 2 failures messages
     var errors = myModel.validate();
     errors.isValid(); //false
     errors.length; //2
     errors.getByField('name');  // [{field: 'name',  message: 'must be present'}]
     errors.getByField('title'); // [{field: 'title', message: 'is too short'}]
     </code></pre>
     */
    export class Errors extends Ext.util.MixedCollection {
        /**
         * Creates new MixedCollection.
         * @param {Object} config A configuration object.
         *  @param {Boolean} [config.allowFunctions=false] Specify 'true' if the {@link #addAll}
         * function should add function references to the collection.
         *  @param {Function} [config.getKey] A function that can accept an item of the type(s) stored in this MixedCollection
         * and return the key value for that item.  This is used when available to look up the key on items that
         * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
         * equivalent to overriding the {@link #method-getKey} method.
         */
        constructor(config: Ext.util.MixedCollectionConfig);

        /**
         * Returns all of the errors for the given field
         * @param {String} fieldName The field to get errors for
         * @return {Object[]} All errors for the given field
         */
        getByField(fieldName: string): any;

        /**
         * Returns true if there are no errors in the collection
         * @return {Boolean}
         */
        isValid(): boolean;
    }

    interface FieldConfig {
        /**
         * A function which converts the value provided by the Reader into an object that will be stored in the Model.
         *
         * If configured as 'null', then no conversion will be applied to the raw data property when this Field
         * is read. This will increase performance. but you must ensure that the data is of the correct type and does
         * not *need* converting.
         *
         * It is passed the following parameters:
         *
         * - **v** : Mixed
         *
         *   The data value as read by the Reader, if undefined will use the configured '{@link Ext.data.Field#defaultValue
         *   defaultValue}'.
         *
         * - **rec** : Ext.data.Model
         *
         *   The data object containing the Model as read so far by the Reader. Note that the Model may not be fully populated
         *   at this point as the fields are read in the order that they are defined in your
         *   {@link Ext.data.Model#cfg-fields fields} array.
         *
         * Example of convert functions:
         *
         *     function fullName(v, record){
         *         return record.data.last + ', ' + record.data.first;
         *     }
         *
         *     function location(v, record){
         *         return !record.data.city ? '' : (record.data.city + ', ' + record.data.state);
         *     }
         *
         *     Ext.define('Dude', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *             {name: 'fullname',  convert: fullName},
         *             {name: 'firstname', mapping: 'name.first'},
         *             {name: 'lastname',  mapping: 'name.last'},
         *             {name: 'city', defaultValue: 'homeless'},
         *             'state',
         *             {name: 'location',  convert: location}
         *         ]
         *     });
         *
         *     // create the data store
         *     var store = Ext.create('Ext.data.Store', {
         *         reader: {
         *             type: 'json',
         *             model: 'Dude',
         *             idProperty: 'key',
         *             root: 'daRoot',
         *             totalProperty: 'total'
         *         }
         *     });
         *
         *     var myData = [
         *         { key: 1,
         *           name: { first: 'Fat',    last:  'Albert' }
         *           // notice no city, state provided in data object
         *         },
         *         { key: 2,
         *           name: { first: 'Barney', last:  'Rubble' },
         *           city: 'Bedrock', state: 'Stoneridge'
         *         },
         *         { key: 3,
         *           name: { first: 'Cliff',  last:  'Claven' },
         *           city: 'Boston',  state: 'MA'
         *         }
         *     ];
         *
         * Optional
         */
        convert?: Function;

        /**
         * Serves as a default for the {@link #dateReadFormat} and {@link #dateWriteFormat} config options. This
         * will be used in place of those other configurations if not specified.
         *
         * A format string for the {@link Ext.Date#parse Ext.Date.parse} function, or "timestamp" if the value provided by
         * the Reader is a UNIX timestamp, or "time" if the value provided by the Reader is a javascript millisecond
         * timestamp. See {@link Ext.Date}.
         *
         * It is quite important to note that while this config is optional, it will default to using the base
         * JavaScript Date object's 'parse' function if not specified, rather than {@link Ext.Date#parse Ext.Date.parse}.
         * This can cause unexpected issues, especially when converting between timezones, or when converting dates that
         * do not have a timezone specified. The behavior of the native 'Date.parse' is implementation-specific, and
         * depending on the value of the date string, it might return the UTC date or the local date. __For this reason
         * it is strongly recommended that you always specify an explicit date format when parsing dates.__
         */
        dateFormat?: string;

        /**
         * Used when converting received data into a Date when the {@link #type} is specified as '"date"'.
         * This configuration takes precedence over {@link #dateFormat}.
         * See {@link #dateFormat} for more information.
         */
        dateReadFormat?: string;

        /**
         * Used to provide a custom format when serializing dates with a {@link Ext.data.writer.Writer}.
         * If this is not specified, the {@link #dateFormat} will be used. See the {@link Ext.data.writer.Writer}
         * docs for more information on writing dates.
         *
         * **Note that to use a {@link Ext.data.JsonWriter JsonWriter} to send Microsoft format "JSON" dates, which are in fact
         * invalid JSON, it is not possible to use the standard date serialization pathway or
         * {@link Ext#USE_NATIVE_JSON native browser JSON production}.**
         *
         * To use a {@link Ext.data.JsonWriter JsonWriter} to write dates in a JSON packet in the form '"\/Date(1357372800000)\/"'
         * configure the field like this:
         *
         *    {
         *        type: 'date',
         *        dateFormat: 'MS',             // To parse incoming dates from server correctly
         *        serialize: Ext.identityFn     // An ExtJS-supplied function which returns the arg unchanged
         *    }
         *
         * Then override ExtJS's JSON date serialize function:
         *
         *    Ext.JSON.encodeDate = function (d) {
         *        return '"' + Ext.Date.format(d, 'MS') + '"';
         *    };
         */
        dateWriteFormat?: string;

        /**
         * The default value used when the creating an instance from a raw data object, and the property referenced by the
         * '{@link Ext.data.Field#mapping mapping}' does not exist in that data object.
         *
         * May be specified as 'undefined' to prevent defaulting in a value.
         *
         * Optional, Defaults to: ""
         */
        defaultValue?: any;

        /**
         * (Optional) A path expression for use by the {@link Ext.data.reader.Reader} implementation that is creating the
         * {@link Ext.data.Model Model} to extract the Field value from the data object. If the path expression is the same
         * as the field name, the mapping may be omitted.
         *
         * The form of the mapping expression depends on the Reader being used.
         *
         * - {@link Ext.data.reader.Json}
         *
         *   The mapping is a string containing the javascript expression to reference the data from an element of the data
         *   item's {@link Ext.data.reader.Json#cfg-root root} Array. Defaults to the field name.
         *
         * - {@link Ext.data.reader.Xml}
         *
         *   The mapping is an {@link Ext.DomQuery} path to the data item relative to the DOM element that represents the
         *   {@link Ext.data.reader.Xml#record record}. Defaults to the field name.
         *
         * - {@link Ext.data.reader.Array}
         *
         *   The mapping is a number indicating the Array index of the field's value. Defaults to the field specification's
         *   Array position.
         *
         * If a more complex value extraction strategy is required, then configure the Field with a {@link #convert}
         * function. This is passed the whole row object, and may interrogate it in whatever way is necessary in order to
         * return the desired data.
         */
        mapping?: string|number;

        /**
         * The name by which the field is referenced within the Model. This is referenced by, for example, the 'dataIndex'
         * property in column definition objects passed to {@link Ext.grid.property.HeaderContainer}.
         *
         * Note: In the simplest case, if no properties other than 'name' are required, a field definition may consist of
         * just a String for the field name.
         */
        name?: string;

        /**
         * False to exclude this field from the {@link Ext.data.Model#modified} fields in a model. This will also exclude
         * the field from being written using a {@link Ext.data.writer.Writer}. This option is useful when model fields are
         * used to keep state on the client but do not need to be persisted to the server. Defaults to true.
         */
        persist?: boolean;

        /**
         * A function which converts the Model's value for this Field into a form which can be used by whatever {@link Ext.data.writer.Writer Writer}
         * is being used to sync data with the server.
         *
         * The function should return a string which represents the Field's value.
         *
         * It is passed the following parameters:
         *
         * - **v** : Mixed
         *
         *   The Field's value - the value to be serialized.
         *
         * - **rec** : Ext.data.Model
         *
         *   The record being serialized.
         *
         * Optional
         */
        serialize?: Function;

        /**
         * Initial direction to sort ('"ASC"' or '"DESC"'). Defaults to '"ASC"'.
         */
        sortDir?: string;

        /**
         * A function which converts a Field's value to a comparable value in order to ensure correct sort ordering.
         * Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:
         *
         *     // current sort     after sort we want
         *     // +-+------+          +-+------+
         *     // |1|First |          |1|First |
         *     // |2|Last  |          |3|Second|
         *     // |3|Second|          |2|Last  |
         *     // +-+------+          +-+------+
         *
         *     sortType: function(value) {
         *        switch (value.toLowerCase()) // native toLowerCase():
         *        {
         *           case 'first': return 1;
         *           case 'second': return 2;
         *           default: return 3;
         *        }
         *     }
         *
         * May also be set to a String value, corresponding to one of the named sort types in {@link Ext.data.SortTypes}.
         */
        sortType?: Function|string;

        /**
         * The data type for automatic conversion from received data to the *stored* value if
         * '{@link Ext.data.Field#convert convert}' has not been specified. This may be specified as a string value.
         * Possible values are
         *
         * - auto (Default, implies no conversion)
         * - string
         * - int
         * - float
         * - boolean
         * - date
         *
         * This may also be specified by referencing a member of the {@link Ext.data.Types} class.
         *
         * Developers may create their own application-specific data types by defining new members of the {@link
         * Ext.data.Types} class.
         */
        type?: string|any;

        /**
         * Use when converting received data into a INT, FLOAT, BOOL or STRING type. If the value cannot be
         * parsed, 'null' will be used if useNull is true, otherwise a default value for that type will be used:
         *
         * - for INT and FLOAT - '0'.
         * - for STRING - '""'.
         * - for BOOL - 'false'.
         *
         * Note that when parsing of DATE type fails, the value will be 'null' regardless of this setting.
         */
        useNull?: boolean;
    }

    /**
     * @author Ed Spencer
     *
     * Fields are used to define what a Model is. They aren't instantiated directly - instead, when we create a class that
     * extends {@link Ext.data.Model}, it will automatically create a Field instance for each field configured in a {@link
     * Ext.data.Model Model}. For example, we might set up a model like this:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'name', 'email',
     *             {name: 'age', type: 'int'},
     *             {name: 'gender', type: 'string', defaultValue: 'Unknown'}
     *         ]
     *     });
     *
     * Four fields will have been created for the User Model - name, email, age and gender. Note that we specified a couple
     * of different formats here; if we only pass in the string name of the field (as with name and email), the field is set
     * up with the 'auto' type. It's as if we'd done this instead:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             {name: 'name', type: 'auto'},
     *             {name: 'email', type: 'auto'},
     *             {name: 'age', type: 'int'},
     *             {name: 'gender', type: 'string', defaultValue: 'Unknown'}
     *         ]
     *     });
     *
     * # Types and conversion
     *
     * The {@link #type} is important - it's used to automatically convert data passed to the field into the correct format.
     * In our example above, the name and email fields used the 'auto' type and will just accept anything that is passed
     * into them. The 'age' field had an 'int' type however, so if we passed 25.4 this would be rounded to 25.
     *
     * Sometimes a simple type isn't enough, or we want to perform some processing when we load a Field's data. We can do
     * this using a {@link #convert} function. Here, we're going to create a new field based on another:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             {
     *                 name: 'firstName',
     *                 convert: function(value, record) {
     *                     var fullName  = record.get('name'),
     *                         splits    = fullName.split(" "),
     *                         firstName = splits[0];
     *
     *                     return firstName;
     *                 }
     *             },
     *             'name', 'email',
     *             {name: 'age', type: 'int'},
     *             {name: 'gender', type: 'string', defaultValue: 'Unknown'}
     *         ]
     *     });
     *
     * Now when we create a new User, the firstName is populated automatically based on the name:
     *
     *     var ed = Ext.create('User', {name: 'Ed Spencer'});
     *
     *     console.log(ed.get('firstName')); //logs 'Ed', based on our convert function
     *
     * Fields which are configured with a custom '''convert''' function are read *after* all other fields
     * when constructing and reading records, so that if convert functions rely on other, non-converted fields
     * (as in this example), they can be sure of those fields being present.
     *
     * In fact, if we log out all of the data inside ed, we'll see this:
     *
     *     console.log(ed.data);
     *
     *     //outputs this:
     *     {
     *         age: 0,
     *         email: "",
     *         firstName: "Ed",
     *         gender: "Unknown",
     *         name: "Ed Spencer"
     *     }
     *
     * The age field has been given a default of zero because we made it an int type. As an auto field, email has defaulted
     * to an empty string. When we registered the User model we set gender's {@link #defaultValue} to 'Unknown' so we see
     * that now. Let's correct that and satisfy ourselves that the types work as we expect:
     *
     *     ed.set('gender', 'Male');
     *     ed.get('gender'); //returns 'Male'
     *
     *     ed.set('age', 25.4);
     *     ed.get('age'); //returns 25 - we wanted an int, not a float, so no decimal places allowed
     */
    export class Field extends Ext.Base implements Ext.data.FieldConfig {
        /**
         * A function which converts the value provided by the Reader into an object that will be stored in the Model.
         *
         * If configured as 'null', then no conversion will be applied to the raw data property when this Field
         * is read. This will increase performance. but you must ensure that the data is of the correct type and does
         * not *need* converting.
         *
         * It is passed the following parameters:
         *
         * - **v** : Mixed
         *
         *   The data value as read by the Reader, if undefined will use the configured '{@link Ext.data.Field#defaultValue
         *   defaultValue}'.
         *
         * - **rec** : Ext.data.Model
         *
         *   The data object containing the Model as read so far by the Reader. Note that the Model may not be fully populated
         *   at this point as the fields are read in the order that they are defined in your
         *   {@link Ext.data.Model#cfg-fields fields} array.
         *
         * Example of convert functions:
         *
         *     function fullName(v, record){
         *         return record.data.last + ', ' + record.data.first;
         *     }
         *
         *     function location(v, record){
         *         return !record.data.city ? '' : (record.data.city + ', ' + record.data.state);
         *     }
         *
         *     Ext.define('Dude', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *             {name: 'fullname',  convert: fullName},
         *             {name: 'firstname', mapping: 'name.first'},
         *             {name: 'lastname',  mapping: 'name.last'},
         *             {name: 'city', defaultValue: 'homeless'},
         *             'state',
         *             {name: 'location',  convert: location}
         *         ]
         *     });
         *
         *     // create the data store
         *     var store = Ext.create('Ext.data.Store', {
         *         reader: {
         *             type: 'json',
         *             model: 'Dude',
         *             idProperty: 'key',
         *             root: 'daRoot',
         *             totalProperty: 'total'
         *         }
         *     });
         *
         *     var myData = [
         *         { key: 1,
         *           name: { first: 'Fat',    last:  'Albert' }
         *           // notice no city, state provided in data object
         *         },
         *         { key: 2,
         *           name: { first: 'Barney', last:  'Rubble' },
         *           city: 'Bedrock', state: 'Stoneridge'
         *         },
         *         { key: 3,
         *           name: { first: 'Cliff',  last:  'Claven' },
         *           city: 'Boston',  state: 'MA'
         *         }
         *     ];
         *
         * Optional
         */
        convert: Function;

        /**
         * Serves as a default for the {@link #dateReadFormat} and {@link #dateWriteFormat} config options. This
         * will be used in place of those other configurations if not specified.
         *
         * A format string for the {@link Ext.Date#parse Ext.Date.parse} function, or "timestamp" if the value provided by
         * the Reader is a UNIX timestamp, or "time" if the value provided by the Reader is a javascript millisecond
         * timestamp. See {@link Ext.Date}.
         *
         * It is quite important to note that while this config is optional, it will default to using the base
         * JavaScript Date object's 'parse' function if not specified, rather than {@link Ext.Date#parse Ext.Date.parse}.
         * This can cause unexpected issues, especially when converting between timezones, or when converting dates that
         * do not have a timezone specified. The behavior of the native 'Date.parse' is implementation-specific, and
         * depending on the value of the date string, it might return the UTC date or the local date. __For this reason
         * it is strongly recommended that you always specify an explicit date format when parsing dates.__
         */
        dateFormat: string;

        /**
         * Used when converting received data into a Date when the {@link #type} is specified as '"date"'.
         * This configuration takes precedence over {@link #dateFormat}.
         * See {@link #dateFormat} for more information.
         */
        dateReadFormat: string;

        /**
         * Used to provide a custom format when serializing dates with a {@link Ext.data.writer.Writer}.
         * If this is not specified, the {@link #dateFormat} will be used. See the {@link Ext.data.writer.Writer}
         * docs for more information on writing dates.
         *
         * **Note that to use a {@link Ext.data.JsonWriter JsonWriter} to send Microsoft format "JSON" dates, which are in fact
         * invalid JSON, it is not possible to use the standard date serialization pathway or
         * {@link Ext#USE_NATIVE_JSON native browser JSON production}.**
         *
         * To use a {@link Ext.data.JsonWriter JsonWriter} to write dates in a JSON packet in the form '"\/Date(1357372800000)\/"'
         * configure the field like this:
         *
         *    {
         *        type: 'date',
         *        dateFormat: 'MS',             // To parse incoming dates from server correctly
         *        serialize: Ext.identityFn     // An ExtJS-supplied function which returns the arg unchanged
         *    }
         *
         * Then override ExtJS's JSON date serialize function:
         *
         *    Ext.JSON.encodeDate = function (d) {
         *        return '"' + Ext.Date.format(d, 'MS') + '"';
         *    };
         */
        dateWriteFormat: string;

        /**
         * The default value used when the creating an instance from a raw data object, and the property referenced by the
         * '{@link Ext.data.Field#mapping mapping}' does not exist in that data object.
         *
         * May be specified as 'undefined' to prevent defaulting in a value.
         *
         * Optional, Defaults to: ""
         */
        defaultValue: any;

        /**
         * (Optional) A path expression for use by the {@link Ext.data.reader.Reader} implementation that is creating the
         * {@link Ext.data.Model Model} to extract the Field value from the data object. If the path expression is the same
         * as the field name, the mapping may be omitted.
         *
         * The form of the mapping expression depends on the Reader being used.
         *
         * - {@link Ext.data.reader.Json}
         *
         *   The mapping is a string containing the javascript expression to reference the data from an element of the data
         *   item's {@link Ext.data.reader.Json#cfg-root root} Array. Defaults to the field name.
         *
         * - {@link Ext.data.reader.Xml}
         *
         *   The mapping is an {@link Ext.DomQuery} path to the data item relative to the DOM element that represents the
         *   {@link Ext.data.reader.Xml#record record}. Defaults to the field name.
         *
         * - {@link Ext.data.reader.Array}
         *
         *   The mapping is a number indicating the Array index of the field's value. Defaults to the field specification's
         *   Array position.
         *
         * If a more complex value extraction strategy is required, then configure the Field with a {@link #convert}
         * function. This is passed the whole row object, and may interrogate it in whatever way is necessary in order to
         * return the desired data.
         */
        mapping: string|number;

        /**
         * The name by which the field is referenced within the Model. This is referenced by, for example, the 'dataIndex'
         * property in column definition objects passed to {@link Ext.grid.property.HeaderContainer}.
         *
         * Note: In the simplest case, if no properties other than 'name' are required, a field definition may consist of
         * just a String for the field name.
         */
        name: string;

        /**
         * False to exclude this field from the {@link Ext.data.Model#modified} fields in a model. This will also exclude
         * the field from being written using a {@link Ext.data.writer.Writer}. This option is useful when model fields are
         * used to keep state on the client but do not need to be persisted to the server. Defaults to true.
         */
        persist: boolean;

        /**
         * A function which converts the Model's value for this Field into a form which can be used by whatever {@link Ext.data.writer.Writer Writer}
         * is being used to sync data with the server.
         *
         * The function should return a string which represents the Field's value.
         *
         * It is passed the following parameters:
         *
         * - **v** : Mixed
         *
         *   The Field's value - the value to be serialized.
         *
         * - **rec** : Ext.data.Model
         *
         *   The record being serialized.
         *
         * Optional
         */
        serialize: Function;

        /**
         * Initial direction to sort ('"ASC"' or '"DESC"'). Defaults to '"ASC"'.
         */
        sortDir: string;

        /**
         * A function which converts a Field's value to a comparable value in order to ensure correct sort ordering.
         * Predefined functions are provided in {@link Ext.data.SortTypes}. A custom sort example:
         *
         *     // current sort     after sort we want
         *     // +-+------+          +-+------+
         *     // |1|First |          |1|First |
         *     // |2|Last  |          |3|Second|
         *     // |3|Second|          |2|Last  |
         *     // +-+------+          +-+------+
         *
         *     sortType: function(value) {
         *        switch (value.toLowerCase()) // native toLowerCase():
         *        {
         *           case 'first': return 1;
         *           case 'second': return 2;
         *           default: return 3;
         *        }
         *     }
         *
         * May also be set to a String value, corresponding to one of the named sort types in {@link Ext.data.SortTypes}.
         */
        sortType: Function|string;

        /**
         * The data type for automatic conversion from received data to the *stored* value if
         * '{@link Ext.data.Field#convert convert}' has not been specified. This may be specified as a string value.
         * Possible values are
         *
         * - auto (Default, implies no conversion)
         * - string
         * - int
         * - float
         * - boolean
         * - date
         *
         * This may also be specified by referencing a member of the {@link Ext.data.Types} class.
         *
         * Developers may create their own application-specific data types by defining new members of the {@link
         * Ext.data.Types} class.
         */
        type: string|any;

        /**
         * Use when converting received data into a INT, FLOAT, BOOL or STRING type. If the value cannot be
         * parsed, 'null' will be used if useNull is true, otherwise a default value for that type will be used:
         *
         * - for INT and FLOAT - '0'.
         * - for STRING - '""'.
         * - for BOOL - 'false'.
         *
         * Note that when parsing of DATE type fails, the value will be 'null' regardless of this setting.
         */
        useNull: boolean;

        constructor(config: Ext.data.FieldConfig);
    }

    /** */
    export class Group extends Ext.util.Observable {
        constructor();
    }

    interface IdGeneratorConfig {
        /**
         * The id by which to register a new instance. This instance can be found using the
         * {@link Ext.data.IdGenerator#get} static method.
         */
        id?: string;
    }

    /**
     * @author Don Griffin
     *
     * This class is a base for all id generators. It also provides lookup of id generators by
     * their id.
     *
     * Generally, id generators are used to generate a primary key for new model instances. There
     * are different approaches to solving this problem, so this mechanism has both simple use
     * cases and is open to custom implementations. A {@link Ext.data.Model} requests id generation
     * using the {@link Ext.data.Model#idgen} property.
     *
     * # Identity, Type and Shared IdGenerators
     *
     * It is often desirable to share IdGenerators to ensure uniqueness or common configuration.
     * This is done by giving IdGenerator instances an id property by which they can be looked
     * up using the {@link #get} method. To configure two {@link Ext.data.Model Model} classes
     * to share one {@link Ext.data.SequentialIdGenerator sequential} id generator, you simply
     * assign them the same id:
     *
     *     Ext.define('MyApp.data.MyModelA', {
     *         extend: 'Ext.data.Model',
     *         idgen: {
     *             type: 'sequential',
     *             id: 'foo'
     *         }
     *     });
     *
     *     Ext.define('MyApp.data.MyModelB', {
     *         extend: 'Ext.data.Model',
     *         idgen: {
     *             type: 'sequential',
     *             id: 'foo'
     *         }
     *     });
     *
     * To make this as simple as possible for generator types that are shared by many (or all)
     * Models, the IdGenerator types (such as 'sequential' or 'uuid') are also reserved as
     * generator id's. This is used by the {@link Ext.data.UuidGenerator} which has an id equal
     * to its type ('uuid'). In other words, the following Models share the same generator:
     *
     *     Ext.define('MyApp.data.MyModelX', {
     *         extend: 'Ext.data.Model',
     *         idgen: 'uuid'
     *     });
     *
     *     Ext.define('MyApp.data.MyModelY', {
     *         extend: 'Ext.data.Model',
     *         idgen: 'uuid'
     *     });
     *
     * This can be overridden (by specifying the id explicitly), but there is no particularly
     * good reason to do so for this generator type.
     *
     * # Creating Custom Generators
     *
     * An id generator should derive from this class and implement the {@link #generate} method.
     * The constructor will apply config properties on new instances, so a constructor is often
     * not necessary.
     *
     * To register an id generator type, a derived class should provide an 'alias' like so:
     *
     *     Ext.define('MyApp.data.CustomIdGenerator', {
     *         extend: 'Ext.data.IdGenerator',
     *         alias: 'idgen.custom',
     *
     *         configProp: 42, // some config property w/default value
     *
     *         generate: function () {
     *             return ... // a new id
     *         }
     *     });
     *
     * Using the custom id generator is then straightforward:
     *
     *     Ext.define('MyApp.data.MyModel', {
     *         extend: 'Ext.data.Model',
     *         idgen: 'custom'
     *     });
     *     // or...
     *
     *     Ext.define('MyApp.data.MyModel', {
     *         extend: 'Ext.data.Model',
     *         idgen: {
     *             type: 'custom',
     *             configProp: value
     *         }
     *     });
     *
     * It is not recommended to mix shared generators with generator configuration. This leads
     * to unpredictable results unless all configurations match (which is also redundant). In
     * such cases, a custom generator with a default id is the best approach.
     *
     *     Ext.define('MyApp.data.CustomIdGenerator', {
     *         extend: 'Ext.data.SequentialIdGenerator',
     *         alias: 'idgen.custom',
     *
     *         id: 'custom', // shared by default
     *
     *         prefix: 'ID_',
     *         seed: 1000
     *     });
     *
     *     Ext.define('MyApp.data.MyModelX', {
     *         extend: 'Ext.data.Model',
     *         idgen: 'custom'
     *     });
     *
     *     Ext.define('MyApp.data.MyModelY', {
     *         extend: 'Ext.data.Model',
     *         idgen: 'custom'
     *     });
     *
     *     // the above models share a generator that produces ID_1000, ID_1001, etc..
     */
    export class IdGenerator extends Ext.Base implements Ext.data.IdGeneratorConfig {
        /**
         * 'true' in this class to identify an object as an instantiated IdGenerator, or subclass thereof.
         */
        isGenerator: boolean;

        /**
         * The id by which to register a new instance. This instance can be found using the
         * {@link Ext.data.IdGenerator#get} static method.
         */
        id: string;

        /**
         * Initializes a new instance.
         * @param {Object} config (optional) Configuration object to be applied to the new instance.
         */
        constructor(config: Ext.data.IdGeneratorConfig);

        /**
         * Generates and returns the next id. This method must be implemented by the derived
         * class.
         *
         * @return {String} The next id.
         * @abstract
         */
        generate(): string;

        /**
         * Returns the IdGenerator given its config description.
         * @param {String/Object} config If this parameter is an IdGenerator instance, it is
         * simply returned. If this is a string, it is first used as an id for lookup and
         * then, if there is no match, as a type to create a new instance. This parameter
         * can also be a config object that contains a 'type' property (among others) that
         * are used to create and configure the instance.
         */
        static get(config: string|Ext.data.IdGeneratorConfig);
    }

    /**
     * This class is used to create JSONP requests. JSONP is a mechanism that allows for making
     * requests for data cross domain. More information is available <a href="http://en.wikipedia.org/wiki/JSONP">here</a>.
     */
    export class JsonP {
        /**
         * Specifies the GET parameter that will be sent to the server containing the function name to be executed when
         * the request completes. Defaults to <tt>callback</tt>. Thus, a common request will be in the form of
         * url?callback=Ext.data.JsonP.callback1
         */
        static callbackKey: string;

        /**
         * True to add a unique cache-buster param to requests. Defaults to <tt>true</tt>.
         */
        static disableCaching: boolean;

        /**
         * Change the parameter which is sent went disabling caching through a cache buster. Defaults to <tt>'_dc'</tt>.
         */
        static disableCachingParam: string;

        /**
         * A default timeout for any JsonP requests. If the request has not completed in this time the
         * failure callback will be fired. The timeout is in ms. Defaults to <tt>30000</tt>.
         */
        static timeout: number;

        /**
         * Abort a request. If the request parameter is not specified all open requests will
         * be aborted.
         * @param {Object/String} request (Optional) The request to abort
         */
        static abort(request: any|string);

        /**
         * Makes a JSONP request.
         * @param {Object} options An object which may contain the following properties. Note that options will
         * take priority over any defaults that are specified in the class.
         * <ul>
         * <li><b>url</b> : String <div class="sub-desc">The URL to request.</div></li>
         * <li><b>params</b> : Object (Optional)<div class="sub-desc">An object containing a series of
         * key value pairs that will be sent along with the request.</div></li>
         * <li><b>timeout</b> : Number (Optional) <div class="sub-desc">See {@link #timeout}</div></li>
         * <li><b>callbackKey</b> : String (Optional) <div class="sub-desc">See {@link #callbackKey}</div></li>
         * <li><b>callbackName</b> : String (Optional) <div class="sub-desc">The function name to use for this request.
         * By default this name will be auto-generated: Ext.data.JsonP.callback1, Ext.data.JsonP.callback2, etc.
         * Setting this option to "my_name" will force the function name to be Ext.data.JsonP.my_name.
         * Use this if you want deterministic behavior, but be careful - the callbackName should be different
         * in each JsonP request that you make.</div></li>
         * <li><b>disableCaching</b> : Boolean (Optional) <div class="sub-desc">See {@link #disableCaching}</div></li>
         * <li><b>disableCachingParam</b> : String (Optional) <div class="sub-desc">See {@link #disableCachingParam}</div></li>
         * <li><b>success</b> : Function (Optional) <div class="sub-desc">A function to execute if the request succeeds.</div></li>
         * <li><b>failure</b> : Function (Optional) <div class="sub-desc">A function to execute if the request fails.</div></li>
         * <li><b>callback</b> : Function (Optional) <div class="sub-desc">A function to execute when the request
         * completes, whether it is a success or failure.</div></li>
         * <li><b>scope</b> : Object (Optional)<div class="sub-desc">The scope in
         * which to execute the callbacks: The "this" object for the callback function. Defaults to the browser window.</div></li>
         * </ul>
         * @return {Object} request An object containing the request details.
         */
        static request(options: any): any;
    }

    /**
     * @extends Ext.data.Store
     * <p>Small helper class to make creating {@link Ext.data.Store}s from different domain JSON data easier.
     * A JsonPStore will be automatically configured with a {@link Ext.data.reader.Json} and a {@link Ext.data.proxy.JsonP JsonPProxy}.</p>
     * <p>A store configuration would be something like:<pre><code>
     var store = new Ext.data.JsonPStore({
     // store configs
     storeId: 'myStore',
     // proxy configs
     url: 'get-images.php',
     // reader configs
     root: 'images',
     idProperty: 'name',
     fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
     });
     * </code></pre></p>
     * <p>This store is configured to consume a returned object of the form:<pre><code>
     stcCallback({
     images: [
     {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
     {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
     ]
     })
     * </code></pre>
     * <p>Where stcCallback is the callback name passed in the request to the remote domain. See {@link Ext.data.proxy.JsonP JsonPProxy}
     * for details of how this works.</p>
     * An object literal of this form could also be used as the {@link #cfg-data} config option.</p>
     * @xtype jsonpstore
     */
    export class JsonPStore extends Ext.data.Store {
        constructor(config: any);
    }

    /**
     * Small helper class to make creating {@link Ext.data.Store}s from JSON data easier.
     * A JsonStore will be automatically configured with a {@link Ext.data.reader.Json}.
     *
     * A store configuration would be something like:
     *
     *     var store = new Ext.data.JsonStore({
     *         // store configs
     *         storeId: 'myStore',
     *
     *         proxy: {
     *             type: 'ajax',
     *             url: 'get-images.php',
     *             reader: {
     *                 type: 'json',
     *                 root: 'images',
     *                 idProperty: 'name'
     *             }
     *         },
     *
     *         //alternatively, a {@link Ext.data.Model} name can be given (see {@link Ext.data.Store} for an example)
     *         fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
     *     });
     *
     * This store is configured to consume a returned object of the form:
     *
     *     {
     *         images: [
     *             {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
     *             {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
     *         ]
     *     }
     *
     * An object literal of this form could also be used as the {@link #cfg-data} config option.
     *
     * @author Ed Spencer
     */
    export class JsonStore extends Ext.data.Store {
        constructor(config: any);
    }

    interface ModelConfig {
        /**
         * An array of {@link Ext.data.Association associations} for this model.
         */
        associations?: any;

        /**
         * One or more {@link Ext.data.BelongsToAssociation BelongsTo associations} for this model.
         */
        belongsTo?: string|any;

        /**
         * The name of a property that is used for submitting this Model's unique client-side identifier
         * to the server when multiple phantom records are saved as part of the same {@link Ext.data.Operation Operation}.
         * In such a case, the server response should include the client id for each record
         * so that the server response data can be used to update the client-side records if necessary.
         * This property cannot have the same name as any of this Model's fields.
         *
         * Optional
         */
        clientIdProperty?: string;

        /**
         * The string type of the default Model Proxy. Defaults to 'ajax'.
         */
        defaultProxyType?: string;

        /**
         * One or more {@link Ext.data.HasManyAssociation HasMany associations} for this model.
         */
        hasMany?: string|any;

        /**
         * The name of the field treated as this Model's unique id. Defaults to 'id'.
         *
         * This may also be specified as a Field config object. This means that the identifying field can be calculated
         * using a {@link Ext.data.Field#convert convert} function which might aggregate several values from the
         * raw data object to use as an identifier.
         *
         * The resulting {@link Ext.data.Field Field} is added to the Model's field collection unless there is already
         * a configured field with a mapping that reads the same property.
         *
         * If defining an **abstract** base Model class, the 'idProperty' may be configured as 'null' which will mean that
         * no identifying field will be generated.
         */
        idProperty?: string|any|Ext.data.Field;

        /**
         * The id generator to use for this model. The default id generator does not generate
         * values for the {@link #idProperty}.
         *
         * This can be overridden at the model level to provide a custom generator for a model.
         * The simplest form of this would be:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          requires: ['Ext.data.SequentialIdGenerator'],
         *          idgen: 'sequential',
         *          ...
         *      });
         *
         * The above would generate {@link Ext.data.SequentialIdGenerator sequential} id's such
         * as 1, 2, 3 etc..
         *
         * Another useful id generator is {@link Ext.data.UuidGenerator}:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          requires: ['Ext.data.UuidGenerator'],
         *          idgen: 'uuid',
         *          ...
         *      });
         *
         * An id generation can also be further configured:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          idgen: {
         *              type: 'sequential',
         *              seed: 1000,
         *              prefix: 'ID_'
         *          }
         *      });
         *
         * The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
         *
         * If multiple models share an id space, a single generator can be shared:
         *
         *      Ext.define('MyApp.data.MyModelX', {
         *          extend: 'Ext.data.Model',
         *          idgen: {
         *              type: 'sequential',
         *              id: 'xy'
         *          }
         *      });
         *
         *      Ext.define('MyApp.data.MyModelY', {
         *          extend: 'Ext.data.Model',
         *          idgen: {
         *              type: 'sequential',
         *              id: 'xy'
         *          }
         *      });
         *
         * For more complex, shared id generators, a custom generator is the best approach.
         * See {@link Ext.data.IdGenerator} for details on creating custom id generators.
         *
         * @markdown
         */
        idgen?: string|any;

        /**
         * The name of the property on this Persistable object that its data is saved to. Defaults to 'data'
         * (i.e: all persistable data resides in 'this.data'.)
         * @deprecated This config is deprecated. In future this will no longer be configurable and will be data.
         */
        persistenceProperty?: string;

        /**
         * The {@link Ext.data.proxy.Proxy proxy} to use for this model.
         */
        proxy?: string|any|Ext.data.proxy.Proxy;

        /**
         * An array of {@link Ext.data.validations validations} for this model.
         */
        validations?: any;
    }

    /**
     * @author Ed Spencer
     *
     * A Model represents some object that your application manages. For example, one might define a Model for Users,
     * Products, Cars, or any other real-world object that we want to model in the system. Models are registered via the
     * {@link Ext.ModelManager model manager}, and are used by {@link Ext.data.Store stores}, which are in turn used by many
     * of the data-bound components in Ext.
     *
     * Models are defined as a set of fields and any arbitrary methods and properties relevant to the model. For example:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             {name: 'name',  type: 'string'},
     *             {name: 'age',   type: 'int', convert: null},
     *             {name: 'phone', type: 'string'},
     *             {name: 'alive', type: 'boolean', defaultValue: true, convert: null}
     *         ],
     *
     *         changeName: function() {
     *             var oldName = this.get('name'),
     *                 newName = oldName + " The Barbarian";
     *
     *             this.set('name', newName);
     *         }
     *     });
     *
     * The fields array is turned into a {@link Ext.util.MixedCollection MixedCollection} automatically by the {@link
     * Ext.ModelManager ModelManager}, and all other functions and properties are copied to the new Model's prototype.
     *
     * A Model definition always has an *identifying field* which should yield a unique key for each instance. By default, a field
     * named "id" will be created with a {@link Ext.data.Field#mapping mapping} of "id". This happens because of the default
     * {@link #idProperty} provided in Model definitions.
     *
     * To alter which field is the identifying field, use the {@link #idProperty} config.
     *
     * If the Model should not have any identifying field (for example if you are defining ab abstract base class for your
     * application models), configure the {@liknk #idProperty} as 'null'.
     *
     * By default, the built in numeric and boolean field types have a {@link Ext.data.Field#convert} function which coerces string
     * values in raw data into the field's type. For better performance with {@link Ext.data.reader.Json Json} or {@link Ext.data.reader.Array Array}
     * readers *if you are in control of the data fed into this Model*, you can null out the default convert function which will cause
     * the raw property to be copied directly into the Field's value.
     *
     * Now we can create instances of our User model and call any model logic we defined:
     *
     *     var user = Ext.create('User', {
     *         id   : 'ABCD12345',
     *         name : 'Conan',
     *         age  : 24,
     *         phone: '555-555-5555'
     *     });
     *
     *     user.changeName();
     *     user.get('name'); //returns "Conan The Barbarian"
     *
     * # Validations
     *
     * Models have built-in support for validations, which are executed against the validator functions in {@link
     * Ext.data.validations} ({@link Ext.data.validations see all validation functions}). Validations are easy to add to
     * models:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             {name: 'name',     type: 'string'},
     *             {name: 'age',      type: 'int'},
     *             {name: 'phone',    type: 'string'},
     *             {name: 'gender',   type: 'string'},
     *             {name: 'username', type: 'string'},
     *             {name: 'alive',    type: 'boolean', defaultValue: true}
     *         ],
     *
     *         validations: [
     *             {type: 'presence',  field: 'age'},
     *             {type: 'length',    field: 'name',     min: 2},
     *             {type: 'inclusion', field: 'gender',   list: ['Male', 'Female']},
     *             {type: 'exclusion', field: 'username', list: ['Admin', 'Operator']},
     *             {type: 'format',    field: 'username', matcher: /([a-z]+)[0-9]{2,3}/}
     *         ]
     *     });
     *
     * The validations can be run by simply calling the {@link #validate} function, which returns a {@link Ext.data.Errors}
     * object:
     *
     *     var instance = Ext.create('User', {
     *         name: 'Ed',
     *         gender: 'Male',
     *         username: 'edspencer'
     *     });
     *
     *     var errors = instance.validate();
     *
     * # Associations
     *
     * Models can have associations with other Models via {@link Ext.data.association.HasOne},
     * {@link Ext.data.association.BelongsTo belongsTo} and {@link Ext.data.association.HasMany hasMany} associations.
     * For example, let's say we're writing a blog administration application which deals with Users, Posts and Comments.
     * We can express the relationships between these models like this:
     *
     *     Ext.define('Post', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'user_id'],
     *
     *         belongsTo: 'User',
     *         hasMany  : {model: 'Comment', name: 'comments'}
     *     });
     *
     *     Ext.define('Comment', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'user_id', 'post_id'],
     *
     *         belongsTo: 'Post'
     *     });
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id'],
     *
     *         hasMany: [
     *             'Post',
     *             {model: 'Comment', name: 'comments'}
     *         ]
     *     });
     *
     * See the docs for {@link Ext.data.association.HasOne}, {@link Ext.data.association.BelongsTo} and
     * {@link Ext.data.association.HasMany} for details on the usage and configuration of associations.
     * Note that associations can also be specified like this:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id'],
     *
     *         associations: [
     *             {type: 'hasMany', model: 'Post',    name: 'posts'},
     *             {type: 'hasMany', model: 'Comment', name: 'comments'}
     *         ]
     *     });
     *
     * # Using a Proxy
     *
     * Models are great for representing types of data and relationships, but sooner or later we're going to want to load or
     * save that data somewhere. All loading and saving of data is handled via a {@link Ext.data.proxy.Proxy Proxy}, which
     * can be set directly on the Model:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email'],
     *
     *         proxy: {
     *             type: 'rest',
     *             url : '/users'
     *         }
     *     });
     *
     * Here we've set up a {@link Ext.data.proxy.Rest Rest Proxy}, which knows how to load and save data to and from a
     * RESTful backend. Let's see how this works:
     *
     *     var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
     *
     *     user.save(); //POST /users
     *
     * Calling {@link #save} on the new Model instance tells the configured RestProxy that we wish to persist this Model's
     * data onto our server. RestProxy figures out that this Model hasn't been saved before because it doesn't have an id,
     * and performs the appropriate action - in this case issuing a POST request to the url we configured (/users). We
     * configure any Proxy on any Model and always follow this API - see {@link Ext.data.proxy.Proxy} for a full list.
     *
     * Loading data via the Proxy is equally easy:
     *
     *     //get a reference to the User model class
     *     var User = Ext.ModelManager.getModel('User');
     *
     *     //Uses the configured RestProxy to make a GET request to /users/123
     *     User.load(123, {
     *         success: function(user) {
     *             console.log(user.getId()); //logs 123
     *         }
     *     });
     *
     * Models can also be updated and destroyed easily:
     *
     *     //the user Model we loaded in the last snippet:
     *     user.set('name', 'Edward Spencer');
     *
     *     //tells the Proxy to save the Model. In this case it will perform a PUT request to /users/123 as this Model already has an id
     *     user.save({
     *         success: function() {
     *             console.log('The User was updated');
     *         }
     *     });
     *
     *     //tells the Proxy to destroy the Model. Performs a DELETE request to /users/123
     *     user.destroy({
     *         success: function() {
     *             console.log('The User was destroyed!');
     *         }
     *     });
     *
     * # Usage in Stores
     *
     * It is very common to want to load a set of Model instances to be displayed and manipulated in the UI. We do this by
     * creating a {@link Ext.data.Store Store}:
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User'
     *     });
     *
     *     //uses the Proxy we set up on Model to load the Store data
     *     store.load();
     *
     * A Store is just a collection of Model instances - usually loaded from a server somewhere. Store can also maintain a
     * set of added, updated and removed Model instances to be synchronized with the server via the Proxy. See the {@link
     * Ext.data.Store Store docs} for more information on Stores.
     */
    export class Model extends Ext.Base implements Ext.data.ModelConfig {
        /**
         * True if this Record has been modified.
         * @readonly
         */
        dirty: boolean;

        /**
         * Internal flag used to track whether or not the model instance is currently being edited.
         * @readonly
         */
        editing: boolean;

        /**
         * A {@link Ext.util.MixedCollection Collection} of the fields defined for this Model (including fields defined in superclasses)
         *
         * This is a collection of {@link Ext.data.Field} instances, each of which encapsulates information that the field was configured with.
         * By default, you can specify a field as simply a String, representing the *name* of the field, but a Field encapsulates
         * {@link Ext.data.Field#type data type}, {@link Ext.data.Field#convert custom conversion} of raw data, and a {@link Ext.data.Field#mapping mapping}
         * property to specify by name of index, how to extract a field's value from a raw data object.
         */
        fields: Ext.util.MixedCollection;

        /**
         * 'true' in this class to identify an object as an instantiated Model, or subclass thereof.
         */
        isModel: boolean;

        /**
         * Key: value pairs of all fields whose values have changed
         */
        modified: any;

        /**
         * True when the record does not yet exist in a server-side database (see {@link #setDirty}).
         * Any record which has a real database pk set as its id property is NOT a phantom -- it's real.
         */
        phantom: boolean;

        /**
         * The raw data used to create this model if created via a reader.
         */
        raw: any;

        /**
         * The {@link Ext.data.Store Store} to which this instance belongs. NOTE: If this
         * instance is bound to multiple stores, this property will reference only the
         * first. To examine all the stores, use the {@link #stores} property instead.
         */
        store: Ext.data.Store;

        /**
         * The {@link Ext.data.Store Stores} to which this instance is bound.
         */
        stores: Ext.data.Store;

        /**
         * An array of {@link Ext.data.Association associations} for this model.
         */
        associations: any;

        /**
         * One or more {@link Ext.data.BelongsToAssociation BelongsTo associations} for this model.
         */
        belongsTo: string|any;

        /**
         * The name of a property that is used for submitting this Model's unique client-side identifier
         * to the server when multiple phantom records are saved as part of the same {@link Ext.data.Operation Operation}.
         * In such a case, the server response should include the client id for each record
         * so that the server response data can be used to update the client-side records if necessary.
         * This property cannot have the same name as any of this Model's fields.
         *
         * Optional
         */
        clientIdProperty: string;

        /**
         * The string type of the default Model Proxy. Defaults to 'ajax'.
         */
        defaultProxyType: string;

        /**
         * One or more {@link Ext.data.HasManyAssociation HasMany associations} for this model.
         */
        hasMany: string|any;

        /**
         * The id generator to use for this model. The default id generator does not generate
         * values for the {@link #idProperty}.
         *
         * This can be overridden at the model level to provide a custom generator for a model.
         * The simplest form of this would be:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          requires: ['Ext.data.SequentialIdGenerator'],
         *          idgen: 'sequential',
         *          ...
         *      });
         *
         * The above would generate {@link Ext.data.SequentialIdGenerator sequential} id's such
         * as 1, 2, 3 etc..
         *
         * Another useful id generator is {@link Ext.data.UuidGenerator}:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          requires: ['Ext.data.UuidGenerator'],
         *          idgen: 'uuid',
         *          ...
         *      });
         *
         * An id generation can also be further configured:
         *
         *      Ext.define('MyApp.data.MyModel', {
         *          extend: 'Ext.data.Model',
         *          idgen: {
         *              type: 'sequential',
         *              seed: 1000,
         *              prefix: 'ID_'
         *          }
         *      });
         *
         * The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
         *
         * If multiple models share an id space, a single generator can be shared:
         *
         *      Ext.define('MyApp.data.MyModelX', {
         *          extend: 'Ext.data.Model',
         *          idgen: {
         *              type: 'sequential',
         *              id: 'xy'
         *          }
         *      });
         *
         *      Ext.define('MyApp.data.MyModelY', {
         *          extend: 'Ext.data.Model',
         *          idgen: {
         *              type: 'sequential',
         *              id: 'xy'
         *          }
         *      });
         *
         * For more complex, shared id generators, a custom generator is the best approach.
         * See {@link Ext.data.IdGenerator} for details on creating custom id generators.
         *
         * @markdown
         */
        idgen: string|any;

        /**
         * The name of the field treated as this Model's unique id. Defaults to 'id'.
         *
         * This may also be specified as a Field config object. This means that the identifying field can be calculated
         * using a {@link Ext.data.Field#convert convert} function which might aggregate several values from the
         * raw data object to use as an identifier.
         *
         * The resulting {@link Ext.data.Field Field} is added to the Model's field collection unless there is already
         * a configured field with a mapping that reads the same property.
         *
         * If defining an **abstract** base Model class, the 'idProperty' may be configured as 'null' which will mean that
         * no identifying field will be generated.
         */
        idProperty: string|any|Ext.data.Field;

        /**
         * The name of the property on this Persistable object that its data is saved to. Defaults to 'data'
         * (i.e: all persistable data resides in 'this.data'.)
         * @deprecated This config is deprecated. In future this will no longer be configurable and will be data.
         */
        persistenceProperty: string;

        /**
         * The {@link Ext.data.proxy.Proxy proxy} to use for this model.
         */
        proxy: string|any|Ext.data.proxy.Proxy;

        /**
         * An array of {@link Ext.data.validations validations} for this model.
         */
        validations: any;

        /**
         * Begins an edit. While in edit mode, no events (e.g.. the 'update' event) are relayed to the containing store.
         * When an edit has begun, it must be followed by either {@link #endEdit} or {@link #cancelEdit}.
         */
        beginEdit();

        /**
         * Cancels all changes made in the current edit operation.
         */
        cancelEdit();

        /**
         * Usually called by the {@link Ext.data.Store} which owns the model instance. Commits all changes made to the
         * instance since either creation or the last commit operation.
         *
         * Developers should subscribe to the {@link Ext.data.Store#event-update} event to have their code notified of commit
         * operations.
         *
         * @param {Boolean} [silent=false] Pass 'true' to skip notification of the owning store of the change.
         * @param {String[]} [modifiedFieldNames] Array of field names changed during sync with server if known.
         * Omit or pass 'null' if unknown. An empty array means that it is known that no fields were modified
         * by the server's response.
         * Defaults to false.
         */
        commit(silent?: boolean, modifiedFieldNames?: string);

        /**
         * Creates new Model instance.
         * @param {Object} data An object containing keys corresponding to this model's fields, and their associated values
         */
        constructor(data: any);

        /**
         * Creates a copy (clone) of this Model instance.
         *
         * @param {String} [id] A new id, defaults to the id of the instance being copied.
         * See '{@link Ext.data.Model#id id}'. To generate a phantom instance with a new id use:
         *
         *     var rec = record.copy(); // clone the record
         *     Ext.data.Model.id(rec); // automatically generate a unique sequential id
         *
         * @return {Ext.data.Model}
         */
        copy(id?: string): Ext.data.Model;

        /**
         * Destroys the model using the configured proxy.
         * @param {Object} options Options to pass to the proxy. Config object for {@link Ext.data.Operation}.
         * @return {Ext.data.Model} The Model instance
         */
        destroy(options: any): Ext.data.Model;

        /**
         * Ends an edit. If any data was modified, the containing store is notified
         * (ie, the store's 'update' event will fire).
         * @param {Boolean} [silent] True to not notify the store of the change
         * @param {String[]} [modifiedFieldNames] Array of field names changed during edit.
         */
        endEdit(silent?: boolean, modifiedFieldNames?: string);

        /**
         * Returns the value of the given field
         * @param {String} fieldName The field to fetch the value for
         * @return {Object} The value
         */
        get(fieldName: string): any;

        /**
         * Gets all of the data from this Models *loaded* associations. It does this recursively - for example if we have a
         * User which hasMany Orders, and each Order hasMany OrderItems, it will return an object like this:
         *
         *     {
         *         orders: [
         *             {
         *                 id: 123,
         *                 status: 'shipped',
         *                 orderItems: [
         *                     ...
         *                 ]
         *             }
         *         ]
         *     }
         *
         * @return {Object} The nested data set for the Model's loaded associations
         */
        getAssociatedData(): any;

        /**
         * Gets a hash of only the fields that have been modified since this Model was created or commited.
         * @return {Object}
         */
        getChanges(): any;

        /**
         * Gets all values for each field in this model and returns an object
         * containing the current data.
         * @param {Boolean} includeAssociated True to also include associated data. Defaults to false.
         * @return {Object} An object hash containing all the values in this model
         */
        getData(includeAssociated: boolean): any;

        /**
         * Returns the unique ID allocated to this model instance as defined by {@link #idProperty}.
         * @return {Number/String} The id
         */
        getId(): number|string;

        /**
         * Returns true if the passed field name has been '{@link #modified}' since the load or last commit.
         * @param {String} fieldName {@link Ext.data.Field#name}
         * @return {Boolean}
         */
        isModified(fieldName: string): boolean;

        /**
         * Checks if the model is valid. See {@link #validate}.
         * @return {Boolean} True if the model is valid.
         */
        isValid(): boolean;

        /**
         * Tells this model instance that it has been added to a store.
         * @param {Ext.data.Store} store The store to which this model has been added.
         */
        join(store: Ext.data.Store);

        /**
         * Usually called by the {@link Ext.data.Store} to which this model instance has been {@link #join joined}. Rejects
         * all changes made to the model instance since either creation, or the last commit operation. Modified fields are
         * reverted to their original values.
         *
         * Developers should subscribe to the {@link Ext.data.Store#event-update} event to have their code notified of reject
         * operations.
         *
         * @param {Boolean} silent (optional) True to skip notification of the owning store of the change.
         * Defaults to false.
         */
        reject(silent: boolean);

        /**
         * Saves the model instance using the configured proxy.
         * @param {Object} [options] Options to pass to the proxy. Config object for {@link Ext.data.Operation}.
         * @return {Ext.data.Model} The Model instance
         */
        save(options?: any): Ext.data.Model;

        /**
         * Sets the given field to the given value, marks the instance as dirty
         * @param {String/Object} fieldName The field to set, or an object containing key/value pairs
         * @param {Object} newValue The value to set
         * @return {String[]} The array of modified field names or null if nothing was modified.
         */
        set(fieldName: string|any, newValue: any): string;

        /**
         * Marks this **Record** as '{@link #dirty}'. This method is used interally when adding '{@link #phantom}' records
         * to a {@link Ext.data.proxy.Server#writer writer enabled store}.
         *
         * Marking a record '{@link #dirty}' causes the phantom to be returned by {@link Ext.data.Store#getUpdatedRecords}
         * where it will have a create action composed for it during {@link Ext.data.Model#save model save} operations.
         */
        setDirty();

        /**
         * Sets the model instance's id field to the given id.
         * @param {Number/String} id The new id
         */
        setId(id: number|string);

        /**
         * Tells this model instance that it has been removed from the store.
         * @param {Ext.data.Store} store The store from which this model has been removed.
         */
        unjoin(store: Ext.data.Store);

        /**
         * Validates the current data against all of its configured {@link #validations}.
         * @return {Ext.data.Errors} The errors object
         */
        validate(): Ext.data.Errors;

        /**
         * Fired when this model's id changes
         * @param {Number/String} oldId The old id
         * @param {Number/String} newId The new id
         */
        idchanged(that: Ext.data.Model, oldId: number|string, newId: number|string);

        /**
         * The update operation of type 'commit'. Used by {@link Ext.data.Store#event-update Store.update} event.
         */
        static COMMIT: any;

        /**
         * The update operation of type 'edit'. Used by {@link Ext.data.Store#event-update Store.update} event.
         */
        static EDIT: any;

        /**
         * The update operation of type 'reject'. Used by {@link Ext.data.Store#event-update Store.update} event.
         */
        static REJECT: any;

        /**
         * Returns an Array of {@link Ext.data.Field Field} definitions which define this Model's structure
         *
         * Fields are sorted upon Model class definition. Fields with custom {@link Ext.data.Field#convert convert} functions
         * are moved to *after* fields with no convert functions. This is so that convert functions which rely on existing
         * field values will be able to read those field values.
         *
         * @return {Ext.data.Field[]} The defined Fields for this Model.
         */
        static getFields(): Ext.data.Field;

        /**
         * Returns the configured Proxy for this Model
         * @return {Ext.data.proxy.Proxy} The proxy
         * @inheritable
         */
        static getProxy(): Ext.data.proxy.Proxy;

        /**
         * Generates a sequential id. This method is typically called when a record is {@link Ext#create
         * create}d and {@link #constructor no id has been specified} either as a parameter, or through the {@link #idProperty}
         * in the passed data. The generated id will automatically be assigned to the
         * record. The returned id takes the form: {PREFIX}-{AUTO_ID}.
         *
         * - **PREFIX** : String - Ext.data.Model.PREFIX (defaults to 'ext-record')
         * - **AUTO_ID** : String - Ext.data.Model.AUTO_ID (defaults to 1 initially)
         *
         * @param {Ext.data.Model} rec The record being created. The record does not exist, it's a {@link #phantom}.
         * @return {String} auto-generated string id, '"ext-record-i++"';
         */
        static id(rec: Ext.data.Model): string;

        /**
         * Asynchronously loads a model instance by id. Sample usage:
         *
         *     Ext.define('MyApp.User', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *             {name: 'id', type: 'int'},
         *             {name: 'name', type: 'string'}
         *         ]
         *     });
         *
         *     MyApp.User.load(10, {
         *         scope: this,
         *         failure: function(record, operation) {
         *             //do something if the load failed
         *             //record is null
         *         },
         *         success: function(record, operation) {
         *             //do something if the load succeeded
         *         },
         *         callback: function(record, operation, success) {
         *             //do something whether the load succeeded or failed
         *             //if operation is unsuccessful, record is null
         *         }
         *     });
         *
         * @param {Number/String} id The id of the model to load
         * @param {Object} config (optional) config object containing success, failure and callback functions, plus
         * optional scope
         * @inheritable
         */
        static load(id: number|string, config: Ext.data.ModelConfig);

        /**
         * Apply a new set of field and/or property definitions to the existing model. This will replace any existing
         * fields, including fields inherited from superclasses. Mainly for reconfiguring the
         * model based on changes in meta data (called from Reader's onMetaChange method).
         * @inheritable
         */
        static setFields();

        /**
         * Sets the Proxy to use for this model. Accepts any options that can be accepted by
         * {@link Ext#createByAlias Ext.createByAlias}.
         * @param {String/Object/Ext.data.proxy.Proxy} proxy The proxy
         * @return {Ext.data.proxy.Proxy}
         * @inheritable
         */
        static setProxy(proxy: string|any|Ext.data.proxy.Proxy): Ext.data.proxy.Proxy;
    }

    interface NodeInterfaceConfig {
        /**
         * Set to false to deny dragging of this node.
         *
         * Optional, Defaults to: true
         */
        allowDrag?: boolean;

        /**
         * Set to false to deny dropping on this node.
         *
         * Optional, Defaults to: true
         */
        allowDrop?: boolean;

        /**
         * Set to true or false to show a checkbox alongside this node.
         *
         * Optional, Defaults to: null
         */
        checked?: boolean;

        /**
         * Array of child nodes.
         */
        children?: Ext.data.NodeInterface;

        /**
         * CSS class to apply for this node.
         */
        cls?: string;

        /**
         * The number of parents this node has. A root node has depth 0, a child of it depth 1, and so on...
         */
        depth?: number;

        /**
         * Set to true to allow for expanding/collapsing of this node.
         *
         * Optional, Defaults to: false
         */
        expandable?: boolean;

        /**
         * True if the node is expanded.
         *
         * Optional, Defaults to: false
         */
        expanded?: boolean;

        /**
         * An URL for a link that's created when this config is specified.
         */
        href?: string;

        /**
         * Target for link. Only applicable when {@link #href} also specified.
         */
        hrefTarget?: string;

        /**
         * URL for this node's icon.
         */
        icon?: string;

        /**
         * CSS class to apply for this node's icon.
         */
        iconCls?: string;

        /**
         * The position of the node inside its parent. When parent has 4 children and the node is third amongst them,
         * index will be 2.
         */
        index?: number;

        /**
         * Set to true to indicate that this child can have no children. The expand icon/arrow will then not be
         * rendered for this node.
         *
         * Optional, Defaults to: false
         */
        leaf?: boolean;

        /**
         * True if the node has finished loading.
         *
         * Optional, Defaults to: false
         */
        loaded?: boolean;

        /**
         * True if the node is currently loading.
         *
         * Optional, Defaults to: false
         */
        loading?: boolean;

        /**
         * ID of parent node.
         */
        parentId?: string;

        /**
         * Tooltip showDelay.
         */
        qshowDelay?: number;

        /**
         * Tooltip text to show on this node.
         */
        qtip?: string;

        /**
         * Tooltip title.
         */
        qtitle?: string;

        /**
         * True if this is the root node.
         */
        root?: boolean;

        /**
         * The text to show on node label.
         */
        text?: string;
    }

    /**
     * This class is used as a set of methods that are applied to the prototype of a
     * Model to decorate it with a Node API. This means that models used in conjunction with a tree
     * will have all of the tree related methods available on the model. In general this class will
     * not be used directly by the developer. This class also creates extra fields on the model if
     * they do not exist, to help maintain the tree state and UI. These fields are documented as
     * config options.
     */
    export class NodeInterface extends Ext.Base implements Ext.data.NodeInterfaceConfig {
        /**
         * An array of this nodes children.  Array will be empty if this node has no chidren.
         */
        childNodes: Ext.data.NodeInterface;

        /**
         * A reference to this node's first child node. 'null' if this node has no children.
         */
        firstChild: Ext.data.NodeInterface;

        /**
         * 'true' in this class to identify an object as an instantiated Node, or subclass thereof.
         */
        isNode: boolean;

        /**
         * A reference to this node's last child node. 'null' if this node has no children.
         */
        lastChild: Ext.data.NodeInterface;

        /**
         * A reference to this node's next sibling node. 'null' if this node does not have a next sibling.
         */
        nextSibling: Ext.data.NodeInterface;

        /**
         * A reference to this node's parent node. 'null' if this node is the root node.
         */
        parentNode: Ext.data.NodeInterface;

        /**
         * A reference to this node's previous sibling node. 'null' if this node does not have a previous sibling.
         */
        previousSibling: Ext.data.NodeInterface;

        /**
         * Set to false to deny dragging of this node.
         *
         * Optional, Defaults to: true
         */
        allowDrag: boolean;

        /**
         * Set to false to deny dropping on this node.
         *
         * Optional, Defaults to: true
         */
        allowDrop: boolean;

        /**
         * Set to true or false to show a checkbox alongside this node.
         *
         * Optional, Defaults to: null
         */
        checked: boolean;

        /**
         * Array of child nodes.
         */
        children: Ext.data.NodeInterface;

        /**
         * CSS class to apply for this node.
         */
        cls: string;

        /**
         * The number of parents this node has. A root node has depth 0, a child of it depth 1, and so on...
         */
        depth: number;

        /**
         * Set to true to allow for expanding/collapsing of this node.
         *
         * Optional, Defaults to: false
         */
        expandable: boolean;

        /**
         * True if the node is expanded.
         *
         * Optional, Defaults to: false
         */
        expanded: boolean;

        /**
         * An URL for a link that's created when this config is specified.
         */
        href: string;

        /**
         * Target for link. Only applicable when {@link #href} also specified.
         */
        hrefTarget: string;

        /**
         * URL for this node's icon.
         */
        icon: string;

        /**
         * CSS class to apply for this node's icon.
         */
        iconCls: string;

        /**
         * The position of the node inside its parent. When parent has 4 children and the node is third amongst them,
         * index will be 2.
         */
        index: number;

        /**
         * Set to true to indicate that this child can have no children. The expand icon/arrow will then not be
         * rendered for this node.
         *
         * Optional, Defaults to: false
         */
        leaf: boolean;

        /**
         * True if the node has finished loading.
         *
         * Optional, Defaults to: false
         */
        loaded: boolean;

        /**
         * True if the node is currently loading.
         *
         * Optional, Defaults to: false
         */
        loading: boolean;

        /**
         * ID of parent node.
         */
        parentId: string;

        /**
         * Tooltip showDelay.
         */
        qshowDelay: number;

        /**
         * Tooltip text to show on this node.
         */
        qtip: string;

        /**
         * Tooltip title.
         */
        qtitle: string;

        /**
         * True if this is the root node.
         */
        root: boolean;

        /**
         * The text to show on node label.
         */
        text: string;

        /**
         * Inserts node(s) as the last child node of this node.
         *
         * If the node was previously a child node of another parent node, it will be removed from that node first.
         *
         * @param {Ext.data.NodeInterface/Ext.data.NodeInterface[]/Object} node The node or Array of nodes to append
         * @param {Boolean} [suppressEvents=false] True to suppress firering of events.
         * @param {Boolean} [commit=false]
         * @return {Ext.data.NodeInterface} The appended node if single append, or null if an array was passed
         */
        appendChild(node: Ext.data.NodeInterface|any, suppressEvents?: boolean, commit?: boolean): Ext.data.NodeInterface;

        /**
         * Bubbles up the tree from this node, calling the specified function with each node. The arguments to the function
         * will be the args provided or the current node. If the function returns false at any point,
         * the bubble is stopped.
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope (this reference) in which the function is executed. Defaults to the current Node.
         * @param {Array} [args] The args to call the function with. Defaults to passing the current Node.
         */
        bubble(fn: Function, scope?: any, args?: any[]);

        /**
         * Cascades down the tree from this node, calling the specified function with each node. The arguments to the function
         * will be the args provided or the current node. If the function returns false at any point,
         * the cascade is stopped on that branch.
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope (this reference) in which the function is executed. Defaults to the current Node.
         * @param {Array} [args] The args to call the function with. Defaults to passing the current Node.
         */
        cascadeBy(fn: Function, scope?: any, args?: any[]);

        /**
         * Collapse this node.
         * @param {Boolean} [recursive=false] True to recursively collapse all the children
         * @param {Function} [callback] The function to execute once the collapse completes
         * @param {Object} [scope] The scope to run the callback in
         */
        collapse(recursive?: boolean, callback?: Function, scope?: any);

        /**
         * Collapse all the children of this node.
         * @param {Function} [recursive=false] True to recursively collapse all the children
         * @param {Function} [callback] The function to execute once all the children are collapsed
         * @param {Object} [scope] The scope to run the callback in
         */
        collapseChildren(recursive?: Function, callback?: Function, scope?: any);

        /**
         * Returns true if this node is an ancestor (at any point) of the passed node.
         * @return {Boolean}
         */
        contains(node: Ext.data.NodeInterface): boolean;

        /**
         * Creates a copy (clone) of this Node.
         * @param {String} [id] A new id, defaults to this Node's id.
         * @param {Boolean} [deep=false] True to recursively copy all child Nodes into the new Node.
         * False to copy without child Nodes.
         * @return {Ext.data.NodeInterface} A copy of this Node.
         */
        copy(id?: string, deep?: boolean): Ext.data.NodeInterface;

        /**
         * Ensures that the passed object is an instance of a Record with the NodeInterface applied
         * @return {Ext.data.NodeInterface}
         */
        createNode(): Ext.data.NodeInterface;

        /**
         * Destroys the node.
         */
        destroy();

        /**
         * Interates the child nodes of this node, calling the specified function with each node. The arguments to the function
         * will be the args provided or the current node. If the function returns false at any point,
         * the iteration stops.
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope (this reference) in which the function is executed. Defaults to the current Node in iteration.
         * @param {Array} [args] The args to call the function with. Defaults to passing the current Node.
         */
        eachChild(fn: Function, scope?: any, args?: any[]);

        /**
         * Expand this node.
         * @param {Boolean} [recursive=false] True to recursively expand all the children
         * @param {Function} [callback] The function to execute once the expand completes
         * @param {Object} [scope] The scope to run the callback in
         */
        expand(recursive?: boolean, callback?: Function, scope?: any);

        /**
         * Expand all the children of this node.
         * @param {Boolean} [recursive=false] True to recursively expand all the children
         * @param {Function} [callback] The function to execute once all the children are expanded
         * @param {Object} [scope] The scope to run the callback in
         */
        expandChildren(recursive?: boolean, callback?: Function, scope?: any);

        /**
         * Finds the first child that has the attribute with the specified value.
         * @param {String} attribute The attribute name
         * @param {Object} value The value to search for
         * @param {Boolean} [deep=false] True to search through nodes deeper than the immediate children
         * @return {Ext.data.NodeInterface} The found child or null if none was found
         */
        findChild(attribute: string, value: any, deep?: boolean): Ext.data.NodeInterface;

        /**
         * Finds the first child by a custom function. The child matches if the function passed returns true.
         * @param {Function} fn A function which must return true if the passed Node is the required Node.
         * @param {Object} [scope] The scope (this reference) in which the function is executed. Defaults to the Node being tested.
         * @param {Boolean} [deep=false] True to search through nodes deeper than the immediate children
         * @return {Ext.data.NodeInterface} The found child or null if none was found
         */
        findChildBy(fn: Function, scope?: any, deep?: boolean): Ext.data.NodeInterface;

        /**
         * Returns the child node at the specified index.
         * @return {Ext.data.NodeInterface}
         */
        getChildAt(index: number): Ext.data.NodeInterface;

        /**
         * Returns depth of this node (the root node has a depth of 0)
         * @return {Number}
         */
        getDepth(): number;

        /**
         * Returns the tree this node is in.
         * @return {Ext.tree.Panel} The tree panel which owns this node.
         */
        getOwnerTree(): Ext.tree.Panel;

        /**
         * Gets the hierarchical path from the root of the current node.
         * @param {String} [field] The field to construct the path from. Defaults to the model idProperty.
         * @param {String} [separator="/"] A separator to use.
         * @return {String} The node path
         */
        getPath(field?: string, separator?: string): string;

        /**
         * Returns true if this node has one or more child nodes, else false.
         * @return {Boolean}
         */
        hasChildNodes(): boolean;

        /**
         * Returns the index of a child node
         * @return {Number} The index of the node or -1 if it was not found
         */
        indexOf(node: Ext.data.NodeInterface): number;

        /**
         * Returns the index of a child node that matches the id
         * @param {String} id The id of the node to find
         * @return {Number} The index of the node or -1 if it was not found
         */
        indexOfId(id: string): number;

        /**
         * Inserts the first node before the second node in this nodes childNodes collection.
         * @param {Ext.data.NodeInterface} node The node to insert
         * @param {Ext.data.NodeInterface} refNode The node to insert before (if null the node is appended)
         * @return {Ext.data.NodeInterface} The inserted node
         */
        insertBefore(node: Ext.data.NodeInterface, refNode: Ext.data.NodeInterface): Ext.data.NodeInterface;

        /**
         * Inserts a node into this node.
         * @param {Number} index The zero-based index to insert the node at
         * @param {Ext.data.NodeInterface} node The node to insert
         * @return {Ext.data.NodeInterface} The node you just inserted
         */
        insertChild(index: number, node: Ext.data.NodeInterface): Ext.data.NodeInterface;

        /**
         * Returns true if the passed node is an ancestor (at any point) of this node.
         * @return {Boolean}
         */
        isAncestor(node: Ext.data.NodeInterface): boolean;

        /**
         * Returns true if this node has one or more child nodes, or if the <tt>expandable</tt>
         * node attribute is explicitly specified as true, otherwise returns false.
         * @return {Boolean}
         */
        isExpandable(): boolean;

        /**
         * Returns true if this node is expaned
         * @return {Boolean}
         */
        isExpanded(): boolean;

        /**
         * Returns true if this node is the first child of its parent
         * @return {Boolean}
         */
        isFirst(): boolean;

        /**
         * Returns true if this node is the last child of its parent
         * @return {Boolean}
         */
        isLast(): boolean;

        /**
         * Returns true if this node is a leaf
         * @return {Boolean}
         */
        isLeaf(): boolean;

        /**
         * Returns true if this node is loaded
         * @return {Boolean}
         */
        isLoaded(): boolean;

        /**
         * Returns true if this node is loading
         * @return {Boolean}
         */
        isLoading(): boolean;

        /**
         * Returns true if this node is the root node
         * @return {Boolean}
         */
        isRoot(): boolean;

        /**
         * Returns true if this node is visible. Note that visibility refers to
         * the structure of the tree, the {@link Ext.tree.Panel#rootVisible}
         * configuration is not taken into account here. If this method is called
         * on the root node, it will always be visible.
         * @return {Boolean}
         */
        isVisible(): boolean;

        /**
         * Removes this node from its parent
         * @param {Boolean} [destroy=false] True to destroy the node upon removal.
         * @return {Ext.data.NodeInterface} this
         */
        remove(destroy?: boolean): Ext.data.NodeInterface;

        /**
         * Removes all child nodes from this node.
         * @param {Boolean} [destroy=false] True to destroy the node upon removal.
         * @return {Ext.data.NodeInterface} this
         */
        removeAll(destroy?: boolean): Ext.data.NodeInterface;

        /**
         * Removes a child node from this node.
         * @param {Ext.data.NodeInterface} node The node to remove
         * @param {Boolean} [destroy=false] True to destroy the node upon removal.
         * @return {Ext.data.NodeInterface} The removed node
         */
        removeChild(node: Ext.data.NodeInterface, destroy?: boolean): Ext.data.NodeInterface;

        /**
         * Replaces one child node in this node with another.
         * @param {Ext.data.NodeInterface} newChild The replacement node
         * @param {Ext.data.NodeInterface} oldChild The node to replace
         * @return {Ext.data.NodeInterface} The replaced node
         */
        replaceChild(newChild: Ext.data.NodeInterface, oldChild: Ext.data.NodeInterface): Ext.data.NodeInterface;

        /**
         * Creates an object representation of this node including its children.
         */
        serialize();

        /**
         * Sorts this nodes children using the supplied sort function.
         * @param {Function} fn A function which, when passed two Nodes, returns -1, 0 or 1 depending upon required sort order.
         * @param {Boolean} [recursive=false] True to apply this sort recursively
         * @param {Boolean} [suppressEvent=false] True to not fire a sort event.
         */
        sort(fn: Function, recursive?: boolean, suppressEvent?: boolean);

        /**
         * Updates general data of this node like isFirst, isLast, depth. This
         * method is internally called after a node is moved. This shouldn't
         * have to be called by the developer unless they are creating custom
         * Tree plugins.
         * @param {Object} info The info to update. May contain any of the following
         *  @param {Object} info.isFirst
         *  @param {Object} info.isLast
         *  @param {Object} info.index
         *  @param {Object} info.depth
         *  @param {Object} info.parentId
         */
        updateInfo(commit: boolean, info: any);

        /**
         * Fires when a new child node is appended
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The newly appended node
         * @param {Number} index The index of the newly appended node
         */
        append(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface, index: number);

        /**
         * Fires before a new child is appended, return false to cancel the append.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The child node to be appended
         */
        beforeappend(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface);

        /**
         * Fires before this node is collapsed.
         * @param {Ext.data.NodeInterface} this The collapsing node
         */
        beforecollapse(that: Ext.data.NodeInterface);

        /**
         * Fires before this node is expanded.
         * @param {Ext.data.NodeInterface} this The expanding node
         */
        beforeexpand(that: Ext.data.NodeInterface);

        /**
         * Fires before a new child is inserted, return false to cancel the insert.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The child node to be inserted
         * @param {Ext.data.NodeInterface} refNode The child node the node is being inserted before
         */
        beforeinsert(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface, refNode: Ext.data.NodeInterface);

        /**
         * Fires before this node is moved to a new location in the tree. Return false to cancel the move.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} oldParent The parent of this node
         * @param {Ext.data.NodeInterface} newParent The new parent this node is moving to
         * @param {Number} index The index it is being moved to
         */
        beforemove(that: Ext.data.NodeInterface, oldParent: Ext.data.NodeInterface, newParent: Ext.data.NodeInterface, index: number);

        /**
         * Fires before a child is removed, return false to cancel the remove.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The child node to be removed
         * @param {Boolean} isMove 'true' if the child node is being removed so it can be moved to another position in the tree.
         * (a side effect of calling {@link Ext.data.NodeInterface#appendChild appendChild} or
         * {@link Ext.data.NodeInterface#insertBefore insertBefore} with a node that already has a parentNode)
         */
        beforeremove(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface, isMove: boolean);

        /**
         * Fires when a new child node is inserted.
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} node The child node inserted
         * @param {Ext.data.NodeInterface} refNode The child node the node was inserted before
         */
        insert(that: Ext.data.NodeInterface, node: Ext.data.NodeInterface, refNode: Ext.data.NodeInterface);

        /**
         * Fires when this node is moved to a new location in the tree
         * @param {Ext.data.NodeInterface} this This node
         * @param {Ext.data.NodeInterface} oldParent The old parent of this node
         * @param {Ext.data.NodeInterface} newParent The new parent of this node
         * @param {Number} index The index it was moved to
         */
        move(that: Ext.data.NodeInterface, oldParent: Ext.data.NodeInterface, newParent: Ext.data.NodeInterface, index: number);

        /**
         * This method allows you to decorate a Model's class to implement the NodeInterface.
         * This adds a set of methods, new events, new properties and new fields on every Record.
         * @param {Ext.Class/Ext.data.Model} modelClass The Model class or an instance of the Model class you want to
         * decorate the prototype of.
         */
        static decorate(modelClass: Ext.Class|Ext.data.Model);
    }

    interface NodeStoreConfig extends Ext.data.StoreConfig {
        /**
         * The Record you want to bind this Store to. Note that
         * this record will be decorated with the Ext.data.NodeInterface if this is not the
         * case yet.
         */
        node?: Ext.data.Model;

        /**
         * Set this to true if you want this NodeStore to represent
         * all the descendents of the node in its flat data collection. This is useful for
         * rendering a tree structure to a DataView and is being used internally by
         * the TreeView. Any records that are moved, removed, inserted or appended to the
         * node at any depth below the node this store is bound to will be automatically
         * updated in this Store's internal flat data structure.
         */
        recursive?: boolean;

        /**
         * False to not include the root node in this Stores collection.
         */
        rootVisible?: boolean;

        /**
         * The TreeStore that is used by this NodeStore's Ext.tree.View.
         */
        treeStore?: Ext.data.TreeStore;
    }

    /**
     * Node Store
     */
    export class NodeStore extends Ext.data.Store implements Ext.data.NodeStoreConfig {
        /**
         * Recursion level counter. Incremented when expansion or collaping of a node is initiated,
         * including when nested nodes below the expanding/collapsing root begin expanding or collapsing.
         *
         * This ensures that collapsestart, collapsecomplete, expandstart and expandcomplete only
         * fire on the top level node being collapsed/expanded.
         *
         * Also, allows listeners to the 'add' and 'remove' events to know whether a collapse of expand is in progress.
         */
        protected isExpandingOrCollapsing: any;

        /**
         * 'true' in this class to identify an object as an instantiated NodeStore, or subclass thereof.
         */
        isNodeStore: boolean;

        /**
         * The Record you want to bind this Store to. Note that
         * this record will be decorated with the Ext.data.NodeInterface if this is not the
         * case yet.
         */
        node: Ext.data.Model;

        /**
         * Set this to true if you want this NodeStore to represent
         * all the descendents of the node in its flat data collection. This is useful for
         * rendering a tree structure to a DataView and is being used internally by
         * the TreeView. Any records that are moved, removed, inserted or appended to the
         * node at any depth below the node this store is bound to will be automatically
         * updated in this Store's internal flat data structure.
         */
        recursive: boolean;

        /**
         * False to not include the root node in this Stores collection.
         */
        rootVisible: boolean;

        /**
         * The TreeStore that is used by this NodeStore's Ext.tree.View.
         */
        treeStore: Ext.data.TreeStore;

        constructor(config: Ext.data.NodeStoreConfig);
    }

    interface OperationConfig {
        /**
         * The action being performed by this Operation. Should be one of 'create', 'read', 'update' or 'destroy'.
         */
        action?: string;

        /**
         * The batch that this Operation is a part of.
         */
        batch?: Ext.data.Batch;

        /**
         * Function to execute when operation completed.
         * Array of records.
         * The Operation itself.
         * True when operation completed successfully.
         */
        callback?: Function;

        /**
         * Optional array of filter objects. Only applies to 'read' actions.
         */
        filters?: Ext.util.Filter;

        /**
         * Optional grouping configuration. Only applies to 'read' actions where grouping is desired.
         */
        groupers?: Ext.util.Grouper;

        /**
         * The number of records to load. Used on 'read' actions when paging is being used.
         */
        limit?: number;

        /**
         * Parameters to pass along with the request when performing the operation.
         */
        params?: any;

        /**
         * Scope for the {@link #callback} function.
         */
        scope?: any;

        /**
         * Optional array of sorter objects. Only applies to 'read' actions.
         */
        sorters?: Ext.util.Sorter;

        /**
         * The start index (offset), used in paging when running a 'read' action.
         */
        start?: number;

        /**
         * True if this Operation is to be executed synchronously. This property is inspected by a
         * {@link Ext.data.Batch Batch} to see if a series of Operations can be executed in parallel or not.
         */
        synchronous?: boolean;
    }

    /**
     * @author Ed Spencer
     *
     * Represents a single read or write operation performed by a {@link Ext.data.proxy.Proxy Proxy}. Operation objects are
     * used to enable communication between Stores and Proxies. Application developers should rarely need to interact with
     * Operation objects directly.
     *
     * Several Operations can be batched together in a {@link Ext.data.Batch batch}.
     */
    export class Operation extends Ext.Base implements Ext.data.OperationConfig {
        /**
         * The RegExp used to categorize actions that require record commits.
         */
        actionCommitRecordsRe: RegExp;

        /**
         * The RegExp used to categorize actions that skip local record synchronization. This defaults
         * to match 'destroy'.
         */
        actionSkipSyncRe: RegExp;

        /**
         * The action being performed by this Operation. Should be one of 'create', 'read', 'update' or 'destroy'.
         */
        action: string;

        /**
         * The batch that this Operation is a part of.
         */
        batch: Ext.data.Batch;

        /**
         * Function to execute when operation completed.
         * Array of records.
         * The Operation itself.
         * True when operation completed successfully.
         */
        callback: Function;

        /**
         * Optional array of filter objects. Only applies to 'read' actions.
         */
        filters: Ext.util.Filter;

        /**
         * Optional grouping configuration. Only applies to 'read' actions where grouping is desired.
         */
        groupers: Ext.util.Grouper;

        /**
         * The number of records to load. Used on 'read' actions when paging is being used.
         */
        limit: number;

        /**
         * Parameters to pass along with the request when performing the operation.
         */
        params: any;

        /**
         * Scope for the {@link #callback} function.
         */
        scope: any;

        /**
         * Optional array of sorter objects. Only applies to 'read' actions.
         */
        sorters: Ext.util.Sorter;

        /**
         * The start index (offset), used in paging when running a 'read' action.
         */
        start: number;

        /**
         * True if this Operation is to be executed synchronously. This property is inspected by a
         * {@link Ext.data.Batch Batch} to see if a series of Operations can be executed in parallel or not.
         */
        synchronous: boolean;

        /**
         * Checks whether this operation should cause writing to occur.
         * @return {Boolean} Whether the operation should cause a write to occur.
         */
        allowWrite(): boolean;

        /**
         * This method is called to commit data to this instance's records given the records in
         * the server response. This is followed by calling {@link Ext.data.Model#commit} on all
         * those records (for 'create' and 'update' actions).
         *
         * If this {@link #action} is 'destroy', any server records are ignored and the
         * {@link Ext.data.Model#commit} method is not called.
         *
         * @param {Ext.data.Model[]} serverRecords An array of {@link Ext.data.Model} objects returned by
         * the server.
         * @markdown
         */
        commitRecords(serverRecords: Ext.data.Model);

        /**
         * Creates new Operation object.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.OperationConfig);

        /**
         * Returns the error string or object that was set using {@link #setException}
         * @return {String/Object} The error object
         */
        getError(): string|any;

        /**
         * Returns the {@link Ext.data.Model record}s associated with this operation.  For read operations the records as set by the {@link Ext.data.proxy.Proxy Proxy} will be returned (returns 'null' if the proxy has not yet set the records).
         * For create, update, and destroy operations the operation's initially configured records will be returned, although the proxy may modify these records' data at some point after the operation is initialized.
         * @return {Ext.data.Model[]}
         */
        getRecords(): Ext.data.Model;

        /**
         * Returns the ResultSet object (if set by the Proxy). This object will contain the {@link Ext.data.Model model}
         * instances as well as meta data such as number of instances fetched, number available etc
         * @return {Ext.data.ResultSet} The ResultSet object
         */
        getResultSet(): Ext.data.ResultSet;

        /**
         * Returns true if this Operation encountered an exception (see also {@link #getError})
         * @return {Boolean} True if there was an exception
         */
        hasException(): boolean;

        /**
         * Returns true if the Operation has been completed
         * @return {Boolean} True if the Operation is complete
         */
        isComplete(): boolean;

        /**
         * Returns true if the Operation has been started but has not yet completed.
         * @return {Boolean} True if the Operation is currently running
         */
        isRunning(): boolean;

        /**
         * Returns true if the Operation has been started. Note that the Operation may have started AND completed, see
         * {@link #isRunning} to test if the Operation is currently running.
         * @return {Boolean} True if the Operation has started
         */
        isStarted(): boolean;

        /**
         * Marks the Operation as completed.
         */
        setCompleted();

        /**
         * Marks the Operation as having experienced an exception. Can be supplied with an option error message/object.
         * @param {String/Object} error (optional) error string/object
         */
        setException(error: string|any);

        /**
         * Marks the Operation as started.
         */
        setStarted();

        /**
         * Marks the Operation as successful.
         */
        setSuccessful();

        /**
         * Returns true if the Operation has completed and was successful
         * @return {Boolean} True if successful
         */
        wasSuccessful(): boolean;
    }

    /**
     * @extends Ext.util.LruCache
     * Private class for use by only Store when configured 'buffered: true'.
     */
    export class PageMap extends Ext.util.LruCache {
        /**
         * Creates new HashMap.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.util.HashMapConfig);

        /**
         * Returns the first record in this page map which elicits a true return value from the
         * passed selection function.
         *
         * **IMPORTANT
         * This can ONLY find records which happen to be cached in the page cache. This will be parts of the dataset around the currently
         * visible zone, or recently visited zones if the pages have not yet been purged from the cache.
         *
         * This CAN NOT find records which have not been loaded into the cache.**
         *
         * If full client side searching is required, do not use a buffered store, instead use a regular, fully loaded store and
         * use the {@link Ext.grid.plugin.BufferedRenderer BufferedRenderer} plugin to minimize DOM footprint.
         * @param {Function} fn The selection function to execute for each item.
         *  @param {Mixed} fn.rec The record.
         *  @param {Mixed} fn.index The index in the total dataset of the record.
         * @param {Object} [scope] The scope ('this' reference) in which the function is executed. Defaults to this PageMap.
         * @return {Object} The first record in this page map which returned true from the selection
         * function, or null if none was found.
         */
        findBy(fn: Function, scope?: any): any;

        /**
         * Returns the index *in the whole dataset* of the first record in this page map which elicits a true return value from the
         * passed selection function.
         *
         * **IMPORTANT
         * This can ONLY find records which happen to be cached in the page cache. This will be parts of the dataset around the currently
         * visible zone, or recently visited zones if the pages have not yet been purged from the cache.
         *
         * This CAN NOT find records which have not been loaded into the cache.**
         *
         * If full client side searching is required, do not use a buffered store, instead use a regular, fully loaded store and
         * use the {@link Ext.grid.plugin.BufferedRenderer BufferedRenderer} plugin to minimize DOM footprint.
         * @param {Function} fn The selection function to execute for each item.
         *  @param {Mixed} fn.rec The record.
         *  @param {Mixed} fn.index The index in the total dataset of the record.
         * @param {Object} [scope] The scope ('this' reference) in which the function is executed. Defaults to this PageMap.
         * @return {Number} The index first record in this page map which returned true from the selection
         * function, or -1 if none was found.
         */
        findIndexBy(fn: Function, scope?: any): number;
    }

    interface RequestConfig {
        /**
         * The name of the action this Request represents. Usually one of 'create', 'read', 'update' or 'destroy'.
         */
        action?: string;

        /**
         * The HTTP method to use on this Request. Should be one of 'GET', 'POST', 'PUT' or 'DELETE'.
         */
        method?: string;

        /**
         * HTTP request params. The Proxy and its Writer have access to and can modify this object.
         */
        params?: any;

        /**
         * The url to access on this Request
         */
        url?: string;
    }

    /**
     * @author Ed Spencer
     *
     * Simple class that represents a Request that will be made by any {@link Ext.data.proxy.Server} subclass.
     * All this class does is standardize the representation of a Request as used by any ServerProxy subclass,
     * it does not contain any actual logic or perform the request itself.
     */
    export class Request extends Ext.Base implements Ext.data.RequestConfig {
        /**
         * The name of the action this Request represents. Usually one of 'create', 'read', 'update' or 'destroy'.
         */
        action: string;

        /**
         * The HTTP method to use on this Request. Should be one of 'GET', 'POST', 'PUT' or 'DELETE'.
         */
        method: string;

        /**
         * HTTP request params. The Proxy and its Writer have access to and can modify this object.
         */
        params: any;

        /**
         * The url to access on this Request
         */
        url: string;

        /**
         * Creates the Request object.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.RequestConfig);
    }

    interface ResultSetConfig {
        /**
         * The number of records in this ResultSet. Note that total may differ from this number.
         */
        count?: number;

        /**
         * True if the records have already been loaded. This is only meaningful when dealing with
         * SQL-backed proxies.
         */
        loaded?: boolean;

        /**
         * (required)
         * The array of record instances.
         */
        records?: Ext.data.Model;

        /**
         * True if the ResultSet loaded successfully, false if any errors were encountered.
         */
        success?: boolean;

        /**
         * The total number of records reported by the data source. This ResultSet may form a subset of
         * those records (see {@link #count}).
         */
        total?: number;
    }

    /**
     * @author Ed Spencer
     *
     * Simple wrapper class that represents a set of records returned by a Proxy.
     */
    export class ResultSet extends Ext.Base implements Ext.data.ResultSetConfig {
        /**
         * Copy of this.total.
         * @deprecated Will be removed in Ext JS 5.0. Use {@link #total} instead.
         */
        totalRecords: number;

        /**
         * The number of records in this ResultSet. Note that total may differ from this number.
         */
        count: number;

        /**
         * True if the records have already been loaded. This is only meaningful when dealing with
         * SQL-backed proxies.
         */
        loaded: boolean;

        /**
         * (required)
         * The array of record instances.
         */
        records: Ext.data.Model;

        /**
         * True if the ResultSet loaded successfully, false if any errors were encountered.
         */
        success: boolean;

        /**
         * The total number of records reported by the data source. This ResultSet may form a subset of
         * those records (see {@link #count}).
         */
        total: number;

        /**
         * Creates the resultSet
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.ResultSetConfig);
    }

    interface SequentialIdGeneratorConfig extends Ext.data.IdGeneratorConfig {
        /**
         * The string to place in front of the sequential number for each generated id. The
         * default is blank.
         */
        prefix?: string;

        /**
         * The number at which to start generating sequential id's. The default is 1.
         */
        seed?: number;
    }

    /**
     * @author Don Griffin
     *
     * This class is a sequential id generator. A simple use of this class would be like so:
     *
     *     Ext.define('MyApp.data.MyModel', {
     *         extend: 'Ext.data.Model',
     *         idgen: 'sequential'
     *     });
     *     // assign id's of 1, 2, 3, etc.
     *
     * An example of a configured generator would be:
     *
     *     Ext.define('MyApp.data.MyModel', {
     *         extend: 'Ext.data.Model',
     *         idgen: {
     *             type: 'sequential',
     *             prefix: 'ID_',
     *             seed: 1000
     *         }
     *     });
     *     // assign id's of ID_1000, ID_1001, ID_1002, etc.
     */
    export class SequentialIdGenerator extends Ext.data.IdGenerator implements Ext.data.SequentialIdGeneratorConfig {
        /**
         * The string to place in front of the sequential number for each generated id. The
         * default is blank.
         */
        prefix: string;

        /**
         * The number at which to start generating sequential id's. The default is 1.
         */
        seed: number;

        constructor();

        /**
         * Generates and returns the next id.
         * @return {String} The next id.
         */
        generate(): string;
    }

    /**
     * This class defines a series of static methods that are used on a
     * {@link Ext.data.Field} for performing sorting. The methods cast the
     * underlying values into a data type that is appropriate for sorting on
     * that particular field.  If a {@link Ext.data.Field#type} is specified,
     * the sortType will be set to a sane default if the sortType is not
     * explicitly defined on the field. The sortType will make any necessary
     * modifications to the value and return it.
     * <ul>
     * <li><b>asText</b> - Removes any tags and converts the value to a string</li>
     * <li><b>asUCText</b> - Removes any tags and converts the value to an uppercase string</li>
     * <li><b>asUCText</b> - Converts the value to an uppercase string</li>
     * <li><b>asDate</b> - Converts the value into Unix epoch time</li>
     * <li><b>asFloat</b> - Converts the value to a floating point number</li>
     * <li><b>asInt</b> - Converts the value to an integer number</li>
     * </ul>
     * <p>
     * It is also possible to create a custom sortType that can be used throughout
     * an application.
     * <pre><code>
     Ext.apply(Ext.data.SortTypes, {
     asPerson: function(person){
     // expects an object with a first and last name property
     return person.lastName.toUpperCase() + person.firstName.toLowerCase();
     }
     });
     Ext.define('Employee', {
     extend: 'Ext.data.Model',
     fields: [{
     name: 'person',
     sortType: 'asPerson'
     }, {
     name: 'salary',
     type: 'float' // sortType set to asFloat
     }]
     });
     * </code></pre>
     * </p>
     * @docauthor Evan Trimboli <evan@sencha.com>
     */
    export class SortTypes {
        /**
         * The regular expression used to strip tags
         */
        static stripTagsRE: RegExp;

        /**
         * Date sorting
         * @param {Object} s The value being converted
         * @return {Number} The comparison value
         */
        static asDate(s: any): number;

        /**
         * Float sorting
         * @param {Object} s The value being converted
         * @return {Number} The comparison value
         */
        static asFloat(s: any): number;

        /**
         * Integer sorting
         * @param {Object} s The value being converted
         * @return {Number} The comparison value
         */
        static asInt(s: any): number;

        /**
         * Strips all HTML tags to sort on text only
         * @param {Object} s The value being converted
         * @return {String} The comparison value
         */
        static asText(s: any): string;

        /**
         * Case insensitive string
         * @param {Object} s The value being converted
         * @return {String} The comparison value
         */
        static asUCString(s: any): string;

        /**
         * Strips all HTML tags to sort on text only - Case insensitive
         * @param {Object} s The value being converted
         * @return {String} The comparison value
         */
        static asUCText(s: any): string;

        /**
         * Default sort that does nothing
         * @param {Object} s The value being converted
         * @return {Object} The comparison value
         */
        static none(s: any): any;
    }

    interface StoreConfig extends Ext.data.AbstractStoreConfig {
        /**
         * When a Store is used by only one {@link Ext.view.View DataView}, and should only exist for the lifetime of that view, then
         * configure the autoDestroy flag as 'true'. This causes the destruction of the view to trigger the destruction of its Store.
         *
         * Optional, Defaults to: false
         */
        autoDestroy?: boolean;

        /**
         * Allows the Store to prefetch and cache in a **page cache**, pages of Records, and to then satisfy
         * loading requirements from this page cache.
         *
         * To use buffered Stores, initiate the process by loading the first page. The number of rows rendered are
         * determined automatically, and the range of pages needed to keep the cache primed for scrolling is
         * requested and cached.
         * Example:
         *
         *     myStore.loadPage(1); // Load page 1
         *
         * A {@link Ext.grid.plugin.BufferedRenderer BufferedRenderer} is instantiated which will monitor the scrolling in the grid, and
         * refresh the view's rows from the page cache as needed. It will also pull new data into the page
         * cache when scrolling of the view draws upon data near either end of the prefetched data.
         *
         * The margins which trigger view refreshing from the prefetched data are {@link Ext.grid.plugin.BufferedRenderer#numFromEdge},
         * {@link Ext.grid.plugin.BufferedRenderer#leadingBufferZone} and {@link Ext.grid.plugin.BufferedRenderer#trailingBufferZone}.
         *
         * The margins which trigger loading more data into the page cache are, {@link #leadingBufferZone} and
         * {@link #trailingBufferZone}.
         *
         * By default, only 5 pages of data are cached in the page cache, with pages "scrolling" out of the buffer
         * as the view moves down through the dataset.
         * Setting this value to zero means that no pages are *ever* scrolled out of the page cache, and
         * that eventually the whole dataset may become present in the page cache. This is sometimes desirable
         * as long as datasets do not reach astronomical proportions.
         *
         * Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
         * records from its collection when those Records cycle out of the Store's primary collection. This is done
         * by configuring the SelectionModel like this:
         *
         *     selModel: {
         *         pruneRemoved: false
         *     }
         */
        buffered?: boolean;

        /**
         * True to empty the store when loading another page via {@link #loadPage},
         * {@link #nextPage} or {@link #previousPage}. Setting to false keeps existing records, allowing
         * large data sets to be loaded one page at a time but rendered all together.
         */
        clearOnPageLoad?: boolean;

        /**
         * 'true' to clear anything in the {@link #removed} record collection when the store loads.
         *
         * Optional, Defaults to: true
         */
        clearRemovedOnLoad?: boolean;

        /**
         * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
         */
        groupDir?: string;

        /**
         * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
         * groupField and {@link #groupDir} are injected as the first sorter (see {@link #sort}). Stores support a single
         * level of grouping, and groups can be fetched via the {@link #getGroups} method.
         */
        groupField?: string;

        /**
         * The collection of {@link Ext.util.Grouper Groupers} currently applied to this Store.
         */
        groupers?: Ext.util.MixedCollection;

        /**
         * When {@link #buffered}, the number of extra rows to keep cached on the leading side of scrolling buffer
         * as scrolling proceeds. A larger number means fewer replenishments from the server.
         */
        leadingBufferZone?: number;

        /**
         * The number of records considered to form a 'page'. This is used to power the built-in
         * paging using the nextPage and previousPage functions when the grid is paged using a
         * {@link Ext.toolbar.Paging PagingToolbar} Defaults to 25.
         *
         * If this Store is {@link #buffered}, pages are loaded into a page cache before the Store's
         * data is updated from the cache. The pageSize is the number of rows loaded into the cache in one request.
         * This will not affect the rendering of a buffered grid, but a larger page size will mean fewer loads.
         *
         * In a buffered grid, scrolling is monitored, and the page cache is kept primed with data ahead of the
         * direction of scroll to provide rapid access to data when scrolling causes it to be required. Several pages
         * in advance may be requested depending on various parameters.
         *
         * It is recommended to tune the {@link #pageSize}, {@link #trailingBufferZone} and
         * {@link #leadingBufferZone} configurations based upon the conditions pertaining in your deployed application.
         *
         * The provided SDK example 'examples/grid/infinite-scroll-grid-tuner.html' can be used to experiment with
         * different settings including simulating Ajax latency.
         */
        pageSize?: number;

        /**
         * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
         * see {@link #setProxy} for details.
         */
        proxy?: string|Ext.data.proxy.Proxy|any;

        /**
         * *Valid only when used with a {@link Ext.data.Store#buffered buffered} Store.*
         *
         * The number of pages *additional to the required buffered range* to keep in the prefetch cache before purging least recently used records.
         *
         * For example, if the height of the view area and the configured {@link #trailingBufferZone} and {@link #leadingBufferZone} require that there
         * are three pages in the cache, then a 'purgePageCount' of 5 ensures that up to 8 pages can be in the page cache any any one time.
         *
         * A value of 0 indicates to never purge the prefetched data.
         */
        purgePageCount?: number;

        /**
         * 'true' if the grouping should be performed on the server side, false if it is local only.
         *
         * {@link #buffered Buffered} stores automatically set this to 'true'. Buffered stores contain an abitrary
         * subset of the full dataset which depends upon various configurations and which pages have been requested
         * for rendering. Such *sparse* datasets are ineligible for local filtering.
         *
         * Optional, Defaults to: false
         */
        remoteFilter?: boolean;

        /**
         * 'true' if the grouping should apply on the server side, false if it is local only.  If the
         * grouping is local, it can be applied immediately to the data.  If it is remote, then it will simply act as a
         * helper, automatically sending the grouping information to the server.
         *
         * {@link #buffered Buffered} stores automatically set this to 'true'. Buffered stores contain an abitrary
         * subset of the full dataset which depends upon various configurations and which pages have been requested
         * for rendering. Such *sparse* datasets are ineligible for local grouping.
         *
         * Optional, Defaults to: false
         */
        remoteGroup?: boolean;

        /**
         * 'true' if the sorting should be performed on the server side, false if it is local only.
         *
         * {@link #buffered Buffered} stores automatically set this to 'true'. Buffered stores contain an abitrary
         * subset of the full dataset which depends upon various configurations and which pages have been requested
         * for rendering. Such *sparse* datasets are ineligible for local sorting.
         *
         * Optional, Defaults to: false
         */
        remoteSort?: boolean;

        /**
         * For local filtering only, causes {@link #sort} to be called whenever {@link #filter} is called,
         * causing the sorters to be reapplied after filtering.
         */
        sortOnFilter?: boolean;

        /**
         * When {@link #buffered}, the number of extra records to keep cached on the trailing side of scrolling buffer
         * as scrolling proceeds. A larger number means fewer replenishments from the server.
         */
        trailingBufferZone?: number;
    }

    /**
     * The Store class encapsulates a client side cache of {@link Ext.data.Model Model} objects. Stores load data via a
     * {@link Ext.data.proxy.Proxy Proxy}, and also provide functions for {@link #sort sorting}, {@link #filter filtering}
     * and querying the {@link Ext.data.Model model} instances contained within it.
     *
     * Creating a Store is easy - we just tell it the Model and the Proxy to use for loading and saving its data:
     *
     *      // Set up a {@link Ext.data.Model model} to use in our Store
     *      Ext.define('User', {
     *          extend: 'Ext.data.Model',
     *          fields: [
     *              {name: 'firstName', type: 'string'},
     *              {name: 'lastName',  type: 'string'},
     *              {name: 'age',       type: 'int'},
     *              {name: 'eyeColor',  type: 'string'}
     *          ]
     *      });
     *
     *      var myStore = Ext.create('Ext.data.Store', {
     *          model: 'User',
     *          proxy: {
     *              type: 'ajax',
     *              url: '/users.json',
     *              reader: {
     *                  type: 'json',
     *                  root: 'users'
     *              }
     *          },
     *          autoLoad: true
     *      });
     *
     * In the example above we configured an AJAX proxy to load data from the url '/users.json'. We told our Proxy to use a
     * {@link Ext.data.reader.Json JsonReader} to parse the response from the server into Model object - {@link
     * Ext.data.reader.Json see the docs on JsonReader} for details.
     *
     * ## Inline data
     *
     * Stores can also load data inline. Internally, Store converts each of the objects we pass in as {@link #cfg-data} into
     * Model instances:
     *
     *      Ext.create('Ext.data.Store', {
     *          model: 'User',
     *          data : [
     *              {firstName: 'Ed',    lastName: 'Spencer'},
     *              {firstName: 'Tommy', lastName: 'Maintz'},
     *              {firstName: 'Aaron', lastName: 'Conran'},
     *              {firstName: 'Jamie', lastName: 'Avins'}
     *          ]
     *      });
     *
     * Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn't
     * need to be processed by a {@link Ext.data.reader.Reader reader}). If your inline data requires processing to decode
     * the data structure, use a {@link Ext.data.proxy.Memory MemoryProxy} instead (see the {@link Ext.data.proxy.Memory
     * MemoryProxy} docs for an example).
     *
     * Additional data can also be loaded locally using {@link #method-add}.
     *
     * ## Dynamic Loading
     *
     * Stores can be dynamically updated by calling the {@link #method-load} method:
     *
     *     store.load({
     *         params: {
     *             group: 3,
     *             type: 'user'
     *         },
     *         callback: function(records, operation, success) {
     *             // do something after the load finishes
     *         },
     *         scope: this
     *     });
     *
     * Here a bunch of arbitrary parameters is passed along with the load request and a callback function is set
     * up to do something after the loading is over.
     *
     * ## Loading Nested Data
     *
     * Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders.
     * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load
     * a nested dataset and allow the Reader to automatically populate the associated models. Below is a brief example, see
     * the {@link Ext.data.reader.Reader} intro docs for a full explanation:
     *
     *      var store = Ext.create('Ext.data.Store', {
     *          autoLoad: true,
     *          model: "User",
     *          proxy: {
     *              type: 'ajax',
     *              url: 'users.json',
     *              reader: {
     *                  type: 'json',
     *                  root: 'users'
     *              }
     *          }
     *      });
     *
     * Which would consume a response like this:
     *
     *      {
     *          "users": [{
     *              "id": 1,
     *              "name": "Ed",
     *              "orders": [{
     *                  "id": 10,
     *                  "total": 10.76,
     *                  "status": "invoiced"
     *             },{
     *                  "id": 11,
     *                  "total": 13.45,
     *                  "status": "shipped"
     *             }]
     *          }]
     *      }
     *
     * See the {@link Ext.data.reader.Reader} intro docs for a full explanation.
     *
     * ## Filtering and Sorting
     *
     * Stores can be sorted and filtered - in both cases either remotely or locally. The {@link #cfg-sorters} and
     * {@link #cfg-filters} are held inside {@link Ext.util.MixedCollection MixedCollection} instances to make them easy to manage.
     * Usually it is sufficient to either just specify sorters and filters in the Store configuration or call {@link #sort}
     * or {@link #filter}:
     *
     *      var store = Ext.create('Ext.data.Store', {
     *          model: 'User',
     *          sorters: [{
     *              property: 'age',
     *              direction: 'DESC'
     *          }, {
     *              property: 'firstName',
     *              direction: 'ASC'
     *          }],
     *
     *          filters: [{
     *              property: 'firstName',
     *              value: /Ed/
     *          }]
     *      });
     *
     * The new Store will keep the configured sorters and filters in the MixedCollection instances mentioned above. By
     * default, sorting and filtering are both performed locally by the Store - see {@link #remoteSort} and
     * {@link #remoteFilter} to allow the server to perform these operations instead.
     *
     * Filtering and sorting after the Store has been instantiated is also easy. Calling {@link #filter} adds another filter
     * to the Store and automatically filters the dataset (calling {@link #filter} with no arguments simply re-applies all
     * existing filters). Note that by default {@link #sortOnFilter} is set to true, which means that your sorters are
     * automatically reapplied if using local sorting.
     *
     *     store.filter('eyeColor', 'Brown');
     *
     * Change the sorting at any time by calling {@link #sort}:
     *
     *     store.sort('height', 'ASC');
     *
     * Note that all existing sorters will be removed in favor of the new sorter data (if {@link #sort} is called with no
     * arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
     * ones, just add them to the MixedCollection:
     *
     *     store.sorters.add(new Ext.util.Sorter({
     *         property : 'shoeSize',
     *         direction: 'ASC'
     *     }));
     *
     *     store.sort();
     *
     * ## Registering with StoreManager
     *
     * Any Store that is instantiated with a {@link #storeId} will automatically be registered with the {@link
     * Ext.data.StoreManager StoreManager}. This makes it easy to reuse the same store in multiple views:
     *
     *     //this store can be used several times
     *     Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         storeId: 'usersStore'
     *     });
     *
     *     new Ext.List({
     *         store: 'usersStore',
     *         //other config goes here
     *     });
     *
     *     new Ext.view.View({
     *         store: 'usersStore',
     *         //other config goes here
     *     });
     *
     * ## Further Reading
     *
     * Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
     * pieces and how they fit together, see:
     *
     *   - {@link Ext.data.proxy.Proxy Proxy} - overview of what Proxies are and how they are used
     *   - {@link Ext.data.Model Model} - the core class in the data package
     *   - {@link Ext.data.reader.Reader Reader} - used by any subclass of {@link Ext.data.proxy.Server ServerProxy} to read a response
     *
     * @author Ed Spencer
     */
    export class Store extends Ext.data.AbstractStore implements Ext.data.StoreConfig {
        /**
         * The page that the Store has most recently loaded (see {@link #loadPage})
         */
        currentPage: number;

        /**
         * When this Store is not {@link #buffered}, the 'data' property is a MixedCollection which holds this store's local cache of records.
         *
         * When this store *is* {@link #buffered}, the 'data' property is a cache of *pages* of records used to satisfy load requests from the Store when the associated view
         * scrolls. Depending on how the {@link #leadingBufferZone buffer zone} and {@link #purgePageCount} are configured,
         * pages which are scrolled out of view may be evicted from the cache, and need to be re-requested from the server
         * when scrolled back into view. For this reason, if using {@link #buffered}, it is recommended that you configure
         * your Model definitions with a unique {@link Ext.data.Model#idProperty} so that records which return to the page
         * cache may be matched against previously selected records.
         *
         * Pages in the direction of scroll are prefetched from the remote server and loaded into this cache *before*
         * they are needed based upon the {@link #leadingBufferZone buffer zone} so that scrolling can proceed without visible pauses for data loading.
         */
        data: Ext.util.MixedCollection|any;

        /**
         * A pristine (unfiltered) collection of the records in this store. This is used to reinstate
         * records when a filter is removed or changed
         */
        snapshot: Ext.util.MixedCollection;

        /**
         * When a Store is used by only one {@link Ext.view.View DataView}, and should only exist for the lifetime of that view, then
         * configure the autoDestroy flag as 'true'. This causes the destruction of the view to trigger the destruction of its Store.
         *
         * Optional, Defaults to: false
         */
        autoDestroy: boolean;

        /**
         * Allows the Store to prefetch and cache in a **page cache**, pages of Records, and to then satisfy
         * loading requirements from this page cache.
         *
         * To use buffered Stores, initiate the process by loading the first page. The number of rows rendered are
         * determined automatically, and the range of pages needed to keep the cache primed for scrolling is
         * requested and cached.
         * Example:
         *
         *     myStore.loadPage(1); // Load page 1
         *
         * A {@link Ext.grid.plugin.BufferedRenderer BufferedRenderer} is instantiated which will monitor the scrolling in the grid, and
         * refresh the view's rows from the page cache as needed. It will also pull new data into the page
         * cache when scrolling of the view draws upon data near either end of the prefetched data.
         *
         * The margins which trigger view refreshing from the prefetched data are {@link Ext.grid.plugin.BufferedRenderer#numFromEdge},
         * {@link Ext.grid.plugin.BufferedRenderer#leadingBufferZone} and {@link Ext.grid.plugin.BufferedRenderer#trailingBufferZone}.
         *
         * The margins which trigger loading more data into the page cache are, {@link #leadingBufferZone} and
         * {@link #trailingBufferZone}.
         *
         * By default, only 5 pages of data are cached in the page cache, with pages "scrolling" out of the buffer
         * as the view moves down through the dataset.
         * Setting this value to zero means that no pages are *ever* scrolled out of the page cache, and
         * that eventually the whole dataset may become present in the page cache. This is sometimes desirable
         * as long as datasets do not reach astronomical proportions.
         *
         * Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
         * records from its collection when those Records cycle out of the Store's primary collection. This is done
         * by configuring the SelectionModel like this:
         *
         *     selModel: {
         *         pruneRemoved: false
         *     }
         */
        buffered: boolean;

        /**
         * True to empty the store when loading another page via {@link #loadPage},
         * {@link #nextPage} or {@link #previousPage}. Setting to false keeps existing records, allowing
         * large data sets to be loaded one page at a time but rendered all together.
         */
        clearOnPageLoad: boolean;

        /**
         * 'true' to clear anything in the {@link #removed} record collection when the store loads.
         *
         * Optional, Defaults to: true
         */
        clearRemovedOnLoad: boolean;

        /**
         * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
         */
        groupDir: string;

        /**
         * The collection of {@link Ext.util.Grouper Groupers} currently applied to this Store.
         */
        groupers: Ext.util.MixedCollection;

        /**
         * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
         * groupField and {@link #groupDir} are injected as the first sorter (see {@link #sort}). Stores support a single
         * level of grouping, and groups can be fetched via the {@link #getGroups} method.
         */
        groupField: string;

        /**
         * When {@link #buffered}, the number of extra rows to keep cached on the leading side of scrolling buffer
         * as scrolling proceeds. A larger number means fewer replenishments from the server.
         */
        leadingBufferZone: number;

        /**
         * The number of records considered to form a 'page'. This is used to power the built-in
         * paging using the nextPage and previousPage functions when the grid is paged using a
         * {@link Ext.toolbar.Paging PagingToolbar} Defaults to 25.
         *
         * If this Store is {@link #buffered}, pages are loaded into a page cache before the Store's
         * data is updated from the cache. The pageSize is the number of rows loaded into the cache in one request.
         * This will not affect the rendering of a buffered grid, but a larger page size will mean fewer loads.
         *
         * In a buffered grid, scrolling is monitored, and the page cache is kept primed with data ahead of the
         * direction of scroll to provide rapid access to data when scrolling causes it to be required. Several pages
         * in advance may be requested depending on various parameters.
         *
         * It is recommended to tune the {@link #pageSize}, {@link #trailingBufferZone} and
         * {@link #leadingBufferZone} configurations based upon the conditions pertaining in your deployed application.
         *
         * The provided SDK example 'examples/grid/infinite-scroll-grid-tuner.html' can be used to experiment with
         * different settings including simulating Ajax latency.
         */
        pageSize: number;

        /**
         * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
         * see {@link #setProxy} for details.
         */
        proxy: string|Ext.data.proxy.Proxy|any;

        /**
         * *Valid only when used with a {@link Ext.data.Store#buffered buffered} Store.*
         *
         * The number of pages *additional to the required buffered range* to keep in the prefetch cache before purging least recently used records.
         *
         * For example, if the height of the view area and the configured {@link #trailingBufferZone} and {@link #leadingBufferZone} require that there
         * are three pages in the cache, then a 'purgePageCount' of 5 ensures that up to 8 pages can be in the page cache any any one time.
         *
         * A value of 0 indicates to never purge the prefetched data.
         */
        purgePageCount: number;

        /**
         * 'true' if the grouping should be performed on the server side, false if it is local only.
         *
         * {@link #buffered Buffered} stores automatically set this to 'true'. Buffered stores contain an abitrary
         * subset of the full dataset which depends upon various configurations and which pages have been requested
         * for rendering. Such *sparse* datasets are ineligible for local filtering.
         *
         * Optional, Defaults to: false
         */
        remoteFilter: boolean;

        /**
         * 'true' if the grouping should apply on the server side, false if it is local only.  If the
         * grouping is local, it can be applied immediately to the data.  If it is remote, then it will simply act as a
         * helper, automatically sending the grouping information to the server.
         *
         * {@link #buffered Buffered} stores automatically set this to 'true'. Buffered stores contain an abitrary
         * subset of the full dataset which depends upon various configurations and which pages have been requested
         * for rendering. Such *sparse* datasets are ineligible for local grouping.
         *
         * Optional, Defaults to: false
         */
        remoteGroup: boolean;

        /**
         * 'true' if the sorting should be performed on the server side, false if it is local only.
         *
         * {@link #buffered Buffered} stores automatically set this to 'true'. Buffered stores contain an abitrary
         * subset of the full dataset which depends upon various configurations and which pages have been requested
         * for rendering. Such *sparse* datasets are ineligible for local sorting.
         *
         * Optional, Defaults to: false
         */
        remoteSort: boolean;

        /**
         * For local filtering only, causes {@link #sort} to be called whenever {@link #filter} is called,
         * causing the sorters to be reapplied after filtering.
         */
        sortOnFilter: boolean;

        /**
         * When {@link #buffered}, the number of extra records to keep cached on the trailing side of scrolling buffer
         * as scrolling proceeds. A larger number means fewer replenishments from the server.
         */
        trailingBufferZone: number;

        /**
         * Adds a new Filter to this Store's {@link #property-filters filter set} and
         * by default, applys the updated filter set to the Store's unfiltered dataset.
         * @param {Object[]/Ext.util.Filter[]} filters The set of filters to add to the current {@link #property-filters filter set}.
         * @param {Boolean} [applyFilters=true] Pass as 'false' to add the filter but not apply the updated filter set.
         */
        addFilter(filters: any|Ext.util.Filter, applyFilters?: boolean);

        /**
         * (Local sort only) Inserts the passed Record into the Store at the index where it
         * should go based on the current sort information.
         */
        addSorted(record: Ext.data.Model);

        /**
         * Runs the aggregate function for all the records in the store.
         *
         * When store is filtered, only items within the filter are aggregated.
         *
         * @param {Function} fn The function to execute. The function is called with a single parameter,
         * an array of records for that group.
         * @param {Object} [scope] The scope to execute the function in. Defaults to the store.
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the group average being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @param {Array} [args] Any arguments to append to the function call
         * @return {Object} An object literal with the group names and their appropriate values.
         */
        aggregate(fn: Function, scope?: any, grouped?: boolean, args?: any[]): any;

        /**
         * Gets the average value in the store.
         *
         * When store is filtered, only items within the filter are aggregated.
         *
         * @param {String} field The field in each record
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the group average being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Object} The average value, if no items exist, 0.
         */
        average(field: string, grouped?: boolean): any;

        /**
         * Reverts to a view of the Record cache with no filtering applied.
         * @param {Boolean} [suppressEvent] If 'true' the filter is cleared silently.
         *
         * For a locally filtered Store, this means that the filter collection is cleared without firing the
         * {@link #datachanged} event.
         *
         * For a remotely filtered Store, this means that the filter collection is cleared, but the store
         * is not reloaded from the server.
         */
        clearFilter(suppressEvent?: boolean);

        /**
         * Clear any groupers in the store
         */
        clearGrouping();

        /**
         * Collects unique values for a particular dataIndex from this store.
         *
         * @param {String} dataIndex The property to collect
         * @param {Boolean} [allowNull] Pass true to allow null, undefined or empty string values
         * @param {Boolean} [bypassFilter] Pass true to collect from all records, even ones which are filtered.
         * @return {Object[]} An array of the unique values
         */
        collect(dataIndex: string, allowNull?: boolean, bypassFilter?: boolean): any;

        /**
         * Commits all Records with {@link #getModifiedRecords outstanding changes}. To handle updates for changes,
         * subscribe to the Store's {@link #event-update update event}, and perform updating when the third parameter is
         * Ext.data.Record.COMMIT.
         */
        commitChanges();

        /**
         * Creates the store.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.StoreConfig);

        /**
         * Gets the count of items in the store.
         *
         * When store is filtered, only items within the filter are counted.
         *
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the count for each group being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Number} the count
         */
        count(grouped?: boolean): number;

        /**
         * Calls the specified function for each {@link Ext.data.Model record} in the store.
         *
         * When store is filtered, only loops over the filtered records.
         *
         * @param {Function} fn The function to call. The {@link Ext.data.Model Record} is passed as the first parameter.
         * Returning 'false' aborts and exits the iteration.
         * @param {Object} [scope] The scope (this reference) in which the function is executed.
         * Defaults to the current {@link Ext.data.Model record} in the iteration.
         */
        each(fn: Function, scope?: any);

        /**
         * Filters the loaded set of records by a given set of filters.
         *
         * By default, the passed filter(s) are *added* to the collection of filters being used to filter this Store.
         *
         * To remove existing filters before applying a new set of filters use
         *
         *     // Clear the filter collection without updating the UI
         *     store.clearFilter(true);
         *
         * see {@link #clearFilter}.
         *
         * Alternatively, if filters are configured with an 'id', then existing filters store may be *replaced* by new
         * filters having the same 'id'.
         *
         * Filtering by single field:
         *
         *     store.filter("email", /\.com$/);
         *
         * Using multiple filters:
         *
         *     store.filter([
         *         {property: "email", value: /\.com$/},
         *         {filterFn: function(item) { return item.get("age") > 10; }}
         *     ]);
         *
         * Using Ext.util.Filter instances instead of config objects
         * (note that we need to specify the {@link Ext.util.Filter#root root} config option in this case):
         *
         *     store.filter([
         *         Ext.create('Ext.util.Filter', {property: "email", value: /\.com$/, root: 'data'}),
         *         Ext.create('Ext.util.Filter', {filterFn: function(item) { return item.get("age") > 10; }, root: 'data'})
         *     ]);
         *
         * When store is filtered, most of the methods for accessing store data will be working only
         * within the set of filtered records. Two notable exceptions are {@link #queryBy} and
         * {@link #getById}.
         *
         * @param {Object[]/Ext.util.Filter[]/String} [filters] The set of filters to apply to the data.
         * These are stored internally on the store, but the filtering itself is done on the Store's
         * {@link Ext.util.MixedCollection MixedCollection}. See MixedCollection's
         * {@link Ext.util.MixedCollection#filter filter} method for filter syntax.
         * Alternatively, pass in a property string.
         *
         * If no parameters are passed, the Store's existing filter set is applied.
         * @param {String} [value] value to filter by (only if using a property string as the first argument)
         */
        filter(filters?: any|Ext.util.Filter|string, value?: string);

        /**
         * Filters by a function. The specified function will be called for each
         * Record in this Store. If the function returns 'true' the Record is included,
         * otherwise it is filtered out.
         *
         * When store is filtered, most of the methods for accessing store data will be working only
         * within the set of filtered records. Two notable exceptions are {@link #queryBy} and
         * {@link #getById}.
         *
         * @param {Function} fn The function to be called. It will be passed the following parameters:
         *  @param {Ext.data.Model} fn.record The record to test for filtering. Access field values
         *  using {@link Ext.data.Model#get}.
         *  @param {Object} fn.id The ID of the Record passed.
         * @param {Object} [scope] The scope (this reference) in which the function is executed.
         * Defaults to this Store.
         */
        filterBy(fn: Function, scope?: any);

        /**
         * Finds the index of the first matching Record in this store by a specific field value.
         *
         * When store is filtered, finds records only within filter.
         *
         * **IMPORTANT
         *
         * If this store is {@link #buffered}, this can ONLY find records which happen to be cached in the page cache.
         * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
         * have not yet been purged from the cache.**
         *
         * @param {String} fieldName The name of the Record field to test.
         * @param {String/RegExp} value Either a string that the field value
         * should begin with, or a RegExp to test against the field.
         * @param {Number} [startIndex=0] The index to start searching at
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just the beginning
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison
         * @param {Boolean} [exactMatch=false] True to force exact match (^ and $ characters added to the regex).
         * @return {Number} The matched index or -1
         */
        find(fieldName: string, value: string|RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;

        /**
         * Find the index of the first matching Record in this Store by a function.
         * If the function returns 'true' it is considered a match.
         *
         * When store is filtered, finds records only within filter.
         *
         * **IMPORTANT
         *
         * If this store is {@link #buffered}, this can ONLY find records which happen to be cached in the page cache.
         * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
         * have not yet been purged from the cache.**
         *
         * @param {Function} fn The function to be called. It will be passed the following parameters:
         *  @param {Ext.data.Model} fn.record The record to test for filtering. Access field values
         *  using {@link Ext.data.Model#get}.
         *  @param {Object} fn.id The ID of the Record passed.
         * @param {Object} [scope] The scope (this reference) in which the function is executed.
         * Defaults to this Store.
         * @param {Number} [startIndex=0] The index to start searching at
         * @return {Number} The matched index or -1
         */
        findBy(fn: Function, scope?: any, startIndex?: number): number;

        /**
         * Finds the index of the first matching Record in this store by a specific field value.
         *
         * When store is filtered, finds records only within filter.
         *
         * **IMPORTANT
         *
         * If this store is {@link #buffered}, this can ONLY find records which happen to be cached in the page cache.
         * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
         * have not yet been purged from the cache.**
         *
         * @param {String} fieldName The name of the Record field to test.
         * @param {Object} value The value to match the field against.
         * @param {Number} [startIndex=0] The index to start searching at
         * @return {Number} The matched index or -1
         */
        findExact(fieldName: string, value: any, startIndex?: number): number;

        /**
         * Finds the first matching Record in this store by a specific field value.
         *
         * When store is filtered, finds records only within filter.
         *
         * **IMPORTANT
         *
         * If this store is {@link #buffered}, this can ONLY find records which happen to be cached in the page cache.
         * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
         * have not yet been purged from the cache.**
         *
         * @param {String} fieldName The name of the Record field to test.
         * @param {String/RegExp} value Either a string that the field value
         * should begin with, or a RegExp to test against the field.
         * @param {Number} [startIndex=0] The index to start searching at
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just the beginning
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison
         * @param {Boolean} [exactMatch=false] True to force exact match (^ and $ characters added to the regex).
         * @return {Ext.data.Model} The matched record or null
         */
        findRecord(fieldName: string, value: string|RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;

        /**
         * Convenience function for getting the first model instance in the store.
         *
         * When store is filtered, will return first item within the filter.
         *
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the first record being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Ext.data.Model/undefined} The first model instance in the store, or undefined
         */
        first(grouped?: boolean): Ext.data.Model;

        /**
         * Get the Record at the specified index.
         *
         * The index is effected by filtering.
         *
         * @param {Number} index The index of the Record to find.
         * @return {Ext.data.Model} The Record at the passed index. Returns undefined if not found.
         */
        getAt(index: number): Ext.data.Model;

        /**
         * Get the Record with the specified id.
         *
         * This method is not effected by filtering, lookup will be performed from all records
         * inside the store, filtered or not.
         *
         * @param {Mixed} id The id of the Record to find.
         * @return {Ext.data.Model} The Record with the passed id. Returns null if not found.
         */
        getById(id: any): Ext.data.Model;

        /**
         * Gets the number of records in store.
         *
         * If using paging, this may not be the total size of the dataset. If the data object
         * used by the Reader contains the dataset size, then the {@link #getTotalCount} function returns
         * the dataset size.  **Note**: see the Important note in {@link #method-load}.
         *
         * When store is filtered, it's the number of records matching the filter.
         *
         * @return {Number} The number of Records in the Store.
         */
        getCount(): number;

        /**
         * Returns an array containing the result of applying grouping to the records in this store.
         * See {@link #groupField}, {@link #groupDir} and {@link #getGroupString}. Example for a store
         * containing records with a color field:
         *
         *     var myStore = Ext.create('Ext.data.Store', {
         *         groupField: 'color',
         *         groupDir  : 'DESC'
         *     });
         *
         *     myStore.getGroups(); // returns:
         *     [
         *         {
         *             name: 'yellow',
         *             children: [
         *                 // all records where the color field is 'yellow'
         *             ]
         *         },
         *         {
         *             name: 'red',
         *             children: [
         *                 // all records where the color field is 'red'
         *             ]
         *         }
         *     ]
         *
         * Group contents are effected by filtering.
         *
         * @param {String} [groupName] Pass in an optional groupName argument to access a specific
         * group as defined by {@link #getGroupString}.
         * @return {Object/Object[]} The grouped data
         */
        getGroups(groupName?: string): any;

        /**
         * Returns the string to group on for a given model instance. The default implementation of this method returns
         * the model's {@link #groupField}, but this can be overridden to group by an arbitrary string. For example, to
         * group by the first letter of a model's 'name' field, use the following code:
         *
         *     Ext.create('Ext.data.Store', {
         *         groupDir: 'ASC',
         *         getGroupString: function(instance) {
         *             return instance.get('name')[0];
         *         }
         *     });
         *
         * @param {Ext.data.Model} instance The model instance
         * @return {String} The string to compare when forming groups
         */
        getGroupString(instance: Ext.data.Model): string;

        /**
         * Determines the page from a record index
         * @param {Number} index The record index
         * @return {Number} The page the record belongs to
         */
        getPageFromRecordIndex(index: number): number;

        /**
         * Gathers a range of Records between specified indices.
         *
         * If this store is {@link #buffered}, the indices are relative to the entire dataset, not the local record cache.
         *
         * If this store is {@link #buffered}, then the requested data range *may* not be immediately available, and will
         * be returned through a passed callback function.
         *
         * This method is affected by filtering.
         *
         * @param {Number} start The starting index. Defaults to zero for non {@link #buffered} Stores.
         * @param {Number} end The ending index. Defaults to the last Record for non {@link #buffered} Stores.
         * @param {Object} [options] Used when the Store is {@link #buffered] and the range may not be available synchronously.
         *  @param {Object} options.callback A function to call when the range becomes available.
         *  @param {Ext.data.Model[]} options.callback.range The requested range of records.
         *   @param {Number} options.callback.start The delivered start index.
         *   @param {Number} options.callback.end The delivered end index
         *   @param {Number} options.callback.options The passed options object.
         * @return {Ext.data.Model[]} An array of records **if the records are immediately available**. For {@link #buffered}
         * stores, you should pass the callback option **unless you know that the range will be present** - see {@link #rangeCached}.
         */
        getRange(start: number, end: number, options?: any): Ext.data.Model;

        /**
         * Returns the total number of {@link Ext.data.Model Model} instances that the {@link Ext.data.proxy.Proxy Proxy}
         * indicates exist. This will usually differ from {@link #getCount} when using paging - getCount returns the
         * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
         * could be loaded into the Store if the Store contained all data
         * @return {Number} The total number of Model instances available via the Proxy. 0 returned if
         * no value has been set via the reader.
         */
        getTotalCount(): number;

        /**
         * Groups data inside the store.
         * @param {String/Object[]} groupers Either a string name of one of the fields in this Store's
         * configured {@link Ext.data.Model Model}, or an Array of grouper configurations.
         * @param {String} [direction="ASC"] The overall direction to group the data by.
         */
        group(groupers: string|any, direction?: string);

        /**
         * Guarantee a specific range, this will load the store with a range (that
         * must be the 'pageSize' or smaller) and take care of any loading that may
         * be necessary.
         * @deprecated Use {@link #getRange}
         */
        guaranteeRange();

        /**
         * Get the index of the record within the store.
         *
         * When store is filtered, records outside of filter will not be found.
         *
         * @param {Ext.data.Model} record The Ext.data.Model object to find.
         * @return {Number} The index of the passed Record. Returns -1 if not found.
         */
        indexOf(record: Ext.data.Model): number;

        /**
         * Get the index within the store of the Record with the passed id.
         *
         * Like #indexOf, this method is effected by filtering.
         *
         * @param {String} id The id of the Record to find.
         * @return {Number} The index of the Record. Returns -1 if not found.
         */
        indexOfId(id: string): number;

        /**
         * Get the index within the entire dataset. From 0 to the totalCount.
         *
         * Like #indexOf, this method is effected by filtering.
         *
         * @param {Ext.data.Model} record The Ext.data.Model object to find.
         * @return {Number} The index of the passed Record. Returns -1 if not found.
         */
        indexOfTotal(record: Ext.data.Model): number;

        /**
         * Inserts Model instances into the Store at the given index and fires the {@link #event-add} event.
         * See also {@link #method-add}.
         *
         * @param {Number} index The start index at which to insert the passed Records.
         * @param {Ext.data.Model[]} records An Array of Ext.data.Model objects to add to the store.
         * @return {Ext.data.Model[]} records The added records
         */
        insert(index: number, records: Ext.data.Model): Ext.data.Model;

        /**
         * Returns 'true' if this store is currently filtered
         * @return {Boolean}
         */
        isFiltered(): boolean;

        /**
         * Checks if the store is currently grouped
         * @return {Boolean} 'true' if the store is grouped.
         */
        isGrouped(): boolean;

        /**
         * Convenience function for getting the last model instance in the store.
         *
         * When store is filtered, will return last item within the filter.
         *
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the last record being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Ext.data.Model/undefined} The last model instance in the store, or undefined
         */
        last(grouped?: boolean): Ext.data.Model;

        /**
         * Loads an array of data straight into the Store.
         *
         * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
         * processed by a reader). If your data requires processing to decode the data structure, use a
         * {@link Ext.data.proxy.Memory MemoryProxy} or {@link #loadRawData}.
         *
         * @param {Ext.data.Model[]/Object[]} data Array of data to load. Any non-model instances will be cast
         * into model instances first.
         * @param {Boolean} [append=false] 'true' to add the records to the existing records in the store, 'false'
         * to remove the old ones first.
         */
        loadData(data: Ext.data.Model|any, append?: boolean);

        /**
         * Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
         * load operation, passing in calculated 'start' and 'limit' params.
         * @param {Number} page The number of the page to load.
         * @param {Object} [options] See options for {@link #method-load}.
         */
        loadPage(page: number, options?: any);

        /**
         * Loads data via the bound Proxy's reader
         *
         * Use this method if you are attempting to load data and want to utilize the configured data reader.
         *
         * @param {Object[]} data The full JSON object you'd like to load into the Data store.
         * @param {Boolean} [append=false] 'true' to add the records to the existing records in the store, 'false'
         * to remove the old ones first.
         */
        loadRawData(data: any, append?: boolean);

        /**
         * Loads an array of {@link Ext.data.Model model} instances into the store, fires the datachanged event. This should only usually
         * be called internally when loading from the {@link Ext.data.proxy.Proxy Proxy}, when adding records manually use {@link #method-add} instead
         * @param {Ext.data.Model[]} records The array of records to load
         * @param {Boolean} [options.addRecords=false] Pass 'true' to add these records to the existing records, 'false' to remove the Store's existing records first.
         * @param {Number}  [options.start] Only used by buffered Stores. The index *within the overall dataset* of the first record in the array.
         */
        loadRecords(records: Ext.data.Model, options: any, options_addRecords?: boolean, options_start?: number);

        /**
         * Gets the maximum value in the store.
         *
         * When store is filtered, only items within the filter are aggregated.
         *
         * @param {String} field The field in each record
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the maximum in the group being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Object} The maximum value, if no items exist, undefined.
         */
        max(field: string, grouped?: boolean): any;

        /**
         * Gets the minimum value in the store.
         *
         * When store is filtered, only items within the filter are aggregated.
         *
         * @param {String} field The field in each record
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the minimum in the group being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Object} The minimum value, if no items exist, undefined.
         */
        min(field: string, grouped?: boolean): any;

        /**
         * Loads the next 'page' in the current data set
         * @param {Object} options See options for {@link #method-load}
         */
        nextPage(options: any);

        /**
         * Prefetches data into the store using its configured {@link #proxy}.
         * @param {Object} options (Optional) config object, passed into the Ext.data.Operation object before loading.
         * See {@link #method-load}
         */
        prefetch(options: any);

        /**
         * Prefetches a page of data.
         * @param {Number} page The page to prefetch
         * @param {Object} options (Optional) config object, passed into the Ext.data.Operation object before loading.
         * See {@link #method-load}
         */
        prefetchPage(page: number, options: any);

        /**
         * Ensures that the specified range of rows is present in the cache.
         *
         * Converts the row range to a page range and then only load pages which are not already
         * present in the page cache.
         */
        prefetchRange();

        /**
         * Loads the previous 'page' in the current data set
         * @param {Object} options See options for {@link #method-load}
         */
        previousPage(options: any);

        /**
         * Query all the cached records in this Store by name/value pair.
         * The parameters will be used to generated a filter function that is given
         * to the queryBy method.
         *
         * This method compliments queryBy by generating the query function automatically.
         *
         * @param {String} property The property to create the filter function for
         * @param {String/RegExp} value The string/regex to compare the property value to
         * @param {Boolean} [anyMatch=false] 'true' if we don't care if the filter value is not the full value.
         * @param {Boolean} [caseSensitive=false] 'true' to create a case-sensitive regex.
         * @param {Boolean} [exactMatch=false] 'true' to force exact match (^ and $ characters added to the regex).
         * Ignored if 'anyMatch' is 'true'.
         * @return {Ext.util.MixedCollection} Returns an Ext.util.MixedCollection of the matched records
         */
        query(property: string, value: string|RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.MixedCollection;

        /**
         * Query all the cached records in this Store using a filtering function. The specified function
         * will be called with each record in this Store. If the function returns 'true' the record is
         * included in the results.
         *
         * This method is not effected by filtering, it will always look from all records inside the store
         * no matter if filter is applied or not.
         *
         * @param {Function} fn The function to be called. It will be passed the following parameters:
         *  @param {Ext.data.Model} fn.record The record to test for filtering. Access field values
         *  using {@link Ext.data.Model#get}.
         *  @param {Object} fn.id The ID of the Record passed.
         * @param {Object} [scope] The scope (this reference) in which the function is executed
         * Defaults to this Store.
         * @return {Ext.util.MixedCollection} Returns an Ext.util.MixedCollection of the matched records
         */
        queryBy(fn: Function, scope?: any): Ext.util.MixedCollection;

        /**
         * {@link Ext.data.Model#reject Rejects} outstanding changes on all {@link #getModifiedRecords modified records}
         * and re-insert any records that were removed locally. Any phantom records will be removed.
         */
        rejectChanges();

        reload(options: any);

        /**
         * Removes the model instance(s) at the given index
         * @param {Number} index The record index
         * @param {Number} [count=1] The number of records to delete
         */
        removeAt(index: number, count?: number);

        /**
         * Removes an individual Filter from the current {@link #property-filters filter set} using the passed Filter/Filter id and
         * by default, applys the updated filter set to the Store's unfiltered dataset.
         *
         * @param {Mixed} toRemove The id of a Filter to remove from the filter set, or a Filter instance to remove.
         * @param {Boolean} [applyFilters=true] Pass as 'false' to remove the filter but not apply the updated filter set.
         *
         * If 'null' is passed, all anonymous Filters (Filters with no 'id' property) will be removed.
         */
        removeFilter(toRemove: any, applyFilters?: boolean);

        sort();

        /**
         * Sums the value of 'field' for each {@link Ext.data.Model record} in store
         * and returns the result.
         *
         * When store is filtered, only sums items within the filter.
         *
         * @param {String} field A field in each record
         * @param {Boolean} [grouped] True to perform the operation for each group
         * in the store. The value returned will be an object literal with the key being the group
         * name and the sum for that group being the value. The grouped parameter is only honored if
         * the store has a groupField.
         * @return {Number} The sum
         */
        sum(field: string, grouped?: boolean): number;

        /**
         * Fires before a prefetch occurs. Return 'false' to cancel.
         * @param {Ext.data.Operation} operation The associated operation.
         */
        beforeprefetch(that: Ext.data.Store, operation: Ext.data.Operation);

        /**
         * Fired whenever the filter set changes.
         * @param {Ext.data.Store} store The store.
         * @param {Ext.util.Filter[]} filters The array of Filter objects.
         */
        filterchange(store: Ext.data.Store, filters: Ext.util.Filter);

        /**
         * Fired whenever the grouping in the grid changes.
         * @param {Ext.data.Store} store The store.
         * @param {Ext.util.Grouper[]} groupers The array of Grouper objects.
         */
        groupchange(store: Ext.data.Store, groupers: Ext.util.Grouper);
    }

    /**
     * @docauthor Evan Trimboli <evan@sencha.com>
     *
     * Contains a collection of all stores that are created that have an identifier. An identifier can be assigned by
     * setting the {@link Ext.data.AbstractStore#storeId storeId} property. When a store is in the StoreManager, it can be
     * referred to via it's identifier:
     *
     *     Ext.create('Ext.data.Store', {
     *         model: 'SomeModel',
     *         storeId: 'myStore'
     *     });
     *
     *     var store = Ext.data.StoreManager.lookup('myStore');
     *
     * Also note that the {@link #lookup} method is aliased to {@link Ext#getStore} for convenience.
     *
     * If a store is registered with the StoreManager, you can also refer to the store by it's identifier when registering
     * it with any Component that consumes data from a store:
     *
     *     Ext.create('Ext.data.Store', {
     *         model: 'SomeModel',
     *         storeId: 'myStore'
     *     });
     *
     *     Ext.create('Ext.view.View', {
     *         store: 'myStore',
     *         // other configuration here
     *     });
     */
    export class StoreManager {
        /**
         * Creates new MixedCollection.
         * @param {Object} config A configuration object.
         *  @param {Boolean} [config.allowFunctions=false] Specify 'true' if the {@link #addAll}
         * function should add function references to the collection.
         *  @param {Function} [config.getKey] A function that can accept an item of the type(s) stored in this MixedCollection
         * and return the key value for that item.  This is used when available to look up the key on items that
         * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
         * equivalent to overriding the {@link #method-getKey} method.
         */
        constructor(config: Ext.util.MixedCollectionConfig);

        /**
         * Gets a registered Store by id
         * @param {String/Object} store The id of the Store, or a Store instance, or a store configuration
         * @return {Ext.data.Store}
         */
        static lookup(store: string|any): Ext.data.Store;

        /**
         * Registers one or more Stores with the StoreManager. You do not normally need to register stores manually. Any
         * store initialized with a {@link Ext.data.Store#storeId} will be auto-registered.
         * @param {Ext.data.Store...} stores Any number of Store instances
         */
        static register(stores: Ext.data.Store);

        /**
         * Unregisters one or more Stores with the StoreManager
         * @param {String/Object...} stores Any number of Store instances or ID-s
         */
        static unregister(stores: string[]|any[]);
    }

    /**
     * This class is used as a container for a series of nodes. The nodes themselves maintain
     * the relationship between parent/child. The tree itself acts as a manager. It gives functionality
     * to retrieve a node by its identifier: {@link #getNodeById}.
     *
     * The tree also relays events from any of it's child nodes, allowing them to be handled in a
     * centralized fashion. In general this class is not used directly, rather used internally
     * by other parts of the framework.
     */
    export class Tree extends Ext.Base {
        /**
         * The root node for this tree
         */
        root: any;

        /**
         * Creates new Tree object.
         * @param {Ext.data.NodeInterface} root (optional) The root node
         */
        constructor(root: Ext.data.NodeInterface);

        /**
         * Gets a node in this tree by its id.
         * @return {Ext.data.NodeInterface} The match node.
         */
        getNodeById(id: string): Ext.data.NodeInterface;

        /**
         * Returns the root node for this tree.
         * @return {Ext.data.NodeInterface}
         */
        getRootNode(): Ext.data.NodeInterface;

        /**
         * Removes the root node from this tree.
         * @return {Ext.data.NodeInterface} The root node
         */
        removeRootNode(): Ext.data.NodeInterface;

        /**
         * Sets the root node for this tree.
         * @return {Ext.data.NodeInterface} The root node
         */
        setRootNode(node: Ext.data.NodeInterface): Ext.data.NodeInterface;

        append();

        beforeappend();

        beforecollapse();

        beforeexpand();

        beforeinsert();

        beforemove();

        beforeremove();

        collapse();

        expand();

        insert();

        move();

        remove();

        /**
         * Fires whenever the root node is changed in the tree.
         * @param {Ext.data.Model} root The new root
         */
        rootchange(root: Ext.data.Model);

        sort();
    }

    /**
     * This class can be used as a base class from which to derived Models used in Trees.
     */
    export class TreeModel extends Ext.data.Model {
        /**
         * Creates new Model instance.
         * @param {Object} data An object containing keys corresponding to this model's fields, and their associated values
         */
        constructor(data: any);
    }

    interface TreeStoreConfig extends Ext.data.AbstractStoreConfig {
        /**
         * Remove previously existing child nodes before loading.
         *
         * Optional, Defaults to: true
         */
        clearOnLoad?: boolean;

        /**
         * If 'true', when a node is reloaded, any records in the {@link #removed} record collection that were previously descendants of the node being reloaded will be cleared from the {@link #removed} collection.
         * Only applicable if {@link #clearOnLoad} is 'true'.
         *
         * Optional, Defaults to: true
         */
        clearRemovedOnLoad?: boolean;

        /**
         * The default root id.
         *
         * Optional, Defaults to: "root"
         */
        defaultRootId?: string;

        /**
         * The root property to specify on the reader if one is not explicitly defined.
         *
         * Optional, Defaults to: "children"
         */
        defaultRootProperty?: string;

        /**
         * The default root text (if not specified)/
         *
         * Optional, Defaults to: "Root"
         */
        defaultRootText?: string;

        /**
         * Set to true to automatically prepend a leaf sorter.
         *
         * Optional, Defaults to: false
         */
        folderSort?: boolean;

        /**
         * The name of the parameter sent to the server which contains the identifier of the node.
         *
         * Optional, Defaults to: "node"
         */
        nodeParam?: string;

        /**
         * The root node for this store. For example:
         *
         *     root: {
         *         expanded: true,
         *         text: "My Root",
         *         children: [
         *             { text: "Child 1", leaf: true },
         *             { text: "Child 2", expanded: true, children: [
         *                 { text: "GrandChild", leaf: true }
         *             ] }
         *         ]
         *     }
         *
         * Setting the 'root' config option is the same as calling {@link #setRootNode}.
         */
        root?: Ext.data.Model|Ext.data.NodeInterface|any;
    }

    /**
     * The TreeStore is a store implementation that is backed by by an {@link Ext.data.Tree}.
     * It provides convenience methods for loading nodes, as well as the ability to use
     * the hierarchical tree structure combined with a store. This class is generally used
     * in conjunction with {@link Ext.tree.Panel}. This class also relays many events from
     * the Tree for convenience.
     *
     * # Using Models
     *
     * If no Model is specified, an implicit model will be created that implements {@link Ext.data.NodeInterface}.
     * The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
     * in the {@link Ext.data.NodeInterface} documentation.
     *
     * # Reading Nested Data
     *
     * For the tree to read nested data, the {@link Ext.data.reader.Reader} must be configured with a root property,
     * so the reader can find nested data for each node (if a root is not specified, it will default to
     * 'children'). This will tell the tree to look for any nested tree nodes by the same keyword, i.e., 'children'.
     * If a root is specified in the config make sure that any nested nodes with children have the same name.
     * Note that setting {@link #defaultRootProperty} accomplishes the same thing.
     */
    export class TreeStore extends Ext.data.AbstractStore implements Ext.data.TreeStoreConfig {
        /**
         * If we have no fields declare for the store, add some defaults.
         * These will be ignored if a model is explicitly specified.
         */
        fields: any;

        /**
         * Remove previously existing child nodes before loading.
         *
         * Optional, Defaults to: true
         */
        clearOnLoad: boolean;

        /**
         * If 'true', when a node is reloaded, any records in the {@link #removed} record collection that were previously descendants of the node being reloaded will be cleared from the {@link #removed} collection.
         * Only applicable if {@link #clearOnLoad} is 'true'.
         *
         * Optional, Defaults to: true
         */
        clearRemovedOnLoad: boolean;

        /**
         * The default root id.
         *
         * Optional, Defaults to: "root"
         */
        defaultRootId: string;

        /**
         * The root property to specify on the reader if one is not explicitly defined.
         *
         * Optional, Defaults to: "children"
         */
        defaultRootProperty: string;

        /**
         * The default root text (if not specified)/
         *
         * Optional, Defaults to: "Root"
         */
        defaultRootText: string;

        /**
         * Set to true to automatically prepend a leaf sorter.
         *
         * Optional, Defaults to: false
         */
        folderSort: boolean;

        /**
         * The name of the parameter sent to the server which contains the identifier of the node.
         *
         * Optional, Defaults to: "node"
         */
        nodeParam: string;

        /**
         * The root node for this store. For example:
         *
         *     root: {
         *         expanded: true,
         *         text: "My Root",
         *         children: [
         *             { text: "Child 1", leaf: true },
         *             { text: "Child 2", expanded: true, children: [
         *                 { text: "GrandChild", leaf: true }
         *             ] }
         *         ]
         *     }
         *
         * Setting the 'root' config option is the same as calling {@link #setRootNode}.
         */
        root: Ext.data.Model|Ext.data.NodeInterface|any;

        constructor(config: Ext.data.TreeStoreConfig);

        /**
         * Returns the record node by id
         * @return {Ext.data.NodeInterface}
         */
        getNodeById(): Ext.data.NodeInterface;

        /**
         * Returns the root node for this tree.
         * @return {Ext.data.NodeInterface}
         */
        getRootNode(): Ext.data.NodeInterface;

        removeAll();

        /**
         * Sets the root node for this store.  See also the {@link #root} config option.
         * @return {Ext.data.NodeInterface} The new root
         */
        setRootNode(root: Ext.data.Model|Ext.data.NodeInterface|any): Ext.data.NodeInterface;

        append();

        beforeappend();

        beforecollapse();

        beforeexpand();

        beforeinsert();

        beforemove();

        beforeremove();

        collapse();

        expand();

        insert();

        move();

        sort();
    }

    /**
     * This is a static class containing the system-supplied data types
     * which may be given to a {@link Ext.data.Field Field}.
     *
     * The properties in this class are used as type indicators in the
     * {@link Ext.data.Field Field} class, so to test whether a Field is
     * of a certain type, compare the {@link Ext.data.Field#type type}
     * property against properties of this class.
     *
     * Developers may add their own application-specific data types to
     * this class. Definition names must be UPPERCASE. Each type
     * definition must contain three properties:
     *
     *   - 'convert' : Function<br>
     *     A function to convert raw data values from a data block into
     *     the data to be stored in the Field. The function is passed the
     *     collowing parameters:
     *
     *       - **v** : Mixed<br>
     *         The data value as read by the Reader, if undefined will use
     *         the configured {@link Ext.data.Field#defaultValue defaultValue}.
     *       - **rec** : Mixed<br>
     *         The data object containing the row as read by the Reader.
     *         Depending on the Reader type, this could be an Array
     *         ({@link Ext.data.reader.Array ArrayReader}), an object
     *         ({@link Ext.data.reader.Json JsonReader}), or an XML element.
     *
     *   - 'sortType' : Function<br>
     *     A function to convert the stored data into comparable form, as
     *     defined by {@link Ext.data.SortTypes}.
     *
     *   - 'type' : String<br>
     *     A textual data type name.
     *
     * For example, to create a VELatLong field (See the Microsoft Bing
     * Mapping API) containing the latitude/longitude value of a datapoint
     * on a map from a JsonReader data block
     *
     * which contained the properties 'lat' and 'long', you would define a
     * new data type like this:
     *
     *     // Add a new Field data type which stores a VELatLong object in the Record.
     *     Ext.data.Types.VELATLONG = {
     *         convert: function(v, data) {
     *             return new VELatLong(data.lat, data.long);
     *         },
     *         sortType: function(v) {
     *             return v.Latitude;  // When sorting, order by latitude
     *         },
     *         type: 'VELatLong'
     *     };
     *
     * Then, when declaring a Model, use:
     *
     *     var types = Ext.data.Types; // allow shorthand type access
     *     Ext.define('Unit',
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             { name: 'unitName', mapping: 'UnitName' },
     *             { name: 'curSpeed', mapping: 'CurSpeed', type: types.INT },
     *             { name: 'latitude', mapping: 'lat', type: types.FLOAT },
     *             { name: 'longitude', mapping: 'long', type: types.FLOAT },
     *             { name: 'position', type: types.VELATLONG }
     *         ]
     *     });
     */
    export class Types {
        /**
         * This data type means that no conversion is applied to the raw data before it is placed into a Record.
         */
        static AUTO: any;

        /**
         * This data type means that the raw data is converted into a boolean before it is placed into
         * a Record. The string "true" and the number 1 are converted to boolean true.
         *
         * The synonym 'BOOLEAN' is equivalent.
         */
        static BOOL: any;

        /**
         * This data type means that the raw data is converted into a boolean before it is placed into
         * a Record. The string "true" and the number 1 are converted to boolean 'true'.
         *
         * The synonym 'BOOL' is equivalent.
         */
        static BOOLEAN: any;

        /**
         * This data type means that the raw data is converted into a Date before it is placed into a Record.
         * The date format is specified in the constructor of the {@link Ext.data.Field} to which this type is
         * being applied.
         */
        static DATE: any;

        /**
         * This data type means that the raw data is converted into a number before it is placed into a Record.
         *
         * The synonym 'NUMBER' is equivalent.
         */
        static FLOAT: any;

        /**
         * This data type means that the raw data is converted into an integer before it is placed into a Record.
         *
         * The synonym 'INTEGER' is equivalent.
         */
        static INT: any;

        /**
         * This data type means that the raw data is converted into an integer before it is placed into a Record.
         *
         * The synonym 'INT' is equivalent.
         */
        static INTEGER: any;

        /**
         * This data type means that the raw data is converted into a number before it is placed into a Record.
         *
         * The synonym 'FLOAT' is equivalent.
         */
        static NUMBER: any;

        /**
         * This data type means that the raw data is converted into a String before it is placed into a Record.
         */
        static STRING: any;

        /**
         * A regular expression for stripping non-numeric characters from a numeric value.
         * This should be overridden for localization.
         */
        static stripRe: RegExp;
    }

    interface UuidGeneratorConfig extends Ext.data.IdGeneratorConfig {
        /**
         * The Version of UUID. Supported values are:
         *
         *  * 1 : Time-based, "sequential" UUID.
         *  * 4 : Pseudo-random UUID.
         *
         * The default is 4.
         */
        version?: number;
    }

    /**
     * @extend Ext.data.IdGenerator
     * @author Don Griffin
     *
     * This class generates UUID's according to RFC 4122. This class has a default id property.
     * This means that a single instance is shared unless the id property is overridden. Thus,
     * two {@link Ext.data.Model} instances configured like the following share one generator:
     *
     *     Ext.define('MyApp.data.MyModelX', {
     *         extend: 'Ext.data.Model',
     *         idgen: 'uuid'
     *     });
     *
     *     Ext.define('MyApp.data.MyModelY', {
     *         extend: 'Ext.data.Model',
     *         idgen: 'uuid'
     *     });
     *
     * This allows all models using this class to share a commonly configured instance.
     *
     * # Using Version 1 ("Sequential") UUID's
     *
     * If a server can provide a proper timestamp and a "cryptographic quality random number"
     * (as described in RFC 4122), the shared instance can be configured as follows:
     *
     *     Ext.data.IdGenerator.get('uuid').reconfigure({
     *         version: 1,
     *         clockSeq: clock, // 14 random bits
     *         salt: salt,      // 48 secure random bits (the Node field)
     *         timestamp: ts    // timestamp per Section 4.1.4
     *     });
     *
     *     // or these values can be split into 32-bit chunks:
     *
     *     Ext.data.IdGenerator.get('uuid').reconfigure({
     *         version: 1,
     *         clockSeq: clock,
     *         salt: { lo: saltLow32, hi: saltHigh32 },
     *         timestamp: { lo: timestampLow32, hi: timestamptHigh32 }
     *     });
     *
     * This approach improves the generator's uniqueness by providing a valid timestamp and
     * higher quality random data. Version 1 UUID's should not be used unless this information
     * can be provided by a server and care should be taken to avoid caching of this data.
     *
     * See http://www.ietf.org/rfc/rfc4122.txt for details.
     */
    export class UuidGenerator extends Ext.data.IdGenerator implements Ext.data.UuidGeneratorConfig {
        /**
         * When created, this value is a 48-bit number. For computation, this value is split
         * into 32-bit parts and stored in an object with 'hi' and 'lo' properties.
         */
        salt: number|any;

        /**
         * When created, this value is a 60-bit number. For computation, this value is split
         * into 32-bit parts and stored in an object with 'hi' and 'lo' properties.
         */
        timestamp: number|any;

        /**
         * The Version of UUID. Supported values are:
         *
         *  * 1 : Time-based, "sequential" UUID.
         *  * 4 : Pseudo-random UUID.
         *
         * The default is 4.
         */
        version: number;

        /**
         * Initializes a new instance.
         * @param {Object} config (optional) Configuration object to be applied to the new instance.
         */
        constructor(config: Ext.data.IdGeneratorConfig);

        /**
         * Reconfigures this generator given new config properties.
         */
        reconfigure();
    }

    /**
     * @author Ed Spencer
     *
     * This singleton contains a set of validation functions that can be used to validate any type of data. They are most
     * often used in {@link Ext.data.Model Models}, where they are automatically set up and executed.
     */
    export class validations {
        /**
         * The default error message used when an email validation fails
         */
        static emailMessage: string;

        /**
         * The regular expression used to validate email addresses
         */
        static emailRe: RegExp;

        /**
         * The default error message used when an exclusion validation fails.
         */
        static exclusionMessage: string;

        /**
         * The default error message used when a format validation fails.
         */
        static formatMessage: string;

        /**
         * The default error message used when an inclusion validation fails.
         */
        static inclusionMessage: string;

        /**
         * The default error message used when a length validation fails.
         */
        static lengthMessage: string;

        /**
         * The default error message used when a presence validation fails.
         */
        static presenceMessage: string;

        /**
         * Validates that an email string is in the correct format
         * @param {Object} config Config object
         * @param {String} email The email address
         * @return {Boolean} True if the value passes validation
         */
        static email(config: any, email: string): boolean;

        /**
         * Validates that the given value is not present in the configured 'list'.
         * For example:
         *
         *     validations: [{type: 'exclusion', field: 'username', list: ['Admin', 'Operator']}]
         *
         * @param {Object} config Config object
         * @param {String} value The value to validate
         * @return {Boolean} True if the value is not present in the list
         */
        static exclusion(config: any, value: string): boolean;

        /**
         * Returns true if the given value passes validation against the configured 'matcher' regex.
         * For example:
         *
         *     validations: [{type: 'format', field: 'username', matcher: /([a-z]+)[0-9]{2,3}/}]
         *
         * @param {Object} config Config object
         * @param {String} value The value to validate
         * @return {Boolean} True if the value passes the format validation
         */
        static format(config: any, value: string): boolean;

        /**
         * Validates that the given value is present in the configured 'list'.
         * For example:
         *
         *     validations: [{type: 'inclusion', field: 'gender', list: ['Male', 'Female']}]
         *
         * @param {Object} config Config object
         * @param {String} value The value to validate
         * @return {Boolean} True if the value is present in the list
         */
        static inclusion(config: any, value: string): boolean;

        /**
         * Returns true if the given value is between the configured min and max values.
         * For example:
         *
         *     validations: [{type: 'length', field: 'name', min: 2}]
         *
         * @param {Object} config Config object
         * @param {String} value The value to validate
         * @return {Boolean} True if the value passes validation
         */
        static length(config: any, value: string): boolean;

        /**
         * Validates that the given value is present.
         * For example:
         *
         *     validations: [{type: 'presence', field: 'age'}]
         *
         * @param {Object} config Config object
         * @param {Object} value The value to validate
         * @return {Boolean} True if validation passed
         */
        static presence(config: any, value: any): boolean;
    }

    /**
     * @author Ed Spencer
     * <p>Small helper class to make creating {@link Ext.data.Store}s from XML data easier.
     * A XmlStore will be automatically configured with a {@link Ext.data.reader.Xml}.</p>
     * <p>A store configuration would be something like:<pre><code>
     var store = new Ext.data.XmlStore({
     // store configs
     storeId: 'myStore',
     url: 'sheldon.xml', // automatically configures a HttpProxy
     // reader configs
     record: 'Item', // records will have an "Item" tag
     idPath: 'ASIN',
     totalRecords: '@TotalResults'
     fields: [
     // set up the fields mapping into the xml doc
     // The first needs mapping, the others are very basic
     {name: 'Author', mapping: 'ItemAttributes > Author'},
     'Title', 'Manufacturer', 'ProductGroup'
     ]
     });
     * </code></pre></p>
     * <p>This store is configured to consume a returned object of the form:<pre><code>
     &#60?xml version="1.0" encoding="UTF-8"?>
     &#60ItemSearchResponse xmlns="http://webservices.amazon.com/AWSECommerceService/2009-05-15">
     &#60Items>
     &#60Request>
     &#60IsValid>True&#60/IsValid>
     &#60ItemSearchRequest>
     &#60Author>Sidney Sheldon&#60/Author>
     &#60SearchIndex>Books&#60/SearchIndex>
     &#60/ItemSearchRequest>
     &#60/Request>
     &#60TotalResults>203&#60/TotalResults>
     &#60TotalPages>21&#60/TotalPages>
     &#60Item>
     &#60ASIN>0446355453&#60/ASIN>
     &#60DetailPageURL>
     http://www.amazon.com/
     &#60/DetailPageURL>
     &#60ItemAttributes>
     &#60Author>Sidney Sheldon&#60/Author>
     &#60Manufacturer>Warner Books&#60/Manufacturer>
     &#60ProductGroup>Book&#60/ProductGroup>
     &#60Title>Master of the Game&#60/Title>
     &#60/ItemAttributes>
     &#60/Item>
     &#60/Items>
     &#60/ItemSearchResponse>
     * </code></pre>
     * An object literal of this form could also be used as the {@link #cfg-data} config option.</p>
     * <p><b>Note:</b> This class accepts all of the configuration options of
     * <b>{@link Ext.data.reader.Xml XmlReader}</b>.</p>
     */
    export class XmlStore extends Ext.data.Store {
        constructor(config: any);
    }
}

declare module Ext.data.association {
    interface AssociationConfig {
        /**
         * The string name of the model that is being associated with.
         *
         * **NB!** This config is required when instantiating the Association directly.
         * When defining the association as a config object inside Model, the #model
         * configuration will shadow this config.
         */
        associatedModel?: string;

        /**
         * The name of the property in the data to read the association from. Defaults to the name of the associated model.
         */
        associationKey?: string;

        /**
         * The string name of the model that is being associated with.
         *
         * This config option is to be used when defining the association as a config
         * object within Model.  The value is then mapped to #associatedModel when
         * Association is instantiated inside Model.
         */
        model?: string;

        /**
         * The string name of the model that owns the association.
         *
         * **NB!** This config is required when instantiating the Association directly.
         * However, it cannot be used at all when defining the association as a config
         * object inside Model, because the name of the model itself will be supplied
         * automatically as the value of this config.
         */
        ownerModel?: string;

        /**
         * The name of the primary key on the associated model. In general this will be the
         * {@link Ext.data.Model#idProperty} of the Model.
         */
        primaryKey?: string;

        /**
         * A special reader to read associated data
         */
        reader?: Ext.data.reader.Reader;
    }

    /**
     * @author Ed Spencer
     *
     * Associations enable you to express relationships between different {@link Ext.data.Model Models}. Let's say we're
     * writing an ecommerce system where Users can make Orders - there's a relationship between these Models that we can
     * express like this:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email'],
     *
     *         hasMany: {model: 'Order', name: 'orders'}
     *     });
     *
     *     Ext.define('Order', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'user_id', 'status', 'price'],
     *
     *         belongsTo: 'User'
     *     });
     *
     * We've set up two models - User and Order - and told them about each other. You can set up as many associations on
     * each Model as you need using the two default types - {@link Ext.data.HasManyAssociation hasMany} and {@link
     * Ext.data.BelongsToAssociation belongsTo}. There's much more detail on the usage of each of those inside their
     * documentation pages. If you're not familiar with Models already, {@link Ext.data.Model there is plenty on those too}.
     *
     * **Further Reading**
     *
     *   - {@link Ext.data.association.HasMany hasMany associations}
     *   - {@link Ext.data.association.BelongsTo belongsTo associations}
     *   - {@link Ext.data.association.HasOne hasOne associations}
     *   - {@link Ext.data.Model using Models}
     *
     * # Self association models
     *
     * We can also have models that create parent/child associations between the same type. Below is an example, where
     * groups can be nested inside other groups:
     *
     *     // Server Data
     *     {
     *         "groups": {
     *             "id": 10,
     *             "parent_id": 100,
     *             "name": "Main Group",
     *             "parent_group": {
     *                 "id": 100,
     *                 "parent_id": null,
     *                 "name": "Parent Group"
     *             },
     *             "nested" : {
     *                 "child_groups": [{
     *                     "id": 2,
     *                     "parent_id": 10,
     *                     "name": "Child Group 1"
     *                 },{
     *                     "id": 3,
     *                     "parent_id": 10,
     *                     "name": "Child Group 2"
     *                 },{
     *                     "id": 4,
     *                     "parent_id": 10,
     *                     "name": "Child Group 3"
     *                 }]
     *             }
     *         }
     *     }
     *
     *     // Client code
     *     Ext.define('Group', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'parent_id', 'name'],
     *         proxy: {
     *             type: 'ajax',
     *             url: 'data.json',
     *             reader: {
     *                 type: 'json',
     *                 root: 'groups'
     *             }
     *         },
     *         associations: [{
     *             type: 'hasMany',
     *             model: 'Group',
     *             primaryKey: 'id',
     *             foreignKey: 'parent_id',
     *             autoLoad: true,
     *             associationKey: 'nested.child_groups' // read child data from nested.child_groups
     *         }, {
     *             type: 'belongsTo',
     *             model: 'Group',
     *             primaryKey: 'id',
     *             foreignKey: 'parent_id',
     *             associationKey: 'parent_group' // read parent data from parent_group
     *         }]
     *     });
     *
     *     Ext.onReady(function(){
     *
     *         Group.load(10, {
     *             success: function(group){
     *                 console.log(group.getGroup().get('name'));
     *
     *                 group.groups().each(function(rec){
     *                     console.log(rec.get('name'));
     *                 });
     *             }
     *         });
     *
     *     });
     */
    export class Association extends Ext.Base implements Ext.data.association.AssociationConfig {
        /**
         * The name of the model is on the other end of the association (e.g. if a User model hasMany Orders, this is
         * 'Order')
         */
        associatedName: string;

        /**
         * The name of the model that 'owns' the association
         */
        ownerName: string;

        /**
         * The string name of the model that is being associated with.
         *
         * **NB!** This config is required when instantiating the Association directly.
         * When defining the association as a config object inside Model, the #model
         * configuration will shadow this config.
         */
        associatedModel: string;

        /**
         * The name of the property in the data to read the association from. Defaults to the name of the associated model.
         */
        associationKey: string;

        /**
         * The string name of the model that is being associated with.
         *
         * This config option is to be used when defining the association as a config
         * object within Model.  The value is then mapped to #associatedModel when
         * Association is instantiated inside Model.
         */
        model: string;

        /**
         * The string name of the model that owns the association.
         *
         * **NB!** This config is required when instantiating the Association directly.
         * However, it cannot be used at all when defining the association as a config
         * object inside Model, because the name of the model itself will be supplied
         * automatically as the value of this config.
         */
        ownerModel: string;

        /**
         * The name of the primary key on the associated model. In general this will be the
         * {@link Ext.data.Model#idProperty} of the Model.
         */
        primaryKey: string;

        /**
         * A special reader to read associated data
         */
        reader: Ext.data.reader.Reader;

        /**
         * Creates the Association object.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.association.AssociationConfig);

        /**
         * Get a specialized reader for reading associated data
         * @return {Ext.data.reader.Reader} The reader, null if not supplied
         */
        getReader(): Ext.data.reader.Reader;
    }

    interface BelongsToConfig extends Ext.data.association.AssociationConfig {
        /**
         * The name of the foreign key on the owner model that links it to the associated
         * model. Defaults to the lowercased name of the associated model plus "_id", e.g. an association with a
         * model called Product would set up a product_id foreign key.
         *
         *     Ext.define('Order', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'date'],
         *         hasMany: 'Product'
         *     });
         *
         *     Ext.define('Product', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'order_id'], // refers to the id of the order that this product belongs to
         *         belongsTo: 'Order'
         *     });
         *     var product = new Product({
         *         id: 1,
         *         name: 'Product 1',
         *         order_id: 22
         *     }, 1);
         *     product.getOrder(); // Will make a call to the server asking for order_id 22
         */
        foreignKey?: string;

        /**
         * The name of the getter function that will be added to the local model's prototype.
         * Defaults to 'get' + the name of the foreign model, e.g. getCategory
         */
        getterName?: string;

        /**
         * The name of the setter function that will be added to the local model's prototype.
         * Defaults to 'set' + the name of the foreign model, e.g. setCategory
         */
        setterName?: string;

        /**
         * The type configuration can be used when creating associations using a configuration object.
         * Use 'belongsTo' to create a BelongsTo association.
         *
         *     associations: [{
         *         type: 'belongsTo',
         *         model: 'User'
         *     }]
         */
        type?: string;
    }

    /**
     * @author Ed Spencer
     *
     * Represents a many to one association with another model. The owner model is expected to have
     * a foreign key which references the primary key of the associated model:
     *
     *     Ext.define('Category', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             { name: 'id',   type: 'int' },
     *             { name: 'name', type: 'string' }
     *         ]
     *     });
     *
     *     Ext.define('Product', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             { name: 'id',          type: 'int' },
     *             { name: 'category_id', type: 'int' },
     *             { name: 'name',        type: 'string' }
     *         ],
     *         // we can use the belongsTo shortcut on the model to create a belongsTo association
     *         associations: [
     *             { type: 'belongsTo', model: 'Category' }
     *         ]
     *     });
     *
     * In the example above we have created models for Products and Categories, and linked them together
     * by saying that each Product belongs to a Category. This automatically links each Product to a Category
     * based on the Product's category_id, and provides new functions on the Product model:
     *
     * ## Generated getter function
     *
     * The first function that is added to the owner model is a getter function:
     *
     *     var product = new Product({
     *         id: 100,
     *         category_id: 20,
     *         name: 'Sneakers'
     *     });
     *
     *     product.getCategory(function(category, operation) {
     *         // do something with the category object
     *         alert(category.get('id')); // alerts 20
     *     }, this);
     *
     * The getCategory function was created on the Product model when we defined the association. This uses the
     * Category's configured {@link Ext.data.proxy.Proxy proxy} to load the Category asynchronously, calling the provided
     * callback when it has loaded.
     *
     * The new getCategory function will also accept an object containing success, failure and callback properties
     * - callback will always be called, success will only be called if the associated model was loaded successfully
     * and failure will only be called if the associatied model could not be loaded:
     *
     *     product.getCategory({
     *         reload: true, // force a reload if the owner model is already cached
     *         callback: function(category, operation) {}, // a function that will always be called
     *         success : function(category, operation) {}, // a function that will only be called if the load succeeded
     *         failure : function(category, operation) {}, // a function that will only be called if the load did not succeed
     *         scope   : this // optionally pass in a scope object to execute the callbacks in
     *     });
     *
     * In each case above the callbacks are called with two arguments - the associated model instance and the
     * {@link Ext.data.Operation operation} object that was executed to load that instance. The Operation object is
     * useful when the instance could not be loaded.
     *
     * Once the getter has been called on the model, it will be cached if the getter is called a second time. To
     * force the model to reload, specify reload: true in the options object.
     *
     * ## Generated setter function
     *
     * The second generated function sets the associated model instance - if only a single argument is passed to
     * the setter then the following two calls are identical:
     *
     *     // this call...
     *     product.setCategory(10);
     *
     *     // is equivalent to this call:
     *     product.set('category_id', 10);
     *
     * An instance of the owner model can also be passed as a parameter.
     *
     * If we pass in a second argument, the model will be automatically saved and the second argument passed to
     * the owner model's {@link Ext.data.Model#save save} method:
     *
     *     product.setCategory(10, function(product, operation) {
     *         // the product has been saved
     *         alert(product.get('category_id')); //now alerts 10
     *     });
     *
     *     //alternative syntax:
     *     product.setCategory(10, {
     *         callback: function(product, operation), // a function that will always be called
     *         success : function(product, operation), // a function that will only be called if the load succeeded
     *         failure : function(product, operation), // a function that will only be called if the load did not succeed
     *         scope   : this //optionally pass in a scope object to execute the callbacks in
     *     })
     *
     * ## Customisation
     *
     * Associations reflect on the models they are linking to automatically set up properties such as the
     * {@link #primaryKey} and {@link #foreignKey}. These can alternatively be specified:
     *
     *     Ext.define('Product', {
     *         fields: [...],
     *
     *         associations: [
     *             { type: 'belongsTo', model: 'Category', primaryKey: 'unique_id', foreignKey: 'cat_id' }
     *         ]
     *     });
     *
     * Here we replaced the default primary key (defaults to 'id') and foreign key (calculated as 'category_id')
     * with our own settings. Usually this will not be needed.
     */
    export class BelongsTo extends Ext.data.association.Association implements Ext.data.association.BelongsToConfig {
        /**
         * The name of the foreign key on the owner model that links it to the associated
         * model. Defaults to the lowercased name of the associated model plus "_id", e.g. an association with a
         * model called Product would set up a product_id foreign key.
         *
         *     Ext.define('Order', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'date'],
         *         hasMany: 'Product'
         *     });
         *
         *     Ext.define('Product', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'order_id'], // refers to the id of the order that this product belongs to
         *         belongsTo: 'Order'
         *     });
         *     var product = new Product({
         *         id: 1,
         *         name: 'Product 1',
         *         order_id: 22
         *     }, 1);
         *     product.getOrder(); // Will make a call to the server asking for order_id 22
         */
        foreignKey: string;

        /**
         * The name of the getter function that will be added to the local model's prototype.
         * Defaults to 'get' + the name of the foreign model, e.g. getCategory
         */
        getterName: string;

        /**
         * The name of the setter function that will be added to the local model's prototype.
         * Defaults to 'set' + the name of the foreign model, e.g. setCategory
         */
        setterName: string;

        /**
         * The type configuration can be used when creating associations using a configuration object.
         * Use 'belongsTo' to create a BelongsTo association.
         *
         *     associations: [{
         *         type: 'belongsTo',
         *         model: 'User'
         *     }]
         */
        type: string;

        /**
         * Creates the Association object.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.association.AssociationConfig);
    }

    interface HasManyConfig extends Ext.data.association.AssociationConfig {
        /**
         * True to automatically load the related store from a remote source when instantiated.
         * Defaults to <tt>false</tt>.
         */
        autoLoad?: boolean;

        /**
         * Optionally overrides the default filter that is set up on the associated Store. If
         * this is not set, a filter is automatically created which filters the association based on the configured
         * {@link #foreignKey}. See intro docs for more details. Defaults to undefined
         */
        filterProperty?: string;

        /**
         * The name of the foreign key on the associated model that links it to the owner
         * model. Defaults to the lowercased name of the owner model plus "_id", e.g. an association with a where a
         * model called Group hasMany Users would create 'group_id' as the foreign key. When the remote store is loaded,
         * the store is automatically filtered so that only records with a matching foreign key are included in the
         * resulting child store. This can be overridden by specifying the {@link #filterProperty}.
         * <pre><code>
         Ext.define('Group', {
         extend: 'Ext.data.Model',
         fields: ['id', 'name'],
         hasMany: 'User'
         });
         Ext.define('User', {
         extend: 'Ext.data.Model',
         fields: ['id', 'name', 'group_id'], // refers to the id of the group that this user belongs to
         belongsTo: 'Group'
         });
         * </code></pre>
         */
        foreignKey?: string;

        /**
         * The name of the function to create on the owner model to retrieve the child store.
         * If not specified, the pluralized name of the child model is used.
         * <pre><code>
         // This will create a users() method on any Group model instance
         Ext.define('Group', {
         extend: 'Ext.data.Model',
         fields: ['id', 'name'],
         hasMany: 'User'
         });
         var group = new Group();
         console.log(group.users());
         // The method to retrieve the users will now be getUserList
         Ext.define('Group', {
         extend: 'Ext.data.Model',
         fields: ['id', 'name'],
         hasMany: {model: 'User', name: 'getUserList'}
         });
         var group = new Group();
         console.log(group.getUserList());
         * </code></pre>
         */
        name?: string;

        /**
         * Optional configuration object that will be passed to the generated Store. Defaults to
         * undefined.
         */
        storeConfig?: any;

        /**
         * The type configuration can be used when creating associations using a configuration object.
         * Use 'hasMany' to create a HasMany association
         * <pre><code>
         associations: [{
         type: 'hasMany',
         model: 'User'
         }]
         * </code></pre>
         */
        type?: string;
    }

    /**
     * @author Ed Spencer
     *
     * <p>Represents a one-to-many relationship between two models. Usually created indirectly via a model definition:</p>
     *
     <pre><code>
     Ext.define('Product', {
     extend: 'Ext.data.Model',
     fields: [
     {name: 'id',      type: 'int'},
     {name: 'user_id', type: 'int'},
     {name: 'name',    type: 'string'}
     ]
     });
     Ext.define('User', {
     extend: 'Ext.data.Model',
     fields: [
     {name: 'id',   type: 'int'},
     {name: 'name', type: 'string'}
     ],
     // we can use the hasMany shortcut on the model to create a hasMany association
     hasMany: {model: 'Product', name: 'products'}
     });
     </code></pre>
     *
     * <p>Above we created Product and User models, and linked them by saying that a User hasMany Products. This gives
     * us a new function on every User instance, in this case the function is called 'products' because that is the name
     * we specified in the association configuration above.</p>
     *
     * <p>This new function returns a specialized {@link Ext.data.Store Store} which is automatically filtered to load
     * only Products for the given model instance:</p>
     *
     <pre><code>
     //first, we load up a User with id of 1
     var user = Ext.create('User', {id: 1, name: 'Ed'});
     //the user.products function was created automatically by the association and returns a {@link Ext.data.Store Store}
     //the created store is automatically scoped to the set of Products for the User with id of 1
     var products = user.products();
     //we still have all of the usual Store functions, for example it's easy to add a Product for this User
     products.add({
     name: 'Another Product'
     });
     //saves the changes to the store - this automatically sets the new Product's user_id to 1 before saving
     products.sync();
     </code></pre>
     *
     * <p>The new Store is only instantiated the first time you call products() to conserve memory and processing time,
     * though calling products() a second time returns the same store instance.</p>
     *
     * <p><u>Custom filtering</u></p>
     *
     * <p>The Store is automatically furnished with a filter - by default this filter tells the store to only return
     * records where the associated model's foreign key matches the owner model's primary key. For example, if a User
     * with ID = 100 hasMany Products, the filter loads only Products with user_id == 100.</p>
     *
     * <p>Sometimes we want to filter by another field - for example in the case of a Twitter search application we may
     * have models for Search and Tweet:</p>
     *
     <pre><code>
     Ext.define('Search', {
     extend: 'Ext.data.Model',
     fields: [
     'id', 'query'
     ],
     hasMany: {
     model: 'Tweet',
     name : 'tweets',
     filterProperty: 'query'
     }
     });
     Ext.define('Tweet', {
     extend: 'Ext.data.Model',
     fields: [
     'id', 'text', 'from_user'
     ]
     });
     //returns a Store filtered by the filterProperty
     var store = new Search({query: 'Sencha Touch'}).tweets();
     </code></pre>
     *
     * <p>The tweets association above is filtered by the query property by setting the {@link #filterProperty}, and is
     * equivalent to this:</p>
     *
     <pre><code>
     var store = Ext.create('Ext.data.Store', {
     model: 'Tweet',
     filters: [
     {
     property: 'query',
     value   : 'Sencha Touch'
     }
     ]
     });
     </code></pre>
     */
    export class HasMany extends Ext.data.association.Association implements Ext.data.association.HasManyConfig {
        /**
         * True to automatically load the related store from a remote source when instantiated.
         * Defaults to <tt>false</tt>.
         */
        autoLoad: boolean;

        /**
         * Optionally overrides the default filter that is set up on the associated Store. If
         * this is not set, a filter is automatically created which filters the association based on the configured
         * {@link #foreignKey}. See intro docs for more details. Defaults to undefined
         */
        filterProperty: string;

        /**
         * The name of the foreign key on the associated model that links it to the owner
         * model. Defaults to the lowercased name of the owner model plus "_id", e.g. an association with a where a
         * model called Group hasMany Users would create 'group_id' as the foreign key. When the remote store is loaded,
         * the store is automatically filtered so that only records with a matching foreign key are included in the
         * resulting child store. This can be overridden by specifying the {@link #filterProperty}.
         * <pre><code>
         Ext.define('Group', {
         extend: 'Ext.data.Model',
         fields: ['id', 'name'],
         hasMany: 'User'
         });
         Ext.define('User', {
         extend: 'Ext.data.Model',
         fields: ['id', 'name', 'group_id'], // refers to the id of the group that this user belongs to
         belongsTo: 'Group'
         });
         * </code></pre>
         */
        foreignKey: string;

        /**
         * The name of the function to create on the owner model to retrieve the child store.
         * If not specified, the pluralized name of the child model is used.
         * <pre><code>
         // This will create a users() method on any Group model instance
         Ext.define('Group', {
         extend: 'Ext.data.Model',
         fields: ['id', 'name'],
         hasMany: 'User'
         });
         var group = new Group();
         console.log(group.users());
         // The method to retrieve the users will now be getUserList
         Ext.define('Group', {
         extend: 'Ext.data.Model',
         fields: ['id', 'name'],
         hasMany: {model: 'User', name: 'getUserList'}
         });
         var group = new Group();
         console.log(group.getUserList());
         * </code></pre>
         */
        name: string;

        /**
         * Optional configuration object that will be passed to the generated Store. Defaults to
         * undefined.
         */
        storeConfig: any;

        /**
         * The type configuration can be used when creating associations using a configuration object.
         * Use 'hasMany' to create a HasMany association
         * <pre><code>
         associations: [{
         type: 'hasMany',
         model: 'User'
         }]
         * </code></pre>
         */
        type: string;

        /**
         * Creates the Association object.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.association.AssociationConfig);
    }

    interface HasOneConfig extends Ext.data.association.AssociationConfig {
        /**
         * The name of the foreign key on the owner model that links it to the associated
         * model. Defaults to the lowercased name of the associated model plus "_id", e.g. an association with a
         * model called Person would set up a address_id foreign key.
         *
         *     Ext.define('Person', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'address_id'], // refers to the id of the address object
         *         hasOne: 'Address'
         *     });
         *
         *     Ext.define('Address', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'number', 'street', 'city', 'zip'],
         *         belongsTo: 'Person'
         *     });
         *     var Person = new Person({
         *         id: 1,
         *         name: 'John Smith',
         *         address_id: 13
         *     }, 1);
         *     person.getAddress(); // Will make a call to the server asking for address_id 13
         */
        foreignKey?: string;

        /**
         * The name of the getter function that will be added to the local model's prototype.
         * Defaults to 'get' + the name of the foreign model, e.g. getAddress
         */
        getterName?: string;

        /**
         * The name of the setter function that will be added to the local model's prototype.
         * Defaults to 'set' + the name of the foreign model, e.g. setAddress
         */
        setterName?: string;

        /**
         * The type configuration can be used when creating associations using a configuration object.
         * Use 'hasOne' to create a HasOne association.
         *
         *     associations: [{
         *         type: 'hasOne',
         *         model: 'Address'
         *     }]
         */
        type?: string;
    }

    /**
     * Represents a one to one association with another model. The owner model is expected to have
     * a foreign key which references the primary key of the associated model:
     *
     *     Ext.define('Address', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             { name: 'id',          type: 'int' },
     *             { name: 'number', type: 'string' },
     *             { name: 'street', type: 'string' },
     *             { name: 'city', type: 'string' },
     *             { name: 'zip', type: 'string' },
     *         ]
     *     });
     *
     *     Ext.define('Person', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             { name: 'id',   type: 'int' },
     *             { name: 'name', type: 'string' },
     *             { name: 'address_id', type: 'int'}
     *         ],
     *         // we can use the hasOne shortcut on the model to create a hasOne association
     *         associations: [{ type: 'hasOne', model: 'Address' }]
     *     });
     *
     * In the example above we have created models for People and Addresses, and linked them together
     * by saying that each Person has a single Address. This automatically links each Person to an Address
     * based on the Persons address_id, and provides new functions on the Person model:
     *
     * ## Generated getter function
     *
     * The first function that is added to the owner model is a getter function:
     *
     *     var person = new Person({
     *         id: 100,
     *         address_id: 20,
     *         name: 'John Smith'
     *     });
     *
     *     person.getAddress(function(address, operation) {
     *         // do something with the address object
     *         alert(address.get('id')); // alerts 20
     *     }, this);
     *
     * The getAddress function was created on the Person model when we defined the association. This uses the
     * Persons configured {@link Ext.data.proxy.Proxy proxy} to load the Address asynchronously, calling the provided
     * callback when it has loaded.
     *
     * The new getAddress function will also accept an object containing success, failure and callback properties
     * - callback will always be called, success will only be called if the associated model was loaded successfully
     * and failure will only be called if the associatied model could not be loaded:
     *
     *     person.getAddress({
     *         reload: true, // force a reload if the owner model is already cached
     *         callback: function(address, operation) {}, // a function that will always be called
     *         success : function(address, operation) {}, // a function that will only be called if the load succeeded
     *         failure : function(address, operation) {}, // a function that will only be called if the load did not succeed
     *         scope   : this // optionally pass in a scope object to execute the callbacks in
     *     });
     *
     * In each case above the callbacks are called with two arguments - the associated model instance and the
     * {@link Ext.data.Operation operation} object that was executed to load that instance. The Operation object is
     * useful when the instance could not be loaded.
     *
     * Once the getter has been called on the model, it will be cached if the getter is called a second time. To
     * force the model to reload, specify reload: true in the options object.
     *
     * ## Generated setter function
     *
     * The second generated function sets the associated model instance - if only a single argument is passed to
     * the setter then the following two calls are identical:
     *
     *     // this call...
     *     person.setAddress(10);
     *
     *     // is equivalent to this call:
     *     person.set('address_id', 10);
     *
     * An instance of the owner model can also be passed as a parameter.
     *
     * If we pass in a second argument, the model will be automatically saved and the second argument passed to
     * the owner model's {@link Ext.data.Model#save save} method:
     *
     *     person.setAddress(10, function(address, operation) {
     *         // the address has been saved
     *         alert(address.get('address_id')); //now alerts 10
     *     });
     *
     *     //alternative syntax:
     *     person.setAddress(10, {
     *         callback: function(address, operation), // a function that will always be called
     *         success : function(address, operation), // a function that will only be called if the load succeeded
     *         failure : function(address, operation), // a function that will only be called if the load did not succeed
     *         scope   : this //optionally pass in a scope object to execute the callbacks in
     *     })
     *
     * ## Customisation
     *
     * Associations reflect on the models they are linking to automatically set up properties such as the
     * {@link #primaryKey} and {@link #foreignKey}. These can alternatively be specified:
     *
     *     Ext.define('Person', {
     *         fields: [...],
     *
     *         associations: [
     *             { type: 'hasOne', model: 'Address', primaryKey: 'unique_id', foreignKey: 'addr_id' }
     *         ]
     *     });
     *
     * Here we replaced the default primary key (defaults to 'id') and foreign key (calculated as 'address_id')
     * with our own settings. Usually this will not be needed.
     */
    export class HasOne extends Ext.data.association.Association implements Ext.data.association.HasOneConfig {
        /**
         * The name of the foreign key on the owner model that links it to the associated
         * model. Defaults to the lowercased name of the associated model plus "_id", e.g. an association with a
         * model called Person would set up a address_id foreign key.
         *
         *     Ext.define('Person', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'address_id'], // refers to the id of the address object
         *         hasOne: 'Address'
         *     });
         *
         *     Ext.define('Address', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'number', 'street', 'city', 'zip'],
         *         belongsTo: 'Person'
         *     });
         *     var Person = new Person({
         *         id: 1,
         *         name: 'John Smith',
         *         address_id: 13
         *     }, 1);
         *     person.getAddress(); // Will make a call to the server asking for address_id 13
         */
        foreignKey: string;

        /**
         * The name of the getter function that will be added to the local model's prototype.
         * Defaults to 'get' + the name of the foreign model, e.g. getAddress
         */
        getterName: string;

        /**
         * The name of the setter function that will be added to the local model's prototype.
         * Defaults to 'set' + the name of the foreign model, e.g. setAddress
         */
        setterName: string;

        /**
         * The type configuration can be used when creating associations using a configuration object.
         * Use 'hasOne' to create a HasOne association.
         *
         *     associations: [{
         *         type: 'hasOne',
         *         model: 'Address'
         *     }]
         */
        type: string;

        /**
         * Creates the Association object.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.association.AssociationConfig);
    }
}

declare module Ext.data.flash {
    /**
     * Simulates an XMLHttpRequest object's methods and properties as returned
     * form the flash polyfill plugin. Used in submitting binary data in browsers that do
     * not support doing so from JavaScript.
     * NOTE: By default this will look for the flash object in the ext directory. When packaging and deploying the app, copy the <tt>ext/plugins</tt> directory and its contents to your root directory. For custom deployments where just the <tt>FlashPlugin.swf</tt> file gets copied (e.g. to <tt>/resources/FlashPlugin.swf</tt>), make sure to notify the framework of the location of the plugin before making the first attempt to post binary data, e.g. in the <tt>launch</tt> method of your app do:
     * <pre><code>
     Ext.flashPluginPath="/resources/FlashPlugin.swf";
     </code></pre>
     */
    export class BinaryXhr extends Ext.Base {
        /**
         * The connection's simulated readyState. Note that the only supported values are 0, 1 and 4. States 2 and 3 will never be reported.
         */
        readyState: number;

        /**
         * The binary bytes returned.
         */
        responseBytes: any[];

        /**
         * Connection status code returned by flash or the server.
         */
        status: number;

        /**
         * Status text (if any) returned by flash or the server.
         */
        statusText: any;

        /**
         * Abort this connection. Sets its readyState to 4.
         */
        abort();

        /**
         * Creates a new instance of BinaryXhr.
         */
        constructor();

        /**
         * As in XMLHttpRequest.
         */
        getAllResponseHeaders();

        /**
         * As in XMLHttpRequest.
         */
        getResponseHeader();

        /**
         * As in XMLHttpRequest.
         */
        onreadystatechange();

        /**
         * As in XMLHttpRequest.
         */
        open();

        /**
         * As in XMLHttpRequest.
         */
        overrideMimeType();

        /**
         * Initiate the request.
         * @param {Array} body an array of byte values to send.
         */
        send(body: any[]);

        /**
         * As in XMLHttpRequest.
         */
        setRequestHeader();
    }
}

declare module Ext.data.proxy {
    interface AjaxConfig extends Ext.data.proxy.ServerConfig {
        /**
         * True to request binary data from the server.  This feature requires
         * the use of a binary reader such as {@link Ext.data.amf.Reader AMF Reader}
         */
        binary?: boolean;

        /**
         * Any headers to add to the Ajax request. Defaults to undefined.
         */
        headers?: any;
    }

    export class Ajax extends Ext.data.proxy.Server implements Ext.data.proxy.AjaxConfig {
        /**
         * Mapping of action name to HTTP request method. In the basic AjaxProxy these are set to 'GET' for 'read' actions
         * and 'POST' for 'create', 'update' and 'destroy' actions. The {@link Ext.data.proxy.Rest} maps these to the
         * correct RESTful methods.
         */
        actionMethods: any;

        /**
         * True to request binary data from the server.  This feature requires
         * the use of a binary reader such as {@link Ext.data.amf.Reader AMF Reader}
         */
        binary: boolean;

        /**
         * Any headers to add to the Ajax request. Defaults to undefined.
         */
        headers: any;

        /**
         * @author Ed Spencer
         *
         * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
         * data from the server, usually to be placed into a {@link Ext.data.Store Store}. Let's take a look at a typical setup.
         * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a {@link Ext.data.Model
         * Model}:
         *
         *     Ext.define('User', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'email']
         *     });
         *
         *     //The Store contains the AjaxProxy as an inline configuration
         *     var store = Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json'
         *         }
         *     });
         *
         *     store.load();
         *
         * Our example is going to load user data into a Store, so we start off by defining a {@link Ext.data.Model Model} with
         * the fields that we expect the server to return. Next we set up the Store itself, along with a
         * {@link Ext.data.Store#proxy proxy} configuration. This configuration was automatically turned into an
         * Ext.data.proxy.Ajax instance, with the url we specified being passed into AjaxProxy's constructor.
         * It's as if we'd done this:
         *
         *     new Ext.data.proxy.Ajax({
         *         url: 'users.json',
         *         model: 'User',
         *         reader: 'json'
         *     });
         *
         * A couple of extra configurations appeared here - {@link #model} and {@link #reader}. These are set by default when we
         * create the proxy via the Store - the Store already knows about the Model, and Proxy's default {@link
         * Ext.data.reader.Reader Reader} is {@link Ext.data.reader.Json JsonReader}.
         *
         * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
         * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
         * {@link #actionMethods} to customize this - by default any kind of read will be sent as a GET request and any kind of write
         * will be sent as a POST request).
         *
         * # Limitations
         *
         * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
         * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
         * talking to each other via AJAX.
         *
         * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
         * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
         * from http://domainA.com), you can use {@link Ext.data.proxy.JsonP} and a technique known as JSON-P (JSON with
         * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
         * JSON-P responses. See {@link Ext.data.proxy.JsonP JsonPProxy}'s introduction docs for more details.
         *
         * # Readers and Writers
         *
         * AjaxProxy can be configured to use any type of {@link Ext.data.reader.Reader Reader} to decode the server's response.
         * If no Reader is supplied, AjaxProxy will default to using a {@link Ext.data.reader.Json JsonReader}. Reader
         * configuration can be passed in as a simple object, which the Proxy automatically turns into a {@link
         * Ext.data.reader.Reader Reader} instance:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         model: 'User',
         *         reader: {
         *             type: 'xml',
         *             root: 'users'
         *         }
         *     });
         *
         *     proxy.getReader(); //returns an {@link Ext.data.reader.Xml XmlReader} instance based on the config we supplied
         *
         * # Url generation
         *
         * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
         * each request. These are controlled with the following configuration options:
         *
         * - {@link #pageParam} - controls how the page number is sent to the server (see also {@link #startParam} and {@link #limitParam})
         * - {@link #sortParam} - controls how sort information is sent to the server
         * - {@link #groupParam} - controls how grouping information is sent to the server
         * - {@link #filterParam} - controls how filter information is sent to the server
         *
         * Each request sent by AjaxProxy is described by an {@link Ext.data.Operation Operation}. To see how we can customize
         * the generated urls, let's say we're loading the Proxy with the following Operation:
         *
         *     var operation = new Ext.data.Operation({
         *         action: 'read',
         *         page  : 2
         *     });
         *
         * Now we'll issue the request for this Operation by calling {@link #read}:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?page=2
         *
         * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
         * to the server:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         pageParam: 'pageNumber'
         *     });
         *
         *     proxy.read(operation); //GET /users?pageNumber=2
         *
         * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
         *
         *     var operation = new Ext.data.Operation({
         *         action: 'read',
         *         start : 50,
         *         limit : 25
         *     });
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?start=50&limit;=25
         *
         * Again we can customize this url:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         startParam: 'startIndex',
         *         limitParam: 'limitIndex'
         *     });
         *
         *     proxy.read(operation); //GET /users?startIndex=50&limitIndex;=25
         *
         * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
         * expressive Operation object:
         *
         *     var operation = new Ext.data.Operation({
         *         action: 'read',
         *         sorters: [
         *             new Ext.util.Sorter({
         *                 property : 'name',
         *                 direction: 'ASC'
         *             }),
         *             new Ext.util.Sorter({
         *                 property : 'age',
         *                 direction: 'DESC'
         *             })
         *         ],
         *         filters: [
         *             new Ext.util.Filter({
         *                 property: 'eyeColor',
         *                 value   : 'brown'
         *             })
         *         ]
         *     });
         *
         * This is the type of object that is generated internally when loading a {@link Ext.data.Store Store} with sorters and
         * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
         * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&filter;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
         * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
         * that format like this:
         *
         *      var proxy = new Ext.data.proxy.Ajax({
         *          url: '/users',
         *          sortParam: 'sortBy',
         *          filterParam: 'filterBy',
         *
         *          //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
         *          encodeSorters: function(sorters) {
         *              var length   = sorters.length,
         *                  sortStrs = [],
         *                  sorter, i;
         *
         *              for (i = 0; i < length; i++) {
         *                  sorter = sorters[i];
         *
         *                  sortStrs[i] = sorter.property + '#' + sorter.direction
         *              }
         *
         *              return sortStrs.join(",");
         *          }
         *      });
         *
         *      proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&filterBy;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can also provide a custom {@link #encodeFilters} function to encode our filters.
         *
         * @constructor
         * Note that if this HttpProxy is being used by a {@link Ext.data.Store Store}, then the Store's call to
         * {@link Ext.data.Store#method-load load} will override any specified callback and params options. In this case, use the
         * {@link Ext.data.Store Store}'s events to modify parameters, or react to loading events.
         *
         * @param {Object} config (optional) Config object.
         * If an options parameter is passed, the singleton {@link Ext.Ajax} object will be used to make the request.
         */
        constructor(config: Ext.data.proxy.AjaxConfig);

        /**
         * Returns the HTTP method name for a given request. By default this returns based on a lookup on
         * {@link #actionMethods}.
         * @param {Ext.data.Request} request The request object
         * @return {String} The HTTP method to use (should be one of 'GET', 'POST', 'PUT' or 'DELETE')
         */
        getMethod(request: Ext.data.Request): string;
    }

    /**
     * @author Ed Spencer
     *
     * Base class for any client-side storage. Used as a superclass for {@link Ext.data.proxy.Memory Memory} and
     * {@link Ext.data.proxy.WebStorage Web Storage} proxies. Do not use directly, use one of the subclasses instead.
     */
    export class Client extends Ext.data.proxy.Proxy {
        /**
         * 'true' in this class to identify that requests made on this proxy are
         * performed synchronously
         */
        isSynchronous: boolean;

        /**
         * Abstract function that must be implemented by each ClientProxy subclass. This should purge all record data
         * from the client side storage, as well as removing any supporting data (such as lists of record IDs)
         */
        clear();

        /**
         * Creates the Proxy
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.MemoryConfig);
    }

    interface DirectConfig extends Ext.data.proxy.ServerConfig {
        /**
         * The same as {@link Ext.data.proxy.Server#api}, however instead of providing urls, you should provide a direct
         * function call. See {@link #directFn}.
         */
        api?: any;

        /**
         * Function to call when executing a request. directFn is a simple alternative to defining the api configuration-parameter
         * for Store's which will not implement a full CRUD api. The directFn may also be a string reference to the fully qualified
         * name of the function, for example: 'MyApp.company.GetProfile'. This can be useful when using dynamic loading. The string
         * will be looked up when the proxy is created.
         */
        directFn?: Function|string;

        /**
         * Extra parameters that will be included on every read request. Individual requests with params
         * of the same name will override these params when they are in conflict.
         */
        extraParams?: any;

        /**
         * Defaults to undefined. A list of params to be executed server side.  Specify the params in the order in
         * which they must be executed on the server-side as either (1) an Array of String values, or (2) a String
         * of params delimited by either whitespace, comma, or pipe. For example, any of the following would be
         * acceptable:
         *
         *     paramOrder: ['param1','param2','param3']
         *     paramOrder: 'param1 param2 param3'
         *     paramOrder: 'param1,param2,param3'
         *     paramOrder: 'param1|param2|param'
         */
        paramOrder?: string;

        /**
         * Send parameters as a collection of named arguments.
         * Providing a {@link #paramOrder} nullifies this configuration.
         */
        paramsAsHash?: boolean;
    }

    /**
     * This class is used to send requests to the server using {@link Ext.direct.Manager Ext.Direct}. When a
     * request is made, the transport mechanism is handed off to the appropriate
     * {@link Ext.direct.RemotingProvider Provider} to complete the call.
     *
     * # Specifying the function
     *
     * This proxy expects a Direct remoting method to be passed in order to be able to complete requests.
     * This can be done by specifying the {@link #directFn} configuration. This will use the same direct
     * method for all requests. Alternatively, you can provide an {@link #api} configuration. This
     * allows you to specify a different remoting method for each CRUD action.
     *
     * # Parameters
     *
     * This proxy provides options to help configure which parameters will be sent to the server.
     * By specifying the {@link #paramsAsHash} option, it will send an object literal containing each
     * of the passed parameters. The {@link #paramOrder} option can be used to specify the order in which
     * the remoting method parameters are passed.
     *
     * # Example Usage
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['firstName', 'lastName'],
     *         proxy: {
     *             type: 'direct',
     *             directFn: MyApp.getUsers,
     *             paramOrder: 'id' // Tells the proxy to pass the id as the first parameter to the remoting method.
     *         }
     *     });
     *     User.load(1);
     */
    export class Direct extends Ext.data.proxy.Server implements Ext.data.proxy.DirectConfig {
        /**
         * The same as {@link Ext.data.proxy.Server#api}, however instead of providing urls, you should provide a direct
         * function call. See {@link #directFn}.
         */
        api: any;

        /**
         * Function to call when executing a request. directFn is a simple alternative to defining the api configuration-parameter
         * for Store's which will not implement a full CRUD api. The directFn may also be a string reference to the fully qualified
         * name of the function, for example: 'MyApp.company.GetProfile'. This can be useful when using dynamic loading. The string
         * will be looked up when the proxy is created.
         */
        directFn: Function|string;

        /**
         * Extra parameters that will be included on every read request. Individual requests with params
         * of the same name will override these params when they are in conflict.
         */
        extraParams: any;

        /**
         * Defaults to undefined. A list of params to be executed server side.  Specify the params in the order in
         * which they must be executed on the server-side as either (1) an Array of String values, or (2) a String
         * of params delimited by either whitespace, comma, or pipe. For example, any of the following would be
         * acceptable:
         *
         *     paramOrder: ['param1','param2','param3']
         *     paramOrder: 'param1 param2 param3'
         *     paramOrder: 'param1,param2,param3'
         *     paramOrder: 'param1|param2|param'
         */
        paramOrder: string;

        /**
         * Send parameters as a collection of named arguments.
         * Providing a {@link #paramOrder} nullifies this configuration.
         */
        paramsAsHash: boolean;

        constructor(config: Ext.data.proxy.DirectConfig);
    }

    interface JsonPConfig extends Ext.data.proxy.ServerConfig {
        /**
         * True to automatically append the request's params to the generated url. Defaults to true
         */
        autoAppendParams?: boolean;

        /**
         * See {@link Ext.data.JsonP#callbackKey}.
         */
        callbackKey?: string;

        /**
         * The HTTP parameter name to use when passing records to the server and the {@link #writer Json writer} is not configured
         * to {@link Ext.data.writer.Json#encode encode} records into a parameter.
         *
         * The {@link #encodeRecords} method is used to encode the records to create this parameter's value.
         *
         * Optional, Defaults to: records
         */
        recordParam?: string;
    }

    /**
     * @author Ed Spencer
     *
     * The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
     * your application is running on http://domainA.com it cannot use {@link Ext.data.proxy.Ajax Ajax} to load its data
     * from http://domainB.com because cross-domain ajax requests are prohibited by the browser.
     *
     * We can get around this using a JsonP proxy. JsonP proxy injects a '<script>' tag into the DOM whenever an AJAX request
     * would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
     * injected might look like this:
     *
     *     <script src="http://domainB.com/users?callback=someCallback"></script>
     *
     * When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
     * other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
     * to be notified when the result comes in and that it should call our callback function with the data it sends back. So
     * long as the server formats the response to look like this, everything will work:
     *
     *     someCallback({
     *         users: [
     *             {
     *                 id: 1,
     *                 name: "Ed Spencer",
     *                 email: "ed@sencha.com"
     *             }
     *         ]
     *     });
     *
     * As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
     * object that the server returned.
     *
     * JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
     * automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
     * the Proxy making it look just like you loaded it through a normal {@link Ext.data.proxy.Ajax AjaxProxy}. Here's how
     * we might set that up:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email']
     *     });
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'jsonp',
     *             url : 'http://domainB.com/users'
     *         }
     *     });
     *
     *     store.load();
     *
     * That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
     * like this:
     *
     *     <script src="http://domainB.com/users?callback=callback1"></script>
     *
     * # Customization
     *
     * This script tag can be customized using the {@link #callbackKey} configuration. For example:
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'jsonp',
     *             url : 'http://domainB.com/users',
     *             callbackKey: 'theCallbackFunction'
     *         }
     *     });
     *
     *     store.load();
     *
     * Would inject a script tag like this:
     *
     *     <script src="http://domainB.com/users?theCallbackFunction=callback1"></script>
     *
     * # Implementing on the server side
     *
     * The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
     * achieve this using Java, PHP and ASP.net:
     *
     * Java:
     *
     *     boolean jsonP = false;
     *     String cb = request.getParameter("callback");
     *     if (cb != null) {
     *         jsonP = true;
     *         response.setContentType("text/javascript");
     *     } else {
     *         response.setContentType("application/x-json");
     *     }
     *     Writer out = response.getWriter();
     *     if (jsonP) {
     *         out.write(cb + "(");
     *     }
     *     out.print(dataBlock.toJsonString());
     *     if (jsonP) {
     *         out.write(");");
     *     }
     *
     * PHP:
     *
     *     $callback = $_REQUEST['callback'];
     *
     *     // Create the output object.
     *     $output = array('a' => 'Apple', 'b' => 'Banana');
     *
     *     //start output
     *     if ($callback) {
     *         header('Content-Type: text/javascript');
     *         echo $callback . '(' . json_encode($output) . ');';
     *     } else {
     *         header('Content-Type: application/x-json');
     *         echo json_encode($output);
     *     }
     *
     * ASP.net:
     *
     *     String jsonString = "{success: true}";
     *     String cb = Request.Params.Get("callback");
     *     String responseString = "";
     *     if (!String.IsNullOrEmpty(cb)) {
     *         responseString = cb + "(" + jsonString + ")";
     *     } else {
     *         responseString = jsonString;
     *     }
     *     Response.Write(responseString);
     */
    export class JsonP extends Ext.data.proxy.Server implements Ext.data.proxy.JsonPConfig {
        /**
         * True to automatically append the request's params to the generated url. Defaults to true
         */
        autoAppendParams: boolean;

        /**
         * See {@link Ext.data.JsonP#callbackKey}.
         */
        callbackKey: string;

        /**
         * The HTTP parameter name to use when passing records to the server and the {@link #writer Json writer} is not configured
         * to {@link Ext.data.writer.Json#encode encode} records into a parameter.
         *
         * The {@link #encodeRecords} method is used to encode the records to create this parameter's value.
         *
         * Optional, Defaults to: records
         */
        recordParam: string;

        /**
         * Aborts the current server request if one is currently running
         */
        abort();

        /**
         * Generates a url based on a given Ext.data.Request object. Adds the params and callback function name to the url
         * @param {Ext.data.Request} request The request object
         * @return {String} The url
         */
        buildUrl(request: Ext.data.Request): string;

        constructor();

        /**
         * Encodes an array of records into a value suitable to be added to the request 'params' as the {@link #recordParam} parameter.
         * This is broken out into its own function so that it can be easily overridden.
         *
         * The default implementation
         * @param {Ext.data.Model[]} records The records array
         * @return {Array} An array of record data objects
         */
        encodeRecords(records: Ext.data.Model): any[];
    }

    /**
     * @author Ed Spencer
     *
     * The LocalStorageProxy uses the new HTML5 localStorage API to save {@link Ext.data.Model Model} data locally on the
     * client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
     * LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
     *
     * localStorage is extremely useful for saving user-specific information without needing to build server-side
     * infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
     * searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
     *
     *     Ext.define('Search', {
     *         fields: ['id', 'query'],
     *         extend: 'Ext.data.Model',
     *         proxy: {
     *             type: 'localstorage',
     *             id  : 'twitter-Searches'
     *         }
     *     });
     *
     * Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
     * pass to the LocalStorage proxy is an {@link #id}. This is important as it separates the Model data in this Proxy from
     * all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
     * LocalStorageProxy to manage the saved Search data.
     *
     * Saving our data into localStorage is easy and would usually be done with a {@link Ext.data.Store Store}:
     *
     *     //our Store automatically picks up the LocalStorageProxy defined on the Search model
     *     var store = Ext.create('Ext.data.Store', {
     *         model: "Search"
     *     });
     *
     *     //loads any existing Search data from localStorage
     *     store.load();
     *
     *     //now add some Searches
     *     store.add({query: 'Sencha Touch'});
     *     store.add({query: 'Ext JS'});
     *
     *     //finally, save our Search data to localStorage
     *     store.sync();
     *
     * The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
     * and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
     *
     *     var search = Ext.create('Search', {query: 'Sencha Animator'});
     *
     *     //uses the configured LocalStorageProxy to save the new Search to localStorage
     *     search.save();
     *
     * # Limitations
     *
     * If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
     * storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
     * object.
     *
     * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
     * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
     */
    export class LocalStorage extends Ext.data.proxy.WebStorage {
        /**
         * Creates the proxy, throws an error if local storage is not supported in the current browser.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.WebStorageConfig);
    }

    interface MemoryConfig extends Ext.data.proxy.ProxyConfig {
        /**
         * Optional data to pass to configured Reader.
         */
        data?: any;

        /**
         * Configure as 'true' to enable this MemoryProxy to honour a read operation's 'start' and 'limit' options.
         *
         * When 'true', read operations will be able to read *pages* of records from the data object.
         *
         * Optional, Defaults to: false
         */
        enablePaging?: boolean;
    }

    /**
     * @author Ed Spencer
     *
     * In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
     * every page refresh.
     *
     * Usually this Proxy isn't used directly, serving instead as a helper to a {@link Ext.data.Store Store} where a reader
     * is required to load data. For example, say we have a Store for a User model and have some inline data we want to
     * load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
     * Store:
     *
     *     //this is the model we will be using in the store
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             {name: 'id',    type: 'int'},
     *             {name: 'name',  type: 'string'},
     *             {name: 'phone', type: 'string', mapping: 'phoneNumber'}
     *         ]
     *     });
     *
     *     //this data does not line up to our model fields - the phone field is called phoneNumber
     *     var data = {
     *         users: [
     *             {
     *                 id: 1,
     *                 name: 'Ed Spencer',
     *                 phoneNumber: '555 1234'
     *             },
     *             {
     *                 id: 2,
     *                 name: 'Abe Elias',
     *                 phoneNumber: '666 1234'
     *             }
     *         ]
     *     };
     *
     *     //note how we set the 'root' in the reader to match the data structure above
     *     var store = Ext.create('Ext.data.Store', {
     *         autoLoad: true,
     *         model: 'User',
     *         data : data,
     *         proxy: {
     *             type: 'memory',
     *             reader: {
     *                 type: 'json',
     *                 root: 'users'
     *             }
     *         }
     *     });
     */
    export class Memory extends Ext.data.proxy.Client implements Ext.data.proxy.MemoryConfig {
        /**
         * Optional data to pass to configured Reader.
         */
        data: any;

        /**
         * Configure as 'true' to enable this MemoryProxy to honour a read operation's 'start' and 'limit' options.
         *
         * When 'true', read operations will be able to read *pages* of records from the data object.
         *
         * Optional, Defaults to: false
         */
        enablePaging: boolean;

        clear();

        /**
         * Creates the Proxy
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.MemoryConfig);

        /**
         * Currently this is a hard-coded method that simply commits any records and sets the operation to successful,
         * then calls the callback function, if provided. It is essentially mocking a server call in memory, but since
         * there is no real back end in this case there's not much else to do. This method can be easily overridden to
         * implement more complex logic if needed.
         * @param {Ext.data.Operation} operation The Operation to perform
         * @param {Function} callback Callback function to be called when the Operation has completed (whether
         * successful or not)
         * @param {Object} scope Scope to execute the callback function in
         */
        destroy(operation: Ext.data.Operation, callback: Function, scope: any);

        /**
         * Reads data from the configured {@link #data} object. Uses the Proxy's {@link #reader}, if present.
         * @param {Ext.data.Operation} operation The read Operation
         * @param {Function} callback The callback to call when reading has completed
         * @param {Object} scope The scope to call the callback function in
         */
        read(operation: Ext.data.Operation, callback: Function, scope: any);

        /**
         * Currently this is a hard-coded method that simply commits any records and sets the operation to successful,
         * then calls the callback function, if provided. It is essentially mocking a server call in memory, but since
         * there is no real back end in this case there's not much else to do. This method can be easily overridden to
         * implement more complex logic if needed.
         * @param {Ext.data.Operation} operation The Operation to perform
         * @param {Function} callback Callback function to be called when the Operation has completed (whether
         * successful or not)
         * @param {Object} scope Scope to execute the callback function in
         */
        update(operation: Ext.data.Operation, callback: Function, scope: any);
    }

    interface ProxyConfig {
        /**
         * True to batch actions of a particular type when synchronizing the store. Defaults to true.
         */
        batchActions?: boolean;

        /**
         * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
         * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
         */
        batchOrder?: string;

        /**
         * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
         * Model constructor. Required.
         */
        model?: string|Ext.data.Model;

        /**
         * The Ext.data.reader.Reader to use to decode the server's response or data read from client. This can either be a
         * Reader instance, a config object or just a valid Reader type name (e.g. 'json', 'xml').
         */
        reader?: any|string|Ext.data.reader.Reader;

        /**
         * The Ext.data.writer.Writer to use to encode any request sent to the server or saved to client. This can either be
         * a Writer instance, a config object or just a valid Writer type name (e.g. 'json', 'xml').
         */
        writer?: any|string|Ext.data.writer.Writer;
    }

    /**
     * @author Ed Spencer
     *
     * Proxies are used by {@link Ext.data.Store Stores} to handle the loading and saving of {@link Ext.data.Model Model}
     * data. Usually developers will not need to create or interact with proxies directly.
     *
     * # Types of Proxy
     *
     * There are two main types of Proxy - {@link Ext.data.proxy.Client Client} and {@link Ext.data.proxy.Server Server}.
     * The Client proxies save their data locally and include the following subclasses:
     *
     * - {@link Ext.data.proxy.LocalStorage LocalStorageProxy} - saves its data to localStorage if the browser supports it
     * - {@link Ext.data.proxy.SessionStorage SessionStorageProxy} - saves its data to sessionStorage if the browsers supports it
     * - {@link Ext.data.proxy.Memory MemoryProxy} - holds data in memory only, any data is lost when the page is refreshed
     *
     * The Server proxies save their data by sending requests to some remote server. These proxies include:
     *
     * - {@link Ext.data.proxy.Ajax Ajax} - sends requests to a server on the same domain
     * - {@link Ext.data.proxy.JsonP JsonP} - uses JSON-P to send requests to a server on a different domain
     * - {@link Ext.data.proxy.Rest Rest} - uses RESTful HTTP methods (GET/PUT/POST/DELETE) to communicate with server
     * - {@link Ext.data.proxy.Direct Direct} - uses {@link Ext.direct.Manager} to send requests
     *
     * Proxies operate on the principle that all operations performed are either Create, Read, Update or Delete. These four
     * operations are mapped to the methods {@link #create}, {@link #read}, {@link #update} and {@link #destroy}
     * respectively. Each Proxy subclass implements these functions.
     *
     * The CRUD methods each expect an {@link Ext.data.Operation Operation} object as the sole argument. The Operation
     * encapsulates information about the action the Store wishes to perform, the {@link Ext.data.Model model} instances
     * that are to be modified, etc. See the {@link Ext.data.Operation Operation} documentation for more details. Each CRUD
     * method also accepts a callback function to be called asynchronously on completion.
     *
     * Proxies also support batching of Operations via a {@link Ext.data.Batch batch} object, invoked by the {@link #batch}
     * method.
     */
    export class Proxy extends Ext.Base implements Ext.data.proxy.ProxyConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Proxy, or subclass thereof.
         */
        isProxy: boolean;

        /**
         * Identifies the proxy as (a)synchronous.
         *
         * Optional, Defaults to: false
         */
        isSynchronous: boolean;

        /**
         * True to batch actions of a particular type when synchronizing the store. Defaults to true.
         */
        batchActions: boolean;

        /**
         * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
         * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
         */
        batchOrder: string;

        /**
         * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
         * Model constructor. Required.
         */
        model: string|Ext.data.Model;

        /**
         * The Ext.data.reader.Reader to use to decode the server's response or data read from client. This can either be a
         * Reader instance, a config object or just a valid Reader type name (e.g. 'json', 'xml').
         */
        reader: any|string|Ext.data.reader.Reader;

        /**
         * The Ext.data.writer.Writer to use to encode any request sent to the server or saved to client. This can either be
         * a Writer instance, a config object or just a valid Writer type name (e.g. 'json', 'xml').
         */
        writer: any|string|Ext.data.writer.Writer;

        /**
         * Performs a batch of {@link Ext.data.Operation Operations}, in the order specified by {@link #batchOrder}. Used
         * internally by {@link Ext.data.Store}'s {@link Ext.data.Store#sync sync} method. Example usage:
         *
         *     myProxy.batch({
         *         create : [myModel1, myModel2],
         *         update : [myModel3],
         *         destroy: [myModel4, myModel5]
         *     });
         *
         * Where the myModel* above are {@link Ext.data.Model Model} instances - in this case 1 and 2 are new instances and
         * have not been saved before, 3 has been saved previously but needs to be updated, and 4 and 5 have already been
         * saved but should now be destroyed.
         *
         * Note that the previous version of this method took 2 arguments (operations and listeners). While this is still
         * supported for now, the current signature is now a single 'options' argument that can contain both operations and
         * listeners, in addition to other options. The multi-argument signature will likely be deprecated in a future release.
         *
         * @param {Object} options Object containing one or more properties supported by the batch method:
         *
         * @param {Object} options.operations Object containing the Model instances to act upon, keyed by action name
         *
         * @param {Object} [options.listeners] Event listeners object passed straight through to the Batch -
         * see {@link Ext.data.Batch} for details
         *
         * @param {Ext.data.Batch/Object} [options.batch] A {@link Ext.data.Batch} object (or batch config to apply
         * to the created batch). If unspecified a default batch will be auto-created.
         *
         * @param {Function} [options.callback] The function to be called upon completion of processing the batch.
         * The callback is called regardless of success or failure and is passed the following parameters:
         * @param {Ext.data.Batch} options.callback.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.callback.options The options argument that was originally passed into batch
         *
         * @param {Function} [options.success] The function to be called upon successful completion of the batch. The
         * success function is called only if no exceptions were reported in any operations. If one or more exceptions
         * occurred then the 'failure' function will be called instead. The success function is called
         * with the following parameters:
         * @param {Ext.data.Batch} options.success.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.success.options The options argument that was originally passed into batch
         *
         * @param {Function} [options.failure] The function to be called upon unsuccessful completion of the batch. The
         * failure function is called when one or more operations returns an exception during processing (even if some
         * operations were also successful). In this case you can check the batch's {@link Ext.data.Batch#exceptions
         * exceptions} array to see exactly which operations had exceptions. The failure function is called with the
         * following parameters:
         * @param {Ext.data.Batch} options.failure.batch The {@link Ext.data.Batch batch} that was processed,
         * containing all operations in their current state after processing
         * @param {Object} options.failure.options The options argument that was originally passed into batch
         *
         * @param {Object} [options.scope] The scope in which to execute any callbacks (i.e. the 'this' object inside
         * the callback, success and/or failure functions). Defaults to the proxy.
         *
         * @return {Ext.data.Batch} The newly created Batch
         */
        batch(options: any, options_operations: any, options_listeners?: any, options_batch?: Ext.data.Batch|any, options_callback?: Function, options_callback_batch?: Ext.data.Batch, options_callback_options?: any, options_success?: Function, options_success_batch?: Ext.data.Batch, options_success_options?: any, options_failure?: Function, options_failure_batch?: Ext.data.Batch, options_failure_options?: any, options_scope?: any): Ext.data.Batch;

        /**
         * Creates the Proxy
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.MemoryConfig);

        /**
         * Performs the given destroy operation.
         * @param {Ext.data.Operation} operation The Operation to perform
         * @param {Function} callback Callback function to be called when the Operation has completed (whether
         * successful or not)
         * @param {Object} scope Scope to execute the callback function in
         */
        destroy(operation: Ext.data.Operation, callback: Function, scope: any);

        /**
         * Returns the model attached to this Proxy
         * @return {Ext.data.Model} The model
         */
        getModel(): Ext.data.Model;

        /**
         * Returns the reader currently attached to this proxy instance
         * @return {Ext.data.reader.Reader} The Reader instance
         */
        getReader(): Ext.data.reader.Reader;

        /**
         * Returns the writer currently attached to this proxy instance
         * @return {Ext.data.writer.Writer} The Writer instance
         */
        getWriter(): Ext.data.writer.Writer;

        /**
         * Performs the given read operation.
         * @param {Ext.data.Operation} operation The Operation to perform
         * @param {Function} callback Callback function to be called when the Operation has completed (whether
         * successful or not)
         * @param {Object} scope Scope to execute the callback function in
         */
        read(operation: Ext.data.Operation, callback: Function, scope: any);

        /**
         * Sets the model associated with this proxy. This will only usually be called by a Store
         *
         * @param {String/Ext.data.Model} model The new model. Can be either the model name string,
         * or a reference to the model's constructor
         * @param {Boolean} setOnStore Sets the new model on the associated Store, if one is present
         */
        setModel(model: string|Ext.data.Model, setOnStore: boolean);

        /**
         * Sets the Proxy's Reader by string, config object or Reader instance
         *
         * @param {String/Object/Ext.data.reader.Reader} reader The new Reader, which can be either a type string,
         * a configuration object or an Ext.data.reader.Reader instance
         * @return {Ext.data.reader.Reader} The attached Reader object
         */
        setReader(reader: string|any|Ext.data.reader.Reader): Ext.data.reader.Reader;

        /**
         * Sets the Proxy's Writer by string, config object or Writer instance
         *
         * @param {String/Object/Ext.data.writer.Writer} writer The new Writer, which can be either a type string,
         * a configuration object or an Ext.data.writer.Writer instance
         * @return {Ext.data.writer.Writer} The attached Writer object
         */
        setWriter(writer: string|any|Ext.data.writer.Writer): Ext.data.writer.Writer;

        /**
         * Performs the given update operation.
         * @param {Ext.data.Operation} operation The Operation to perform
         * @param {Function} callback Callback function to be called when the Operation has completed (whether
         * successful or not)
         * @param {Object} scope Scope to execute the callback function in
         */
        update(operation: Ext.data.Operation, callback: Function, scope: any);

        /**
         * Fires when this proxy's reader provides new metadata. Metadata usually consists
         * of new field definitions, but can include any configuration data required by an
         * application, and can be processed as needed in the event handler.
         * This event is currently only fired for JsonReaders. Note that this event is also
         * propagated by {@link Ext.data.Store}, which is typically where it would be handled.
         * @param {Object} meta The JSON metadata
         */
        metachange(that: Ext.data.proxy.Proxy, meta: any);
    }

    interface RestConfig extends Ext.data.proxy.AjaxConfig {
        /**
         * True to automatically append the ID of a Model instance when performing a request based on that single instance.
         * See Rest proxy intro docs for more details. Defaults to true.
         */
        appendId?: boolean;

        /**
         * True to batch actions of a particular type when synchronizing the store. Defaults to false.
         */
        batchActions?: boolean;

        /**
         * Optional data format to send to the server when making any request (e.g. 'json'). See the Rest proxy intro docs
         * for full details. Defaults to undefined.
         */
        format?: string;
    }

    /**
     * @author Ed Spencer
     *
     * The Rest proxy is a specialization of the {@link Ext.data.proxy.Ajax AjaxProxy} which simply maps the four actions
     * (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a {@link Ext.data.Model Model}
     * with an inline Rest proxy
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email'],
     *
     *         proxy: {
     *             type: 'rest',
     *             url : '/users'
     *         }
     *     });
     *
     * Now we can create a new User instance and save it via the Rest proxy. Doing this will cause the Proxy to send a POST
     * request to '/users':
     *
     *     var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
     *
     *     user.save(); //POST /users
     *
     * Let's expand this a little and provide a callback for the {@link Ext.data.Model#save} call to update the Model once
     * it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
     *
     *     user.save({
     *         success: function(user) {
     *             user.set('name', 'Khan Noonien Singh');
     *
     *             user.save(); //PUT /users/123
     *         }
     *     });
     *
     * Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
     * relevant url for that user. Now let's delete this user, which will use the DELETE method:
     *
     *         user.destroy(); //DELETE /users/123
     *
     * Finally, when we perform a load of a Model or Store, Rest proxy will use the GET method:
     *
     *     //1. Load via Store
     *
     *     //the Store automatically picks up the Proxy from the User model
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User'
     *     });
     *
     *     store.load(); //GET /users
     *
     *     //2. Load directly from the Model
     *
     *     //GET /users/123
     *     Ext.ModelManager.getModel('User').load(123, {
     *         success: function(user) {
     *             console.log(user.getId()); //outputs 123
     *         }
     *     });
     *
     * # Url generation
     *
     * The Rest proxy is able to automatically generate the urls above based on two configuration options - {@link #appendId} and
     * {@link #format}. If appendId is true (it is by default) then Rest proxy will automatically append the ID of the Model
     * instance in question to the configured url, resulting in the '/users/123' that we saw above.
     *
     * If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
     * The Rest proxy will automatically insert a '/' before the ID if one is not already present.
     *
     *     new Ext.data.proxy.Rest({
     *         url: '/users',
     *         appendId: true //default
     *     });
     *
     *     // Collection url: /users
     *     // Instance url  : /users/123
     *
     * The Rest proxy can also optionally append a format string to the end of any generated url:
     *
     *     new Ext.data.proxy.Rest({
     *         url: '/users',
     *         format: 'json'
     *     });
     *
     *     // Collection url: /users.json
     *     // Instance url  : /users/123.json
     *
     * If further customization is needed, simply implement the {@link #buildUrl} method and add your custom generated url
     * onto the {@link Ext.data.Request Request} object that is passed to buildUrl. See [Rest proxy's implementation][1] for
     * an example of how to achieve this.
     *
     * Note that Rest proxy inherits from {@link Ext.data.proxy.Ajax AjaxProxy}, which already injects all of the sorter,
     * filter, group and paging options into the generated url. See the {@link Ext.data.proxy.Ajax AjaxProxy docs} for more
     * details.
     *
     * [1]: source/Rest.html#Ext-data-proxy-Rest-method-buildUrl
     */
    export class Rest extends Ext.data.proxy.Ajax implements Ext.data.proxy.RestConfig {
        /**
         * Mapping of action name to HTTP request method. These default to RESTful conventions for the 'create', 'read',
         * 'update' and 'destroy' actions (which map to 'POST', 'GET', 'PUT' and 'DELETE' respectively). This object
         * should not be changed except globally via {@link Ext#override Ext.override} - the {@link #getMethod} function
         * can be overridden instead.
         */
        actionMethods: any;

        /**
         * True to automatically append the ID of a Model instance when performing a request based on that single instance.
         * See Rest proxy intro docs for more details. Defaults to true.
         */
        appendId: boolean;

        /**
         * True to batch actions of a particular type when synchronizing the store. Defaults to false.
         */
        batchActions: boolean;

        /**
         * Optional data format to send to the server when making any request (e.g. 'json'). See the Rest proxy intro docs
         * for full details. Defaults to undefined.
         */
        format: string;

        /**
         * @author Ed Spencer
         *
         * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
         * data from the server, usually to be placed into a {@link Ext.data.Store Store}. Let's take a look at a typical setup.
         * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a {@link Ext.data.Model
         * Model}:
         *
         *     Ext.define('User', {
         *         extend: 'Ext.data.Model',
         *         fields: ['id', 'name', 'email']
         *     });
         *
         *     //The Store contains the AjaxProxy as an inline configuration
         *     var store = Ext.create('Ext.data.Store', {
         *         model: 'User',
         *         proxy: {
         *             type: 'ajax',
         *             url : 'users.json'
         *         }
         *     });
         *
         *     store.load();
         *
         * Our example is going to load user data into a Store, so we start off by defining a {@link Ext.data.Model Model} with
         * the fields that we expect the server to return. Next we set up the Store itself, along with a
         * {@link Ext.data.Store#proxy proxy} configuration. This configuration was automatically turned into an
         * Ext.data.proxy.Ajax instance, with the url we specified being passed into AjaxProxy's constructor.
         * It's as if we'd done this:
         *
         *     new Ext.data.proxy.Ajax({
         *         url: 'users.json',
         *         model: 'User',
         *         reader: 'json'
         *     });
         *
         * A couple of extra configurations appeared here - {@link #model} and {@link #reader}. These are set by default when we
         * create the proxy via the Store - the Store already knows about the Model, and Proxy's default {@link
         * Ext.data.reader.Reader Reader} is {@link Ext.data.reader.Json JsonReader}.
         *
         * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
         * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
         * {@link #actionMethods} to customize this - by default any kind of read will be sent as a GET request and any kind of write
         * will be sent as a POST request).
         *
         * # Limitations
         *
         * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
         * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
         * talking to each other via AJAX.
         *
         * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
         * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
         * from http://domainA.com), you can use {@link Ext.data.proxy.JsonP} and a technique known as JSON-P (JSON with
         * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
         * JSON-P responses. See {@link Ext.data.proxy.JsonP JsonPProxy}'s introduction docs for more details.
         *
         * # Readers and Writers
         *
         * AjaxProxy can be configured to use any type of {@link Ext.data.reader.Reader Reader} to decode the server's response.
         * If no Reader is supplied, AjaxProxy will default to using a {@link Ext.data.reader.Json JsonReader}. Reader
         * configuration can be passed in as a simple object, which the Proxy automatically turns into a {@link
         * Ext.data.reader.Reader Reader} instance:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         model: 'User',
         *         reader: {
         *             type: 'xml',
         *             root: 'users'
         *         }
         *     });
         *
         *     proxy.getReader(); //returns an {@link Ext.data.reader.Xml XmlReader} instance based on the config we supplied
         *
         * # Url generation
         *
         * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
         * each request. These are controlled with the following configuration options:
         *
         * - {@link #pageParam} - controls how the page number is sent to the server (see also {@link #startParam} and {@link #limitParam})
         * - {@link #sortParam} - controls how sort information is sent to the server
         * - {@link #groupParam} - controls how grouping information is sent to the server
         * - {@link #filterParam} - controls how filter information is sent to the server
         *
         * Each request sent by AjaxProxy is described by an {@link Ext.data.Operation Operation}. To see how we can customize
         * the generated urls, let's say we're loading the Proxy with the following Operation:
         *
         *     var operation = new Ext.data.Operation({
         *         action: 'read',
         *         page  : 2
         *     });
         *
         * Now we'll issue the request for this Operation by calling {@link #read}:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?page=2
         *
         * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
         * to the server:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         pageParam: 'pageNumber'
         *     });
         *
         *     proxy.read(operation); //GET /users?pageNumber=2
         *
         * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
         *
         *     var operation = new Ext.data.Operation({
         *         action: 'read',
         *         start : 50,
         *         limit : 25
         *     });
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?start=50&limit;=25
         *
         * Again we can customize this url:
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users',
         *         startParam: 'startIndex',
         *         limitParam: 'limitIndex'
         *     });
         *
         *     proxy.read(operation); //GET /users?startIndex=50&limitIndex;=25
         *
         * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
         * expressive Operation object:
         *
         *     var operation = new Ext.data.Operation({
         *         action: 'read',
         *         sorters: [
         *             new Ext.util.Sorter({
         *                 property : 'name',
         *                 direction: 'ASC'
         *             }),
         *             new Ext.util.Sorter({
         *                 property : 'age',
         *                 direction: 'DESC'
         *             })
         *         ],
         *         filters: [
         *             new Ext.util.Filter({
         *                 property: 'eyeColor',
         *                 value   : 'brown'
         *             })
         *         ]
         *     });
         *
         * This is the type of object that is generated internally when loading a {@link Ext.data.Store Store} with sorters and
         * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
         * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
         *
         *     var proxy = new Ext.data.proxy.Ajax({
         *         url: '/users'
         *     });
         *
         *     proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&filter;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
         * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
         * that format like this:
         *
         *      var proxy = new Ext.data.proxy.Ajax({
         *          url: '/users',
         *          sortParam: 'sortBy',
         *          filterParam: 'filterBy',
         *
         *          //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
         *          encodeSorters: function(sorters) {
         *              var length   = sorters.length,
         *                  sortStrs = [],
         *                  sorter, i;
         *
         *              for (i = 0; i < length; i++) {
         *                  sorter = sorters[i];
         *
         *                  sortStrs[i] = sorter.property + '#' + sorter.direction
         *              }
         *
         *              return sortStrs.join(",");
         *          }
         *      });
         *
         *      proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&filterBy;=[{"property":"eyeColor","value":"brown"}]
         *
         * We can also provide a custom {@link #encodeFilters} function to encode our filters.
         *
         * @constructor
         * Note that if this HttpProxy is being used by a {@link Ext.data.Store Store}, then the Store's call to
         * {@link Ext.data.Store#method-load load} will override any specified callback and params options. In this case, use the
         * {@link Ext.data.Store Store}'s events to modify parameters, or react to loading events.
         *
         * @param {Object} config (optional) Config object.
         * If an options parameter is passed, the singleton {@link Ext.Ajax} object will be used to make the request.
         */
        constructor(config: Ext.data.proxy.AjaxConfig);
    }

    interface ServerConfig extends Ext.data.proxy.ProxyConfig {
        /**
         * Specific urls to call on CRUD action methods "create", "read", "update" and "destroy". Defaults to:
         *
         *     api: {
         *         create  : undefined,
         *         read    : undefined,
         *         update  : undefined,
         *         destroy : undefined
         *     }
         *
         * The url is built based upon the action being executed [create|read|update|destroy] using the commensurate
         * {@link #api} property, or if undefined default to the configured
         * {@link Ext.data.Store}.{@link Ext.data.proxy.Server#url url}.
         *
         * For example:
         *
         *     api: {
         *         create  : '/controller/new',
         *         read    : '/controller/load',
         *         update  : '/controller/update',
         *         destroy : '/controller/destroy_action'
         *     }
         *
         * If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the
         * configured {@link Ext.data.proxy.Server#url url}.
         */
        api?: any;

        /**
         * The name of the cache param added to the url when using noCache. Defaults to "_dc".
         *
         * Optional, Defaults to: "_dc"
         */
        cacheString?: string;

        /**
         * The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
         * true.**
         *
         * Optional, Defaults to: "dir"
         */
        directionParam?: string;

        /**
         * Extra parameters that will be included on every request. Individual requests with params of the same name
         * will override these params when they are in conflict.
         */
        extraParams?: any;

        /**
         * The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to undefined if you don't
         * want to send a filter parameter.
         *
         * Optional, Defaults to: "filter"
         */
        filterParam?: string;

        /**
         * The name of the direction parameter to send in a request. **This is only used when simpleGroupMode is set to
         * true.**
         *
         * Optional, Defaults to: "groupDir"
         */
        groupDirectionParam?: string;

        /**
         * The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to undefined if you don't
         * want to send a group parameter.
         *
         * Optional, Defaults to: "group"
         */
        groupParam?: string;

        /**
         * The name of the parameter which carries the id of the entity being operated upon.
         *
         * Optional, Defaults to: "id"
         */
        idParam?: string;

        /**
         * The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to undefined if you don't
         * want to send a limit parameter.
         *
         * Optional, Defaults to: "limit"
         */
        limitParam?: string;

        /**
         * Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
         *
         * Optional, Defaults to: true
         */
        noCache?: boolean;

        /**
         * The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to undefined if you don't
         * want to send a page parameter.
         *
         * Optional, Defaults to: "page"
         */
        pageParam?: string;

        /**
         * Enabling simpleGroupMode in conjunction with remoteGroup will only send one group property and a direction when a
         * remote group is requested. The {@link #groupDirectionParam} and {@link #groupParam} will be sent with the property name and either 'ASC'
         * or 'DESC'.
         *
         * Optional, Defaults to: false
         */
        simpleGroupMode?: boolean;

        /**
         * Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
         * remote sort is requested. The {@link #directionParam} and {@link #sortParam} will be sent with the property name
         * and either 'ASC' or 'DESC'.
         *
         * Optional, Defaults to: false
         */
        simpleSortMode?: boolean;

        /**
         * The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to undefined if you don't
         * want to send a sort parameter.
         *
         * Optional, Defaults to: "sort"
         */
        sortParam?: string;

        /**
         * The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to undefined if you don't
         * want to send a start parameter.
         *
         * Optional, Defaults to: "start"
         */
        startParam?: string;

        /**
         * The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
         */
        timeout?: number;

        /**
         * The URL from which to request the data object.
         */
        url?: string;
    }

    /**
     * @author Ed Spencer
     *
     * ServerProxy is a superclass of {@link Ext.data.proxy.JsonP JsonPProxy} and {@link Ext.data.proxy.Ajax AjaxProxy}, and
     * would not usually be used directly.
     *
     * ServerProxy should ideally be named HttpProxy as it is a superclass for all HTTP proxies - for Ext JS 4.x it has been
     * called ServerProxy to enable any 3.x applications that reference the HttpProxy to continue to work (HttpProxy is now
     * an alias of AjaxProxy).
     */
    export class Server extends Ext.data.proxy.Proxy implements Ext.data.proxy.ServerConfig {
        /**
         * Specific urls to call on CRUD action methods "create", "read", "update" and "destroy". Defaults to:
         *
         *     api: {
         *         create  : undefined,
         *         read    : undefined,
         *         update  : undefined,
         *         destroy : undefined
         *     }
         *
         * The url is built based upon the action being executed [create|read|update|destroy] using the commensurate
         * {@link #api} property, or if undefined default to the configured
         * {@link Ext.data.Store}.{@link Ext.data.proxy.Server#url url}.
         *
         * For example:
         *
         *     api: {
         *         create  : '/controller/new',
         *         read    : '/controller/load',
         *         update  : '/controller/update',
         *         destroy : '/controller/destroy_action'
         *     }
         *
         * If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the
         * configured {@link Ext.data.proxy.Server#url url}.
         */
        api: any;

        /**
         * The name of the cache param added to the url when using noCache. Defaults to "_dc".
         *
         * Optional, Defaults to: "_dc"
         */
        cacheString: string;

        /**
         * The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
         * true.**
         *
         * Optional, Defaults to: "dir"
         */
        directionParam: string;

        /**
         * Extra parameters that will be included on every request. Individual requests with params of the same name
         * will override these params when they are in conflict.
         */
        extraParams: any;

        /**
         * The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to undefined if you don't
         * want to send a filter parameter.
         *
         * Optional, Defaults to: "filter"
         */
        filterParam: string;

        /**
         * The name of the direction parameter to send in a request. **This is only used when simpleGroupMode is set to
         * true.**
         *
         * Optional, Defaults to: "groupDir"
         */
        groupDirectionParam: string;

        /**
         * The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to undefined if you don't
         * want to send a group parameter.
         *
         * Optional, Defaults to: "group"
         */
        groupParam: string;

        /**
         * The name of the parameter which carries the id of the entity being operated upon.
         *
         * Optional, Defaults to: "id"
         */
        idParam: string;

        /**
         * The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to undefined if you don't
         * want to send a limit parameter.
         *
         * Optional, Defaults to: "limit"
         */
        limitParam: string;

        /**
         * Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
         *
         * Optional, Defaults to: true
         */
        noCache: boolean;

        /**
         * The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to undefined if you don't
         * want to send a page parameter.
         *
         * Optional, Defaults to: "page"
         */
        pageParam: string;

        /**
         * Enabling simpleGroupMode in conjunction with remoteGroup will only send one group property and a direction when a
         * remote group is requested. The {@link #groupDirectionParam} and {@link #groupParam} will be sent with the property name and either 'ASC'
         * or 'DESC'.
         *
         * Optional, Defaults to: false
         */
        simpleGroupMode: boolean;

        /**
         * Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
         * remote sort is requested. The {@link #directionParam} and {@link #sortParam} will be sent with the property name
         * and either 'ASC' or 'DESC'.
         *
         * Optional, Defaults to: false
         */
        simpleSortMode: boolean;

        /**
         * The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to undefined if you don't
         * want to send a sort parameter.
         *
         * Optional, Defaults to: "sort"
         */
        sortParam: string;

        /**
         * The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to undefined if you don't
         * want to send a start parameter.
         *
         * Optional, Defaults to: "start"
         */
        startParam: string;

        /**
         * The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
         */
        timeout: number;

        /**
         * The URL from which to request the data object.
         */
        url: string;

        /**
         * Optional callback function which can be used to clean up after a request has been completed.
         * @param {Ext.data.Request} request The Request object
         * @param {Boolean} success True if the request was successful
         */
        protected afterRequest(request: Ext.data.Request, success: boolean);

        /**
         * Creates an {@link Ext.data.Request Request} object from {@link Ext.data.Operation Operation}.
         *
         * This gets called from doRequest methods in subclasses of Server proxy.
         *
         * @param {Ext.data.Operation} operation The operation to execute
         * @return {Ext.data.Request} The request object
         */
        buildRequest(operation: Ext.data.Operation): Ext.data.Request;

        /**
         * Generates a url based on a given Ext.data.Request object. By default, ServerProxy's buildUrl will add the
         * cache-buster param to the end of the url. Subclasses may need to perform additional modifications to the url.
         * @param {Ext.data.Request} request The request object
         * @return {String} The url
         */
        buildUrl(request: Ext.data.Request): string;

        /**
         * Creates the Proxy
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.MemoryConfig);

        /**
         * In ServerProxy subclasses, the {@link #create}, {@link #read}, {@link #update} and {@link #destroy} methods all
         * pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see {@link
         * Ext.data.proxy.JsonP} and {@link Ext.data.proxy.Ajax} for examples. This method carries the same signature as
         * each of the methods that delegate to it.
         *
         * @param {Ext.data.Operation} operation The Ext.data.Operation object
         * @param {Function} callback The callback function to call when the Operation has completed
         * @param {Object} scope The scope in which to execute the callback
         */
        doRequest(operation: Ext.data.Operation, callback: Function, scope: any);

        /**
         * Encodes the array of {@link Ext.util.Filter} objects into a string to be sent in the request url. By default,
         * this simply JSON-encodes the filter data
         * @param {Ext.util.Filter[]} filters The array of {@link Ext.util.Filter Filter} objects
         * @return {String} The encoded filters
         */
        encodeFilters(filters: Ext.util.Filter): string;

        /**
         * Encodes the array of {@link Ext.util.Sorter} objects into a string to be sent in the request url. By default,
         * this simply JSON-encodes the sorter data
         * @param {Ext.util.Sorter[]} sorters The array of {@link Ext.util.Sorter Sorter} objects
         * @return {String} The encoded sorters
         */
        encodeSorters(sorters: Ext.util.Sorter): string;

        /**
         * Sets a value in the underlying {@link #extraParams}.
         * @param {String} name The key for the new value
         * @param {Object} value The value
         */
        setExtraParam(name: string, value: any);

        /**
         * Fires when the server returns an exception. This event may also be listened
         * to in the event that a request has timed out or has been aborted.
         * @param {Object} response The response from the AJAX request
         * @param {Ext.data.Operation} operation The operation that triggered request
         */
        exception(that: Ext.data.proxy.Proxy, response: any, operation: Ext.data.Operation);
    }

    /**
     * @author Ed Spencer
     *
     * Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
     * where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
     * unique ID which is used as a key in which all record data are stored in the session storage object.
     *
     * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
     * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
     *
     * Proxies are almost always used with a {@link Ext.data.Store store}:
     *
     *     new Ext.data.Store({
     *         proxy: {
     *             type: 'sessionstorage',
     *             id  : 'myProxyKey'
     *         }
     *     });
     *
     * Alternatively you can instantiate the Proxy directly:
     *
     *     new Ext.data.proxy.SessionStorage({
     *         id  : 'myOtherProxyKey'
     *     });
     *
     * Note that session storage is different to local storage (see {@link Ext.data.proxy.LocalStorage}) - if a browser
     * session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
     * don't affect the {@link Ext.data.proxy.LocalStorage} - the data are preserved.
     */
    export class SessionStorage extends Ext.data.proxy.WebStorage {
        /**
         * Creates the proxy, throws an error if local storage is not supported in the current browser.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.WebStorageConfig);
    }

    interface WebStorageConfig extends Ext.data.proxy.ProxyConfig {
        /**
         * The unique ID used as the key in which all record data are stored in the local storage object.
         */
        id?: string;
    }

    /**
     * @author Ed Spencer
     *
     * WebStorageProxy is simply a superclass for the {@link Ext.data.proxy.LocalStorage LocalStorage} and {@link
     * Ext.data.proxy.SessionStorage SessionStorage} proxies. It uses the new HTML5 key/value client-side storage objects to
     * save {@link Ext.data.Model model instances} for offline use.
     */
    export class WebStorage extends Ext.data.proxy.Client implements Ext.data.proxy.WebStorageConfig {
        /**
         * Cached map of records already retrieved by this Proxy. Ensures that the same instance is always retrieved.
         */
        cache: any;

        /**
         * The unique ID used as the key in which all record data are stored in the local storage object.
         */
        id: string;

        /**
         * Destroys all records stored in the proxy and removes all keys and values used to support the proxy from the
         * storage object.
         */
        clear();

        /**
         * Creates the proxy, throws an error if local storage is not supported in the current browser.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.proxy.WebStorageConfig);

        /**
         * Saves the given record in the Proxy.
         * @param {Ext.data.Model} record The model instance
         * @param {String} [id] The id to save the record under (defaults to the value of the record's getId() function)
         */
        setRecord(record: Ext.data.Model, id?: string);
    }
}

declare module Ext.data.reader {
    interface ArrayConfig extends Ext.data.reader.JsonConfig {
        successProperty?: any;

        totalProperty?: any;
    }

    export class Array extends Ext.data.reader.Json implements Ext.data.reader.ArrayConfig {
        successProperty: string;

        totalProperty: string;

        /**
         * @author Ed Spencer
         *
         * <p>Data reader class to create an Array of {@link Ext.data.Model} objects from an Array.
         * Each element of that Array represents a row of data fields. The
         * fields are pulled into a Record object using as a subscript, the <code>mapping</code> property
         * of the field definition if it exists, or the field's ordinal position in the definition.</p>
         *
         * <p><u>Example code:</u></p>
         *
         <pre><code>
         Employee = Ext.define('Employee', {
         extend: 'Ext.data.Model',
         fields: [
         'id',
         {name: 'name', mapping: 1},         // "mapping" only needed if an "id" field is present which
         {name: 'occupation', mapping: 2}    // precludes using the ordinal position as the index.
         ]
         });
         var myReader = new Ext.data.reader.Array({
         model: 'Employee'
         }, Employee);
         </code></pre>
         *
         * <p>This would consume an Array like this:</p>
         *
         <pre><code>
         [ [1, 'Bill', 'Gardener'], [2, 'Ben', 'Horticulturalist'] ]
         </code></pre>
         *
         * @constructor
         * Create a new ArrayReader
         * @param {Object} meta Metadata configuration options.
         */
        constructor(meta: any);
    }

    interface JsonConfig extends Ext.data.reader.ReaderConfig {
        /**
         * Name of the property from which to retrieve the 'metaData' attribute. See {@link #metaData}.
         *
         * Optional, Defaults to: "metaData"
         */
        metaProperty?: string;

        /**
         * The optional location within the JSON response that the record data itself can be found at.
         * See the JsonReader intro docs for more details. This is not often needed.
         */
        record?: string;

        root?: any;

        /**
         * True to ensure that field names/mappings are treated as literals when
         * reading values.
         *
         * For example, by default, using the mapping "foo.bar.baz" will try and read a property foo from the root, then a property bar
         * from foo, then a property baz from bar. Setting the simple accessors to true will read the property with the name
         * "foo.bar.baz" direct from the root object.
         */
        useSimpleAccessors?: boolean;
    }

    /**
     * @author Ed Spencer
     *
     * The JSON Reader is used by a Proxy to read a server response that is sent back in JSON format. This usually
     * happens as a result of loading a Store - for example we might create something like this:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email']
     *     });
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'ajax',
     *             url : 'users.json',
     *             reader: {
     *                 type: 'json'
     *             }
     *         }
     *     });
     *
     * The example above creates a 'User' model. Models are explained in the {@link Ext.data.Model Model} docs if you're
     * not already familiar with them.
     *
     * We created the simplest type of JSON Reader possible by simply telling our {@link Ext.data.Store Store}'s
     * {@link Ext.data.proxy.Proxy Proxy} that we want a JSON Reader. The Store automatically passes the configured model to the
     * Store, so it is as if we passed this instead:
     *
     *     reader: {
     *         type : 'json',
     *         model: 'User'
     *     }
     *
     * The reader we set up is ready to read data from our server - at the moment it will accept a response like this:
     *
     *     [
     *         {
     *             "id": 1,
     *             "name": "Ed Spencer",
     *             "email": "ed@sencha.com"
     *         },
     *         {
     *             "id": 2,
     *             "name": "Abe Elias",
     *             "email": "abe@sencha.com"
     *         }
     *     ]
     *
     * ## Reading other JSON formats
     *
     * If you already have your JSON format defined and it doesn't look quite like what we have above, you can usually
     * pass JsonReader a couple of configuration options to make it parse your format. For example, we can use the
     * {@link #cfg-root} configuration to parse data that comes back like this:
     *
     *     {
     *         "users": [
     *            {
     *                "id": 1,
     *                "name": "Ed Spencer",
     *                "email": "ed@sencha.com"
     *            },
     *            {
     *                "id": 2,
     *                "name": "Abe Elias",
     *                "email": "abe@sencha.com"
     *            }
     *         ]
     *     }
     *
     * To parse this we just pass in a {@link #root} configuration that matches the 'users' above:
     *
     *     reader: {
     *         type: 'json',
     *         root: 'users'
     *     }
     *
     * Sometimes the JSON structure is even more complicated. Document databases like CouchDB often provide metadata
     * around each record inside a nested structure like this:
     *
     *     {
     *         "total": 122,
     *         "offset": 0,
     *         "users": [
     *             {
     *                 "id": "ed-spencer-1",
     *                 "value": 1,
     *                 "user": {
     *                     "id": 1,
     *                     "name": "Ed Spencer",
     *                     "email": "ed@sencha.com"
     *                 }
     *             }
     *         ]
     *     }
     *
     * In the case above the record data is nested an additional level inside the "users" array as each "user" item has
     * additional metadata surrounding it ('id' and 'value' in this case). To parse data out of each "user" item in the
     * JSON above we need to specify the {@link #record} configuration like this:
     *
     *     reader: {
     *         type  : 'json',
     *         root  : 'users',
     *         record: 'user'
     *     }
     *
     * ## Response MetaData
     *
     * The server can return metadata in its response, in addition to the record data, that describe attributes
     * of the data set itself or are used to reconfigure the Reader. To pass metadata in the response you simply
     * add a 'metaData' attribute to the root of the response data. The metaData attribute can contain anything,
     * but supports a specific set of properties that are handled by the Reader if they are present:
     *
     * - {@link #root}: the property name of the root response node containing the record data
     * - {@link #idProperty}: property name for the primary key field of the data
     * - {@link #totalProperty}: property name for the total number of records in the data
     * - {@link #successProperty}: property name for the success status of the response
     * - {@link #messageProperty}: property name for an optional response message
     * - {@link Ext.data.Model#cfg-fields fields}: Config used to reconfigure the Model's fields before converting the
     * response data into records
     *
     * An initial Reader configuration containing all of these properties might look like this ("fields" would be
     * included in the Model definition, not shown):
     *
     *     reader: {
     *         type : 'json',
     *         root : 'root',
     *         idProperty     : 'id',
     *         totalProperty  : 'total',
     *         successProperty: 'success',
     *         messageProperty: 'message'
     *     }
     *
     * If you were to pass a response object containing attributes different from those initially defined above, you could
     * use the 'metaData' attribute to reconifgure the Reader on the fly. For example:
     *
     *     {
     *         "count": 1,
     *         "ok": true,
     *         "msg": "Users found",
     *         "users": [{
     *             "userId": 123,
     *             "name": "Ed Spencer",
     *             "email": "ed@sencha.com"
     *         }],
     *         "metaData": {
     *             "root": "users",
     *             "idProperty": 'userId',
     *             "totalProperty": 'count',
     *             "successProperty": 'ok',
     *             "messageProperty": 'msg'
     *         }
     *     }
     *
     * You can also place any other arbitrary data you need into the 'metaData' attribute which will be ignored by the Reader,
     * but will be accessible via the Reader's {@link #metaData} property (which is also passed to listeners via the Proxy's
     * {@link Ext.data.proxy.Proxy#metachange metachange} event (also relayed by the {@link Ext.data.AbstractStore#metachange
     * store}). Application code can then process the passed metadata in any way it chooses.
     *
     * A simple example for how this can be used would be customizing the fields for a Model that is bound to a grid. By passing
     * the 'fields' property the Model will be automatically updated by the Reader internally, but that change will not be
     * reflected automatically in the grid unless you also update the column configuration. You could do this manually, or you
     * could simply pass a standard grid {@link Ext.panel.Table#columns column} config object as part of the 'metaData' attribute
     * and then pass that along to the grid. Here's a very simple example for how that could be accomplished:
     *
     *     // response format:
     *     {
     *         ...
     *         "metaData": {
     *             "fields": [
     *                 { "name": "userId", "type": "int" },
     *                 { "name": "name", "type": "string" },
     *                 { "name": "birthday", "type": "date", "dateFormat": "Y-j-m" },
     *             ],
     *             "columns": [
     *                 { "text": "User ID", "dataIndex": "userId", "width": 40 },
     *                 { "text": "User Name", "dataIndex": "name", "flex": 1 },
     *                 { "text": "Birthday", "dataIndex": "birthday", "flex": 1, "format": 'Y-j-m', "xtype": "datecolumn" }
     *             ]
     *         }
     *     }
     *
     * The Reader will automatically read the meta fields config and rebuild the Model based on the new fields, but to handle
     * the new column configuration you would need to handle the metadata within the application code. This is done simply enough
     * by handling the metachange event on either the store or the proxy, e.g.:
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         ...
     *         listeners: {
     *             'metachange': function(store, meta) {
     *                 myGrid.reconfigure(store, meta.columns);
     *             }
     *         }
     *     });
     */
    export class Json extends Ext.data.reader.Reader implements Ext.data.reader.JsonConfig {
        /**
         * A copy of this.rawData.
         * @deprecated Will be removed in Ext JS 5.0. This is just a copy of this.rawData - use that instead.
         */
        jsonData: any;

        /**
         * Name of the property from which to retrieve the 'metaData' attribute. See {@link #metaData}.
         *
         * Optional, Defaults to: "metaData"
         */
        metaProperty: string;

        /**
         * The optional location within the JSON response that the record data itself can be found at.
         * See the JsonReader intro docs for more details. This is not often needed.
         */
        record: string;

        root: string;

        /**
         * True to ensure that field names/mappings are treated as literals when
         * reading values.
         *
         * For example, by default, using the mapping "foo.bar.baz" will try and read a property foo from the root, then a property bar
         * from foo, then a property baz from bar. Setting the simple accessors to true will read the property with the name
         * "foo.bar.baz" direct from the root object.
         */
        useSimpleAccessors: boolean;

        /**
         * Creates new Reader.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.reader.JsonConfig);

        /**
         * Reads a JSON object and returns a ResultSet. Uses the internal getTotal and getSuccess extractors to
         * retrieve meta data from the response, and extractData to turn the JSON data into model instances.
         * @param {Object} data The raw JSON data
         * @return {Ext.data.ResultSet} A ResultSet containing model instances and meta data about the results
         */
        readRecords(data: any): Ext.data.ResultSet;
    }

    interface ReaderConfig {
        /**
         * Name of the property within a row object that contains a record identifier value. Defaults to the id of the
         * model. If an idProperty is explicitly specified it will take precedence over idProperty defined on the model.
         */
        idProperty?: string;

        /**
         * True to automatically parse models nested within other models in a response object. See the
         * Ext.data.reader.Reader intro docs for full explanation.
         *
         * Optional, Defaults to: true
         */
        implicitIncludes?: boolean;

        /**
         * The name of the property which contains a response message. This property is optional.
         */
        messageProperty?: string;

        /**
         * True to extract the records from a data packet even if the {@link #successProperty} returns false.
         *
         * Optional, Defaults to: true
         */
        readRecordsOnFailure?: boolean;

        /**
         * The name of the property which contains the data items corresponding to the Model(s) for which this
         * Reader is configured.  For JSON reader it's a property name (or a dot-separated list of property names
         * if the root is nested).  For XML reader it's a CSS selector.  For Array reader the root is not applicable
         * since the data is assumed to be a single-level array of arrays.
         *
         * By default the natural root of the data will be used: the root JSON array, the root XML element, or the array.
         *
         * The data packet value for this property should be an empty array to clear the data or show no data.
         *
         * Optional
         */
        root?: string;

        /**
         * Name of the property from which to retrieve the 'success' attribute, the value of which indicates
         * whether a given request succeeded or failed (typically a boolean or 'true'|'false'). See
         * {@link Ext.data.proxy.Server}.{@link Ext.data.proxy.Server#exception exception} for additional information.
         *
         * Optional, Defaults to: "success"
         */
        successProperty?: string;

        /**
         * Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
         * the whole dataset is not passed in one go, but is being paged from the remote server.
         *
         * Optional, Defaults to: "total"
         */
        totalProperty?: string;
    }

    /**
     * @author Ed Spencer
     *
     * Readers are used to interpret data to be loaded into a {@link Ext.data.Model Model} instance or a {@link
     * Ext.data.Store Store} - often in response to an AJAX request. In general there is usually no need to create
     * a Reader instance directly, since a Reader is almost always used together with a {@link Ext.data.proxy.Proxy Proxy},
     * and is configured using the Proxy's {@link Ext.data.proxy.Proxy#cfg-reader reader} configuration property:
     *
     *     Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'ajax',
     *             url : 'users.json',
     *             reader: {
     *                 type: 'json',
     *                 root: 'users'
     *             }
     *         },
     *     });
     *
     * The above reader is configured to consume a JSON string that looks something like this:
     *
     *     {
     *         "success": true,
     *         "users": [
     *             { "name": "User 1" },
     *             { "name": "User 2" }
     *         ]
     *     }
     *
     *
     * # Loading Nested Data
     *
     * Readers have the ability to automatically load deeply-nested data objects based on the {@link Ext.data.association.Association
     * associations} configured on each Model. Below is an example demonstrating the flexibility of these associations in a
     * fictional CRM system which manages a User, their Orders, OrderItems and Products. First we'll define the models:
     *
     *     Ext.define("User", {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'id', 'name'
     *         ],
     *
     *         hasMany: {model: 'Order', name: 'orders'},
     *
     *         proxy: {
     *             type: 'rest',
     *             url : 'users.json',
     *             reader: {
     *                 type: 'json',
     *                 root: 'users'
     *             }
     *         }
     *     });
     *
     *     Ext.define("Order", {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'id', 'total'
     *         ],
     *
     *         hasMany  : {model: 'OrderItem', name: 'orderItems', associationKey: 'order_items'},
     *         belongsTo: 'User'
     *     });
     *
     *     Ext.define("OrderItem", {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'id', 'price', 'quantity', 'order_id', 'product_id'
     *         ],
     *
     *         belongsTo: ['Order', {model: 'Product', associationKey: 'product'}]
     *     });
     *
     *     Ext.define("Product", {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             'id', 'name'
     *         ],
     *
     *         hasMany: 'OrderItem'
     *     });
     *
     * This may be a lot to take in - basically a User has many Orders, each of which is composed of several OrderItems.
     * Finally, each OrderItem has a single Product. This allows us to consume data like this:
     *
     *     {
     *         "users": [
     *             {
     *                 "id": 123,
     *                 "name": "Ed",
     *                 "orders": [
     *                     {
     *                         "id": 50,
     *                         "total": 100,
     *                         "order_items": [
     *                             {
     *                                 "id"      : 20,
     *                                 "price"   : 40,
     *                                 "quantity": 2,
     *                                 "product" : {
     *                                     "id": 1000,
     *                                     "name": "MacBook Pro"
     *                                 }
     *                             },
     *                             {
     *                                 "id"      : 21,
     *                                 "price"   : 20,
     *                                 "quantity": 3,
     *                                 "product" : {
     *                                     "id": 1001,
     *                                     "name": "iPhone"
     *                                 }
     *                             }
     *                         ]
     *                     }
     *                 ]
     *             }
     *         ]
     *     }
     *
     * The JSON response is deeply nested - it returns all Users (in this case just 1 for simplicity's sake), all of the
     * Orders for each User (again just 1 in this case), all of the OrderItems for each Order (2 order items in this case),
     * and finally the Product associated with each OrderItem. Now we can read the data and use it as follows:
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: "User"
     *     });
     *
     *     store.load({
     *         callback: function() {
     *             //the user that was loaded
     *             var user = store.first();
     *
     *             console.log("Orders for " + user.get('name') + ":")
     *
     *             //iterate over the Orders for each User
     *             user.orders().each(function(order) {
     *                 console.log("Order ID: " + order.getId() + ", which contains items:");
     *
     *                 //iterate over the OrderItems for each Order
     *                 order.orderItems().each(function(orderItem) {
     *                     //we know that the Product data is already loaded, so we can use the synchronous getProduct
     *                     //usually, we would use the asynchronous version (see {@link Ext.data.association.BelongsTo})
     *                     var product = orderItem.getProduct();
     *
     *                     console.log(orderItem.get('quantity') + ' orders of ' + product.get('name'));
     *                 });
     *             });
     *         }
     *     });
     *
     * Running the code above results in the following:
     *
     *     Orders for Ed:
     *     Order ID: 50, which contains items:
     *     2 orders of MacBook Pro
     *     3 orders of iPhone
     */
    export class Reader extends Ext.Base implements Ext.data.reader.ReaderConfig {
        /**
         * The raw meta data that was most recently read, if any. Meta data can include existing
         * Reader config options like {@link #idProperty}, {@link #totalProperty}, etc. that get
         * automatically applied to the Reader, and those can still be accessed directly from the Reader
         * if needed. However, meta data is also often used to pass other custom data to be processed
         * by application code. For example, it is common when reconfiguring the data model of a grid to
         * also pass a corresponding column model config to be applied to the grid. Any such data will
         * not get applied to the Reader directly (it just gets passed through and is ignored by Ext).
         * This metaData property gives you access to all meta data that was passed, including any such
         * custom data ignored by the reader.
         *
         * This is a read-only property, and it will get replaced each time a new meta data object is
         * passed to the reader. Note that typically you would handle proxy's
         * {@link Ext.data.proxy.Proxy#metachange metachange} event which passes this exact same meta
         * object to listeners. However this property is available if it's more convenient to access it
         * via the reader directly in certain cases.
         * @readonly
         */
        metaData: any;

        /**
         * The raw data object that was last passed to {@link #readRecords}. Stored for further processing if needed.
         */
        rawData: any;

        /**
         * Name of the property within a row object that contains a record identifier value. Defaults to the id of the
         * model. If an idProperty is explicitly specified it will take precedence over idProperty defined on the model.
         */
        idProperty: string;

        /**
         * True to automatically parse models nested within other models in a response object. See the
         * Ext.data.reader.Reader intro docs for full explanation.
         *
         * Optional, Defaults to: true
         */
        implicitIncludes: boolean;

        /**
         * The name of the property which contains a response message. This property is optional.
         */
        messageProperty: string;

        /**
         * True to extract the records from a data packet even if the {@link #successProperty} returns false.
         *
         * Optional, Defaults to: true
         */
        readRecordsOnFailure: boolean;

        /**
         * The name of the property which contains the data items corresponding to the Model(s) for which this
         * Reader is configured.  For JSON reader it's a property name (or a dot-separated list of property names
         * if the root is nested).  For XML reader it's a CSS selector.  For Array reader the root is not applicable
         * since the data is assumed to be a single-level array of arrays.
         *
         * By default the natural root of the data will be used: the root JSON array, the root XML element, or the array.
         *
         * The data packet value for this property should be an empty array to clear the data or show no data.
         *
         * Optional
         */
        root: string;

        /**
         * Name of the property from which to retrieve the 'success' attribute, the value of which indicates
         * whether a given request succeeded or failed (typically a boolean or 'true'|'false'). See
         * {@link Ext.data.proxy.Server}.{@link Ext.data.proxy.Server#exception exception} for additional information.
         *
         * Optional, Defaults to: "success"
         */
        successProperty: string;

        /**
         * Name of the property from which to retrieve the total number of records in the dataset. This is only needed if
         * the whole dataset is not passed in one go, but is being paged from the remote server.
         *
         * Optional, Defaults to: "total"
         */
        totalProperty: string;

        /**
         * Creates new Reader.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.reader.JsonConfig);

        /**
         * Takes a raw response object (as passed to the {@link #read} method) and returns the useful data
         * segment from it. This must be implemented by each subclass.
         * @param {Object} response The response object
         * @return {Ext.data.ResultSet} A ResultSet object
         */
        getResponseData(response: any): Ext.data.ResultSet;

        /**
         * Reads the given response object. This method normalizes the different types of response object that may be passed to it.
         * If it's an XMLHttpRequest object, hand off to the subclass' {@link #getResponseData} method.
         * Else, hand off the reading of records to the {@link #readRecords} method.
         * @param {Object} response The response object. This may be either an XMLHttpRequest object or a plain JS object
         * @return {Ext.data.ResultSet} The parsed or default ResultSet object
         */
        read(response: any): Ext.data.ResultSet;

        /**
         * Abstracts common functionality used by all Reader subclasses. Each subclass is expected to call this function
         * before running its own logic and returning the Ext.data.ResultSet instance. For most Readers additional
         * processing should not be needed.
         * @param {Object} data The raw data object
         * @return {Ext.data.ResultSet} A ResultSet object
         */
        readRecords(data: any): Ext.data.ResultSet;

        /**
         * Fires when the reader receives improperly encoded data from the server
         * @param {Ext.data.reader.Reader} reader A reference to this reader
         * @param {XMLHttpRequest} response The XMLHttpRequest response object
         * @param {Ext.data.ResultSet} error The error object
         */
        exception(reader: Ext.data.reader.Reader, response: any, error: Ext.data.ResultSet);
    }

    interface XmlConfig extends Ext.data.reader.ReaderConfig {
        /**
         * A namespace prefix that will be prepended to the field name when reading a
         * field from an XML node.  Take, for example, the following Model:
         *
         *     Ext.define('Foo', {
         *         extend: 'Ext.data.Model',
         *         fields: ['bar', 'baz']
         *     });
         *
         * The reader would need to be configured with a namespace of 'n' in order to read XML
         * data in the following format:
         *
         *     <foo>
         *         <n:bar>bar</n:bar>
         *         <n:baz>baz</n:baz>
         *     </foo>
         */
        namespace?: string;

        /**
         * (required)
         * The DomQuery path to the repeated element which contains record information.
         *
         * By default, the elements which match the selector may be nested at any level below the {@link #root}
         *
         * If this Reader is being used by a {@link Ext.data.TreeStore TreeStore} to read tree-structured data,
         * then only first generation child nodes of the root element must be selected, so the record selector must be
         * specified with a more specific selector which will not select all descendants. For example:
         *
         *    record: '>node'
         */
        record?: string;
    }

    /**
     * @author Ed Spencer
     *
     * The XML Reader is used by a Proxy to read a server response that is sent back in XML format. This usually happens as
     * a result of loading a Store - for example we might create something like this:
     *
     *     Ext.define('User', {
     *         extend: 'Ext.data.Model',
     *         fields: ['id', 'name', 'email']
     *     });
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         model: 'User',
     *         proxy: {
     *             type: 'ajax',
     *             url : 'users.xml',
     *             reader: {
     *                 type: 'xml',
     *                 record: 'user',
     *                 root: 'users'
     *             }
     *         }
     *     });
     *
     * The example above creates a 'User' model. Models are explained in the {@link Ext.data.Model Model} docs if you're not
     * already familiar with them.
     *
     * We created the simplest type of XML Reader possible by simply telling our {@link Ext.data.Store Store}'s {@link
     * Ext.data.proxy.Proxy Proxy} that we want a XML Reader. The Store automatically passes the configured model to the
     * Store, so it is as if we passed this instead:
     *
     *     reader: {
     *         type : 'xml',
     *         model: 'User',
     *         record: 'user',
     *         root: 'users'
     *     }
     *
     * The reader we set up is ready to read data from our server - at the moment it will accept a response like this:
     *
     *     <?xml version="1.0" encoding="UTF-8"?>
     *     <users>
     *         <user>
     *             <id>1</id>
     *             <name>Ed Spencer</name>
     *             <email>ed@sencha.com</email>
     *         </user>
     *         <user>
     *             <id>2</id>
     *             <name>Abe Elias</name>
     *             <email>abe@sencha.com</email>
     *         </user>
     *     </users>
     *
     * First off there's {@link #root} option to define the root node '<users>' (there should be only one in a well-formed
     * XML document). Then the XML Reader uses the configured {@link #record} option to pull out the data for each record -
     * in this case we set record to 'user', so each '<user>' above will be converted into a User model.
     *
     * Note that XmlReader doesn't care whether your {@link #root} and {@link #record} elements are nested deep inside a
     * larger structure, so a response like this will still work:
     *
     *     <?xml version="1.0" encoding="UTF-8"?>
     *     <deeply>
     *         <nested>
     *             <xml>
     *                 <users>
     *                     <user>
     *                         <id>1</id>
     *                         <name>Ed Spencer</name>
     *                         <email>ed@sencha.com</email>
     *                     </user>
     *                     <user>
     *                         <id>2</id>
     *                         <name>Abe Elias</name>
     *                         <email>abe@sencha.com</email>
     *                     </user>
     *                 </users>
     *             </xml>
     *         </nested>
     *     </deeply>
     *
     * If this Reader is being used by a {@link Ext.data.TreeStore TreeStore} to read tree-structured data in which records
     * are nested as descendant nodes of other records, then this lenient behaviour must be overridden by using a more specific
     * child node selector as your {@link #record} selector which will not select all descendants, such as:
     *
     *    record: '>user'
     *
     * # Response metadata
     *
     * The server can return additional data in its response, such as the {@link #totalProperty total number of records} and
     * the {@link #successProperty success status of the response}. These are typically included in the XML response like
     * this:
     *
     *     <?xml version="1.0" encoding="UTF-8"?>
     *     <users>
     *         <total>100</total>
     *         <success>true</success>
     *         <user>
     *             <id>1</id>
     *             <name>Ed Spencer</name>
     *             <email>ed@sencha.com</email>
     *         </user>
     *         <user>
     *             <id>2</id>
     *             <name>Abe Elias</name>
     *             <email>abe@sencha.com</email>
     *         </user>
     *     </users>
     *
     * If these properties are present in the XML response they can be parsed out by the XmlReader and used by the Store
     * that loaded it. We can set up the names of these properties by specifying a final pair of configuration options:
     *
     *     reader: {
     *         type: 'xml',
     *         root: 'users',
     *         totalProperty  : 'total',
     *         successProperty: 'success'
     *     }
     *
     * These final options are not necessary to make the Reader work, but can be useful when the server needs to report an
     * error or if it needs to indicate that there is a lot of data available of which only a subset is currently being
     * returned.
     *
     * # Response format
     *
     * **Note:** in order for the browser to parse a returned XML document, the Content-Type header in the HTTP response
     * must be set to "text/xml" or "application/xml". This is very important - the XmlReader will not work correctly
     * otherwise.
     */
    export class Xml extends Ext.data.reader.Reader implements Ext.data.reader.XmlConfig {
        /**
         * Copy of {@link #rawData}.
         * @deprecated Will be removed in Ext JS 5.0. Use {@link #rawData} instead.
         */
        xmlData: any;

        /**
         * A namespace prefix that will be prepended to the field name when reading a
         * field from an XML node.  Take, for example, the following Model:
         *
         *     Ext.define('Foo', {
         *         extend: 'Ext.data.Model',
         *         fields: ['bar', 'baz']
         *     });
         *
         * The reader would need to be configured with a namespace of 'n' in order to read XML
         * data in the following format:
         *
         *     <foo>
         *         <n:bar>bar</n:bar>
         *         <n:baz>baz</n:baz>
         *     </foo>
         */
        namespace: string;

        /**
         * (required)
         * The DomQuery path to the repeated element which contains record information.
         *
         * By default, the elements which match the selector may be nested at any level below the {@link #root}
         *
         * If this Reader is being used by a {@link Ext.data.TreeStore TreeStore} to read tree-structured data,
         * then only first generation child nodes of the root element must be selected, so the record selector must be
         * specified with a more specific selector which will not select all descendants. For example:
         *
         *    record: '>node'
         */
        record: string;

        /**
         * Creates new Reader.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.data.reader.JsonConfig);

        /**
         * Normalizes the data object.
         * @param {Object} data The raw data object
         * @return {Object} The documentElement property of the data object if present, or the same object if not.
         */
        getData(data: any): any;
    }
}

declare module Ext.data.writer {
    interface JsonConfig extends Ext.data.writer.WriterConfig {
        /**
         * Configure with 'false' to ensure that records are always wrapped in an array, even if there is only
         * one record being sent. When there is more than one record, they will always be encoded into an array.
         *
         * Optional, Defaults to: true
         */
        allowSingle?: boolean;

        /**
         * Configure 'true' to send record data (all record fields if {@link #writeAllFields} is 'true')
         * as a JSON encoded HTTP parameter named by the {@link #root} configuration.
         *
         * The encode option should only be set to true when a {@link #root} is defined, because the values will be
         * sent as part of the request parameters as opposed to a raw post. The root will be the name of the parameter
         * sent to the server.
         *
         * Optional, Defaults to: false
         */
        encode?: boolean;

        /**
         * By default, when dot-delimited field {@link #nameProperty mappings} are
         * used (e.g. 'name: 'myProperty', mapping: 'my.nested.property'') the writer will simply output a flat data
         * object containing the mapping string literal as the property name (e.g. '{ 'my.nested.property': 'foo' }').
         *
         * Mappings are used to map incoming nested JSON to flat Ext models. In many case, the data output by the
         * writer should preferrably match the original nested data format. Setting this config to 'true' will ensure
         * that the output will instead look like '{ my: { nested: { property: 'foo' }}}'. The output is generated
         * by {@link #getExpandedData}, which can optionally be overridden to apply more customized logic.
         *
         * Optional, Defaults to: false
         */
        expandData?: boolean;

        /**
         * The HTTP parameter name by which JSON encoded records will be passed to the server if the
         * {@link #encode} option is 'true'.
         */
        root?: string;
    }

    /**
     This class is used to write {@link Ext.data.Model} data to the server in a JSON format.
     The {@link #allowSingle} configuration can be set to false to force the records to always be
     encoded in an array, even if there is only a single record being sent.
     * @markdown
     */
    export class Json extends Ext.data.writer.Writer implements Ext.data.writer.JsonConfig {
        /**
         * Configure with 'false' to ensure that records are always wrapped in an array, even if there is only
         * one record being sent. When there is more than one record, they will always be encoded into an array.
         *
         * Optional, Defaults to: true
         */
        allowSingle: boolean;

        /**
         * Configure 'true' to send record data (all record fields if {@link #writeAllFields} is 'true')
         * as a JSON encoded HTTP parameter named by the {@link #root} configuration.
         *
         * The encode option should only be set to true when a {@link #root} is defined, because the values will be
         * sent as part of the request parameters as opposed to a raw post. The root will be the name of the parameter
         * sent to the server.
         *
         * Optional, Defaults to: false
         */
        encode: boolean;

        /**
         * By default, when dot-delimited field {@link #nameProperty mappings} are
         * used (e.g. 'name: 'myProperty', mapping: 'my.nested.property'') the writer will simply output a flat data
         * object containing the mapping string literal as the property name (e.g. '{ 'my.nested.property': 'foo' }').
         *
         * Mappings are used to map incoming nested JSON to flat Ext models. In many case, the data output by the
         * writer should preferrably match the original nested data format. Setting this config to 'true' will ensure
         * that the output will instead look like '{ my: { nested: { property: 'foo' }}}'. The output is generated
         * by {@link #getExpandedData}, which can optionally be overridden to apply more customized logic.
         *
         * Optional, Defaults to: false
         */
        expandData: boolean;

        /**
         * The HTTP parameter name by which JSON encoded records will be passed to the server if the
         * {@link #encode} option is 'true'.
         */
        root: string;

        /**
         * Creates new Writer.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.writer.JsonConfig);

        /**
         * The Reader classes support dot-delimited data mappings for extracting nested raw data into fields, so the
         * writer must support converting the flat {@link Ext.data.Model} structure back into the original nested data
         * format. Using the same mappings when available, the Writer will simply split each delimiter into a nested
         * object in the output, which should exactly match the input format. For example, record data like this:
         *
         *     my.nested.property: 'foo',
         *     my.nested.another: 'bar',
         *     my.somethingElse: 123
         *
         * should write out as...
         *
         *     my: {
         *         nested: {
         *             property: 'foo',
         *             another: 'bar
         *         },
         *         somethingElse: 123
         *     }
         *
         * This behavior is governed by the {@link #expandData} config. By default, this option is 'false' for
         * compatibility reasons, and will output a flat structure matching the flat record format. Setting this config
         * to 'true' will enable the expanded mapping behavior as shown here. This method could also be overridden
         * to provide an even more customized output data structure.
         */
        protected getExpandedData();
    }

    interface WriterConfig {
        /**
         * This is used for each field of type date in the model to format the value before
         * it is sent to the server.
         */
        dateFormat?: string;

        /**
         * This property is used to read the key for each value that will be sent to the server. For example:
         *
         *     Ext.define('Person', {
         *         extend: 'Ext.data.Model',
         *         fields: [{
         *             name: 'first',
         *             mapping: 'firstName'
         *         }, {
         *             name: 'last',
         *             mapping: 'lastName'
         *         }, {
         *             name: 'age'
         *         }]
         *     });
         *     new Ext.data.writer.Writer({
         *         writeAllFields: true,
         *         nameProperty: 'mapping'
         *     });
         *
         *     // This will be sent to the server
         *     {
         *         firstName: 'first name value',
         *         lastName: 'last name value',
         *         age: 1
         *     }
         *
         * If the value is not present, the field name will always be used.
         */
        nameProperty?: string;

        /**
         * True to write all fields from the record to the server. If set to false it will only send the fields that were
         * modified. Note that any fields that have {@link Ext.data.Field#persist} set to false will still be ignored.
         */
        writeAllFields?: boolean;

        /**
         * By default, each record's id is always included in the output for non-phantom records since in most
         * cases the id will be required on the server to process the record action. This is helpful since the id
         * will normally not be modified, and so would not be sent to the server unless {@link #writeAllFields}
         * was explicitly enabled.
         *
         * However, there are cases where it is not desirable for the record id to be passed in the data directly.
         * For example, when using a RESTful API the record id would typically be appended to the url instead.
         *
         * Optional
         */
        writeRecordId?: boolean;
    }

    /**
     * @author Ed Spencer
     *
     * Base Writer class used by most subclasses of {@link Ext.data.proxy.Server}. This class is responsible for taking a
     * set of {@link Ext.data.Operation} objects and a {@link Ext.data.Request} object and modifying that request based on
     * the Operations.
     *
     * For example a Ext.data.writer.Json would format the Operations and their {@link Ext.data.Model} instances based on
     * the config options passed to the JsonWriter's constructor.
     *
     * Writers are not needed for any kind of local storage - whether via a {@link Ext.data.proxy.WebStorage Web Storage
     * proxy} (see {@link Ext.data.proxy.LocalStorage localStorage} and {@link Ext.data.proxy.SessionStorage
     * sessionStorage}) or just in memory via a {@link Ext.data.proxy.Memory MemoryProxy}.
     *
     * # Dates
     * Before sending dates to the server, they can be formatted using one of the {@link Ext.Date} formats.
     * These formats can be specified both on the field and the writer itself. In terms of precedence, from highest to lowest:
     *
     * -  {@link #dateFormat Writer.dateFormat} The writer dateFormat will always have the highest precedence
     * -  {@link Ext.data.Field#dateWriteFormat} The dateWriteFormat will be used if no format is specified on the writer
     * -  {@link Ext.data.Field#dateFormat Field.dateFormat}/{@link Ext.data.Field#dateReadFormat Field.dateReadFormat}
     * Finally, if none of the above options are specified the field will be formatted using the format that was used to read the date from the server.
     */
    export class Writer extends Ext.Base implements Ext.data.writer.WriterConfig {
        /**
         * This is used for each field of type date in the model to format the value before
         * it is sent to the server.
         */
        dateFormat: string;

        /**
         * This property is used to read the key for each value that will be sent to the server. For example:
         *
         *     Ext.define('Person', {
         *         extend: 'Ext.data.Model',
         *         fields: [{
         *             name: 'first',
         *             mapping: 'firstName'
         *         }, {
         *             name: 'last',
         *             mapping: 'lastName'
         *         }, {
         *             name: 'age'
         *         }]
         *     });
         *     new Ext.data.writer.Writer({
         *         writeAllFields: true,
         *         nameProperty: 'mapping'
         *     });
         *
         *     // This will be sent to the server
         *     {
         *         firstName: 'first name value',
         *         lastName: 'last name value',
         *         age: 1
         *     }
         *
         * If the value is not present, the field name will always be used.
         */
        nameProperty: string;

        /**
         * True to write all fields from the record to the server. If set to false it will only send the fields that were
         * modified. Note that any fields that have {@link Ext.data.Field#persist} set to false will still be ignored.
         */
        writeAllFields: boolean;

        /**
         * By default, each record's id is always included in the output for non-phantom records since in most
         * cases the id will be required on the server to process the record action. This is helpful since the id
         * will normally not be modified, and so would not be sent to the server unless {@link #writeAllFields}
         * was explicitly enabled.
         *
         * However, there are cases where it is not desirable for the record id to be passed in the data directly.
         * For example, when using a RESTful API the record id would typically be appended to the url instead.
         *
         * Optional
         */
        writeRecordId: boolean;

        /**
         * Creates new Writer.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.writer.JsonConfig);

        /**
         * Formats the data for each record before sending it to the server. This
         * method should be overridden to format the data in a way that differs from the default.
         * @param {Ext.data.Model} record The record that we are writing to the server.
         * @param {Ext.data.Operation} [operation] An operation object.
         * @return {Object} An object literal of name/value keys to be written to the server.
         * By default this method returns the data property on the record.
         */
        getRecordData(record: Ext.data.Model, operation?: Ext.data.Operation): any;

        /**
         * Prepares a Proxy's Ext.data.Request object
         * @param {Ext.data.Request} request The request object
         * @return {Ext.data.Request} The modified request object
         */
        write(request: Ext.data.Request): Ext.data.Request;
    }

    interface XmlConfig extends Ext.data.writer.WriterConfig {
        /**
         * The root to be used if {@link #documentRoot} is empty and a root is required
         * to form a valid XML document.
         */
        defaultDocumentRoot?: string;

        /**
         * The name of the root element of the document. Defaults to <tt>'xmlData'</tt>.
         * If there is more than 1 record and the root is not specified, the default document root will still be used
         * to ensure a valid XML document is created.
         */
        documentRoot?: string;

        /**
         * A header to use in the XML document (such as setting the encoding or version).
         * Defaults to <tt>''</tt>.
         */
        header?: string;

        /**
         * The name of the node to use for each record. Defaults to <tt>'record'</tt>.
         */
        record?: string;
    }

    /**
     * @author Ed Spencer
     This class is used to write {@link Ext.data.Model} data to the server in an XML format.
     The {@link #documentRoot} property is used to specify the root element in the XML document.
     The {@link #record} option is used to specify the element name for each record that will make
     up the XML document.
     * @markdown
     */
    export class Xml extends Ext.data.writer.Writer implements Ext.data.writer.XmlConfig {
        /**
         * The root to be used if {@link #documentRoot} is empty and a root is required
         * to form a valid XML document.
         */
        defaultDocumentRoot: string;

        /**
         * The name of the root element of the document. Defaults to <tt>'xmlData'</tt>.
         * If there is more than 1 record and the root is not specified, the default document root will still be used
         * to ensure a valid XML document is created.
         */
        documentRoot: string;

        /**
         * A header to use in the XML document (such as setting the encoding or version).
         * Defaults to <tt>''</tt>.
         */
        header: string;

        /**
         * The name of the node to use for each record. Defaults to <tt>'record'</tt>.
         */
        record: string;

        /**
         * Creates new Writer.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.data.writer.JsonConfig);
    }
}

declare module Ext.dd {
    /**
     * A DragDrop implementation where the linked element follows the
     * mouse cursor during a drag.
     */
    export class DD extends Ext.dd.DragDrop {
        /**
         * When set to true, the utility automatically tries to scroll the browser
         * window when a drag and drop element is dragged near the viewport boundary.
         */
        scroll: boolean;

        /**
         * Sets the element to the location of the mousedown or click event,
         * maintaining the cursor location relative to the location on the element
         * that was clicked.  Override this if you want to place the element in a
         * location other than where the cursor is.
         * @param {HTMLElement} el the element to move
         * @param {Number} iPageX the X coordinate of the mousedown or drag event
         * @param {Number} iPageY the Y coordinate of the mousedown or drag event
         */
        alignElWithMouse(el: HTMLElement, iPageX: number, iPageY: number);

        /**
         * Sets up config options specific to this class. Overrides
         * Ext.dd.DragDrop, but all versions of this method through the
         * inheritance chain are called
         */
        applyConfig();

        /**
         * Sets the pointer offset to the distance between the linked element's top
         * left corner and the location the element was clicked.
         * @param {Number} iPageX the X coordinate of the click
         * @param {Number} iPageY the Y coordinate of the click
         */
        autoOffset(iPageX: number, iPageY: number);

        /**
         * Event that fires prior to the onDrag event.  Overrides
         * Ext.dd.DragDrop.
         */
        b4Drag();

        /**
         * Event that fires prior to the onMouseDown event.  Overrides
         * Ext.dd.DragDrop.
         */
        b4MouseDown();

        /**
         * Saves the most recent position so that we can reset the constraints and
         * tick marks on-demand.  We need to know this so that we can calculate the
         * number of pixels the element is offset from its original position.
         *
         * @param {Number} [iPageX] the current x position (this just makes it so we
         * don't have to look it up again)
         * @param {Number} [iPageY] the current y position (this just makes it so we
         * don't have to look it up again)
         */
        cachePosition(iPageX?: number, iPageY?: number);

        /**
         * Creates new DD instance.
         * @param {String} id the id of the linked element
         * @param {String} sGroup the group of related DragDrop items
         * @param {Object} config an object containing configurable attributes.
         * Valid properties for DD: scroll
         */
        constructor(id: string, sGroup: string, config: any);

        /**
         * Sets the pointer offset.  You can call this directly to force the
         * offset to be in a particular location (e.g., pass in 0,0 to set it
         * to the center of the object)
         * @param {Number} iDeltaX the distance from the left
         * @param {Number} iDeltaY the distance from the top
         */
        setDelta(iDeltaX: number, iDeltaY: number);

        /**
         * Sets the drag element to the location of the mousedown or click event,
         * maintaining the cursor location relative to the location on the element
         * that was clicked.  Override this if you want to place the element in a
         * location other than where the cursor is.
         * @param {Number} iPageX the X coordinate of the mousedown or drag event
         * @param {Number} iPageY the Y coordinate of the mousedown or drag event
         */
        setDragElPos(iPageX: number, iPageY: number);
    }

    /**
     * A DragDrop implementation that inserts an empty, bordered div into
     * the document that follows the cursor during drag operations.  At the time of
     * the click, the frame div is resized to the dimensions of the linked html
     * element, and moved to the exact location of the linked element.
     *
     * References to the "frame" element refer to the single proxy element that
     * was created to be dragged in place of all DDProxy elements on the
     * page.
     */
    export class DDProxy extends Ext.dd.DD {
        /**
         * By default the frame is positioned exactly where the drag element is, so
         * we use the cursor offset provided by Ext.dd.DD.  Another option that works only if
         * you do not have constraints on the obj is to have the drag frame centered
         * around the cursor.  Set centerFrame to true for this effect.
         */
        centerFrame: boolean;

        /**
         * By default we resize the drag frame to be the same size as the element
         * we want to drag (this is to get the frame effect).  We can turn it off
         * if we want a different behavior.
         */
        resizeFrame: boolean;

        applyConfig();

        b4MouseDown();

        /**
         * Creates new DDProxy.
         * @param {String} id the id of the linked html element
         * @param {String} sGroup the group of related DragDrop objects
         * @param {Object} config an object containing configurable attributes.
         * Valid properties for DDProxy in addition to those in DragDrop:
         *
         * - resizeFrame
         * - centerFrame
         * - dragElId
         */
        constructor(id: string, sGroup: string, config: any);

        /**
         * Creates the proxy element if it does not yet exist
         */
        createFrame();

        /**
         * Initialization for the drag frame element.  Must be called in the
         * constructor of all subclasses
         */
        initFrame();

        /**
         * The default drag frame div id
         */
        static dragElId: any;
    }

    /**
     * A DragDrop implementation that does not move, but can be a drop
     * target.  You would get the same result by simply omitting implementation
     * for the event callbacks, but this way we reduce the processing cost of the
     * event listener and the callbacks.
     */
    export class DDTarget extends Ext.dd.DragDrop {
        /**
         * Overridden and disabled. A DDTarget does not support being dragged.
         */
        clearConstraints();

        /**
         * Overridden and disabled. A DDTarget does not support being dragged.
         */
        clearTicks();

        /**
         * Creates new DDTarget.
         * @param {String} id the id of the element that is a drop target
         * @param {String} sGroup the group of related DragDrop objects
         * @param {Object} config an object containing configurable attributes.
         * Valid properties for DDTarget in addition to those in DragDrop: none.
         */
        constructor(id: string, sGroup: string, config: any);
    }

    /**
     * Defines the interface and base operation of items that that can be
     * dragged or can be drop targets.  It was designed to be extended, overriding
     * the event handlers for startDrag, onDrag, onDragOver and onDragOut.
     * Up to three html elements can be associated with a DragDrop instance:
     *
     * - linked element: the element that is passed into the constructor.
     *   This is the element which defines the boundaries for interaction with
     *   other DragDrop objects.
     *
     * - handle element(s): The drag operation only occurs if the element that
     *   was clicked matches a handle element.  By default this is the linked
     *   element, but there are times that you will want only a portion of the
     *   linked element to initiate the drag operation, and the setHandleElId()
     *   method provides a way to define this.
     *
     * - drag element: this represents the element that would be moved along
     *   with the cursor during a drag operation.  By default, this is the linked
     *   element itself as in {@link Ext.dd.DD}.  setDragElId() lets you define
     *   a separate element that would be moved, as in {@link Ext.dd.DDProxy}.
     *
     * This class should not be instantiated until the onload event to ensure that
     * the associated elements are available.
     * The following would define a DragDrop obj that would interact with any
     * other DragDrop obj in the "group1" group:
     *
     *     dd = new Ext.dd.DragDrop("div1", "group1");
     *
     * Since none of the event handlers have been implemented, nothing would
     * actually happen if you were to run the code above.  Normally you would
     * override this class or one of the default implementations, but you can
     * also override the methods you want on an instance of the class...
     *
     *     dd.onDragDrop = function(e, id) {
     *         alert("dd was dropped on " + id);
     *     }
     */
    export class DragDrop extends Ext.Base {
        /**
         * The available property is false until the linked dom element is accessible.
         */
        available: boolean;

        /**
         * Configuration attributes passed into the constructor
         */
        config: any;

        /**
         * Provides default constraint padding to "constrainTo" elements.
         */
        defaultPadding: any;

        /**
         * The group defines a logical collection of DragDrop objects that are
         * related.  Instances only get events when interacting with other
         * DragDrop object in the same group.  This lets us define multiple
         * groups using a single DragDrop subclass if we want.
         *
         * An object in the format {'group1':true, 'group2':true}
         */
        groups: any;

        /**
         * By default, drags can only be initiated if the mousedown occurs in the
         * region the linked element is.  This is done in part to work around a
         * bug in some browsers that mis-report the mousedown if the previous
         * mouseup happened outside of the window.  This property is set to true
         * if outer handles are defined. Defaults to false.
         */
        hasOuterHandles: boolean;

        /**
         * The id of the element associated with this object.  This is what we
         * refer to as the "linked element" because the size and position of
         * this element is used to determine when the drag and drop objects have
         * interacted.
         */
        id: string;

        /**
         * Set to false to enable a DragDrop object to fire drag events while dragging
         * over its own Element. Defaults to true - DragDrop objects do not by default
         * fire drag events to themselves.
         */
        ignoreSelf: boolean;

        /**
         * An Array of CSS class names for elements to be considered in valid as drag handles.
         */
        invalidHandleClasses: string;

        /**
         * An object who's property names identify the IDs of elements to be considered invalid as drag handles.
         * A non-null property value identifies the ID as invalid. For example, to prevent
         * dragging from being initiated on element ID "foo", use:
         *
         *     {
         *         foo: true
         *     }
         */
        invalidHandleIds: any;

        /**
         * An object who's property names identify HTML tags to be considered invalid as drag handles.
         * A non-null property value identifies the tag as invalid. Defaults to the
         * following value which prevents drag operations from being initiated by '<a>' elements:
         *
         *     {
         *         A: "A"
         *     }
         */
        invalidHandleTypes: any;

        /**
         * By default, all instances can be a drop target.  This can be disabled by
         * setting isTarget to false.
         */
        isTarget: boolean;

        /**
         * Maintain offsets when we resetconstraints.  Set to true when you want
         * the position of the element relative to its parent to stay the same
         * when the page changes
         */
        maintainOffset: boolean;

        /**
         * When set to true, other DD objects in cooperating DDGroups do not receive
         * notification events when this DD object is dragged over them.
         */
        moveOnly: boolean;

        /**
         * The padding configured for this drag and drop object for calculating
         * the drop zone intersection with this object.
         * An array containing the 4 padding values: [top, right, bottom, left]
         */
        padding: number;

        /**
         * By default the drag and drop instance will only respond to the primary
         * button click (left button for a right-handed mouse).  Set to true to
         * allow drag and drop to start with any mouse click that is propogated
         * by the browser
         */
        primaryButtonOnly: boolean;

        /**
         * Array of pixel locations the element will snap to if we specified a
         * horizontal graduation/interval.  This array is generated automatically
         * when you define a tick interval.
         */
        xTicks: number;

        /**
         * Array of pixel locations the element will snap to if we specified a
         * vertical graduation/interval.  This array is generated automatically
         * when you define a tick interval.
         */
        yTicks: number;

        /**
         * Lets you specify a css class of elements that will not initiate a drag
         * @param {String} cssClass the class of the elements you wish to ignore
         */
        addInvalidHandleClass(cssClass: string);

        /**
         * Lets you to specify an element id for a child of a drag handle
         * that should not initiate a drag
         * @param {String} id the element id of the element you wish to ignore
         */
        addInvalidHandleId(id: string);

        /**
         * Allows you to specify a tag name that should not start a drag operation
         * when clicked.  This is designed to facilitate embedding links within a
         * drag handle that do something other than start the drag.
         * @param {String} tagName the type of element to exclude
         */
        addInvalidHandleType(tagName: string);

        /**
         * Adds this instance to a group of related drag/drop objects.  All
         * instances belong to at least one group, and can belong to as many
         * groups as needed.
         * @param {String} sGroup the name of the group
         */
        addToGroup(sGroup: string);

        /**
         * Applies the configuration parameters that were passed into the constructor.
         * This is supposed to happen at each level through the inheritance chain.  So
         * a DDProxy implentation will execute apply config on DDProxy, DD, and
         * DragDrop in order to get all of the parameters that are available in
         * each object.
         */
        applyConfig();

        /**
         * Clears any constraints applied to this instance.  Also clears ticks
         * since they can't exist independent of a constraint at this time.
         */
        clearConstraints();

        /**
         * Clears any tick interval defined for this instance
         */
        clearTicks();

        /**
         * Initializes the drag drop object's constraints to restrict movement to a certain element.
         *
         * Usage:
         *
         *     var dd = new Ext.dd.DDProxy("dragDiv1", "proxytest",
         *                    { dragElId: "existingProxyDiv" });
         *     dd.startDrag = function(){
         *         this.constrainTo("parent-id");
         *     };
         *
         * Or you can initalize it using the {@link Ext.Element} object:
         *
         *     Ext.get("dragDiv1").initDDProxy("proxytest", {dragElId: "existingProxyDiv"}, {
         *         startDrag : function(){
         *             this.constrainTo("parent-id");
         *         }
         *     });
         *
         * @param {String/HTMLElement/Ext.Element} constrainTo The element or element ID to constrain to.
         * @param {Object/Number} pad (optional) Pad provides a way to specify "padding" of the constraints,
         * and can be either a number for symmetrical padding (4 would be equal to '{left:4, right:4, top:4, bottom:4}') or
         * an object containing the sides to pad. For example: '{right:10, bottom:10}'
         * @param {Boolean} inContent (optional) Constrain the draggable in the content box of the element (inside padding and borders)
         */
        constrainTo(constrainTo: string|HTMLElement|Ext.dom.Element, pad: any|number, inContent: boolean);

        /**
         * Creates new DragDrop.
         * @param {String} id of the element that is linked to this instance
         * @param {String} sGroup the group of related DragDrop objects
         * @param {Object} config an object containing configurable attributes.
         * Valid properties for DragDrop:
         *
         * - padding
         * - isTarget
         * - maintainOffset
         * - primaryButtonOnly
         */
        constructor(id: string, sGroup: string, config: any);

        /**
         * Destroy this DragDrop instance
         */
        destroy();

        /**
         * Called when we are done dragging the object
         * @param {Event} e the mouseup event
         */
        endDrag(e: Event);

        /**
         * Returns a reference to the actual element to drag.  By default this is
         * the same as the html element, but it can be assigned to another
         * element. An example of this can be found in Ext.dd.DDProxy
         * @return {HTMLElement} the html element
         */
        getDragEl(): HTMLElement;

        /**
         * Returns a reference to the linked element
         * @return {HTMLElement} the html element
         */
        getEl(): HTMLElement;

        /**
         * Sets up the DragDrop object.  Must be called in the constructor of any
         * Ext.dd.DragDrop subclass
         * @param {String} id the id of the linked element
         * @param {String} sGroup the group of related items
         * @param {Object} config configuration attributes
         */
        init(id: string, sGroup: string, config: any);

        /**
         * Initializes Targeting functionality only... the object does not
         * get a mousedown handler.
         * @param {String} id the id of the linked element
         * @param {String} sGroup the group of related items
         * @param {Object} config configuration attributes
         */
        initTarget(id: string, sGroup: string, config: any);

        /**
         * Returns true if this instance is locked, or the drag drop mgr is locked
         * (meaning that all drag/drop is disabled on the page.)
         * @return {Boolean} true if this obj or all drag/drop is locked, else
         * false
         */
        isLocked(): boolean;

        /**
         * Checks the tag exclusion list to see if this click should be ignored
         * @param {HTMLElement} node the HTMLElement to evaluate
         * @return {Boolean} true if this is a valid tag type, false if not
         */
        isValidHandleChild(node: HTMLElement): boolean;

        /**
         * Locks this instance
         */
        lock();

        /**
         * Override the onAvailable method to do what is needed after the initial
         * position was determined.
         */
        onAvailable();

        /**
         * Abstract method called during the onMouseMove event while dragging an
         * object.
         * @param {Event} e the mousemove event
         */
        onDrag(e: Event);

        /**
         * Abstract method called when this item is dropped on another DragDrop
         * obj
         * @param {Event} e the mouseup event
         * @param {String/Ext.dd.DragDrop[]} id In POINT mode, the element
         * id this was dropped on.  In INTERSECT mode, an array of dd items this
         * was dropped on.
         */
        onDragDrop(e: Event, id: string|Ext.dd.DragDrop);

        /**
         * Abstract method called when this element fist begins hovering over
         * another DragDrop obj
         * @param {Event} e the mousemove event
         * @param {String/Ext.dd.DragDrop[]} id In POINT mode, the element
         * id this is hovering over.  In INTERSECT mode, an array of one or more
         * dragdrop items being hovered over.
         */
        onDragEnter(e: Event, id: string|Ext.dd.DragDrop);

        /**
         * Abstract method called when we are no longer hovering over an element
         * @param {Event} e the mousemove event
         * @param {String/Ext.dd.DragDrop[]} id In POINT mode, the element
         * id this was hovering over.  In INTERSECT mode, an array of dd items
         * that the mouse is no longer over.
         */
        onDragOut(e: Event, id: string|Ext.dd.DragDrop);

        /**
         * Abstract method called when this element is hovering over another
         * DragDrop obj
         * @param {Event} e the mousemove event
         * @param {String/Ext.dd.DragDrop[]} id In POINT mode, the element
         * id this is hovering over.  In INTERSECT mode, an array of dd items
         * being hovered over.
         */
        onDragOver(e: Event, id: string|Ext.dd.DragDrop);

        /**
         * Abstract method called when this item is dropped on an area with no
         * drop target
         * @param {Event} e the mouseup event
         */
        onInvalidDrop(e: Event);

        /**
         * Called when a drag/drop obj gets a mousedown
         * @param {Event} e the mousedown event
         */
        onMouseDown(e: Event);

        /**
         * Called when a drag/drop obj gets a mouseup
         * @param {Event} e the mouseup event
         */
        onMouseUp(e: Event);

        /**
         * Removes this instance from the supplied interaction group
         * @param {String} sGroup  The group to drop
         */
        removeFromGroup(sGroup: string);

        /**
         * Unsets an invalid css class
         * @param {String} cssClass the class of the element(s) you wish to
         * re-enable
         */
        removeInvalidHandleClass(cssClass: string);

        /**
         * Unsets an invalid handle id
         * @param {String} id the id of the element to re-enable
         */
        removeInvalidHandleId(id: string);

        /**
         * Unsets an excluded tag name set by addInvalidHandleType
         * @param {String} tagName the type of element to unexclude
         */
        removeInvalidHandleType(tagName: string);

        /**
         * Must be called if you manually reposition a dd element.
         */
        resetConstraints(maintainOffset: boolean);

        /**
         * Allows you to specify that an element other than the linked element
         * will be moved with the cursor during a drag
         * @param {String} id the id of the element that will be used to initiate the drag
         */
        setDragElId(id: string);

        /**
         * Allows you to specify a child of the linked element that should be
         * used to initiate the drag operation.  An example of this would be if
         * you have a content div with text and links.  Clicking anywhere in the
         * content area would normally start the drag operation.  Use this method
         * to specify that an element inside of the content div is the element
         * that starts the drag operation.
         * @param {String} id the id of the element that will be used to
         * initiate the drag.
         */
        setHandleElId(id: string);

        /**
         * Stores the initial placement of the linked element.
         * @param {Number} diffX   the X offset, default 0
         * @param {Number} diffY   the Y offset, default 0
         */
        setInitPosition(diffX: number, diffY: number);

        /**
         * Allows you to set an element outside of the linked element as a drag
         * handle
         * @param {String} id the id of the element that will be used to initiate the drag
         */
        setOuterHandleElId(id: string);

        /**
         * Configures the padding for the target zone in px.  Effectively expands
         * (or reduces) the virtual object size for targeting calculations.
         * Supports css-style shorthand; if only one parameter is passed, all sides
         * will have that padding, and if only two are passed, the top and bottom
         * will have the first param, the left and right the second.
         * @param {Number} iTop    Top pad
         * @param {Number} iRight  Right pad
         * @param {Number} iBot    Bot pad
         * @param {Number} iLeft   Left pad
         */
        setPadding(iTop: number, iRight: number, iBot: number, iLeft: number);

        /**
         * By default, the element can be dragged any place on the screen.  Use
         * this method to limit the horizontal travel of the element.  Pass in
         * 0,0 for the parameters if you want to lock the drag to the y axis.
         * @param {Number} iLeft the number of pixels the element can move to the left
         * @param {Number} iRight the number of pixels the element can move to the
         * right
         * @param {Number} iTickSize (optional) parameter for specifying that the
         * element should move iTickSize pixels at a time.
         */
        setXConstraint(iLeft: number, iRight: number, iTickSize: number);

        /**
         * By default, the element can be dragged any place on the screen.  Set
         * this to limit the vertical travel of the element.  Pass in 0,0 for the
         * parameters if you want to lock the drag to the x axis.
         * @param {Number} iUp the number of pixels the element can move up
         * @param {Number} iDown the number of pixels the element can move down
         * @param {Number} iTickSize (optional) parameter for specifying that the
         * element should move iTickSize pixels at a time.
         */
        setYConstraint(iUp: number, iDown: number, iTickSize: number);

        /**
         * Abstract method called after a drag/drop object is clicked
         * and the drag or mousedown time thresholds have beeen met.
         * @param {Number} x X click location
         * @param {Number} y Y click location
         */
        startDrag(x: number, y: number);

        /**
         * toString method
         * @return {String} string representation of the dd obj
         */
        toString(): string;

        /**
         * Unlocks this instace
         */
        unlock();

        /**
         * Removes all drag and drop hooks for this element
         */
        unreg();
    }

    /** @class Ext.dd.DragDropElement */
    export class DragDropElement {
        /**
         * Returns the X position of an html element
         * @param {HTMLElement} el the element for which to get the position
         * @return {Number} the X coordinate
         */
        getPosX(el: HTMLElement): number;

        /**
         * Returns the Y position of an html element
         * @param {HTMLElement} el the element for which to get the position
         * @return {Number} the Y coordinate
         */
        getPosY(el: HTMLElement): number;

        /**
         * Gets the scrollLeft
         * @return {Number} the document's scrollTop
         */
        getScrollLeft(): number;

        /**
         * Gets the scrollTop
         * @return {Number} the document's scrollTop
         */
        getScrollTop(): number;

        /**
         * Returns the specified element style property
         * @param {HTMLElement} el          the element
         * @param {String}      styleProp   the style property
         * @return {String} The value of the style property
         */
        getStyle(el: HTMLElement, styleProp: string): string;

        /**
         * Recursively searches the immediate parent and all child nodes for
         * the handle element in order to determine wheter or not it was
         * clicked.
         * @param {HTMLElement} node the html element to inspect
         */
        handleWasClicked(node: HTMLElement);

        /**
         * Sets the x/y position of an element to the location of the
         * target element.
         * @param {HTMLElement} moveEl      The element to move
         * @param {HTMLElement} targetEl    The position reference element
         */
        moveToEl(moveEl: HTMLElement, targetEl: HTMLElement);

        /**
         * Numeric array sort function
         * @returns {Number} positive, negative or 0
         */
        numericSort(a: number, b: number);

        /**
         * Swap two nodes.  In IE, we use the native method, for others we
         * emulate the IE behavior
         * @param {HTMLElement} n1 the first node to swap
         * @param {HTMLElement} n2 the other node to swap
         */
        swapNode(n1: HTMLElement, n2: HTMLElement);
    }

    /**
     * DragDropManager is a singleton that tracks the element interaction for
     * all DragDrop items in the window.  Generally, you will not call
     * this class directly, but it does have helper methods that could
     * be useful in your DragDrop implementations.
     */
    export class DragDropManager {
        /**
         * The number of pixels that the mouse needs to move after the
         * mousedown before the drag is initiated.  Default=3;
         */
        static clickPixelThresh: number;

        /**
         * The number of milliseconds after the mousedown event to initiate the
         * drag if we don't get a mouseup event. Default=350
         */
        static clickTimeThresh: number;

        /**
         * @readonly
         * Class to add to the {@link Ext.dd.DragDrop#getDragEl dragged element} of a DragDrop instance.
         */
        static dragCls: string;

        /**
         * In intersect mode, drag and drop interaction is defined by the
         * overlap of two or more drag and drop objects.
         */
        static INTERSECT: number;

        /**
         * The current drag and drop mode.  Default: POINT
         */
        static mode: number;

        /**
         * This config is only provided to provide old, usually unwanted drag/drop behaviour.
         *
         * From ExtJS 4.1.0 onwards, when drop targets are contained in floating, absolutely positioned elements
         * such as in {@link Ext.window.Window Windows}, which may overlap each other, 'over' and 'drop' events
         * are only delivered to the topmost drop target at the mouse position.
         *
         * If all targets below that in zIndex order should also receive notifications, set
         * 'notifyOccluded' to 'true'.
         *
         * Optional, Defaults to: false
         */
        static notifyOccluded: boolean;

        /**
         * In point mode, drag and drop interaction is defined by the
         * location of the cursor during the drag/drop
         */
        static POINT: number;

        /**
         * Flag to determine if we should prevent the default behavior of the
         * events we define. By default this is true, but this can be set to
         * false if you need the default behavior (not recommended)
         */
        static preventDefault: boolean;

        /**
         * Flag to determine if we should stop the propagation of the events
         * we generate. This is true by default but you may want to set it to
         * false if the html element contains other features that require the
         * mouse click.
         */
        static stopPropagation: boolean;

        /**
         * Set useCache to false if you want to force object the lookup of each
         * drag and drop linked element constantly during a drag.
         */
        static useCache: boolean;

        /**
         * Helper function for getting the best match from the list of drag
         * and drop objects returned by the drag and drop events when we are
         * in INTERSECT mode.  It returns either the first object that the
         * cursor is over, or the object that has the greatest overlap with
         * the dragged element.
         * targeted
         * @return {Ext.dd.DragDrop}       The best single match
         */
        static getBestMatch(): Ext.dd.DragDrop;

        /**
         * Returns the style property for the DOM element (i.e.,
         * document.getElById(id).style)
         * @param {String} id the id of the elment to get
         * @return {Object} The style property of the element
         */
        static getCss(id: string): any;

        /**
         * Returns the DragDrop instance for a given id
         * @param {String} id the id of the DragDrop object
         * @return {Ext.dd.DragDrop} the drag drop object, null if it is not found
         */
        static getDDById(id: string): Ext.dd.DragDrop;

        /**
         * Returns the actual DOM element
         * @param {String} id the id of the elment to get
         * @return {Object} The element
         * @deprecated use Ext.lib.Ext.getDom instead
         */
        static getElement(id: string): any;

        /**
         * Returns a Region object containing the drag and drop element's position
         * and size, including the padding configured for it
         * @param {Ext.dd.DragDrop} oDD the drag and drop object to get the location for.
         * @return {Ext.util.Region} a Region object representing the total area
         * the element occupies, including any padding
         * the instance is configured for.
         */
        static getLocation(oDD: Ext.dd.DragDrop): Ext.util.Region;

        /**
         * Returns the drag and drop instances that are in all groups the
         * passed in instance belongs to.
         * @param {Ext.dd.DragDrop} p_oDD the obj to get related data for
         * @param {Boolean} bTargetsOnly if true, only return targetable objs
         * @return {Ext.dd.DragDrop[]} the related instances
         */
        static getRelated(p_oDD: Ext.dd.DragDrop, bTargetsOnly: boolean): Ext.dd.DragDrop;

        /**
         * Utility function to determine if a given element has been
         * registered as a drag drop item.
         * @param {String} id the element id to check
         * @return {Boolean} true if this element is a DragDrop item,
         * false otherwise
         */
        static isDragDrop(id: string): boolean;

        /**
         * Utility function to determine if a given element has been
         * registered as a drag drop handle for the given Drag Drop object.
         * @param {String} id the element id to check
         * @return {Boolean} true if this element is a DragDrop handle, false
         * otherwise
         */
        static isHandle(id: string): boolean;

        /**
         * Returns true if the specified dd target is a legal target for
         * the specifice drag obj
         * @param {Ext.dd.DragDrop} oDD the drag obj
         * @param {Ext.dd.DragDrop} oTargetDD the target
         * @return {Boolean} true if the target is a legal target for the
         * dd obj
         */
        static isLegalTarget(oDD: Ext.dd.DragDrop, oTargetDD: Ext.dd.DragDrop): boolean;

        /**
         * Is drag and drop locked?
         * @return {Boolean} True if drag and drop is locked, false otherwise.
         */
        static isLocked(): boolean;

        /**
         * My goal is to be able to transparently determine if an object is
         * typeof DragDrop, and the exact subclass of DragDrop.  typeof
         * returns "object", oDD.constructor.toString() always returns
         * "DragDrop" and not the name of the subclass.  So for now it just
         * evaluates a well-known variable in DragDrop.
         * @param {Object} the object to evaluate
         * @return {Boolean} true if typeof oDD = DragDrop
         */
        static isTypeOfDD(the: any): boolean;

        /**
         * Lock all drag and drop functionality
         */
        static lock();

        /**
         * Refreshes the cache of the top-left and bottom-right points of the
         * drag and drop objects in the specified group(s).  This is in the
         * format that is stored in the drag and drop instance, so typical
         * usage is:
         *
         *     Ext.dd.DragDropManager.refreshCache(ddinstance.groups);
         *
         * Alternatively:
         *
         *     Ext.dd.DragDropManager.refreshCache({group1:true, group2:true});
         *
         * TODO: this really should be an indexed array.  Alternatively this
         * method could accept both.
         *
         * @param {Object} groups an associative array of groups to refresh
         */
        static refreshCache(groups: any);

        /**
         * Each DragDrop instance must be registered with the DragDropManager.
         * This is executed in DragDrop.init()
         * @param {Ext.dd.DragDrop} oDD the DragDrop object to register
         * @param {String} sGroup the name of the group this element belongs to
         */
        static regDragDrop(oDD: Ext.dd.DragDrop, sGroup: string);

        /**
         * Each DragDrop handle element must be registered.  This is done
         * automatically when executing DragDrop.setHandleElId()
         * @param {String} sDDId the DragDrop id this element is a handle for
         * @param {String} sHandleId the id of the element that is the drag
         * handle
         */
        static regHandle(sDDId: string, sHandleId: string);

        /**
         * Fired when either the drag pixel threshold or the mousedown hold
         * time threshold has been met.
         * @param {Number} x the X position of the original mousedown
         * @param {Number} y the Y position of the original mousedown
         */
        static startDrag(x: number, y: number);

        /**
         * Utility to stop event propagation and event default, if these
         * features are turned on.
         * @param {Event} e the event as returned by this.getEvent()
         */
        static stopEvent(e: Event);

        /**
         * Unlock all drag and drop functionality
         */
        static unlock();

        /**
         * This checks to make sure an element exists and is in the DOM.  The
         * main purpose is to handle cases where innerHTML is used to remove
         * drag and drop objects from the DOM.  IE provides an 'unspecified
         * error' when trying to access the offsetParent of such an element
         * @param {HTMLElement} el the element to check
         * @return {Boolean} true if the element looks usable
         */
        static verifyEl(el: HTMLElement): boolean;
    }

    interface DragSourceConfig {
        /**
         * If true, animates the proxy element back to the position of the handle element used to trigger the drag.
         */
        animRepair?: boolean;

        /**
         * A named drag drop group to which this object belongs.  If a group is specified, then this object will only
         * interact with other drag drop objects in the same group.
         */
        ddGroup?: string;

        /**
         * The CSS class returned to the drag source when drop is allowed.
         */
        dropAllowed?: string;

        /**
         * The CSS class returned to the drag source when drop is not allowed.
         */
        dropNotAllowed?: string;

        /**
         * The color to use when visually highlighting the drag source in the afterRepair
         * method after a failed drop (defaults to light blue). The color must be a 6 digit hex value, without
         * a preceding '#'.
         */
        repairHighlightColor?: string;
    }

    /**
     * A simple class that provides the basic implementation needed to make any element draggable.
     */
    export class DragSource extends Ext.dd.DDProxy implements Ext.dd.DragSourceConfig {
        /**
         * This property contains the data representing the dragged object. This data is set up by the implementation of the
         * {@link #getDragData} method. It must contain a ddel property, but can contain any other data according to the
         * application's needs.
         */
        dragData: any;

        /**
         * If true, animates the proxy element back to the position of the handle element used to trigger the drag.
         */
        animRepair: boolean;

        /**
         * A named drag drop group to which this object belongs.  If a group is specified, then this object will only
         * interact with other drag drop objects in the same group.
         */
        ddGroup: string;

        /**
         * The CSS class returned to the drag source when drop is allowed.
         */
        dropAllowed: string;

        /**
         * The CSS class returned to the drag source when drop is not allowed.
         */
        dropNotAllowed: string;

        /**
         * The color to use when visually highlighting the drag source in the afterRepair
         * method after a failed drop (defaults to light blue). The color must be a 6 digit hex value, without
         * a preceding '#'.
         */
        repairHighlightColor: string;

        /**
         * An empty function by default, but provided so that you can perform a custom action
         * after a valid drag drop has occurred by providing an implementation.
         * @param {Ext.dd.DragDrop} target The drop target
         * @param {Event} e The event object
         * @param {String} id The id of the dropped element
         */
        afterDragDrop(target: Ext.dd.DragDrop, e: Event, id: string);

        /**
         * An empty function by default, but provided so that you can perform a custom action
         * when the dragged item enters the drop target by providing an implementation.
         * @param {Ext.dd.DragDrop} target The drop target
         * @param {Event} e The event object
         * @param {String} id The id of the dragged element
         */
        afterDragEnter(target: Ext.dd.DragDrop, e: Event, id: string);

        /**
         * An empty function by default, but provided so that you can perform a custom action
         * after the dragged item is dragged out of the target without dropping.
         * @param {Ext.dd.DragDrop} target The drop target
         * @param {Event} e The event object
         * @param {String} id The id of the dragged element
         */
        afterDragOut(target: Ext.dd.DragDrop, e: Event, id: string);

        /**
         * An empty function by default, but provided so that you can perform a custom action
         * while the dragged item is over the drop target by providing an implementation.
         * @param {Ext.dd.DragDrop} target The drop target
         * @param {Event} e The event object
         * @param {String} id The id of the dragged element
         */
        afterDragOver(target: Ext.dd.DragDrop, e: Event, id: string);

        /**
         * An empty function by default, but provided so that you can perform a custom action
         * after an invalid drop has occurred by providing an implementation.
         * @param {Event} e The event object
         * @param {String} id The id of the dropped element
         */
        afterInvalidDrop(e: Event, id: string);

        /**
         * An empty function by default, but provided so that you can perform a custom action
         * after a valid drop has occurred by providing an implementation.
         * @param {Object} target The target DD
         * @param {Event} e The event object
         * @param {String} id The id of the dropped element
         */
        afterValidDrop(target: any, e: Event, id: string);

        /**
         * An empty function by default, but provided so that you can perform a custom action before the dragged
         * item is dropped onto the target and optionally cancel the onDragDrop.
         * @param {Ext.dd.DragDrop} target The drop target
         * @param {Event} e The event object
         * @param {String} id The id of the dragged element
         * @return {Boolean} isValid True if the drag drop event is valid, else false to cancel
         */
        beforeDragDrop(target: Ext.dd.DragDrop, e: Event, id: string): boolean;

        /**
         * An empty function by default, but provided so that you can perform a custom action
         * before the dragged item enters the drop target and optionally cancel the onDragEnter.
         * @param {Ext.dd.DragDrop} target The drop target
         * @param {Event} e The event object
         * @param {String} id The id of the dragged element
         * @return {Boolean} isValid True if the drag event is valid, else false to cancel
         */
        beforeDragEnter(target: Ext.dd.DragDrop, e: Event, id: string): boolean;

        /**
         * An empty function by default, but provided so that you can perform a custom action before the dragged
         * item is dragged out of the target without dropping, and optionally cancel the onDragOut.
         * @param {Ext.dd.DragDrop} target The drop target
         * @param {Event} e The event object
         * @param {String} id The id of the dragged element
         * @return {Boolean} isValid True if the drag event is valid, else false to cancel
         */
        beforeDragOut(target: Ext.dd.DragDrop, e: Event, id: string): boolean;

        /**
         * An empty function by default, but provided so that you can perform a custom action
         * while the dragged item is over the drop target and optionally cancel the onDragOver.
         * @param {Ext.dd.DragDrop} target The drop target
         * @param {Event} e The event object
         * @param {String} id The id of the dragged element
         * @return {Boolean} isValid True if the drag event is valid, else false to cancel
         */
        beforeDragOver(target: Ext.dd.DragDrop, e: Event, id: string): boolean;

        /**
         * An empty function by default, but provided so that you can perform a custom action after an invalid
         * drop has occurred.
         * @param {Ext.dd.DragDrop} target The drop target
         * @param {Event} e The event object
         * @param {String} id The id of the dragged element
         * @return {Boolean} isValid True if the invalid drop should proceed, else false to cancel
         */
        beforeInvalidDrop(target: Ext.dd.DragDrop, e: Event, id: string): boolean;

        /**
         * Creates new drag-source.
         * @param {String/HTMLElement/Ext.Element} el The container element or ID of it.
         * @param {Object} config (optional) Config object.
         */
        constructor(el: string|HTMLElement|Ext.dom.Element, config: Ext.dd.DragSourceConfig);

        destroy();

        /**
         * Returns the data object associated with this drag source
         * @return {Object} data An object containing arbitrary data
         */
        getDragData(): any;

        /**
         * Returns the drag source's underlying {@link Ext.dd.StatusProxy}
         * @return {Ext.dd.StatusProxy} proxy The StatusProxy
         */
        getProxy(): Ext.dd.StatusProxy;

        /**
         * Hides the drag source's {@link Ext.dd.StatusProxy}
         */
        hideProxy();

        /**
         * An empty function by default, but provided so that you can perform a custom action before the initial
         * drag event begins and optionally cancel it.
         * @param {Object} data An object containing arbitrary data to be shared with drop targets
         * @param {Event} e The event object
         * @return {Boolean} isValid True if the drag event is valid, else false to cancel
         */
        onBeforeDrag(data: any, e: Event): boolean;

        /**
         * An empty function by default, but provided so that you can perform a custom action once the initial
         * drag event has begun.  The drag cannot be canceled from this function.
         * @param {Number} x The x position of the click on the dragged object
         * @param {Number} y The y position of the click on the dragged object
         */
        onStartDrag(x: number, y: number);
    }

    interface DragTrackerConfig {
        /**
         * Specify 'true' to defer trigger start by 1000 ms.
         * Specify a Number for the number of milliseconds to defer trigger start.
         */
        autoStart?: boolean|number;

        /**
         * A {@link Ext.util.Region Region} (Or an element from which a Region measurement will be read)
         * which is used to constrain the result of the {@link #getOffset} call.
         *
         * This may be set any time during the DragTracker's lifecycle to set a dynamic constraining region.
         */
        constrainTo?: Ext.util.Region|Ext.dom.Element;

        /**
         * A {@link Ext.DomQuery DomQuery} selector which identifies child elements within the DragTracker's encapsulating
         * Element which are the tracked elements. This limits tracking to only begin when the matching elements are mousedowned.
         *
         * This may also be a specific child element within the DragTracker's encapsulating element to use as the tracked element.
         */
        delegate?: string;

        /**
         * A CSS class to add to the DragTracker's target element when the element (or, if the {@link #delegate}
         * option is used, when a delegate element) is mouseovered.
         *
         * If the {@link #delegate} option is used, these events fire only when a delegate element is entered of left.
         */
        overCls?: string;

        /**
         * Specify 'false' to enable default actions on onMouseDown events.
         *
         * Optional, Defaults to: true
         */
        preventDefault?: boolean;

        /**
         * Specify 'true' to stop the 'mousedown' event from bubbling to outer listeners from the target element (or its delegates).
         *
         * Optional, Defaults to: false
         */
        stopEvent?: boolean;

        /**
         * Number of pixels the drag target must be moved before dragging is
         * considered to have started.
         */
        tolerance?: number;

        /**
         * Set to true to fire mouseover and mouseout events when the mouse enters or leaves the target element.
         *
         * This is implicitly set when an {@link #overCls} is specified.
         *
         * If the {@link #delegate} option is used, these events fire only when a delegate element is entered of left.
         */
        trackOver?: boolean;
    }

    /**
     * A DragTracker listens for drag events on an Element and fires events at the start and end of the drag,
     * as well as during the drag. This is useful for components such as {@link Ext.slider.Multi}, where there is
     * an element that can be dragged around to change the Slider's value.
     *
     * DragTracker provides a series of template methods that should be overridden to provide functionality
     * in response to detected drag operations. These are onBeforeStart, onStart, onDrag and onEnd.
     * See {@link Ext.slider.Multi}'s initEvents function for an example implementation.
     */
    export class DragTracker extends Ext.Base implements Ext.dd.DragTrackerConfig {
        /**
         * Indicates whether the user is currently dragging this tracker.
         * @readonly
         */
        active: boolean;

        /**
         * The element being dragged.
         *
         * Only valid during drag operations.
         *
         * If the {@link #delegate} option is used, this will be the delegate element which was mousedowned.
         * @readonly
         */
        dragTarget: HTMLElement;

        /**
         * Specify 'true' to defer trigger start by 1000 ms.
         * Specify a Number for the number of milliseconds to defer trigger start.
         */
        autoStart: boolean|number;

        /**
         * A {@link Ext.util.Region Region} (Or an element from which a Region measurement will be read)
         * which is used to constrain the result of the {@link #getOffset} call.
         *
         * This may be set any time during the DragTracker's lifecycle to set a dynamic constraining region.
         */
        constrainTo: Ext.util.Region|Ext.dom.Element;

        /**
         * A {@link Ext.DomQuery DomQuery} selector which identifies child elements within the DragTracker's encapsulating
         * Element which are the tracked elements. This limits tracking to only begin when the matching elements are mousedowned.
         *
         * This may also be a specific child element within the DragTracker's encapsulating element to use as the tracked element.
         */
        delegate: string;

        /**
         * A CSS class to add to the DragTracker's target element when the element (or, if the {@link #delegate}
         * option is used, when a delegate element) is mouseovered.
         *
         * If the {@link #delegate} option is used, these events fire only when a delegate element is entered of left.
         */
        overCls: string;

        /**
         * Specify 'false' to enable default actions on onMouseDown events.
         *
         * Optional, Defaults to: true
         */
        preventDefault: boolean;

        /**
         * Specify 'true' to stop the 'mousedown' event from bubbling to outer listeners from the target element (or its delegates).
         *
         * Optional, Defaults to: false
         */
        stopEvent: boolean;

        /**
         * Number of pixels the drag target must be moved before dragging is
         * considered to have started.
         */
        tolerance: number;

        /**
         * Set to true to fire mouseover and mouseout events when the mouse enters or leaves the target element.
         *
         * This is implicitly set when an {@link #overCls} is specified.
         *
         * If the {@link #delegate} option is used, these events fire only when a delegate element is entered of left.
         */
        trackOver: boolean;

        /**
         * Returns the drag target. This is usually the DragTracker's encapsulating element.
         *
         * If the {@link #delegate} option is being used, this may be a child element which matches the
         * {@link #delegate} selector.
         *
         * @return {Ext.Element} The element currently being tracked.
         */
        getDragTarget(): Ext.dom.Element;

        /**
         * Returns the X, Y offset of the current mouse position from the mousedown point.
         *
         * This method may optionally constrain the real offset values, and returns a point coerced in one
         * of two modes:
         *
         *  - 'point'
         *    The current mouse position is coerced into the constrainRegion and the resulting position is returned.
         *  - 'dragTarget'
         *    The new {@link Ext.util.Region Region} of the {@link #getDragTarget dragTarget} is calculated
         *    based upon the current mouse position, and then coerced into the constrainRegion. The returned
         *    mouse position is then adjusted by the same delta as was used to coerce the region.\
         *
         * @param {String} constrainMode (Optional) If omitted the true mouse position is returned. May be passed
         * as 'point' or 'dragTarget'. See above.
         * @returns {Number[]} The 'X, Y' offset from the mousedown point, optionally constrained.
         */
        getOffset(constrainMode: string);

        /**
         * Initializes the DragTracker on a given element.
         * @param {Ext.Element/HTMLElement} el The element
         */
        initEl(el: Ext.dom.Element|HTMLElement);

        /**
         * Template method which should be overridden by each DragTracker instance. Called when the user first clicks and
         * holds the mouse button down. Return false to disallow the drag
         * @param {Ext.EventObject} e The event object
         */
        onBeforeStart(e: Ext.EventObject);

        /**
         * Template method which should be overridden by each DragTracker instance. Called whenever a drag has been detected.
         * @param {Ext.EventObject} e The event object
         */
        onDrag(e: Ext.EventObject);

        /**
         * Template method which should be overridden by each DragTracker instance. Called when a drag operation has been completed
         * (e.g. the user clicked and held the mouse down, dragged the element and then released the mouse button)
         * @param {Ext.EventObject} e The event object
         */
        onEnd(e: Ext.EventObject);

        /**
         * Template method which should be overridden by each DragTracker instance. Called when a drag operation starts
         * (e.g. the user has moved the tracked element beyond the specified tolerance)
         * @param {Ext.EventObject} e The event object
         */
        onStart(e: Ext.EventObject);

        /**
         * @param {Object} e event object
         */
        beforestart(that: any, e: any);

        /**
         * @param {Object} e event object
         */
        drag(that: any, e: any);

        /**
         * @param {Object} e event object
         */
        dragend(that: any, e: any);

        /**
         * @param {Object} e event object
         */
        dragstart(that: any, e: any);

        /**
         * Fires when the mouse button is pressed down, but before a drag operation begins. The
         * drag operation begins after either the mouse has been moved by {@link #tolerance} pixels,
         * or after the {@link #autoStart} timer fires.
         *
         * Return 'false' to veto the drag operation.
         *
         * @param {Object} e event object
         */
        mousedown(that: any, e: any);

        /**
         * Fired when the mouse is moved. Returning false cancels the drag operation.
         * @param {Object} e event object
         */
        mousemove(that: any, e: any);

        /**
         * Fires when the mouse exits the DragTracker's target element (or if {@link #delegate} is
         * used, when the mouse exits a delegate element).
         *
         * **Only available when {@link #trackOver} is 'true'**
         *
         * @param {Object} e event object
         */
        mouseout(that: any, e: any);

        /**
         * Fires when the mouse enters the DragTracker's target element (or if {@link #delegate} is
         * used, when the mouse enters a delegate element).
         *
         * **Only available when {@link #trackOver} is 'true'**
         *
         * @param {Object} e event object
         * @param {HTMLElement} target The element mouseovered.
         */
        mouseover(that: any, e: any, target: HTMLElement);

        /**
         * @param {Object} e event object
         */
        mouseup(that: any, e: any);
    }

    interface DragZoneConfig extends Ext.dd.DragSourceConfig {
        /**
         * True to register this container with the Scrollmanager for auto scrolling during drag operations.
         * A {@link Ext.dd.ScrollManager} configuration may also be passed.
         */
        containerScroll?: any|boolean;

        /**
         * An element to register with the ScrollManager if {@link #containerScroll}
         * is set. Defaults to the drag element.
         */
        scrollEl?: string|HTMLElement|Ext.dom.Element;
    }

    /**
     * This class provides a container DD instance that allows dragging of multiple child source nodes.
     *
     * This class does not move the drag target nodes, but a proxy element which may contain any DOM structure you wish. The
     * DOM element to show in the proxy is provided by either a provided implementation of {@link #getDragData}, or by
     * registered draggables registered with {@link Ext.dd.Registry}
     *
     * If you wish to provide draggability for an arbitrary number of DOM nodes, each of which represent some application
     * object (For example nodes in a {@link Ext.view.View DataView}) then use of this class is the most efficient way to
     * "activate" those nodes.
     *
     * By default, this class requires that draggable child nodes are registered with {@link Ext.dd.Registry}. However a
     * simpler way to allow a DragZone to manage any number of draggable elements is to configure the DragZone with an
     * implementation of the {@link #getDragData} method which interrogates the passed mouse event to see if it has taken
     * place within an element, or class of elements. This is easily done by using the event's {@link
     * Ext.EventObject#getTarget getTarget} method to identify a node based on a {@link Ext.DomQuery} selector. For example,
     * to make the nodes of a DataView draggable, use the following technique. Knowledge of the use of the DataView is
     * required:
     *
     *     myDataView.on('render', function(v) {
     *         myDataView.dragZone = new Ext.dd.DragZone(v.getEl(), {
     *
     *     //      On receipt of a mousedown event, see if it is within a DataView node.
     *     //      Return a drag data object if so.
     *             getDragData: function(e) {
     *
     *     //          Use the DataView's own itemSelector (a mandatory property) to
     *     //          test if the mousedown is within one of the DataView's nodes.
     *                 var sourceEl = e.getTarget(v.itemSelector, 10);
     *
     *     //          If the mousedown is within a DataView node, clone the node to produce
     *     //          a ddel element for use by the drag proxy. Also add application data
     *     //          to the returned data object.
     *                 if (sourceEl) {
     *                     d = sourceEl.cloneNode(true);
     *                     d.id = Ext.id();
     *                     return {
     *                         ddel: d,
     *                         sourceEl: sourceEl,
     *                         repairXY: Ext.fly(sourceEl).getXY(),
     *                         sourceStore: v.store,
     *                         draggedRecord: v.{@link Ext.view.View#getRecord getRecord}(sourceEl)
     *                     }
     *                 }
     *             },
     *
     *     //      Provide coordinates for the proxy to slide back to on failed drag.
     *     //      This is the original XY coordinates of the draggable element captured
     *     //      in the getDragData method.
     *             getRepairXY: function() {
     *                 return this.dragData.repairXY;
     *             }
     *         });
     *     });
     *
     * See the {@link Ext.dd.DropZone DropZone} documentation for details about building a DropZone which cooperates with
     * this DragZone.
     */
    export class DragZone extends Ext.dd.DragSource implements Ext.dd.DragZoneConfig {
        /**
         * True to register this container with the Scrollmanager for auto scrolling during drag operations.
         * A {@link Ext.dd.ScrollManager} configuration may also be passed.
         */
        containerScroll: any|boolean;

        /**
         * An element to register with the ScrollManager if {@link #containerScroll}
         * is set. Defaults to the drag element.
         */
        scrollEl: string|HTMLElement|Ext.dom.Element;

        /**
         * Creates new DragZone.
         * @param {String/HTMLElement/Ext.Element} el The container element or ID of it.
         */
        constructor(el: string|HTMLElement|Ext.dom.Element, config: Ext.dd.DragZoneConfig);

        destroy();

        /**
         * Called before a repair of an invalid drop to get the XY to animate to. By default returns the XY of
         * this.dragData.ddel
         * @param {Event} e The mouse up event
         * @return {Number[]} The xy location (e.g. '[100, 200]')
         */
        getRepairXY(e: Event): number;

        /**
         * Called once drag threshold has been reached to initialize the proxy element. By default, it clones the
         * this.dragData.ddel
         * @param {Number} x The x position of the click on the dragged object
         * @param {Number} y The y position of the click on the dragged object
         * @return {Boolean} true to continue the drag, false to cancel
         */
        onInitDrag(x: number, y: number): boolean;
    }

    interface DropTargetConfig {
        /**
         * A named drag drop group to which this object belongs.  If a group is specified, then this object will only
         * interact with other drag drop objects in the same group.
         */
        ddGroup?: string;

        /**
         * The CSS class returned to the drag source when drop is allowed.
         */
        dropAllowed?: string;

        /**
         * The CSS class returned to the drag source when drop is not allowed.
         */
        dropNotAllowed?: string;

        /**
         * The CSS class applied to the drop target element while the drag source is over it.
         *
         * Optional, Defaults to: ""
         */
        overClass?: string;
    }

    /**
     * A simple class that provides the basic implementation needed to make any element a drop target that can have
     * draggable items dropped onto it.  The drop has no effect until an implementation of notifyDrop is provided.
     */
    export class DropTarget extends Ext.dd.DDTarget implements Ext.dd.DropTargetConfig {
        isTarget: boolean;

        /**
         * A named drag drop group to which this object belongs.  If a group is specified, then this object will only
         * interact with other drag drop objects in the same group.
         */
        ddGroup: string;

        /**
         * The CSS class returned to the drag source when drop is allowed.
         */
        dropAllowed: string;

        /**
         * The CSS class returned to the drag source when drop is not allowed.
         */
        dropNotAllowed: string;

        /**
         * The CSS class applied to the drop target element while the drag source is over it.
         *
         * Optional, Defaults to: ""
         */
        overClass: string;

        /**
         * Creates new DropTarget.
         * @param {String/HTMLElement/Ext.Element} el The container element or ID of it.
         */
        constructor(el: string|HTMLElement|Ext.dom.Element, config: Ext.dd.DropTargetConfig);

        destroy();

        /**
         * The function a {@link Ext.dd.DragSource} calls once to notify this drop target that the dragged item has
         * been dropped on it.  This method has no default implementation and returns false, so you must provide an
         * implementation that does something to process the drop event and returns true so that the drag source's
         * repair action does not run.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop target
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {Boolean} False if the drop was invalid.
         */
        notifyDrop(source: Ext.dd.DragSource, e: Event, data: any): boolean;

        /**
         * The function a {@link Ext.dd.DragSource} calls once to notify this drop target that the source is now over the
         * target.  This default implementation adds the CSS class specified by overClass (if any) to the drop element
         * and returns the dropAllowed config value.  This method should be overridden if drop validation is required.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop target
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {String} status The CSS class that communicates the drop status back to the source so that the
         * underlying {@link Ext.dd.StatusProxy} can be updated
         */
        notifyEnter(source: Ext.dd.DragSource, e: Event, data: any): string;

        /**
         * The function a {@link Ext.dd.DragSource} calls once to notify this drop target that the source has been dragged
         * out of the target without dropping.  This default implementation simply removes the CSS class specified by
         * overClass (if any) from the drop element.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop target
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         */
        notifyOut(source: Ext.dd.DragSource, e: Event, data: any);

        /**
         * The function a {@link Ext.dd.DragSource} calls continuously while it is being dragged over the target.
         * This method will be called on every mouse movement while the drag source is over the drop target.
         * This default implementation simply returns the dropAllowed config value.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop target
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {String} status The CSS class that communicates the drop status back to the source so that the
         * underlying {@link Ext.dd.StatusProxy} can be updated
         */
        notifyOver(source: Ext.dd.DragSource, e: Event, data: any): string;
    }

    /**
     * This class provides a container DD instance that allows dropping on multiple child target nodes.
     *
     * By default, this class requires that child nodes accepting drop are registered with {@link Ext.dd.Registry}.
     * However a simpler way to allow a DropZone to manage any number of target elements is to configure the
     * DropZone with an implementation of {@link #getTargetFromEvent} which interrogates the passed
     * mouse event to see if it has taken place within an element, or class of elements. This is easily done
     * by using the event's {@link Ext.EventObject#getTarget getTarget} method to identify a node based on a
     * {@link Ext.DomQuery} selector.
     *
     * Once the DropZone has detected through calling getTargetFromEvent, that the mouse is over
     * a drop target, that target is passed as the first parameter to {@link #onNodeEnter}, {@link #onNodeOver},
     * {@link #onNodeOut}, {@link #onNodeDrop}. You may configure the instance of DropZone with implementations
     * of these methods to provide application-specific behaviour for these events to update both
     * application state, and UI state.
     *
     * For example to make a GridPanel a cooperating target with the example illustrated in
     * {@link Ext.dd.DragZone DragZone}, the following technique might be used:
     *
     *     myGridPanel.on('render', function() {
     *         myGridPanel.dropZone = new Ext.dd.DropZone(myGridPanel.getView().scroller, {
     *
     *             // If the mouse is over a grid row, return that node. This is
     *             // provided as the "target" parameter in all "onNodeXXXX" node event handling functions
     *             getTargetFromEvent: function(e) {
     *                 return e.getTarget(myGridPanel.getView().rowSelector);
     *             },
     *
     *             // On entry into a target node, highlight that node.
     *             onNodeEnter : function(target, dd, e, data){
     *                 Ext.fly(target).addCls('my-row-highlight-class');
     *             },
     *
     *             // On exit from a target node, unhighlight that node.
     *             onNodeOut : function(target, dd, e, data){
     *                 Ext.fly(target).removeCls('my-row-highlight-class');
     *             },
     *
     *             // While over a target node, return the default drop allowed class which
     *             // places a "tick" icon into the drag proxy.
     *             onNodeOver : function(target, dd, e, data){
     *                 return Ext.dd.DropZone.prototype.dropAllowed;
     *             },
     *
     *             // On node drop we can interrogate the target to find the underlying
     *             // application object that is the real target of the dragged data.
     *             // In this case, it is a Record in the GridPanel's Store.
     *             // We can use the data set up by the DragZone's getDragData method to read
     *             // any data we decided to attach in the DragZone's getDragData method.
     *             onNodeDrop : function(target, dd, e, data){
     *                 var rowIndex = myGridPanel.getView().findRowIndex(target);
     *                 var r = myGridPanel.getStore().getAt(rowIndex);
     *                 Ext.Msg.alert('Drop gesture', 'Dropped Record id ' + data.draggedRecord.id +
     *                     ' on Record id ' + r.id);
     *                 return true;
     *             }
     *         });
     *     }
     *
     * See the {@link Ext.dd.DragZone DragZone} documentation for details about building a DragZone which
     * cooperates with this DropZone.
     */
    export class DropZone extends Ext.dd.DropTarget {
        /**
         * Creates new DropTarget.
         * @param {String/HTMLElement/Ext.Element} el The container element or ID of it.
         */
        constructor(el: string|HTMLElement|Ext.dom.Element, config: Ext.dd.DropTargetConfig);

        /**
         * Returns a custom data object associated with the DOM node that is the target of the event.  By default
         * this looks up the event target in the {@link Ext.dd.Registry}, although you can override this method to
         * provide your own custom lookup.
         * @param {Event} e The event
         * @return {Object} data The custom data
         */
        getTargetFromEvent(e: Event): any;

        /**
         * The function a {@link Ext.dd.DragSource} calls once to notify this drop zone that the dragged item has
         * been dropped on it.  The drag zone will look up the target node based on the event passed in, and if there
         * is a node registered for that event, it will delegate to {@link #onNodeDrop} for node-specific handling,
         * otherwise it will call {@link #onContainerDrop}.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop zone
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {Boolean} False if the drop was invalid.
         */
        notifyDrop(source: Ext.dd.DragSource, e: Event, data: any): boolean;

        /**
         * The function a {@link Ext.dd.DragSource} calls once to notify this drop zone that the source is now over
         * the zone.  The default implementation returns this.dropNotAllowed and expects that only registered drop
         * nodes can process drag drop operations, so if you need the drop zone itself to be able to process drops
         * you should override this method and provide a custom implementation.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop zone
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {String} status The CSS class that communicates the drop status back to the source so that the
         * underlying {@link Ext.dd.StatusProxy} can be updated
         */
        notifyEnter(source: Ext.dd.DragSource, e: Event, data: any): string;

        /**
         * The function a {@link Ext.dd.DragSource} calls once to notify this drop zone that the source has been dragged
         * out of the zone without dropping.  If the drag source is currently over a registered node, the notification
         * will be delegated to {@link #onNodeOut} for node-specific handling, otherwise it will be ignored.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop target
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag zone
         */
        notifyOut(source: Ext.dd.DragSource, e: Event, data: any);

        /**
         * The function a {@link Ext.dd.DragSource} calls continuously while it is being dragged over the drop zone.
         * This method will be called on every mouse movement while the drag source is over the drop zone.
         * It will call {@link #onNodeOver} while the drag source is over a registered node, and will also automatically
         * delegate to the appropriate node-specific methods as necessary when the drag source enters and exits
         * registered nodes ({@link #onNodeEnter}, {@link #onNodeOut}). If the drag source is not currently over a
         * registered node, it will call {@link #onContainerOver}.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop zone
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {String} status The CSS class that communicates the drop status back to the source so that the
         * underlying {@link Ext.dd.StatusProxy} can be updated
         */
        notifyOver(source: Ext.dd.DragSource, e: Event, data: any): string;

        /**
         * Called when the DropZone determines that a {@link Ext.dd.DragSource} has been dropped on it,
         * but not on any of its registered drop nodes.  The default implementation returns false, so it should be
         * overridden to provide the appropriate processing of the drop event if you need the drop zone itself to
         * be able to accept drops.  It should return true when valid so that the drag source's repair action does not run.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop zone
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {Boolean} True if the drop was valid, else false
         */
        onContainerDrop(source: Ext.dd.DragSource, e: Event, data: any): boolean;

        /**
         * Called while the DropZone determines that a {@link Ext.dd.DragSource} is being dragged over it,
         * but not over any of its registered drop nodes.  The default implementation returns this.dropNotAllowed, so
         * it should be overridden to provide the proper feedback if necessary.
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop zone
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {String} status The CSS class that communicates the drop status back to the source so that the
         * underlying {@link Ext.dd.StatusProxy} can be updated
         */
        onContainerOver(source: Ext.dd.DragSource, e: Event, data: any): string;

        /**
         * Called when the DropZone determines that a {@link Ext.dd.DragSource} has been dropped onto
         * the drop node.  The default implementation returns false, so it should be overridden to provide the
         * appropriate processing of the drop event and return true so that the drag source's repair action does not run.
         * @param {Object} nodeData The custom data associated with the drop node (this is the same value returned from
         * {@link #getTargetFromEvent} for this node)
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop zone
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {Boolean} True if the drop was valid, else false
         */
        onNodeDrop(nodeData: any, source: Ext.dd.DragSource, e: Event, data: any): boolean;

        /**
         * Called when the DropZone determines that a {@link Ext.dd.DragSource} has entered a drop node
         * that has either been registered or detected by a configured implementation of {@link #getTargetFromEvent}.
         * This method has no default implementation and should be overridden to provide
         * node-specific processing if necessary.
         * @param {Object} nodeData The custom data associated with the drop node (this is the same value returned from
         * {@link #getTargetFromEvent} for this node)
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop zone
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         */
        onNodeEnter(nodeData: any, source: Ext.dd.DragSource, e: Event, data: any);

        /**
         * Called when the DropZone determines that a {@link Ext.dd.DragSource} has been dragged out of
         * the drop node without dropping.  This method has no default implementation and should be overridden to provide
         * node-specific processing if necessary.
         * @param {Object} nodeData The custom data associated with the drop node (this is the same value returned from
         * {@link #getTargetFromEvent} for this node)
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop zone
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         */
        onNodeOut(nodeData: any, source: Ext.dd.DragSource, e: Event, data: any);

        /**
         * Called while the DropZone determines that a {@link Ext.dd.DragSource} is over a drop node
         * that has either been registered or detected by a configured implementation of {@link #getTargetFromEvent}.
         * The default implementation returns this.dropAllowed, so it should be
         * overridden to provide the proper feedback.
         * @param {Object} nodeData The custom data associated with the drop node (this is the same value returned from
         * {@link #getTargetFromEvent} for this node)
         * @param {Ext.dd.DragSource} source The drag source that was dragged over this drop zone
         * @param {Event} e The event
         * @param {Object} data An object containing arbitrary data supplied by the drag source
         * @return {String} status The CSS class that communicates the drop status back to the source so that the
         * underlying {@link Ext.dd.StatusProxy} can be updated
         */
        onNodeOver(nodeData: any, source: Ext.dd.DragSource, e: Event, data: any): string;
    }

    /**
     * Provides easy access to all drag drop components that are registered on a page. Items can be retrieved either
     * directly by DOM node id, or by passing in the drag drop event that occurred and looking up the event target.
     */
    export class Registry {
        /**
         * Returns the handle registered for a DOM Node by id
         * @param {String/HTMLElement} id The DOM node or id to look up
         * @return {Object} handle The custom handle data
         */
        static getHandle(id: string|HTMLElement): any;

        /**
         * Returns the handle that is registered for the DOM node that is the target of the event
         * @param {Event} e The event
         * @return {Object} handle The custom handle data
         */
        static getHandleFromEvent(e: Event): any;

        /**
         * Returns a custom data object that is registered for a DOM node by id
         * @param {String/HTMLElement} id The DOM node or id to look up
         * @return {Object} data The custom data
         */
        static getTarget(id: string|HTMLElement): any;

        /**
         * Returns a custom data object that is registered for the DOM node that is the target of the event
         * @param {Event} e The event
         * @return {Object} data The custom data
         */
        static getTargetFromEvent(e: Event): any;

        /**
         * Registers a drag drop element.
         *
         * @param {String/HTMLElement} element The id or DOM node to register
         * @param {Object} data An custom data object that will be passed between the elements that are involved in drag
         * drop operations. You can populate this object with any arbitrary properties that your own code knows how to
         * interpret, plus there are some specific properties known to the Registry that should be populated in the data
         * object (if applicable):
         * @param {HTMLElement[]} data.handles Array of DOM nodes that trigger dragging for the element being registered.
         * @param {Boolean} data.isHandle True if the element passed in triggers dragging itself, else false.
         */
        static register(element: string|HTMLElement, data: any, data_handles: HTMLElement, data_isHandle: boolean);

        /**
         * Unregister a drag drop element
         * @param {String/HTMLElement} element The id or DOM node to unregister
         */
        static unregister(element: string|HTMLElement);
    }

    /**
     * Provides automatic scrolling of overflow regions in the page during drag operations.
     *
     * The ScrollManager configs will be used as the defaults for any scroll container registered with it, but you can also
     * override most of the configs per scroll container by adding a ddScrollConfig object to the target element that
     * contains these properties: {@link #hthresh}, {@link #vthresh}, {@link #increment} and {@link #frequency}. Example
     * usage:
     *
     *     var el = Ext.get('scroll-ct');
     *     el.ddScrollConfig = {
     *         vthresh: 50,
     *         hthresh: -1,
     *         frequency: 100,
     *         increment: 200
     *     };
     *     Ext.dd.ScrollManager.register(el);
     *
     * Note: This class is designed to be used in "Point Mode
     */
    export class ScrollManager {
        /**
         * True to animate the scroll
         */
        static animate: any;

        /**
         * The animation duration in seconds - MUST BE less than Ext.dd.ScrollManager.frequency!
         */
        static animDuration: any;

        /**
         * The named drag drop {@link Ext.dd.DragSource#ddGroup group} to which this container belongs. If a ddGroup is
         * specified, then container scrolling will only occur when a dragged object is in the same ddGroup.
         */
        static ddGroup: string;

        /**
         * The frequency of scrolls in milliseconds
         */
        static frequency: any;

        /**
         * The number of pixels from the right or left edge of a container the pointer needs to be to trigger scrolling
         */
        static hthresh: any;

        /**
         * The number of pixels to scroll in each scroll increment
         */
        static increment: any;

        /**
         * The number of pixels from the top or bottom edge of a container the pointer needs to be to trigger scrolling
         */
        static vthresh: any;

        /**
         * Manually trigger a cache refresh.
         */
        static refreshCache();

        /**
         * Registers new overflow element(s) to auto scroll
         * The id of or the element to be scrolled or an array of either
         */
        static register(el: string|HTMLElement|Ext.dom.Element);

        /**
         * Unregisters overflow element(s) so they are no longer scrolled
         * The id of or the element to be removed or an array of either
         */
        static unregister(el: string|HTMLElement|Ext.dom.Element);
    }

    interface StatusProxyConfig extends Ext.ComponentConfig {
        /**
         * The CSS class to apply to the status element when drop is allowed.
         */
        dropAllowed?: string;

        /**
         * The CSS class to apply to the status element when drop is not allowed.
         */
        dropNotAllowed?: string;
    }

    /**
     * A specialized floating Component that supports a drop status icon, {@link Ext.Layer} styles
     * and auto-repair.  This is the default drag proxy used by all Ext.dd components.
     */
    export class StatusProxy extends Ext.Component implements Ext.dd.StatusProxyConfig {
        /**
         * The CSS class to apply to the status element when drop is allowed.
         */
        dropAllowed: string;

        /**
         * The CSS class to apply to the status element when drop is not allowed.
         */
        dropNotAllowed: string;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * Creates new StatusProxy.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.dd.StatusProxyConfig);

        /**
         * Returns the ghost element
         * @return {Ext.Element} el
         */
        getGhost(): Ext.dom.Element;

        /**
         * Causes the proxy to return to its position of origin via an animation.
         * Should be called after an invalid drop operation by the item being dragged.
         * @param {Number[]} xy The XY position of the element ([x, y])
         * @param {Function} callback The function to call after the repair is complete.
         * @param {Object} scope The scope ('this' reference) in which the callback function is executed.
         * Defaults to the browser window.
         */
        repair(xy: number, callback: Function, scope: any);

        /**
         * Resets the status indicator to the default dropNotAllowed value
         * @param {Boolean} clearGhost True to also remove all content from the ghost, false to preserve it
         */
        reset(clearGhost: boolean);

        /**
         * Updates the proxy's visual element to indicate the status of whether or not drop is allowed
         * over the current target element.
         * @param {String} cssClass The css class for the new drop status indicator image
         */
        setStatus(cssClass: string);

        /**
         * Stops the repair animation if it's currently running
         */
        stop();

        /**
         * Force the Layer to sync its shadow and shim positions to the element
         */
        sync();
    }
}

declare module Ext.dd.DragDropManager {
    /**
     * Deprecated inner class for cached elements.
     * @deprecated This wrapper isn't that useful
     */
    export class ElementWrapper {
        /** A reference to the style property */
        css: any;

        /** The element */
        el: any;

        /** The element id */
        id: any;
    }
}

declare module Ext.direct {
    /**
     * Base class for all Ext.direct events. An event is
     * created after some kind of interaction with the server.
     * The event class is essentially just a data structure
     * to hold a Direct response.
     */
    export class Event extends Ext.Base {
        /**
         * Creates new Event.
         * @param {Object} [config] Config object.
         */
        constructor(config?: any);

        /**
         * Return the raw data for this event.
         * @return {Mixed} The data from the event
         */
        getData(): any;
    }

    /**
     * An event that is fired when an exception is received from a {@link Ext.direct.RemotingProvider}
     */
    export class ExceptionEvent extends Ext.direct.RemotingEvent {
        /**
         * Creates new Event.
         * @param {Object} [config] Config object.
         */
        constructor(config?: any);
    }

    /**
     * A base provider for communicating using JSON. This is an abstract class
     * and should not be instanced directly.
     *
     * @abstract
     */
    export class JsonProvider extends Ext.direct.Provider {
        /**
         * Create an event from a response object
         *
         * @param {Object} response Response object
         *
         * @return {Ext.direct.Event} The event
         */
        createEvent(response: any): Ext.direct.Event;

        /**
         * Creates a set of events based on the XHR response
         *
         * @param {Object} response The XHR response
         *
         * @return {Ext.direct.Event[]} An array of Ext.direct.Event
         */
        createEvents(response: any): Ext.direct.Event;
    }

    /**
     * Ext.Direct aims to streamline communication between the client and server by providing a single interface that
     * reduces the amount of common code typically required to validate data and handle returned data packets (reading data,
     * error conditions, etc).
     *
     * The Ext.direct namespace includes several classes for a closer integration with the server-side. The Ext.data
     * namespace also includes classes for working with Ext.data.Stores which are backed by data from an Ext.Direct method.
     *
     * # Specification
     *
     * For additional information consult the [Ext.Direct Specification][1].
     *
     * # Providers
     *
     * Ext.Direct uses a provider architecture, where one or more providers are used to transport data to and from the
     * server. There are several providers that exist in the core at the moment:
     *
     * - {@link Ext.direct.JsonProvider JsonProvider} for simple JSON operations
     * - {@link Ext.direct.PollingProvider PollingProvider} for repeated requests
     * - {@link Ext.direct.RemotingProvider RemotingProvider} exposes server side on the client.
     *
     * A provider does not need to be invoked directly, providers are added via {@link Ext.direct.Manager}.{@link #addProvider}.
     *
     * # Router
     *
     * Ext.Direct utilizes a "router" on the server to direct requests from the client to the appropriate server-side
     * method. Because the Ext.Direct API is completely platform-agnostic, you could completely swap out a Java based server
     * solution and replace it with one that uses C# without changing the client side JavaScript at all.
     *
     * # Server side events
     *
     * Custom events from the server may be handled by the client by adding listeners, for example:
     *
     *     {"type":"event","name":"message","data":"Successfully polled at: 11:19:30 am"}
     *
     *     // add a handler for a 'message' event sent by the server
     *     Ext.direct.Manager.on('message', function(e){
     *         out.append(String.format('<p><i>{0}</i></p>', e.data));
     *         out.el.scrollTo('t', 100000, true);
     *     });
     *
     *    [1]: http://sencha.com/products/extjs/extdirect
     *
     * @alternateClassName Ext.Direct
     */
    export class Manager {
        /**
         * Exception types.
         */
        static exceptions: any;

        /**
         * Adds an Ext.Direct Provider and creates the proxy or stub methods to execute server-side methods. If the provider
         * is not already connected, it will auto-connect.
         *
         *      var pollProv = new Ext.direct.PollingProvider({
         *          url: 'php/poll2.php'
         *      });
         *
         *      Ext.direct.Manager.addProvider({
         *          type: 'remoting',           // create a {@link Ext.direct.RemotingProvider}
         *          url:  'php/router.php',     // url to connect to the Ext.Direct server-side router.
         *          actions: {                  // each property within the actions object represents a Class
         *              TestAction: [{          // array of methods within each server side Class
         *                  name: 'doEcho',     // name of method
         *                  len:  1
         *              }, {
         *                  name: 'multiply',
         *                  len:  1
         *              }, {
         *                  name: 'doForm',
         *                  formHandler: true   // handle form on server with Ext.Direct.Transaction
         *              }]
         *          },
         *          namespace: 'myApplication', // namespace to create the Remoting Provider in
         *      }, {
         *          type: 'polling',            // create a {@link Ext.direct.PollingProvider}
         *          url:  'php/poll.php'
         *      },
         *      pollProv);                      // reference to previously created instance
         *
         * Accepts any number of Provider descriptions (an instance or config object for
         * a Provider). Each Provider description instructs Ext.Direct how to create
         * client-side stub methods.
         */
        static addProvider(provider: Ext.direct.Provider[]|any[]);

        /**
         * Retrieves a {@link Ext.direct.Provider provider} by the **{@link Ext.direct.Provider#id id}** specified when the
         * provider is {@link #addProvider added}.
         *
         * @param {String/Ext.direct.Provider} id The id of the provider, or the provider instance.
         */
        static getProvider(id: string|Ext.direct.Provider);

        /**
         * Parses a direct function. It may be passed in a string format, for example:
         * "MyApp.Person.read".
         *
         * @param {String/Function} fn The direct function
         *
         * @return {Function} The function to use in the direct call. Null if not found
         */
        protected static parseMethod(fn: string|Function): Function;

        /**
         * Removes the provider.
         *
         * @param {String/Ext.direct.Provider} provider The provider instance or the id of the provider.
         *
         * @return {Ext.direct.Provider} The provider, null if not found.
         */
        static removeProvider(provider: string|Ext.direct.Provider): Ext.direct.Provider;

        /**
         * Fires after an event.
         *
         * @param {Ext.direct.Event} event The Ext.direct.Event type that occurred.
         * @param {Ext.direct.Provider} provider The {@link Ext.direct.Provider Provider}.
         */
        static event(event: Ext.direct.Event, provider: Ext.direct.Provider);

        /**
         * Fires after an event exception.
         *
         * @param {Ext.direct.Event} event The event type that occurred.
         */
        static exception(event: Ext.direct.Event);
    }

    interface PollingProviderConfig extends Ext.direct.ProviderConfig {
        /**
         * An object containing properties which are to be sent as parameters on every polling request
         *
         * Optional
         */
        baseParams?: any;

        /**
         * How often to poll the server-side in milliseconds. Defaults to every 3 seconds.
         *
         * Optional, Defaults to: 3000
         */
        interval?: number;

        /**
         * The url which the PollingProvider should contact with each request. This can also be
         * an imported Ext.Direct method which will accept the baseParams as its only argument.
         */
        url?: string|Function;
    }

    /**
     * Provides for repetitive polling of the server at distinct {@link #interval intervals}.
     * The initial request for data originates from the client, and then is responded to by the
     * server.
     *
     * Configuration for the PollingProvider can be generated by the server-side
     * API portion of the Ext.Direct stack.
     *
     * An instance of PollingProvider may be created directly via the new keyword or by simply
     * specifying 'type = 'polling''. For example:
     *
     *      var pollA = new Ext.direct.PollingProvider({
     *          type:'polling',
     *          url: 'php/pollA.php',
     *      });
     *      Ext.direct.Manager.addProvider(pollA);
     *      pollA.disconnect();
     *
     *      Ext.direct.Manager.addProvider({
     *          type:'polling',
     *          url: 'php/pollB.php',
     *          id: 'pollB-provider'
     *      });
     *      var pollB = Ext.direct.Manager.getProvider('pollB-provider');
     */
    export class PollingProvider extends Ext.direct.JsonProvider implements Ext.direct.PollingProviderConfig {
        /**
         * An object containing properties which are to be sent as parameters on every polling request
         *
         * Optional
         */
        baseParams: any;

        /**
         * How often to poll the server-side in milliseconds. Defaults to every 3 seconds.
         *
         * Optional, Defaults to: 3000
         */
        interval: number;

        /**
         * The url which the PollingProvider should contact with each request. This can also be
         * an imported Ext.Direct method which will accept the baseParams as its only argument.
         */
        url: string|Function;

        /**
         * Connect to the server-side and begin the polling process. To handle each
         * response subscribe to the data event.
         */
        connect();

        /**
         * Disconnect from the server-side and stop the polling process. The disconnect
         * event will be fired on a successful disconnect.
         */
        disconnect();

        /**
         * Returns whether or not the server-side is currently connected.
         * Abstract method for subclasses to implement.
         */
        isConnected();

        /**
         * Fired immediately before a poll takes place.
         */
        beforepoll(that: Ext.direct.PollingProvider);

        /**
         * Fired immediately after a poll takes place.
         */
        poll(that: Ext.direct.PollingProvider);
    }

    interface ProviderConfig {
        /**
         * The unique id of the provider (defaults to an {@link Ext#id auto-assigned id}).
         * You should assign an id if you need to be able to access the provider later and you do
         * not have an object reference available, for example:
         *
         *      Ext.direct.Manager.addProvider({
         *          type: 'polling',
         *          url:  'php/poll.php',
         *          id:   'poll-provider'
         *      });
         *      var p = {@link Ext.direct.Manager}.{@link Ext.direct.Manager#getProvider getProvider}('poll-provider');
         *     p.disconnect();
         */
        id?: string;

        /**
         * List of Provider events that should be relayed by {@link Ext.direct.Manager}.
         * 'data' event is always relayed.
         */
        relayedEvents?: string;
    }

    /**
     * Ext.direct.Provider is an abstract class meant to be extended.
     *
     * For example Ext JS implements the following subclasses:
     *
     *     Provider
     *     |
     *     +---{@link Ext.direct.JsonProvider JsonProvider}
     *         |
     *         +---{@link Ext.direct.PollingProvider PollingProvider}
     *         |
     *         +---{@link Ext.direct.RemotingProvider RemotingProvider}
     *
     * @abstract
     */
    export class Provider extends Ext.Base implements Ext.direct.ProviderConfig {
        /**
         * The unique id of the provider (defaults to an {@link Ext#id auto-assigned id}).
         * You should assign an id if you need to be able to access the provider later and you do
         * not have an object reference available, for example:
         *
         *      Ext.direct.Manager.addProvider({
         *          type: 'polling',
         *          url:  'php/poll.php',
         *          id:   'poll-provider'
         *      });
         *      var p = {@link Ext.direct.Manager}.{@link Ext.direct.Manager#getProvider getProvider}('poll-provider');
         *     p.disconnect();
         */
        id: string;

        /**
         * List of Provider events that should be relayed by {@link Ext.direct.Manager}.
         * 'data' event is always relayed.
         */
        relayedEvents: string;

        /**
         * Abstract method for subclasses to implement.
         */
        connect();

        /**
         * Abstract method for subclasses to implement.
         */
        disconnect();

        /**
         * Returns whether or not the server-side is currently connected.
         * Abstract method for subclasses to implement.
         */
        isConnected();

        /**
         * Fires when the Provider receives data from the server-side
         *
         * @param {Ext.direct.Provider} provider The {@link Ext.direct.Provider Provider}.
         * @param {Ext.direct.Event} e The Ext.direct.Event type that occurred.
         */
        data(provider: Ext.direct.Provider, e: Ext.direct.Event);

        /**
         * Fires when the Provider receives an exception from the server-side
         */
        exception();
    }

    /**
     * An event that is fired when data is received from a
     * {@link Ext.direct.RemotingProvider}. Contains a method to the
     * related transaction for the direct request, see {@link #getTransaction}
     */
    export class RemotingEvent extends Ext.direct.Event {
        /**
         * Creates new Event.
         * @param {Object} [config] Config object.
         */
        constructor(config?: any);

        /**
         * Get the transaction associated with this event.
         * @return {Ext.direct.Transaction} The transaction
         */
        getTransaction(): Ext.direct.Transaction;
    }

    /**
     * Small utility class used internally to represent a Direct method.
     */
    export class RemotingMethod extends Ext.Base {
        constructor(config: any);

        /**
         * Takes the arguments for the Direct function and splits the arguments
         * from the scope and the callback.
         *
         * @param {Array} args The arguments passed to the direct call
         *
         * @return {Object} An object with 3 properties: args, callback & scope.
         */
        getCallData(args: any[]): any;
    }

    interface RemotingProviderConfig extends Ext.direct.ProviderConfig {
        /**
         * Object literal defining the server side actions and methods. For example, if
         * the Provider is configured with:
         *
         *      // each property within the 'actions' object represents a server side Class
         *      actions: {
         *          TestAction: [   // array of methods within each server side Class to be
         *          {               // stubbed out on client
         *              name: 'doEcho',   // stub method will be TestAction.doEcho
         *              len:  1
         *          }, {
         *              name: 'multiply', // name of method
         *              len:  2           // The number of parameters that will be used to create an
         *                                // array of data to send to the server side function.
         *          }, {
         *              name: 'doForm',
         *              formHandler: true // tells the client that this method handles form calls
         *          }],
         *
         *          // These methods will be created in nested namespace TestAction.Foo
         *          'TestAction.Foo': [{
         *              name: 'ordered',  // stub method will be TestAction.Foo.ordered
         *              len:  1
         *          }, {
         *              name: 'noParams', // this method does not accept any parameters
         *              len:  0
         *          }, {
         *              name: 'named',    // stub method will be TestAction.Foo.named
         *              params: ['foo', 'bar']    // parameters are passed by name
         *          }]
         *      }
         *
         * Note that starting with 4.2, dotted Action names will generate nested objects.
         * If you wish to reverse to previous behavior, set {@link #cfg-disableNestedActions}
         * to 'true'.
         *
         * In the following example a *client side* handler is used to call the
         * server side method "multiply" in the server-side "TestAction" Class:
         *
         *      TestAction.multiply(
         *          // pass two arguments to server, so specify len=2
         *          2, 4,
         *
         *          // callback function after the server is called
         *          //  result: the result returned by the server
         *          //       e: Ext.direct.RemotingEvent object
         *          // success: true or false
         *          // options: options to be applied to method call and passed to callback
         *          function (result, e, success, options) {
         *              var t, action, method;
         *
         *              t = e.getTransaction();
         *              action = t.action; // server side Class called
         *              method = t.method; // server side method called
         *
         *              if (e.status) {
         *                  var answer = Ext.encode(result); // 8
         *              }
         *              else {
         *                  var msg = e.message; // failure message
         *              }
         *          },
         *
         *          // Scope to call the callback in (optional)
         *          window,
         *
         *          // Options to apply to this method call. This can include
         *          // Ajax.request() options; only 'timeout' is supported at this time.
         *          // When timeout is set for a method call, it will be executed immediately
         *          // without buffering.
         *          // The same options object is passed to the callback so it's possible
         *          // to "forward" some data when needed.
         *          {
         *              timeout: 60000, // milliseconds
         *              foo: 'bar'
         *          }
         *      );
         *
         * In the example above, the server side "multiply" function will be passed two
         * arguments (2 and 4). The "multiply" method should return the value 8 which will be
         * available as the 'result' in the callback example above.
         */
        actions?: any;

        /**
         * In versions prior to 4.2, using dotted Action names was not really meaningful,
         * because it generated flat {@link #cfg-namespace} object with dotted property names.
         * For example, take this API declaration:
         *
         *      {
         *          actions: {
         *              TestAction: {
         *                  name: 'foo',
         *                  len:  1
         *              },
         *              'TestAction.Foo' {
         *                  name: 'bar',
         *                  len: 1
         *              }
         *          },
         *          namespace: 'MyApp'
         *      }
         *
         * Before 4.2, that would generate the following API object:
         *
         *      window.MyApp = {
         *          TestAction: {
         *              foo: function() { ... }
         *          },
         *          'TestAction.Foo': {
         *              bar: function() { ... }
         *          }
         *      }
         *
         * In Ext JS 4.2, we introduced new namespace handling behavior. Now the same API object
         * will be like this:
         *
         *      window.MyApp = {
         *          TestAction: {
         *              foo: function() { ... },
         *
         *              Foo: {
         *                  bar: function() { ... }
         *              }
         *          }
         *      }
         *
         * Instead of addressing Action methods array-style 'MyApp['TestAction.Foo'].bar()',
         * now it is possible to use object addressing: 'MyApp.TestAction.Foo.bar()'.
         *
         * If you find this behavior undesirable, set this config option to 'true'.
         *
         * Optional, Defaults to: false
         */
        disableNestedActions?: boolean;

        /**
         * 'true' or 'false' to enable or disable combining of method
         * calls. If a number is specified this is the amount of time in milliseconds
         * to wait before sending a batched request.
         *
         * Calls which are received within the specified timeframe will be
         * concatenated together and sent in a single request, optimizing the
         * application by reducing the amount of round trips that have to be made
         * to the server. To cancel buffering for some particular invocations, pass
         * 'timeout' parameter in 'options' object for that method call.
         *
         * Optional, Defaults to: 10
         */
        enableBuffer?: number|boolean;

        /**
         * Specify which param will hold the arguments for the method.
         *
         * Optional, Defaults to: data
         */
        enableUrlEncode?: string;

        /**
         * Number of times to re-attempt delivery on failure of a call.
         *
         * Optional, Defaults to: 1
         */
        maxRetries?: number;

        /**
         * Namespace for the Remoting Provider (defaults to 'Ext.global').
         * Explicitly specify the namespace Object, or specify a String to have a
         * {@link Ext#namespace namespace} created implicitly.
         */
        namespace?: string|any;

        /**
         * The timeout to use for each request.
         *
         * Optional
         */
        timeout?: number;

        /**
         * **Required**. The url to connect to the {@link Ext.direct.Manager} server-side router.
         */
        url?: string;
    }

    /**
     * The {@link Ext.direct.RemotingProvider RemotingProvider} exposes access to
     * server side methods on the client (a remote procedure call (RPC) type of
     * connection where the client can initiate a procedure on the server).
     *
     * This allows for code to be organized in a fashion that is maintainable,
     * while providing a clear path between client and server, something that is
     * not always apparent when using URLs.
     *
     * To accomplish this the server-side needs to describe what classes and methods
     * are available on the client-side. This configuration will typically be
     * outputted by the server-side Ext.Direct stack when the API description is built.
     */
    export class RemotingProvider extends Ext.direct.JsonProvider implements Ext.direct.RemotingProviderConfig {
        /**
         * Object literal defining the server side actions and methods. For example, if
         * the Provider is configured with:
         *
         *      // each property within the 'actions' object represents a server side Class
         *      actions: {
         *          TestAction: [   // array of methods within each server side Class to be
         *          {               // stubbed out on client
         *              name: 'doEcho',   // stub method will be TestAction.doEcho
         *              len:  1
         *          }, {
         *              name: 'multiply', // name of method
         *              len:  2           // The number of parameters that will be used to create an
         *                                // array of data to send to the server side function.
         *          }, {
         *              name: 'doForm',
         *              formHandler: true // tells the client that this method handles form calls
         *          }],
         *
         *          // These methods will be created in nested namespace TestAction.Foo
         *          'TestAction.Foo': [{
         *              name: 'ordered',  // stub method will be TestAction.Foo.ordered
         *              len:  1
         *          }, {
         *              name: 'noParams', // this method does not accept any parameters
         *              len:  0
         *          }, {
         *              name: 'named',    // stub method will be TestAction.Foo.named
         *              params: ['foo', 'bar']    // parameters are passed by name
         *          }]
         *      }
         *
         * Note that starting with 4.2, dotted Action names will generate nested objects.
         * If you wish to reverse to previous behavior, set {@link #cfg-disableNestedActions}
         * to 'true'.
         *
         * In the following example a *client side* handler is used to call the
         * server side method "multiply" in the server-side "TestAction" Class:
         *
         *      TestAction.multiply(
         *          // pass two arguments to server, so specify len=2
         *          2, 4,
         *
         *          // callback function after the server is called
         *          //  result: the result returned by the server
         *          //       e: Ext.direct.RemotingEvent object
         *          // success: true or false
         *          // options: options to be applied to method call and passed to callback
         *          function (result, e, success, options) {
         *              var t, action, method;
         *
         *              t = e.getTransaction();
         *              action = t.action; // server side Class called
         *              method = t.method; // server side method called
         *
         *              if (e.status) {
         *                  var answer = Ext.encode(result); // 8
         *              }
         *              else {
         *                  var msg = e.message; // failure message
         *              }
         *          },
         *
         *          // Scope to call the callback in (optional)
         *          window,
         *
         *          // Options to apply to this method call. This can include
         *          // Ajax.request() options; only 'timeout' is supported at this time.
         *          // When timeout is set for a method call, it will be executed immediately
         *          // without buffering.
         *          // The same options object is passed to the callback so it's possible
         *          // to "forward" some data when needed.
         *          {
         *              timeout: 60000, // milliseconds
         *              foo: 'bar'
         *          }
         *      );
         *
         * In the example above, the server side "multiply" function will be passed two
         * arguments (2 and 4). The "multiply" method should return the value 8 which will be
         * available as the 'result' in the callback example above.
         */
        actions: any;

        /**
         * In versions prior to 4.2, using dotted Action names was not really meaningful,
         * because it generated flat {@link #cfg-namespace} object with dotted property names.
         * For example, take this API declaration:
         *
         *      {
         *          actions: {
         *              TestAction: {
         *                  name: 'foo',
         *                  len:  1
         *              },
         *              'TestAction.Foo' {
         *                  name: 'bar',
         *                  len: 1
         *              }
         *          },
         *          namespace: 'MyApp'
         *      }
         *
         * Before 4.2, that would generate the following API object:
         *
         *      window.MyApp = {
         *          TestAction: {
         *              foo: function() { ... }
         *          },
         *          'TestAction.Foo': {
         *              bar: function() { ... }
         *          }
         *      }
         *
         * In Ext JS 4.2, we introduced new namespace handling behavior. Now the same API object
         * will be like this:
         *
         *      window.MyApp = {
         *          TestAction: {
         *              foo: function() { ... },
         *
         *              Foo: {
         *                  bar: function() { ... }
         *              }
         *          }
         *      }
         *
         * Instead of addressing Action methods array-style 'MyApp['TestAction.Foo'].bar()',
         * now it is possible to use object addressing: 'MyApp.TestAction.Foo.bar()'.
         *
         * If you find this behavior undesirable, set this config option to 'true'.
         *
         * Optional, Defaults to: false
         */
        disableNestedActions: boolean;

        /**
         * 'true' or 'false' to enable or disable combining of method
         * calls. If a number is specified this is the amount of time in milliseconds
         * to wait before sending a batched request.
         *
         * Calls which are received within the specified timeframe will be
         * concatenated together and sent in a single request, optimizing the
         * application by reducing the amount of round trips that have to be made
         * to the server. To cancel buffering for some particular invocations, pass
         * 'timeout' parameter in 'options' object for that method call.
         *
         * Optional, Defaults to: 10
         */
        enableBuffer: number|boolean;

        /**
         * Specify which param will hold the arguments for the method.
         *
         * Optional, Defaults to: data
         */
        enableUrlEncode: string;

        /**
         * Number of times to re-attempt delivery on failure of a call.
         *
         * Optional, Defaults to: 1
         */
        maxRetries: number;

        /**
         * Namespace for the Remoting Provider (defaults to 'Ext.global').
         * Explicitly specify the namespace Object, or specify a String to have a
         * {@link Ext#namespace namespace} created implicitly.
         */
        namespace: string|any;

        /**
         * The timeout to use for each request.
         *
         * Optional
         */
        timeout: number;

        /**
         * **Required**. The url to connect to the {@link Ext.direct.Manager} server-side router.
         */
        url: string;

        /**
         * Abstract method for subclasses to implement.
         */
        connect();

        /**
         * Abstract method for subclasses to implement.
         */
        disconnect();

        /**
         * Returns whether or not the server-side is currently connected.
         * Abstract method for subclasses to implement.
         */
        isConnected();

        /**
         * Fires immediately before the client-side sends off the RPC call. By returning
         * 'false' from an event handler you can prevent the call from being made.
         *
         * @param {Object} meta The meta data
         */
        beforecall(provider: Ext.direct.RemotingProvider, transaction: Ext.direct.Transaction, meta: any);

        /**
         * Fires before callback function is executed. By returning 'false' from an event handler
         * you can prevent the callback from executing.
         */
        beforecallback(provider: Ext.direct.RemotingProvider, transaction: Ext.direct.Transaction);

        /**
         * Fires immediately after the request to the server-side is sent. This does
         * NOT fire after the response has come back from the call.
         *
         * @param {Object} meta The meta data
         */
        call(provider: Ext.direct.RemotingProvider, transaction: Ext.direct.Transaction, meta: any);
    }

    interface TransactionConfig {
        /**
         * Provider to use with this Transaction.
         */
        provider?: Ext.direct.Provider;
    }

    /**
     * Supporting Class for Ext.Direct (not intended to be used directly).
     */
    export class Transaction extends Ext.Base implements Ext.direct.TransactionConfig {
        /**
         * Provider to use with this Transaction.
         */
        provider: Ext.direct.Provider;

        /**
         * Creates new Transaction.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.direct.TransactionConfig);
    }
}

declare module Ext.dom {
    export class AbstractElement extends Ext.Base {
        /**
         * The default unit to append to CSS values where a unit isn't provided.
         */
        defaultUnit: string;

        /**
         * The DOM element
         */
        dom: HTMLElement;

        /**
         * The DOM element ID
         */
        id: string;

        /**
         * Adds one or more CSS classes to the element. Duplicate classes are automatically filtered out.
         * @param {String/String[]} className The CSS classes to add separated by space, or an array of classes
         * @return {Ext.dom.Element} this
         */
        addCls(className: string): Ext.dom.Element;

        /**
         * Appends the passed element(s) to this element
         * @param {String/HTMLElement/Ext.dom.AbstractElement/Object} el The id or element to insert or a DomHelper config
         * The id of the node, a DOM Node or an existing Element.
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead of Ext.dom.AbstractElement
         * @return {Ext.dom.AbstractElement} The inserted Element.
         */
        appendChild(el: string|HTMLElement|Ext.dom.AbstractElement|any, returnDom?: boolean): Ext.dom.AbstractElement;

        /**
         * Appends this element to the passed element
         * @param {String/HTMLElement/Ext.dom.AbstractElement} el The new parent element.
         * The id of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.AbstractElement} This element
         */
        appendTo(el: string|HTMLElement|Ext.dom.AbstractElement): Ext.dom.AbstractElement;

        /**
         * More flexible version of {@link #setStyle} for setting style properties.
         * @param {String/Object/Function} styles A style specification string, e.g. "width:100px", or object in the form {width:"100px"}, or
         * a function which returns such a specification.
         * @return {Ext.dom.Element} this
         */
        applyStyles(styles: string|any|Function): Ext.dom.Element;

        /**
         * Selects a single *direct* child based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @param {Boolean} [returnDom=false] True to return the DOM node instead of Ext.dom.Element.
         * @return {HTMLElement/Ext.dom.Element} The child Ext.dom.Element (or DOM node if returnDom = true)
         */
        child(selector: string, returnDom?: boolean): HTMLElement|Ext.dom.Element;

        constructor(element: any, forceNew: any);

        /**
         * Returns true if this element is an ancestor of the passed element
         * @param {HTMLElement/String} el The element to check
         * @return {Boolean} True if this element is an ancestor of el, else false
         */
        contains(el: HTMLElement|string): boolean;

        /**
         * Creates the passed DomHelper config and appends it to this element or optionally inserts it before the passed child element.
         * @param {Object} config DomHelper element config object.  If no tag is specified (e.g., {tag:'input'}) then a div will be
         * automatically generated with the specified attributes.
         * @param {HTMLElement} [insertBefore] a child element of this element
         * @param {Boolean} [returnDom=false] true to return the dom node instead of creating an Element
         * @return {Ext.dom.AbstractElement} The new child element
         */
        createChild(config: any, insertBefore?: HTMLElement, returnDom?: boolean): Ext.dom.AbstractElement;

        /**
         * Alias to {@link #remove}.
         */
        destroy();

        /**
         * Selects a single child at any depth below this element based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @param {Boolean} [returnDom=false] True to return the DOM node instead of Ext.dom.Element
         * @return {HTMLElement/Ext.dom.Element} The child Ext.dom.Element (or DOM node if returnDom = true)
         */
        down(selector: string, returnDom?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Looks at this node and then at parent nodes for a match of the passed simple selector (e.g. div.some-class or span:first-child)
         * @param {String} selector The simple selector to test
         * @param {Number/String/HTMLElement/Ext.Element} [limit]
         * The max depth to search as a number or an element which causes the upward traversal to stop
         * and is <b>not</b> considered for inclusion as the result. (defaults to 50 || document.documentElement)
         * @param {Boolean} [returnEl=false] True to return a Ext.Element object instead of DOM node
         * @return {HTMLElement} The matching DOM node (or null if no match was found)
         */
        findParent(selector: string, limit?: number|string|HTMLElement|Ext.dom.Element, returnEl?: boolean): HTMLElement;

        /**
         * Looks at parent nodes for a match of the passed simple selector (e.g. div.some-class or span:first-child)
         * @param {String} selector The simple selector to test
         * @param {Number/String/HTMLElement/Ext.Element} [limit]
         * The max depth to search as a number or an element which causes the upward traversal to stop
         * and is <b>not</b> considered for inclusion as the result. (defaults to 50 || document.documentElement)
         * @param {Boolean} [returnEl=false] True to return a Ext.Element object instead of DOM node
         * @return {HTMLElement} The matching DOM node (or null if no match was found)
         */
        findParentNode(selector: string, limit?: number|string|HTMLElement|Ext.dom.Element, returnEl?: boolean): HTMLElement;

        /**
         * Gets the first child, skipping text nodes
         * @param {String} [selector] Find the next sibling that matches the passed simple selector
         * @param {Boolean} [returnDom=false] True to return a raw dom node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The first child or null
         */
        first(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Returns the active element in the DOM. If the browser supports activeElement
         * on the document, this is returned. If not, the focus is tracked and the active
         * element is maintained internally.
         * @return {HTMLElement} The active (focused) element in the document.
         */
        getActiveElement(): HTMLElement;

        /**
         * Returns the value of an attribute from the element's underlying DOM node.
         * @param {String} name The attribute name
         * @param {String} [namespace] The namespace in which to look for the attribute
         * @return {String} The attribute value
         */
        getAttribute(name: string, namespace?: string): string;

        /**
         * Gets the width of the border(s) for the specified side(s)
         * @param {String} side Can be t, l, r, b or any combination of those to add multiple values. For example,
         * passing ''lr'' would get the border **l**eft width + the border **r**ight width.
         * @return {Number} The width of the sides passed added together
         */
        getBorderWidth(side: string): number;

        /**
         * Returns a child element of this element given its 'id'.
         * @param {String} id The id of the desired child element.
         * @param {Boolean} [asDom=false] True to return the DOM element, false to return a
         * wrapped Element object.
         */
        getById(id: string, asDom?: boolean);

        /**
         * Returns the offset height of the element
         * @param {Boolean} [contentHeight] true to get the height minus borders and padding
         * @return {Number} The element's height
         */
        getHeight(contentHeight?: boolean): number;

        /**
         * Returns the innerHTML of an Element or an empty string if the element's
         * dom no longer exists.
         */
        getHTML();

        /**
         * Returns an object with properties top, left, right and bottom representing the margins of this element unless sides is passed,
         * then it returns the calculated width of the sides (see getPadding)
         * @param {String} [sides] Any combination of l, r, t, b to get the sum of those sides
         * @return {Object/Number}
         */
        getMargin(sides?: string): any|number;

        /**
         * Gets the width of the padding(s) for the specified side(s)
         * @param {String} side Can be t, l, r, b or any combination of those to add multiple values. For example,
         * passing ''lr'' would get the padding **l**eft + the padding **r**ight.
         * @return {Number} The padding of the sides passed added together
         */
        getPadding(side: string): number;

        /**
         * Returns the size of the element.
         * @param {Boolean} [contentSize] true to get the width/size minus borders and padding
         * @return {Object} An object containing the element's size:
         * @return {Number} return.width
         * @return {Number} return.height
         */
        getSize(contentSize?: boolean): any;

        /**
         * Returns a named style property based on computed/currentStyle (primary) and
         * inline-style if primary is not available.
         *
         * @param {String/String[]} property The style property (or multiple property names
         * in an array) whose value is returned.
         * @param {Boolean} [inline=false] if 'true' only inline styles will be returned.
         * @return {String/Object} The current value of the style property for this element
         * (or a hash of named style values if multiple property arguments are requested).
         */
        getStyle(property: string, inline?: boolean): string|any;

        /**
         * Returns the value of the "value" attribute
         * @param {Boolean} asNumber true to parse the value as a number
         * @return {String/Number}
         */
        getValue(asNumber: boolean): string|number;

        /**
         * Returns the offset width of the element
         * @param {Boolean} [contentWidth] true to get the width minus borders and padding
         * @return {Number} The element's width
         */
        getWidth(contentWidth?: boolean): number;

        /**
         * Checks if the specified CSS class exists on this element's DOM node.
         * @param {String} className The CSS class to check for
         * @return {Boolean} True if the class exists, else false
         */
        hasCls(className: string): boolean;

        /**
         * Hide this element - Uses display mode to determine whether to use "display" or "visibility". See {@link #setVisible}.
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Ext.Element} this
         */
        hide(animate: boolean|any): Ext.dom.Element;

        /**
         * Inserts this element after the passed element in the DOM
         * @param {String/HTMLElement/Ext.dom.AbstractElement} el The element to insert after.
         * The id of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.AbstractElement} This element
         */
        insertAfter(el: string|HTMLElement|Ext.dom.AbstractElement): Ext.dom.AbstractElement;

        /**
         * Inserts this element before the passed element in the DOM
         * @param {String/HTMLElement/Ext.dom.AbstractElement} el The element before which this element will be inserted.
         * The id of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.AbstractElement} This element
         */
        insertBefore(el: string|HTMLElement|Ext.dom.AbstractElement): Ext.dom.AbstractElement;

        /**
         * Inserts (or creates) an element (or DomHelper config) as the first child of this element
         * @param {String/HTMLElement/Ext.dom.AbstractElement/Object} el The id or element to insert or a DomHelper config
         * to create and insert
         * @return {Ext.dom.AbstractElement} The new child
         */
        insertFirst(el: string|HTMLElement|Ext.dom.AbstractElement|any): Ext.dom.AbstractElement;

        /**
         * Inserts an html fragment into this element
         * @param {String} where Where to insert the html in relation to this element - beforeBegin, afterBegin, beforeEnd, afterEnd.
         * See {@link Ext.dom.Helper#insertHtml} for details.
         * @param {String} html The HTML fragment
         * @param {Boolean} [returnEl=false] True to return an Ext.dom.AbstractElement
         * @return {HTMLElement/Ext.dom.AbstractElement} The inserted node (or nearest related if more than 1 inserted)
         */
        insertHtml(where: string, html: string, returnEl?: boolean): HTMLElement|Ext.dom.AbstractElement;

        /**
         * Inserts (or creates) the passed element (or DomHelper config) as a sibling of this element
         * @param {String/HTMLElement/Ext.dom.AbstractElement/Object/Array} el The id, element to insert or a DomHelper config
         * to create and insert *or* an array of any of those.
         * @param {String} [where='before'] 'before' or 'after'
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead of Ext.dom.AbstractElement
         * @return {Ext.dom.AbstractElement} The inserted Element. If an array is passed, the last inserted element is returned.
         */
        insertSibling(el: string|HTMLElement|Ext.dom.AbstractElement|any|any[], where?: string, returnDom?: boolean): Ext.dom.AbstractElement;

        /**
         * Returns true if this element matches the passed simple selector (e.g. div.some-class or span:first-child)
         * @param {String} selector The simple selector to test
         * @return {Boolean} True if this element matches the selector, else false
         */
        is(selector: string): boolean;

        /**
         * Checks if the current value of a style is equal to a given value.
         * @param {String} style property whose value is returned.
         * @param {String} value to check against.
         * @return {Boolean} true for when the current value equals the given value.
         */
        isStyle(style: string, value: string): boolean;

        /**
         * Returns true if the value of the given property is visually transparent. This
         * may be due to a 'transparent' style value or an rgba value with 0 in the alpha
         * component.
         * @param {String} prop The style property whose value is to be tested.
         * @return {Boolean} True if the style property is visually transparent.
         */
        isTransparent(prop: string): boolean;

        /**
         * Gets the last child, skipping text nodes
         * @param {String} [selector] Find the previous sibling that matches the passed simple selector
         * @param {Boolean} [returnDom=false] True to return a raw dom node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The last child or null
         */
        last(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Puts a mask over this element to disable user interaction. Requires core.css.
         * This method can only be applied to elements which accept child nodes.
         * @param {String} [msg] A message to display in the mask
         * @param {String} [msgCls] A css class to apply to the msg element
         */
        mask(msg?: string, msgCls?: string);

        /**
         * Gets the next sibling, skipping text nodes
         * @param {String} [selector] Find the next sibling that matches the passed simple selector
         * @param {Boolean} [returnDom=false] True to return a raw dom node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The next sibling or null
         */
        next(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Gets the parent node for this element, optionally chaining up trying to match a selector
         * @param {String} [selector] Find a parent node that matches the passed simple selector
         * @param {Boolean} [returnDom=false] True to return a raw dom node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The parent node or null
         */
        parent(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Gets the previous sibling, skipping text nodes
         * @param {String} [selector] Find the previous sibling that matches the passed simple selector
         * @param {Boolean} [returnDom=false] True to return a raw dom node instead of an Ext.dom.Element
         * @return {Ext.dom.Element/HTMLElement} The previous sibling or null
         */
        prev(selector?: string, returnDom?: boolean): Ext.dom.Element|HTMLElement;

        /**
         * Selects child nodes based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @return {HTMLElement[]} An array of the matched nodes
         */
        query(selector: string): HTMLElement;

        /**
         * Adds one or more CSS classes to this element and removes the same class(es) from all siblings.
         * @param {String/String[]} className The CSS class to add, or an array of classes
         * @return {Ext.dom.Element} this
         */
        radioCls(className: string): Ext.dom.Element;

        /**
         * Removes this element's dom reference. Note that event and cache removal is handled at {@link Ext#removeNode
         * Ext.removeNode}
         */
        remove();

        /**
         * Forces the browser to repaint this element
         * @return {Ext.dom.Element} this
         */
        repaint(): Ext.dom.Element;

        /**
         * Replaces the passed element with this element
         * @param {String/HTMLElement/Ext.dom.AbstractElement} el The element to replace.
         * The id of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.AbstractElement} This element
         */
        replace(el: string|HTMLElement|Ext.dom.AbstractElement): Ext.dom.AbstractElement;

        /**
         * Replaces a CSS class on the element with another.  If the old name does not exist, the new name will simply be added.
         * @param {String} oldClassName The CSS class to replace
         * @param {String} newClassName The replacement CSS class
         * @return {Ext.dom.Element} this
         */
        replaceCls(oldClassName: string, newClassName: string): Ext.dom.Element;

        /**
         * Replaces this element with the passed element
         * @param {String/HTMLElement/Ext.dom.AbstractElement/Object} el The new element (id of the node, a DOM Node
         * or an existing Element) or a DomHelper config of an element to create
         * @return {Ext.dom.AbstractElement} This element
         */
        replaceWith(el: string|HTMLElement|Ext.dom.AbstractElement|any): Ext.dom.AbstractElement;

        /**
         * Creates a {@link Ext.CompositeElement} for child nodes based on the passed CSS selector (the selector should not contain an id).
         * @param {String} selector The CSS selector
         * @param {Boolean} [unique] True to create a unique Ext.Element for each element. Defaults to a shared flyweight object.
         * @return {Ext.CompositeElement} The composite element
         */
        select(selector: string, unique?: boolean): Ext.dom.CompositeElement;

        /**
         * Serializes a DOM form into a url encoded string
         * @param {Object} form The form
         * @return {String} The url encoded form
         */
        serializeForm(form: any): string;

        /**
         * Sets the passed attributes as attributes of this element (a style attribute can be a string, object or function)
         * @param {Object} o The object with the attributes
         * @param {Boolean} [useSet=true] false to override the default setAttribute to use expandos.
         * @return {Ext.dom.Element} this
         */
        set(o: any, useSet?: boolean): Ext.dom.Element;

        /**
         * Set the height of this Element.
         *
         *     // change the height to 200px and animate with default configuration
         *     Ext.fly('elementId').setHeight(200, true);
         *
         *     // change the height to 150px and animate with a custom configuration
         *     Ext.fly('elId').setHeight(150, {
         *         duration : 500, // animation will have a duration of .5 seconds
         *         // will change the content to "finished"
         *         callback: function(){ this.{@link #update}("finished"); }
         *     });
         *
         * @param {Number/String} height The new height. This may be one of:
         *
         * - A Number specifying the new height in this Element's {@link #defaultUnit}s (by default, pixels.)
         * - A String used to set the CSS height style. Animation may **not** be used.
         *
         * @return {Ext.dom.Element} this
         */
        setHeight(height: number|string): Ext.dom.Element;

        /**
         * Set the innerHTML of this element
         * @param {String} html The new HTML
         * @return {Ext.Element} this
         */
        setHTML(html: string): Ext.dom.Element;

        /**
         * Set the size of this Element. If animation is true, both width and height will be animated concurrently.
         * @param {Number/String} width The new width. This may be one of:
         *
         * - A Number specifying the new width in this Element's {@link #defaultUnit}s (by default, pixels).
         * - A String used to set the CSS width style. Animation may **not** be used.
         * - A size object in the format '{width: widthValue, height: heightValue}'.
         *
         * @param {Number/String} height The new height. This may be one of:
         *
         * - A Number specifying the new height in this Element's {@link #defaultUnit}s (by default, pixels).
         * - A String used to set the CSS height style. Animation may **not** be used.
         *
         * @return {Ext.dom.Element} this
         */
        setSize(width: number|string, height: number|string): Ext.dom.Element;

        /**
         * Wrapper for setting style properties, also takes single object parameter of multiple styles.
         * @param {String/Object} property The style property to be set, or an object of multiple styles.
         * @param {String} [value] The value to apply to the given property, or null if an object was passed.
         * @return {Ext.dom.Element} this
         */
        setStyle(property: string|any, value?: string): Ext.dom.Element;

        /**
         * Use this to change the visibility mode between {@link #VISIBILITY}, {@link #DISPLAY}, {@link #OFFSETS} or {@link #ASCLASS}.
         */
        setVisibilityMode();

        /**
         * Sets the visibility of the element (see details). If the visibilityMode is set to Element.DISPLAY, it will use
         * the display property to hide the element, otherwise it uses visibility. The default is to hide and show using the visibility property.
         * @param {Boolean} visible Whether the element is visible
         * @param {Boolean/Object} animate (optional) True for the default animation, or a standard Element animation config object
         * @return {Ext.Element} this
         */
        setVisible(visible: boolean, animate: boolean|any): Ext.dom.Element;

        /**
         * Set the width of this Element.
         * @param {Number/String} width The new width. This may be one of:
         *
         * - A Number specifying the new width in this Element's {@link #defaultUnit}s (by default, pixels).
         * - A String used to set the CSS width style. Animation may **not** be used.
         *
         * @return {Ext.dom.Element} this
         */
        setWidth(width: number|string): Ext.dom.Element;

        /**
         * Show this element - Uses display mode to determine whether to use "display" or "visibility". See {@link #setVisible}.
         * @param {Boolean/Object} animate (optional) true for the default animation or a standard Element animation config object
         * @return {Ext.Element} this
         */
        show(animate: boolean|any): Ext.dom.Element;

        /**
         * Toggles the specified CSS class on this element (removes it if it already exists, otherwise adds it).
         * @param {String} className The CSS class to toggle
         * @return {Ext.dom.Element} this
         */
        toggleCls(className: string): Ext.dom.Element;

        /**
         * Removes a previously applied mask.
         */
        unmask();

        /**
         * Walks up the DOM looking for a parent node that matches the passed simple selector (e.g. div.some-class or span:first-child).
         * This is a shortcut for findParentNode() that always returns an Ext.dom.Element.
         * @param {String} selector The simple selector to test
         * @param {Number/String/HTMLElement/Ext.Element} [limit]
         * The max depth to search as a number or an element which causes the upward traversal to stop
         * and is <b>not</b> considered for inclusion as the result. (defaults to 50 || document.documentElement)
         * @param {Boolean} [returnDom=false] True to return the DOM node instead of Ext.dom.Element
         * @return {Ext.Element} The matching DOM node (or null if no match was found)
         */
        up(selector: string, limit?: number|string|HTMLElement|Ext.dom.Element, returnDom?: boolean): Ext.dom.Element;

        /**
         * Update the innerHTML of this element
         * @param {String} html The new HTML
         * @return {Ext.dom.Element} this
         */
        update(html: string): Ext.dom.Element;

        /**
         * Creates and wraps this element with another element
         * @param {Object} [config] DomHelper element config object for the wrapper element or null for an empty div
         * @param {Boolean} [returnDom=false] True to return the raw DOM element instead of Ext.dom.AbstractElement
         * @param {String} [selector] A {@link Ext.dom.Query DomQuery} selector to select a descendant node within the created element to use as the wrapping element.
         * @return {HTMLElement/Ext.dom.AbstractElement} The newly created wrapper element
         */
        wrap(config?: any, returnDom?: boolean, selector?: string): HTMLElement|Ext.dom.AbstractElement;

        /**
         * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
         * Add or remove the {@link Ext.Layer#visibilityCls} class to hide the element.
         * @inheritable
         */
        static ASCLASS: any;

        /**
         * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
         * Use the CSS 'display' property to hide the element.
         * @inheritable
         */
        static DISPLAY: any;

        /**
         * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
         * Use CSS absolute positioning and top/left offsets to hide the element.
         * @inheritable
         */
        static OFFSETS: any;

        /**
         * Visibility mode constant for use with {@link Ext.dom.Element#setVisibilityMode}.
         * Use the CSS 'visibility' property to hide the element.
         *
         * Note that in this mode, {@link Ext.dom.Element#isVisible isVisible} may return true
         * for an element even though it actually has a parent element that is hidden. For this
         * reason, and in most cases, using the {@link #OFFSETS} mode is a better choice.
         * @inheritable
         */
        static VISIBILITY: any;

        /**
         * Gets the singleton {@link Ext.dom.Element.Fly flyweight} element, with the passed node as the active element.
         *
         * Because it is a singleton, this Flyweight does not have an ID, and must be used and discarded in a single line.
         * You may not keep and use the reference to this singleton over multiple lines because methods that you call
         * may themselves make use of {@link Ext#fly} and may change the DOM element to which the instance refers.
         *
         * {@link Ext#fly} is alias for {@link Ext.dom.AbstractElement#fly}.
         *
         * Use this to make one-time references to DOM elements which are not going to be accessed again either by
         * application code, or by Ext's classes. If accessing an element which will be processed regularly, then {@link
         * Ext#get Ext.get} will be more appropriate to take advantage of the caching provided by the Ext.dom.Element
         * class.
         *
         * @param {String/HTMLElement} dom The dom node or id
         * @param {String} [named] Allows for creation of named reusable flyweights to prevent conflicts (e.g.
         * internally Ext uses "_global")
         * @return {Ext.dom.Element.Fly} The singleton flyweight object (or null if no matching element was found)
         */
        static fly(dom: string|HTMLElement, named?: string): Ext.dom.Element.Fly;

        /**
         * Returns the top Element that is located at the passed coordinates
         * @param {Number} x The x coordinate
         * @param {Number} y The y coordinate
         * @return {String} The found Element
         */
        static fromPoint(x: number, y: number): string;

        /**
         * Retrieves Ext.dom.Element objects. {@link Ext#get} is alias for {@link Ext.dom.Element#get}.
         *
         * **This method does not retrieve {@link Ext.Component Component}s.** This method retrieves Ext.dom.Element
         * objects which encapsulate DOM elements. To retrieve a Component by its ID, use {@link Ext.ComponentManager#get}.
         *
         * When passing an id, it should not include the '#' character that is used for a css selector.
         *
         *     // For an element with id 'foo'
         *     Ext.get('foo'); // Correct
         *     Ext.get('#foo'); // Incorrect
         *
         * Uses simple caching to consistently return the same object. Automatically fixes if an object was recreated with
         * the same id via AJAX or DOM.
         *
         * @param {String/HTMLElement/Ext.Element} el The id of the node, a DOM Node or an existing Element.
         * @return {Ext.dom.Element} The Element object (or null if no matching element was found)
         * @inheritable
         */
        static get(el: string|HTMLElement|Ext.dom.Element): Ext.dom.Element;

        /**
         * Retrieves the document height
         * @return {Number} documentHeight
         */
        static getDocumentHeight(): number;

        /**
         * Retrieves the document width
         * @return {Number} documentWidth
         */
        static getDocumentWidth(): number;

        /**
         * Retrieves the current orientation of the window. This is calculated by
         * determing if the height is greater than the width.
         * @return {String} Orientation of window: 'portrait' or 'landscape'
         */
        static getOrientation(): string;

        /**
         * Retrieves the viewport height of the window.
         * @return {Number} viewportHeight
         */
        static getViewportHeight(): number;

        /**
         * Retrieves the viewport width of the window.
         * @return {Number} viewportWidth
         */
        static getViewportWidth(): number;

        /**
         * Retrieves the viewport size of the window.
         * @return {Object} object containing width and height properties
         */
        static getViewSize(): any;

        /**
         * <p>Returns an array of unique class names based upon the input strings, or string arrays.</p>
         * <p>The number of parameters is unlimited.</p>
         * <p>Example</p><pre><code>
         // Add x-invalid and x-mandatory classes, do not duplicate
         myElement.dom.className = Ext.core.Element.mergeClsList(this.initialClasses, 'x-invalid x-mandatory');
         </code></pre>
         * @param {Mixed} clsList1 A string of class names, or an array of class names.
         * @param {Mixed} clsList2 A string of class names, or an array of class names.
         * @return {Array} An array of strings representing remaining unique, merged class names. If class names were added to the first list, the <code>changed</code> property will be <code>true</code>.
         * @inheritable
         */
        static mergeClsList(clsList1: any, clsList2: any): any[];

        /**
         * Normalizes CSS property keys from dash delimited to camel case JavaScript Syntax.
         * For example:
         *
         * - border-width -> borderWidth
         * - padding-top -> paddingTop
         *
         * @param {String} prop The property to normalize
         * @return {String} The normalized string
         */
        static normalize(prop: string): string;

        /**
         * Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
         * (e.g. 10, "10", "10 10", "10 10 10" and "10 10 10 10" are all valid options and would return the same result)
         * @param {Number/String} box The encoded margins
         * @return {Object} An object with margin sizes for top, right, bottom and left
         */
        static parseBox(box: number|string): any;

        /**
         * Converts a CSS string into an object with a property for each style.
         *
         * The sample code below would return an object with 2 properties, one
         * for background-color and one for color.
         *
         *     var css = 'background-color: red;color: blue; ';
         *     console.log(Ext.dom.Element.parseStyles(css));
         *
         * @param {String} styles A CSS string
         * @return {Object} styles
         */
        static parseStyles(styles: string): any;

        /**
         * <p>Returns an array of unique class names deom the first parameter with all class names
         * from the second parameter removed.</p>
         * <p>Example</p><pre><code>
         // Remove x-invalid and x-mandatory classes if present.
         myElement.dom.className = Ext.core.Element.removeCls(this.initialClasses, 'x-invalid x-mandatory');
         </code></pre>
         * @param {Mixed} existingClsList A string of class names, or an array of class names.
         * @param {Mixed} removeClsList A string of class names, or an array of class names to remove from <code>existingClsList</code>.
         * @return {Array} An array of strings representing remaining class names. If class names were removed, the <code>changed</code> property will be <code>true</code>.
         * @inheritable
         */
        static removeCls(existingClsList: any, removeClsList: any): any[];

        /**
         * Parses a number or string representing margin sizes into an object. Supports CSS-style margin declarations
         * (e.g. 10, "10", "10 10", "10 10 10" and "10 10 10 10" are all valid options and would return the same result)
         * @param {Number/String/Object} box The encoded margins, or an object with top, right,
         * bottom, and left properties
         * @param {String} units The type of units to add
         * @return {String} An string with unitized (px if units is not specified) metrics for top, right, bottom and left
         */
        static unitizeBox(box: number|string|any, units: string): string;
    }

    /**
     * Abstract base class for {@link Ext.dom.Helper}.
     */
    export class AbstractHelper extends Ext.Base {
        /**
         * Creates new DOM element(s) and appends them to el.
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @param {Boolean} [returnElement] true to return a Ext.Element
         * @return {HTMLElement/Ext.Element} The new node
         */
        append(el: string|HTMLElement|Ext.dom.Element, o: any|string, returnElement?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Applies a style specification to an element.
         * @param {String/HTMLElement} el The element to apply styles to
         * @param {String/Object/Function} styles A style specification string e.g. 'width:100px', or object in the form {width:'100px'}, or
         * a function which returns such a specification.
         */
        applyStyles(el: string|HTMLElement, styles: string|any|Function);

        /**
         * Converts the styles from the given object to text. The styles are CSS style names
         * with their associated value.
         *
         * The basic form of this method returns a string:
         *
         *      var s = Ext.DomHelper.generateStyles({
         *          backgroundColor: 'red'
         *      });
         *
         *      // s = 'background-color:red;'
         *
         * Alternatively, this method can append to an output array.
         *
         *      var buf = [];
         *
         *      ...
         *
         *      Ext.DomHelper.generateStyles({
         *          backgroundColor: 'red'
         *      }, buf);
         *
         * In this case, the style text is pushed on to the array and the array is returned.
         *
         * @param {Object} styles The object describing the styles.
         * @param {String[]} [buffer] The output buffer.
         * @return {String/String[]} If buffer is passed, it is returned. Otherwise the style
         * string is returned.
         */
        generateStyles(styles: any, buffer?: string): string;

        /**
         * Creates new DOM element(s) and inserts them after el.
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object} o The DOM object spec (and children)
         * @param {Boolean} [returnElement] true to return a Ext.Element
         * @return {HTMLElement/Ext.Element} The new node
         */
        insertAfter(el: string|HTMLElement|Ext.dom.Element, o: any, returnElement?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Creates new DOM element(s) and inserts them before el.
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @param {Boolean} [returnElement] true to return a Ext.Element
         * @return {HTMLElement/Ext.Element} The new node
         */
        insertBefore(el: string|HTMLElement|Ext.dom.Element, o: any|string, returnElement?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Creates new DOM element(s) and inserts them as the first child of el.
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @param {Boolean} [returnElement] true to return a Ext.Element
         * @return {HTMLElement/Ext.Element} The new node
         */
        insertFirst(el: string|HTMLElement|Ext.dom.Element, o: any|string, returnElement?: boolean): HTMLElement|Ext.dom.Element;

        /**
         * Inserts an HTML fragment into the DOM.
         * @param {String} where Where to insert the html in relation to el - beforeBegin, afterBegin, beforeEnd, afterEnd.
         *
         * For example take the following HTML: '<div>Contents</div>'
         *
         * Using different 'where' values inserts element to the following places:
         *
         * - beforeBegin: '<HERE><div>Contents</div>'
         * - afterBegin: '<div><HERE>Contents</div>'
         * - beforeEnd: '<div>Contents<HERE></div>'
         * - afterEnd: '<div>Contents</div><HERE>'
         *
         * @param {HTMLElement/TextNode} el The context element
         * @param {String} html The HTML fragment
         * @return {HTMLElement} The new node
         */
        insertHtml(where: string, el: HTMLElement|any, html: string): HTMLElement;

        /**
         * Returns the markup for the passed Element(s) config.
         * @param {Object} spec The DOM object spec (and children)
         * @return {String}
         */
        markup(spec: any): string;

        /**
         * Creates new DOM element(s) and overwrites the contents of el with them.
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @param {Boolean} [returnElement] true to return a Ext.Element
         * @return {HTMLElement/Ext.Element} The new node
         */
        overwrite(el: string|HTMLElement|Ext.dom.Element, o: any|string, returnElement?: boolean): HTMLElement|Ext.dom.Element;
    }

    export class AbstractQuery extends Ext.Base {
        /**
         * Returns true if the passed element(s) match the passed simple selector (e.g. div.some-class or span:first-child)
         * @param {String/HTMLElement/Array} el An element id, element or array of elements
         * @param {String} selector The simple selector to test
         * @return {Boolean}
         */
        is(el: string|HTMLElement|any[], selector: string): boolean;

        /**
         * Selects a group of elements.
         * @param {String} selector The selector/xpath query (can be a comma separated list of selectors)
         * @param {HTMLElement/String} [root] The start of the query (defaults to document).
         * @return {HTMLElement[]} An Array of DOM elements which match the selector. If there are
         * no matches, and empty Array is returned.
         */
        select(selector: string, root?: HTMLElement|string): HTMLElement;

        /**
         * Selects a single element.
         * @param {String} selector The selector/xpath query
         * @param {HTMLElement/String} [root] The start of the query (defaults to document).
         * @return {HTMLElement} The DOM element which matched the selector.
         */
        selectNode(selector: string, root?: HTMLElement|string): HTMLElement;
    }

    /**
     * <p>This class encapsulates a <i>collection</i> of DOM elements, providing methods to filter
     * members, or to perform collective actions upon the whole set.</p>
     * <p>Although they are not listed, this class supports all of the methods of {@link Ext.dom.Element} and
     * {@link Ext.fx.Anim}. The methods from these classes will be performed on all the elements in this collection.</p>
     * <p>All methods return <i>this</i> and can be chained.</p>
     * Usage:
     <pre><code>
     var els = Ext.select("#some-el div.some-class", true);
     // or select directly from an existing element
     var el = Ext.get('some-el');
     el.select('div.some-class', true);
     els.setWidth(100); // all elements become 100 width
     els.hide(true); // all elements fade out and hide
     // or
     els.setWidth(100).hide(true);
     </code></pre>
     */
    export class CompositeElement extends Ext.dom.CompositeElementLite {
        constructor(elements: any, root: any);
    }

    /**
     * This class encapsulates a *collection* of DOM elements, providing methods to filter members, or to perform collective
     * actions upon the whole set.
     *
     * Although they are not listed, this class supports all of the methods of {@link Ext.dom.Element} and
     * {@link Ext.fx.Anim}. The methods from these classes will be performed on all the elements in this collection.
     *
     * Example:
     *
     *     var els = Ext.select("#some-el div.some-class");
     *     // or select directly from an existing element
     *     var el = Ext.get('some-el');
     *     el.select('div.some-class');
     *
     *     els.setWidth(100); // all elements become 100 width
     *     els.hide(true); // all elements fade out and hide
     *     // or
     *     els.setWidth(100).hide(true);
     */
    export class CompositeElementLite extends Ext.Base {
        /**
         * The Array of DOM elements which this CompositeElement encapsulates.
         *
         * This will not *usually* be accessed in developers' code, but developers wishing to augment the capabilities
         * of the CompositeElementLite class may use it when adding methods to the class.
         *
         * For example to add the 'nextAll' method to the class to **add** all following siblings of selected elements,
         * the code would be
         *
         *     Ext.override(Ext.dom.CompositeElementLite, {
         *         nextAll: function() {
         *             var elements = this.elements, i, l = elements.length, n, r = [], ri = -1;
         *
         *             // Loop through all elements in this Composite, accumulating
         *             // an Array of all siblings.
         *             for (i = 0; i < l; i++) {
         *                 for (n = elements[i].nextSibling; n; n = n.nextSibling) {
         *                     r[++ri] = n;
         *                 }
         *             }
         *
         *             // Add all found siblings to this Composite
         *             return this.add(r);
         *         }
         *     });
         *
         * @readonly
         */
        elements: HTMLElement;

        /**
         * 'true' in this class to identify an object as an instantiated CompositeElement, or subclass thereof.
         */
        isComposite: boolean;

        /**
         * Adds elements to this Composite object.
         * @param {HTMLElement[]/Ext.dom.CompositeElement} els Either an Array of DOM elements to add, or another Composite
         * object who's elements should be added.
         * @return {Ext.dom.CompositeElement} This Composite object.
         */
        add(els: HTMLElement|Ext.dom.CompositeElement): Ext.dom.CompositeElement;

        /**
         * Removes all elements from this Composite.
         * @param {Boolean} [removeDom] True to also remove the elements from the document.
         */
        clear(removeDom?: boolean);

        constructor(elements: any, root: any);

        /**
         * Returns true if this composite contains the passed element.
         * @param {String/HTMLElement/Ext.Element/Number} el The id of an element, or an Ext.Element, or an HtmlElement to
         * find within the composite collection.
         * @return {Boolean}
         */
        contains(el: string|HTMLElement|Ext.dom.Element|number): boolean;

        /**
         * Calls the passed function for each element in this composite.
         * @param {Function} fn The function to call.
         * @param {Ext.dom.Element} fn.el The current Element in the iteration. **This is the flyweight
         * (shared) Ext.dom.Element instance, so if you require a a reference to the dom node, use el.dom.**
         * @param {Ext.dom.CompositeElement} fn.c This Composite object.
         * @param {Number} fn.index The zero-based index in the iteration.
         * @param {Object} [scope] The scope (this reference) in which the function is executed.
         * Defaults to the Element.
         * @return {Ext.dom.CompositeElement} this
         */
        each(fn: Function, fn_el: Ext.dom.Element, fn_c: Ext.dom.CompositeElement, fn_index: number, scope?: any): Ext.dom.CompositeElement;

        /**
         * Clears this Composite and adds the elements passed.
         * @param {HTMLElement[]/Ext.dom.CompositeElement} els Either an array of DOM elements, or another Composite from which
         * to fill this Composite.
         * @return {Ext.dom.CompositeElement} this
         */
        fill(els: HTMLElement|Ext.dom.CompositeElement): Ext.dom.CompositeElement;

        /**
         * Filters this composite to only elements that match the passed selector.
         * @param {String/Function} selector A string CSS selector or a comparison function. The comparison function will be
         * called with the following arguments:
         * @param {Ext.dom.Element} selector.el The current DOM element.
         * @param {Number} selector.index The current index within the collection.
         * @return {Ext.dom.CompositeElement} this
         */
        filter(selector: string|Function, selector_el: Ext.dom.Element, selector_index: number): Ext.dom.CompositeElement;

        /**
         * Returns the first Element
         * @return {Ext.dom.Element}
         */
        first(): Ext.dom.Element;

        /**
         * Returns the number of elements in this Composite.
         * @return {Number}
         */
        getCount(): number;

        /**
         * Find the index of the passed element within the composite collection.
         * @param {String/HTMLElement/Ext.Element/Number} el The id of an element, or an Ext.dom.Element, or an HtmlElement
         * to find within the composite collection.
         * @return {Number} The index of the passed Ext.dom.Element in the composite collection, or -1 if not found.
         */
        indexOf(el: string|HTMLElement|Ext.dom.Element|number): number;

        /**
         * Returns a flyweight Element of the dom element object at the specified index
         * @return {Ext.dom.Element}
         */
        item(index: number): Ext.dom.Element;

        /**
         * Returns the last Element
         * @return {Ext.dom.Element}
         */
        last(): Ext.dom.Element;

        /**
         * Removes the specified element(s).
         * @param {String/HTMLElement/Ext.Element/Number} el The id of an element, the Element itself, the index of the
         * element in this composite or an array of any of those.
         * @param {Boolean} [removeDom] True to also remove the element from the document.
         * @return {Ext.dom.CompositeElement} this
         */
        removeElement(el: string|HTMLElement|Ext.dom.Element|number, removeDom?: boolean): Ext.dom.CompositeElement;

        /**
         * Replaces the specified element with the passed element.
         * @param {String/HTMLElement/Ext.Element/Number} el The id of an element, the Element itself, the index of the
         * element in this composite to replace.
         * @param {String/Ext.Element} replacement The id of an element or the Element itself.
         * @param {Boolean} [domReplace] True to remove and replace the element in the document too.
         * @return {Ext.dom.CompositeElement} this
         */
        replaceElement(el: string|HTMLElement|Ext.dom.Element|number, replacement: string|Ext.dom.Element, domReplace?: boolean): Ext.dom.CompositeElement;

        /**
         * Gets a range nodes.
         * @param {Number} start (optional) The index of the first node in the range
         * @param {Number} end (optional) The index of the last node in the range
         * @return {HTMLElement[]} An array of nodes
         */
        slice(start: number, end: number): HTMLElement;
    }

    export class Element extends Ext.dom.AbstractElement {
        /**
         * True to automatically adjust width and height settings for box-model issues.
         */
        autoBoxAdjust: boolean;

        /**
         * The element's default display mode.
         */
        originalDisplay: any;

        /**
         * Sets up event handlers to add and remove a css class when the mouse is down and then up on this element (a click effect)
         * @param {String} className The class to add
         * @param {Function} [testFn] A test function to execute before adding the class. The passed parameter
         * will be the Element instance. If this functions returns false, the class will not be added.
         * @param {Object} [scope] The scope to execute the testFn in.
         * @return {Ext.dom.Element} this
         */
        addClsOnClick(className: string, testFn?: Function, scope?: any): Ext.dom.Element;

        /**
         * Sets up event handlers to add and remove a css class when this element has the focus
         * @param {String} className The class to add
         * @param {Function} [testFn] A test function to execute before adding the class. The passed parameter
         * will be the Element instance. If this functions returns false, the class will not be added.
         * @param {Object} [scope] The scope to execute the testFn in.
         * @return {Ext.dom.Element} this
         */
        addClsOnFocus(className: string, testFn?: Function, scope?: any): Ext.dom.Element;

        /**
         * Sets up event handlers to add and remove a css class when the mouse is over this element
         * @param {String} className The class to add
         * @param {Function} [testFn] A test function to execute before adding the class. The passed parameter
         * will be the Element instance. If this functions returns false, the class will not be added.
         * @param {Object} [scope] The scope to execute the testFn in.
         * @return {Ext.dom.Element} this
         */
        addClsOnOver(className: string, testFn?: Function, scope?: any): Ext.dom.Element;

        /**
         * Convenience method for constructing a KeyMap
         * @param {String/Number/Number[]/Object} key Either a string with the keys to listen for, the numeric key code,
         * array of key codes or an object with the following options:
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope ('this' reference) in which the specified function is executed. Defaults to this Element.
         * @return {Ext.util.KeyMap} The KeyMap created
         */
        addKeyListener(key: string|number|any, key_key: number|any[], key_shift: boolean, key_ctrl: boolean, key_alt: boolean, fn: Function, scope?: any): Ext.util.KeyMap;

        /**
         * Creates a KeyMap for this element
         * @param {Object} config The KeyMap config. See {@link Ext.util.KeyMap} for more details
         * @return {Ext.util.KeyMap} The KeyMap created
         */
        addKeyMap(config: any): Ext.util.KeyMap;

        /**
         * Shorthand for {@link #on}.
         */
        addListener();

        /**
         * Performs custom animation on this Element.
         *
         * The following properties may be specified in 'from', 'to', and 'keyframe' objects:
         *
         *   - 'x' - The page X position in pixels.
         *
         *   - 'y' - The page Y position in pixels
         *
         *   - 'left' - The element's CSS 'left' value. Units must be supplied.
         *
         *   - 'top' - The element's CSS 'top' value. Units must be supplied.
         *
         *   - 'width' - The element's CSS 'width' value. Units must be supplied.
         *
         *   - 'height' - The element's CSS 'height' value. Units must be supplied.
         *
         *   - 'scrollLeft' - The element's 'scrollLeft' value.
         *
         *   - 'scrollTop' - The element's 'scrollTop' value.
         *
         *   - 'opacity' - The element's 'opacity' value. This must be a value between '0' and '1'.
         *
         * **Be aware** that animating an Element which is being used by an Ext Component without in some way informing the
         * Component about the changed element state will result in incorrect Component behaviour. This is because the
         * Component will be using the old state of the element. To avoid this problem, it is now possible to directly
         * animate certain properties of Components.
         *
         * @param {Object} config  Configuration for {@link Ext.fx.Anim}.
         * Note that the {@link Ext.fx.Anim#to to} config is required.
         * @return {Ext.dom.Element} this
         */
        animate(config: any): Ext.dom.Element;

        /**
         * Tries to blur the element. Any exceptions are caught and ignored.
         * @return {Ext.dom.Element} this
         */
        blur(): Ext.dom.Element;

        /**
         * Wraps the specified element with a special 9 element markup/CSS block that renders by default as
         * a gray container with a gradient background, rounded corners and a 4-way shadow.
         *
         * This special markup is used throughout Ext when box wrapping elements ({@link Ext.button.Button},
         * {@link Ext.panel.Panel} when {@link Ext.panel.Panel#frame frame=true}, {@link Ext.window.Window}).
         * The markup is of this form:
         *
         *     Ext.dom.Element.boxMarkup =
         *     '<div class="{0}-tl"><div class="{0}-tr"><div class="{0}-tc"></div></div></div>
         *     <div class="{0}-ml"><div class="{0}-mr"><div class="{0}-mc"></div></div></div>
         *     <div class="{0}-bl"><div class="{0}-br"><div class="{0}-bc"></div></div></div>';
         *
         * Example usage:
         *
         *     // Basic box wrap
         *     Ext.get("foo").boxWrap();
         *
         *     // You can also add a custom class and use CSS inheritance rules to customize the box look.
         *     // 'x-box-blue' is a built-in alternative -- look at the related CSS definitions as an example
         *     // for how to create a custom box wrap style.
         *     Ext.get("foo").boxWrap().addCls("x-box-blue");
         *
         * @param {String} [class='x-box'] A base CSS class to apply to the containing wrapper element.
         * Note that there are a number of CSS rules that are dependent on this name to make the overall effect work,
         * so if you supply an alternate base class, make sure you also supply all of the necessary rules.
         * @return {Ext.dom.Element} The outermost wrapping element of the created box structure.
         */
        boxWrap(clazz?: string): Ext.dom.Element;

        /**
         * When an element is moved around in the DOM, or is hidden using 'display:none', it loses layout, and therefore
         * all scroll positions of all descendant elements are lost.
         *
         * This function caches them, and returns a function, which when run will restore the cached positions.
         * In the following example, the Panel is moved from one Container to another which will cause it to lose all scroll positions:
         *
         *     var restoreScroll = myPanel.el.cacheScrollValues();
         *     myOtherContainer.add(myPanel);
         *     restoreScroll();
         *
         * @return {Function} A function which will restore all descentant elements of this Element to their scroll
         * positions recorded when this function was executed. Be aware that the returned function is a closure which has
         * captured the scope of 'cacheScrollValues', so take care to derefence it as soon as not needed - if is it is a 'var'
         * it will drop out of scope, and the reference will be freed.
         */
        cacheScrollValues(): Function;

        /**
         * Centers the Element in either the viewport, or another Element.
         * @param {String/HTMLElement/Ext.dom.Element} centerIn element in
         * which to center the element.
         */
        center(centerIn: string|HTMLElement|Ext.dom.Element);

        /**
         * Removes Empty, or whitespace filled text nodes. Combines adjacent text nodes.
         * @param {Boolean} [forceReclean=false] By default the element keeps track if it has been cleaned already
         * so you can call this over and over. However, if you update the element and need to force a reclean, you
         * can pass true.
         */
        clean(forceReclean?: boolean);

        /**
         * Alias for {@link #removeAllListeners}.
         */
        clearListeners();

        /**
         * Clears any opacity settings from this element. Required in some cases for IE.
         * @return {Ext.dom.Element} this
         */
        clearOpacity(): Ext.dom.Element;

        /**
         * Clears positioning back to the default when the document was loaded.
         * @param {String} [value=''] The value to use for the left, right, top, bottom.
         * You could use 'auto'.
         * @return {Ext.dom.Element} this
         */
        clearPositioning(value?: string): Ext.dom.Element;

        /**
         * Store the current overflow setting and clip overflow on the element - use {@link #unclip} to remove
         * @return {Ext.dom.Element} this
         */
        clip(): Ext.dom.Element;

        /**
         * @alternateClassName Ext.Element
         * @alternateClassName Ext.core.Element
         * @extends Ext.dom.AbstractElement
         *
         * Encapsulates a DOM element, adding simple DOM manipulation facilities, normalizing for browser differences.
         *
         * All instances of this class inherit the methods of {@link Ext.fx.Anim} making visual effects easily available to all
         * DOM elements.
         *
         * Note that the events documented in this class are not Ext events, they encapsulate browser events. Some older browsers
         * may not support the full range of events. Which events are supported is beyond the control of Ext JS.
         *
         * Usage:
         *
         *     // by id
         *     var el = Ext.get("my-div");
         *
         *     // by DOM element reference
         *     var el = Ext.get(myDivElement);
         *
         * # Animations
         *
         * When an element is manipulated, by default there is no animation.
         *
         *     var el = Ext.get("my-div");
         *
         *     // no animation
         *     el.setWidth(100);
         *
         * Many of the functions for manipulating an element have an optional "animate" parameter. This parameter can be
         * specified as boolean (true) for default animation effects.
         *
         *     // default animation
         *     el.setWidth(100, true);
         *
         * To configure the effects, an object literal with animation options to use as the Element animation configuration
         * object can also be specified. Note that the supported Element animation configuration options are a subset of the
         * {@link Ext.fx.Anim} animation options specific to Fx effects. The supported Element animation configuration options
         * are:
         *
         *     Option    Default   Description
         *     --------- --------  ---------------------------------------------
         *     {@link Ext.fx.Anim#duration duration}  350       The duration of the animation in milliseconds
         *     {@link Ext.fx.Anim#easing easing}    easeOut   The easing method
         *     {@link Ext.fx.Anim#callback callback}  none      A function to execute when the anim completes
         *     {@link Ext.fx.Anim#scope scope}     this      The scope (this) of the callback function
         *
         * Usage:
         *
         *     // Element animation options object
         *     var opt = {
         *         {@link Ext.fx.Anim#duration duration}: 1000,
         *         {@link Ext.fx.Anim#easing easing}: 'elasticIn',
         *         {@link Ext.fx.Anim#callback callback}: this.foo,
         *         {@link Ext.fx.Anim#scope scope}: this
         *     };
         *     // animation with some options set
         *     el.setWidth(100, opt);
         *
         * The Element animation object being used for the animation will be set on the options object as "anim", which allows
         * you to stop or manipulate the animation. Here is an example:
         *
         *     // using the "anim" property to get the Anim object
         *     if(opt.anim.isAnimated()){
         *         opt.anim.stop();
         *     }
         *
         * # Composite (Collections of) Elements
         *
         * For working with collections of Elements, see {@link Ext.CompositeElement}
         *
         * @constructor
         * Creates new Element directly.
         * @param {Boolean} [forceNew] By default the constructor checks to see if there is already an instance of this
         * element in the cache and if there is it returns the same instance. This will skip that check (useful for extending
         * this class).
         * @return {Object}
         */
        constructor(element: string|HTMLElement, forceNew?: boolean);

        /**
         * Creates a proxy element of this element
         * @param {String/Object} config The class name of the proxy element or a DomHelper config object
         * @param {String/HTMLElement} [renderTo] The element or element id to render the proxy to. Defaults to: document.body.
         * @param {Boolean} [matchBox=false] True to align and size the proxy to this element now.
         * @return {Ext.dom.Element} The new proxy element
         */
        createProxy(config: string|any, renderTo?: string|HTMLElement, matchBox?: boolean): Ext.dom.Element;

        /**
         * Creates an iframe shim for this element to keep selects and other windowed objects from
         * showing through.
         * @return {Ext.dom.Element} The new shim element
         */
        createShim(): Ext.dom.Element;

        /**
         * Convenience method for setVisibilityMode(Element.DISPLAY)
         * @param {String} [display] What to set display to when visible
         * @return {Ext.dom.Element} this
         */
        enableDisplayMode(display?: string): Ext.dom.Element;

        /**
         * Fade an element in (from transparent to opaque). The ending opacity can be specified using the 'opacity'
         * config option. Usage:
         *
         *     // default: fade in from opacity 0 to 100%
         *     el.fadeIn();
         *
         *     // custom: fade in from opacity 0 to 75% over 2 seconds
         *     el.fadeIn({ opacity: .75, duration: 2000});
         *
         *     // common config options shown with default values
         *     el.fadeIn({
         *         opacity: 1, //can be any value between 0 and 1 (e.g. .5)
         *         easing: 'easeOut',
         *         duration: 500
         *     });
         *
         * @param {Object} options (optional) Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.Element} The Element
         */
        fadeIn(options: any): Ext.dom.Element;

        /**
         * Fade an element out (from opaque to transparent). The ending opacity can be specified using the 'opacity'
         * config option. Note that IE may require 'useDisplay:true' in order to redisplay correctly.
         * Usage:
         *
         *     // default: fade out from the element's current opacity to 0
         *     el.fadeOut();
         *
         *     // custom: fade out from the element's current opacity to 25% over 2 seconds
         *     el.fadeOut({ opacity: .25, duration: 2000});
         *
         *     // common config options shown with default values
         *     el.fadeOut({
         *         opacity: 0, //can be any value between 0 and 1 (e.g. .5)
         *         easing: 'easeOut',
         *         duration: 500,
         *         remove: false,
         *         useDisplay: false
         *     });
         *
         * @param {Object} options (optional) Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.Element} The Element
         */
        fadeOut(options: any): Ext.dom.Element;

        /**
         * Tries to focus the element. Any exceptions are caught and ignored.
         * @param {Number} [defer] Milliseconds to defer the focus
         * @return {Ext.dom.Element} this
         */
        focus(defer?: number): Ext.dom.Element;

        /**
         * Alias for {@link #isFocusable}.
         */
        focusable();

        /**
         * Shows a ripple of exploding, attenuating borders to draw attention to an Element. Usage:
         *
         *     // default: a single light blue ripple
         *     el.frame();
         *
         *     // custom: 3 red ripples lasting 3 seconds total
         *     el.frame("#ff0000", 3, { duration: 3000 });
         *
         *     // common config options shown with default values
         *     el.frame("#C3DAF9", 1, {
         *         duration: 1000 // duration of each individual ripple.
         *         // Note: Easing is not configurable and will be ignored if included
         *     });
         *
         * @param {String} [color='#C3DAF9'] The hex color value for the border.
         * @param {Number} [count=1] The number of ripples to display.
         * @param {Object} [options] Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.dom.Element} The Element
         */
        frame(color?: string, count?: number, options?: any): Ext.dom.Element;

        /**
         * Returns the value of a namespaced attribute from the element's underlying DOM node.
         * @param {String} namespace The namespace in which to look for the attribute
         * @param {String} name The attribute name
         * @return {String} The attribute value
         */
        getAttributeNS(namespace: string, name: string): string;

        /**
         * Gets the bottom Y coordinate of the element (element Y position + element height)
         * @param {Boolean} local True to get the local css position instead of page
         * coordinate
         * @return {Number}
         * @deprecated
         */
        getBottom(local: boolean): number;

        /**
         * Calculates the x, y to center this element on the screen
         * @return {Number[]} The x, y values [x, y]
         * @deprecated
         */
        getCenterXY(): number;

        /**
         * Return the CSS color for the specified CSS attribute. rgb, 3 digit (like '#fff') and valid values
         * are convert to standard 6 digit hex color.
         * @param {String} attr The css attribute
         * @param {String} defaultValue The default value to use when a valid color isn't found
         * @param {String} [prefix] defaults to #. Use an empty string when working with
         * color anims.
         */
        getColor(attr: string, defaultValue: string, prefix?: string);

        /**
         * Returns either the offsetHeight or the height of this element based on CSS height adjusted by padding or borders
         * when needed to simulate offsetHeight when offsets aren't available. This may not work on display:none elements
         * if a height has not been set using CSS.
         * @return {Number}
         */
        getComputedHeight(): number;

        /**
         * Returns either the offsetWidth or the width of this element based on CSS width adjusted by padding or borders
         * when needed to simulate offsetWidth when offsets aren't available. This may not work on display:none elements
         * if a width has not been set using CSS.
         * @return {Number}
         */
        getComputedWidth(): number;

        /**
         * Returns the sum width of the padding and borders for the passed "sides". See getBorderWidth()
         * for more information about the sides.
         * @return {Number}
         */
        getFrameWidth(sides: string): number;

        /**
         * Gets the left X coordinate
         * @param {Boolean} local True to get the local css position instead of
         * page coordinate
         * @return {Number}
         * @deprecated Use {@link #getX} or {@link #getLocalX}
         */
        getLeft(local: boolean): number;

        /**
         * Gets this element's {@link Ext.ElementLoader ElementLoader}
         * @return {Ext.ElementLoader} The loader
         */
        getLoader(): Ext.ElementLoader;

        /**
         * Gets the local CSS X position for the element
         *
         * @return {Number}
         */
        getLocalX(): number;

        /**
         * Gets the local CSS X and Y position for the element
         *
         * @return {Array} [x, y]
         */
        getLocalXY(): any[];

        /**
         * Gets the local CSS Y position for the element
         *
         * @return {Number}
         */
        getLocalY(): number;

        /**
         * Returns an object defining the area of this Element which can be passed to
         * {@link Ext.util.Positionable#setBox} to set another Element's size/location to match this element.
         *
         * @param {Boolean} [asRegion] If true an Ext.util.Region will be returned
         * @return {Object/Ext.util.Region} box An object in the following format:
         *
         *     {
         *         left: <Element's X position>,
         *         top: <Element's Y position>,
         *         width: <Element's width>,
         *         height: <Element's height>,
         *         bottom: <Element's lower bound>,
         *         right: <Element's rightmost bound>
         *     }
         *
         * The returned object may also be addressed as an Array where index 0 contains
         * the X position and index 1 contains the Y position. So the result may also be
         * used for {@link #setXY}
         * @deprecated use {@link Ext.util.Positionable#getBox} to get a box object, and
         * {@link Ext.util.Positionable#getRegion} to get a {@link Ext.util.Region Region}.
         */
        getPageBox(asRegion?: boolean): any|Ext.util.Region;

        /**
         * Gets an object with all CSS positioning properties. Useful along with
         * #setPostioning to get snapshot before performing an update and then restoring
         * the element.
         * @param {Boolean} [autoPx=false] true to return pixel values for "auto" styles.
         * @return {Object}
         */
        getPositioning(autoPx?: boolean): any;

        /**
         * Gets the right X coordinate of the element (element X position + element width)
         * @param {Boolean} local True to get the local css position instead of page
         * coordinates
         * @return {Number}
         * @deprecated
         */
        getRight(local: boolean): number;

        /**
         * Returns the current scroll position of the element.
         * @return {Object} An object containing the scroll position in the format
         * '{left: (scrollLeft), top: (scrollTop)}'
         */
        getScroll(): any;

        /**
         * Gets the left scroll position
         * @return {Number} The left scroll position
         */
        getScrollLeft(): number;

        /**
         * Gets the top scroll position
         * @return {Number} The top scroll position
         */
        getScrollTop(): number;

        /**
         * Returns the dimensions of the element available to lay content out in.
         *
         * getStyleSize utilizes prefers style sizing if present, otherwise it chooses the larger of offsetHeight/clientHeight and
         * offsetWidth/clientWidth. To obtain the size excluding scrollbars, use getViewSize.
         *
         * Sizing of the document body is handled at the adapter level which handles special cases for IE and strict modes, etc.
         *
         * @return {Object} Object describing width and height.
         * @return {Number} return.width
         * @return {Number} return.height
         */
        getStyleSize(): any;

        /**
         * Returns the width in pixels of the passed text, or the width of the text in this Element.
         * @param {String} text The text to measure. Defaults to the innerHTML of the element.
         * @param {Number} [min] The minumum value to return.
         * @param {Number} [max] The maximum value to return.
         * @return {Number} The text width in pixels.
         */
        getTextWidth(text: string, min?: number, max?: number): number;

        /**
         * Gets the top Y coordinate
         * @param {Boolean} local True to get the local css position instead of page
         * coordinates
         * @return {Number}
         * @deprecated Use {@link #getY} or {@link #getLocalY}
         */
        getTop(local: boolean): number;

        /**
         * Gets element X position in page coordinates
         *
         * @return {Number}
         */
        getX(): number;

        /**
         * Gets element X and Y positions in page coordinates
         *
         * @return {Array} [x, y]
         */
        getXY(): any[];

        /**
         * Gets element Y position in page coordinates
         *
         * @return {Number}
         */
        getY(): number;

        /**
         * Slides the element while fading it out of view. An anchor point can be optionally passed to set the ending point
         * of the effect. Usage:
         *
         *     // default: slide the element downward while fading out
         *     el.ghost();
         *
         *     // custom: slide the element out to the right with a 2-second duration
         *     el.ghost('r', { duration: 2000 });
         *
         *     // common config options shown with default values
         *     el.ghost('b', {
         *         easing: 'easeOut',
         *         duration: 500
         *     });
         *
         * @param {String} anchor (optional) One of the valid {@link Ext.fx.Anim} anchor positions (defaults to bottom: 'b')
         * @param {Object} options (optional) Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.dom.Element} The Element
         */
        ghost(anchor: string, options: any): Ext.dom.Element;

        /**
         * Highlights the Element by setting a color (applies to the background-color by default, but can be changed using
         * the "attr" config option) and then fading back to the original color. If no original color is available, you
         * should provide the "endColor" config option which will be cleared after the animation. Usage:
         *
         *     // default: highlight background to yellow
         *     el.highlight();
         *
         *     // custom: highlight foreground text to blue for 2 seconds
         *     el.highlight("0000ff", { attr: 'color', duration: 2000 });
         *
         *     // common config options shown with default values
         *     el.highlight("ffff9c", {
         *         attr: "backgroundColor", //can be any valid CSS property (attribute) that supports a color value
         *         endColor: (current color) or "ffffff",
         *         easing: 'easeIn',
         *         duration: 1000
         *     });
         *
         * @param {String} color (optional) The highlight color. Should be a 6 char hex color without the leading #
         * (defaults to yellow: 'ffff9c')
         * @param {Object} options (optional) Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.dom.Element} The Element
         */
        highlight(color: string, options: any): Ext.dom.Element;

        /**
         * Sets up event handlers to call the passed functions when the mouse is moved into and out of the Element.
         * @param {Function} overFn The function to call when the mouse enters the Element.
         * @param {Function} outFn The function to call when the mouse leaves the Element.
         * @param {Object} [scope] The scope ('this' reference) in which the functions are executed. Defaults
         * to the Element's DOM element.
         * @param {Object} [options] Options for the listener. See {@link Ext.util.Observable#addListener the
         * options parameter}.
         * @return {Ext.dom.Element} this
         */
        hover(overFn: Function, outFn: Function, scope?: any, options?: any): Ext.dom.Element;

        /**
         * Initializes a {@link Ext.dd.DD} drag drop object for this element.
         * @param {String} group The group the DD object is member of
         * @param {Object} config The DD config object
         * @param {Object} overrides An object containing methods to override/implement on the DD object
         * @return {Ext.dd.DD} The DD object
         */
        initDD(group: string, config: any, overrides: any): Ext.dd.DD;

        /**
         * Initializes a {@link Ext.dd.DDProxy} object for this element.
         * @param {String} group The group the DDProxy object is member of
         * @param {Object} config The DDProxy config object
         * @param {Object} overrides An object containing methods to override/implement on the DDProxy object
         * @return {Ext.dd.DDProxy} The DDProxy object
         */
        initDDProxy(group: string, config: any, overrides: any): Ext.dd.DDProxy;

        /**
         * Initializes a {@link Ext.dd.DDTarget} object for this element.
         * @param {String} group The group the DDTarget object is member of
         * @param {Object} config The DDTarget config object
         * @param {Object} overrides An object containing methods to override/implement on the DDTarget object
         * @return {Ext.dd.DDTarget} The DDTarget object
         */
        initDDTarget(group: string, config: any, overrides: any): Ext.dd.DDTarget;

        /**
         * Tests various css rules/browsers to determine if this element uses a border box
         * @return {Boolean}
         */
        isBorderBox(): boolean;

        /**
         * Returns true if display is not "none"
         * @return {Boolean}
         */
        isDisplayed(): boolean;

        /**
         * Checks whether this element can be focused.
         * @return {Boolean} True if the element is focusable
         */
        isFocusable(): boolean;

        /**
         * Returns true if this element is masked. Also re-centers any displayed message within the mask.
         * @return {Boolean}
         */
        isMasked(): boolean;

        /**
         * Returns true if this element is scrollable.
         * @return {Boolean}
         */
        isScrollable(): boolean;

        /**
         * Checks whether the element is currently visible using both visibility and display properties.
         * @param {Boolean} [deep=false] True to walk the dom and see if parent elements are hidden.
         * If false, the function only checks the visibility of the element itself and it may return
         * 'true' even though a parent is not visible.
         * @return {Boolean} 'true' if the element is currently visible, else 'false'
         */
        isVisible(deep?: boolean): boolean;

        /**
         * Direct access to the Ext.ElementLoader {@link Ext.ElementLoader#method-load} method. The method takes the same object
         * parameter as {@link Ext.ElementLoader#method-load}
         * @return {Ext.dom.Element} this
         */
        load(): Ext.dom.Element;

        /**
         * Monitors this Element for the mouse leaving. Calls the function after the specified delay only if
         * the mouse was not moved back into the Element within the delay. If the mouse *was* moved
         * back in, the function is not called.
         * @param {Number} delay The delay **in milliseconds** to wait for possible mouse re-entry before calling the handler function.
         * @param {Function} handler The function to call if the mouse remains outside of this Element for the specified time.
         * @param {Object} [scope] The scope ('this' reference) in which the handler function executes. Defaults to this Element.
         * @return {Object} The listeners object which was added to this element so that monitoring can be stopped. Example usage:
         *
         *     // Hide the menu if the mouse moves out for 250ms or more
         *     this.mouseLeaveMonitor = this.menuEl.monitorMouseLeave(250, this.hideMenu, this);
         *
         *     ...
         *     // Remove mouseleave monitor on menu destroy
         *     this.menuEl.un(this.mouseLeaveMonitor);
         */
        monitorMouseLeave(delay: number, handler: Function, scope?: any): any;

        /**
         * Sets the position of the element in page coordinates.
         * @param {Number} x X value for new position (coordinates are page-based)
         * @param {Number} y Y value for new position (coordinates are page-based)
         * @param {Boolean/Object} [animate] True for the default animation, or a standard
         * Element animation config object
         * @return {Ext.dom.Element} this
         * @deprecated Use {@link #setXY} instead.
         */
        moveTo(x: number, y: number, animate?: boolean|any): Ext.dom.Element;

        /**
         * Returns true if this element needs an explicit tabIndex to make it focusable. Input fields, text areas, buttons
         * anchors elements **with an href** etc do not need a tabIndex, but structural elements do.
         */
        needsTabIndex();

        /**
         * Appends an event handler to this element.
         *
         * @param {String} eventName The name of event to handle.
         *
         * @param {Function} fn The handler function the event invokes. This function is passed the following parameters:
         *
         * - **evt** : EventObject
         *
         *   The {@link Ext.EventObject EventObject} describing the event.
         *
         * - **el** : HtmlElement
         *
         *   The DOM element which was the target of the event. Note that this may be filtered by using the delegate option.
         *
         * - **o** : Object
         *
         *   The options object from the call that setup the listener.
         *
         * @param {Object} scope (optional) The scope (**this** reference) in which the handler function is executed. **If
         * omitted, defaults to this Element.**
         *
         * @param {Object} options (optional) An object containing handler configuration properties. This may contain any of
         * the following properties:
         *
         * - **scope** Object :
         *
         *   The scope (**this** reference) in which the handler function is executed. **If omitted, defaults to this
         *   Element.**
         *
         * - **delegate** String:
         *
         *   A simple selector to filter the target or look for a descendant of the target. See below for additional details.
         *
         * - **stopEvent** Boolean:
         *
         *   True to stop the event. That is stop propagation, and prevent the default action.
         *
         * - **preventDefault** Boolean:
         *
         *   True to prevent the default action
         *
         * - **stopPropagation** Boolean:
         *
         *   True to prevent event propagation
         *
         * - **normalized** Boolean:
         *
         *   False to pass a browser event to the handler function instead of an Ext.EventObject
         *
         * - **target** Ext.dom.Element:
         *
         *   Only call the handler if the event was fired on the target Element, _not_ if the event was bubbled up from a
         *   child node.
         *
         * - **delay** Number:
         *
         *   The number of milliseconds to delay the invocation of the handler after the event fires.
         *
         * - **single** Boolean:
         *
         *   True to add a handler to handle just the next firing of the event, and then remove itself.
         *
         * - **buffer** Number:
         *
         *   Causes the handler to be scheduled to run in an {@link Ext.util.DelayedTask} delayed by the specified number of
         *   milliseconds. If the event fires again within that time, the original handler is _not_ invoked, but the new
         *   handler is scheduled in its place.
         *
         * **Combining Options**
         *
         * Using the options argument, it is possible to combine different types of listeners:
         *
         * A delayed, one-time listener that auto stops the event and adds a custom argument (forumId) to the options
         * object. The options object is available as the third parameter in the handler function.
         *
         * Code:
         *
         *     el.on('click', this.onClick, this, {
         *         single: true,
         *         delay: 100,
         *         stopEvent : true,
         *         forumId: 4
         *     });
         *
         * **Attaching multiple handlers in 1 call**
         *
         * The method also allows for a single argument to be passed which is a config object containing properties which
         * specify multiple handlers.
         *
         * Code:
         *
         *     el.on({
         *         'click' : {
         *             fn: this.onClick,
         *             scope: this,
         *             delay: 100
         *         },
         *         'mouseover' : {
         *             fn: this.onMouseOver,
         *             scope: this
         *         },
         *         'mouseout' : {
         *             fn: this.onMouseOut,
         *             scope: this
         *         }
         *     });
         *
         * Or a shorthand syntax:
         *
         * Code:
         *
         *     el.on({
         *         'click' : this.onClick,
         *         'mouseover' : this.onMouseOver,
         *         'mouseout' : this.onMouseOut,
         *         scope: this
         *     });
         *
         * **delegate**
         *
         * This is a configuration option that you can pass along when registering a handler for an event to assist with
         * event delegation. Event delegation is a technique that is used to reduce memory consumption and prevent exposure
         * to memory-leaks. By registering an event for a container element as opposed to each element within a container.
         * By setting this configuration option to a simple selector, the target element will be filtered to look for a
         * descendant of the target. For example:
         *
         *     // using this markup:
         *     <div id='elId'>
         *         <p id='p1'>paragraph one</p>
         *         <p id='p2' class='clickable'>paragraph two</p>
         *         <p id='p3'>paragraph three</p>
         *     </div>
         *
         *     // utilize event delegation to registering just one handler on the container element:
         *     el = Ext.get('elId');
         *     el.on(
         *         'click',
         *         function(e,t) {
         *             // handle click
         *             console.info(t.id); // 'p2'
         *         },
         *         this,
         *         {
         *             // filter the target element to be a descendant with the class 'clickable'
         *             delegate: '.clickable'
         *         }
         *     );
         *
         * @return {Ext.dom.Element} this
         */
        on(eventName: string, fn: Function, scope: any, options: any): Ext.dom.Element;

        /**
         * Creates a pause before any subsequent queued effects begin. If there are no effects queued after the pause it will
         * have no effect. Usage:
         *
         *     el.pause(1);
         *
         * @deprecated 4.0 Use the 'delay' config to {@link #animate} instead.
         * @param {Number} seconds The length of time to pause (in seconds)
         * @return {Ext.Element} The Element
         */
        pause(seconds: number): Ext.dom.Element;

        /**
         * Initializes positioning on this element. If a desired position is not passed,
         * it will make the the element positioned relative IF it is not already positioned.
         * @param {String} [pos] Positioning to use "relative", "absolute" or "fixed"
         * @param {Number} [zIndex] The zIndex to apply
         * @param {Number} [x] Set the page X position
         * @param {Number} [y] Set the page Y position
         */
        position(pos?: string, zIndex?: number, x?: number, y?: number);

        /**
         * Fades the element out while slowly expanding it in all directions. When the effect is completed, the element will
         * be hidden (visibility = 'hidden') but block elements will still take up space in the document. Usage:
         *
         *     // default
         *     el.puff();
         *
         *     // common config options shown with default values
         *     el.puff({
         *         easing: 'easeOut',
         *         duration: 500,
         *         useDisplay: false
         *     });
         *
         * @param {Object} options (optional) Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.dom.Element} The Element
         */
        puff(options: any): Ext.dom.Element;

        /**
         * Recursively removes all previous added listeners from this element and its children
         * @return {Ext.dom.Element} this
         */
        purgeAllListeners(): Ext.dom.Element;

        /**
         * Create an event handler on this element such that when the event fires and is handled by this element,
         * it will be relayed to another object (i.e., fired again as if it originated from that object instead).
         * @param {String} eventName The type of event to relay
         * @param {Object} observable Any object that extends {@link Ext.util.Observable} that will provide the context
         * for firing the relayed event
         */
        relayEvent(eventName: string, observable: any);

        /**
         * Removes all previous added listeners from this element
         * @return {Ext.dom.Element} this
         */
        removeAllListeners(): Ext.dom.Element;

        /**
         * Shorthand for {@link #un}.
         */
        removeListener();

        /**
         * Animates the transition of an element's dimensions from a starting height/width to an ending height/width. This
         * method is a convenience implementation of {@link #shift}. Usage:
         *
         *     // change height and width to 100x100 pixels
         *     el.scale(100, 100);
         *
         *     // common config options shown with default values.  The height and width will default to
         *     // the element's existing values if passed as null.
         *     el.scale(
         *         [element's width],
         *         [element's height], {
         *             easing: 'easeOut',
         *             duration: 350
         *         }
         *     );
         *
         * @deprecated 4.0 Just use {@link #animate} instead.
         * @param {Number} width The new width (pass undefined to keep the original width)
         * @param {Number} height The new height (pass undefined to keep the original height)
         * @param {Object} options (optional) Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.Element} The Element
         */
        scale(width: number, height: number, options: any): Ext.dom.Element;

        /**
         * Scrolls this element the specified direction. Does bounds checking to make sure the scroll is
         * within this element's scrollable range.
         * @param {String} direction Possible values are:
         *
         * - '"l"' (or '"left"')
         * - '"r"' (or '"right"')
         * - '"t"' (or '"top"', or '"up"')
         * - '"b"' (or '"bottom"', or '"down"')
         *
         * @param {Number} distance How far to scroll the element in pixels
         * @param {Boolean/Object} [animate] true for the default animation or a standard Element
         * animation config object
         * @return {Boolean} Returns true if a scroll was triggered or false if the element
         * was scrolled as far as it could go.
         */
        scroll(direction: string, distance: number, animate?: boolean|any): boolean;

        /**
         * Scrolls this element by the passed delta values, optionally animating.
         *
         * All of the following are equivalent:
         *
         *      el.scrollBy(10, 10, true);
         *      el.scrollBy([10, 10], true);
         *      el.scrollBy({ x: 10, y: 10 }, true);
         *
         * @param {Number/Number[]/Object} deltaX Either the x delta, an Array specifying x and y deltas or
         * an object with "x" and "y" properties.
         * @param {Number/Boolean/Object} deltaY Either the y delta, or an animate flag or config object.
         * @param {Boolean/Object} animate Animate flag/config object if the delta values were passed separately.
         * @return {Ext.Element} this
         */
        scrollBy(deltaX: number|any, deltaY: number|boolean|any, animate: boolean|any): Ext.dom.Element;

        /**
         * Scrolls this element into view within the passed container.
         * @param {String/HTMLElement/Ext.Element} [container=document.body] The container element
         * to scroll.  Should be a string (id), dom node, or Ext.Element.
         * @param {Boolean} [hscroll=true] False to disable horizontal scroll.
         * @param {Boolean/Object} [animate] true for the default animation or a standard Element
         * @param {Boolean} [highlight=false] true to {@link #highlight} the element when it is in view.
         * animation config object
         * @return {Ext.dom.Element} this
         */
        scrollIntoView(container?: string|HTMLElement|Ext.dom.Element, hscroll?: boolean, animate?: boolean|any, highlight?: boolean): Ext.dom.Element;

        /**
         * Scrolls this element the specified scroll point. It does NOT do bounds checking so
         * if you scroll to a weird value it will try to do it. For auto bounds checking, use #scroll.
         * @param {String} side Either "left" for scrollLeft values or "top" for scrollTop values.
         * @param {Number} value The new scroll value
         * @param {Boolean/Object} [animate] true for the default animation or a standard Element
         * animation config object
         * @return {Ext.Element} this
         */
        scrollTo(side: string, value: number, animate?: boolean|any): Ext.dom.Element;

        /**
         * Enable text selection for this element (normalized across browsers)
         * @return {Ext.Element} this
         */
        selectable(): Ext.dom.Element;

        /**
         * Sets the element's CSS bottom style.
         * @param {Number/String} bottom Number of pixels or CSS string value to set as
         * the bottom CSS property value
         * @return {Ext.dom.Element} this
         * @deprecated
         */
        setBottom(bottom: number|string): Ext.dom.Element;

        /**
         * Sets the element's position and size in one shot. If animation is true then
         * width, height, x and y will be animated concurrently.
         *
         * @param {Number} x X value for new position (coordinates are page-based)
         * @param {Number} y Y value for new position (coordinates are page-based)
         * @param {Number/String} width The new width. This may be one of:
         *
         * - A Number specifying the new width in this Element's
         * {@link #defaultUnit}s (by default, pixels)
         * - A String used to set the CSS width style. Animation may **not** be used.
         *
         * @param {Number/String} height The new height. This may be one of:
         *
         * - A Number specifying the new height in this Element's
         * {@link #defaultUnit}s (by default, pixels)
         * - A String used to set the CSS height style. Animation may **not** be used.
         *
         * @param {Boolean/Object} [animate] true for the default animation or
         * a standard Element animation config object
         *
         * @return {Ext.dom.Element} this
         * @deprecated Use {@link Ext.util.Positionable#setBox} instead.
         */
        setBounds(x: number, y: number, width: number|string, height: number|string, animate?: boolean|any): Ext.dom.Element;

        /**
         * Sets the CSS display property. Uses originalDisplay if the specified value is a boolean true.
         * @param {Boolean/String} value Boolean value to display the element using its default display, or a string to set the display directly.
         * @return {Ext.dom.Element} this
         */
        setDisplayed(value: boolean|string): Ext.dom.Element;

        /**
         * Sets the element's left position directly using CSS style
         * (instead of {@link #setX}).
         * @param {Number/String} left Number of pixels or CSS string value to
         * set as the left CSS property value
         * @return {Ext.dom.Element} this
         * @deprecated
         */
        setLeft(left: number|string): Ext.dom.Element;

        /**
         * Sets the element's left and top positions directly using CSS style
         * @param {Number/String} left Number of pixels or CSS string value to
         * set as the left CSS property value
         * @param {Number/String} top Number of pixels or CSS string value to
         * set as the top CSS property value
         * @return {Ext.dom.Element} this
         * @deprecated
         */
        setLeftTop(left: number|string, top: number|string): Ext.dom.Element;

        /**
         * Sets the position of the element in page coordinates.
         * @param {Number} x X value for new position
         * @param {Number} y Y value for new position
         * @param {Boolean/Object} [animate] True for the default animation, or a standard
         * Element animation config object
         * @return {Ext.dom.Element} this
         * @deprecated Use {@link #setXY} instead.
         */
        setLocation(x: number, y: number, animate?: boolean|any): Ext.dom.Element;

        /**
         * Set the opacity of the element
         * @param {Number} opacity The new opacity. 0 = transparent, .5 = 50% visibile, 1 = fully visible, etc
         * @param {Boolean/Object} [animate] a standard Element animation config object or 'true' for
         * the default animation ('{duration: 350, easing: 'easeIn'}')
         * @return {Ext.dom.Element} this
         */
        setOpacity(opacity: number, animate?: boolean|any): Ext.dom.Element;

        /**
         * Set positioning with an object returned by #getPositioning.
         * @return {Ext.dom.Element} this
         */
        setPositioning(posCfg: any): Ext.dom.Element;

        /**
         * Sets the element's CSS right style.
         * @param {Number/String} right Number of pixels or CSS string value to
         * set as the right CSS property value
         * @return {Ext.dom.Element} this
         * @deprecated
         */
        setRight(right: number|string): Ext.dom.Element;

        /**
         * Sets the left scroll position
         * @param {Number} left The left scroll position
         * @return {Ext.dom.Element} this
         */
        setScrollLeft(left: number): Ext.dom.Element;

        /**
         * Sets the top scroll position
         * @param {Number} top The top scroll position
         * @return {Ext.dom.Element} this
         */
        setScrollTop(top: number): Ext.dom.Element;

        /**
         * Sets the element's top position directly using CSS style
         * (instead of {@link #setY}).
         * @param {Number/String} top Number of pixels or CSS string value to
         * set as the top CSS property value
         * @return {Ext.dom.Element} this
         * @deprecated
         */
        setTop(top: number|string): Ext.dom.Element;

        /**
         * Animates the transition of any combination of an element's dimensions, xy position and/or opacity. Any of these
         * properties not specified in the config object will not be changed. This effect requires that at least one new
         * dimension, position or opacity setting must be passed in on the config object in order for the function to have
         * any effect. Usage:
         *
         *     // slide the element horizontally to x position 200 while changing the height and opacity
         *     el.shift({ x: 200, height: 50, opacity: .8 });
         *
         *     // common config options shown with default values.
         *     el.shift({
         *         width: [element's width],
         *         height: [element's height],
         *         x: [element's x position],
         *         y: [element's y position],
         *         opacity: [element's opacity],
         *         easing: 'easeOut',
         *         duration: 350
         *     });
         *
         * @deprecated 4.0 Just use {@link #animate} instead.
         * @param {Object} options Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.Element} The Element
         */
        shift(options: any): Ext.dom.Element;

        /**
         * Slides the element into view. An anchor point can be optionally passed to set the point of origin for the slide
         * effect. This function automatically handles wrapping the element with a fixed-size container if needed. See the
         * {@link Ext.fx.Anim} class overview for valid anchor point options. Usage:
         *
         *     // default: slide the element in from the top
         *     el.slideIn();
         *
         *     // custom: slide the element in from the right with a 2-second duration
         *     el.slideIn('r', { duration: 2000 });
         *
         *     // common config options shown with default values
         *     el.slideIn('t', {
         *         easing: 'easeOut',
         *         duration: 500
         *     });
         *
         * @param {String} anchor (optional) One of the valid {@link Ext.fx.Anim} anchor positions (defaults to top: 't')
         * @param {Object} options (optional) Object literal with any of the {@link Ext.fx.Anim} config options
         * @param {Boolean} options.preserveScroll Set to true if preservation of any descendant elements'
         * 'scrollTop' values is required. By default the DOM wrapping operation performed by 'slideIn' and
         * 'slideOut' causes the browser to lose all scroll positions.
         * @return {Ext.dom.Element} The Element
         */
        slideIn(anchor: string, options: any, options_preserveScroll: boolean): Ext.dom.Element;

        /**
         * Slides the element out of view. An anchor point can be optionally passed to set the end point for the slide
         * effect. When the effect is completed, the element will be hidden (visibility = 'hidden') but block elements will
         * still take up space in the document. The element must be removed from the DOM using the 'remove' config option if
         * desired. This function automatically handles wrapping the element with a fixed-size container if needed. See the
         * {@link Ext.fx.Anim} class overview for valid anchor point options. Usage:
         *
         *     // default: slide the element out to the top
         *     el.slideOut();
         *
         *     // custom: slide the element out to the right with a 2-second duration
         *     el.slideOut('r', { duration: 2000 });
         *
         *     // common config options shown with default values
         *     el.slideOut('t', {
         *         easing: 'easeOut',
         *         duration: 500,
         *         remove: false,
         *         useDisplay: false
         *     });
         *
         * @param {String} anchor (optional) One of the valid {@link Ext.fx.Anim} anchor positions (defaults to top: 't')
         * @param {Object} options (optional) Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.dom.Element} The Element
         */
        slideOut(anchor: string, options: any): Ext.dom.Element;

        /**
         * Stops the specified event(s) from bubbling and optionally prevents the default action
         * @param {String/String[]} eventName an event / array of events to stop from bubbling
         * @param {Boolean} [preventDefault] true to prevent the default action too
         * @return {Ext.dom.Element} this
         */
        swallowEvent(eventName: string, preventDefault?: boolean): Ext.dom.Element;

        /**
         * Blinks the element as if it was clicked and then collapses on its center (similar to switching off a television).
         * When the effect is completed, the element will be hidden (visibility = 'hidden') but block elements will still
         * take up space in the document. The element must be removed from the DOM using the 'remove' config option if
         * desired. Usage:
         *
         *     // default
         *     el.switchOff();
         *
         *     // all config options shown with default values
         *     el.switchOff({
         *         easing: 'easeIn',
         *         duration: .3,
         *         remove: false,
         *         useDisplay: false
         *     });
         *
         * @param {Object} options (optional) Object literal with any of the {@link Ext.fx.Anim} config options
         * @return {Ext.dom.Element} The Element
         */
        switchOff(options: any): Ext.dom.Element;

        /**
         * Toggles the element's visibility or display, depending on visibility mode.
         * @param {Boolean/Object} [animate] True for the default animation, or a standard Element animation config object
         * @return {Ext.dom.Element} this
         */
        toggle(animate?: boolean|any): Ext.dom.Element;

        /**
         * Removes an event handler from this element.
         *
         * **Note**: if a *scope* was explicitly specified when {@link #on adding} the listener,
         * the same scope must be specified here.
         *
         * Example:
         *
         *     el.un('click', this.handlerFn);
         *     // or
         *     el.removeListener('click', this.handlerFn);
         *
         * @param {String} eventName The name of the event from which to remove the handler.
         * @param {Function} fn The handler function to remove. **This must be a reference to the function passed into the
         * {@link #on} call.**
         * @param {Object} scope If a scope (**this** reference) was specified when the listener was added, then this must
         * refer to the same object.
         * @return {Ext.dom.Element} this
         */
        un(eventName: string, fn: Function, scope: any): Ext.dom.Element;

        /**
         * Return clipping (overflow) to original clipping before {@link #clip} was called
         * @return {Ext.dom.Element} this
         */
        unclip(): Ext.dom.Element;

        /**
         * Hides a previously applied mask.
         */
        unmask();

        /**
         * Disables text selection for this element (normalized across browsers)
         * @return {Ext.dom.Element} this
         */
        unselectable(): Ext.dom.Element;

        /**
         * Fires when an object/image is stopped from loading before completely loaded.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        abort(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a control loses the input focus and its value has been modified since gaining focus.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        change(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a mouse click is detected within the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        click(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a right click is detected within the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        contextmenu(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a mouse double click is detected within the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        dblclick(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Fires when an element is activated, for instance, through a mouse click or a keypress.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMActivate(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Fires when an attribute has been modified.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMAttrModified(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Fires when the character data has been modified.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMCharacterDataModified(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Similar to HTML focus event, but can be applied to any focusable element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMFocusIn(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Similar to HTML blur event, but can be applied to any focusable element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMFocusOut(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Fires when a node has been added as a child of another node.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMNodeInserted(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Fires when a node is being inserted into a document.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMNodeInsertedIntoDocument(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Fires when a descendant node of the element is removed.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMNodeRemoved(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Fires when a node is being removed from a document.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMNodeRemovedFromDocument(e: Ext.EventObject, t: HTMLElement);

        /**
         * Where supported. Fires when the subtree is modified.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        DOMSubtreeModified(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when an object/image/frame cannot be loaded properly.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        error(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a keydown is detected within the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        keydown(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a keypress is detected within the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        keypress(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a keyup is detected within the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        keyup(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a mousedown is detected within the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mousedown(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when the mouse enters the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseenter(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when the mouse leaves the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseleave(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a mousemove is detected with the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mousemove(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a mouseout is detected with the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseout(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a mouseover is detected within the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseover(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a mouseup is detected within the element.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        mouseup(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a form is reset.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        reset(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a document view is resized.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        resize(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when a form is submitted.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        submit(e: Ext.EventObject, t: HTMLElement);

        /**
         * Fires when the user agent removes all content from a window or frame. For elements, it fires when the target
         * element or any of its content has been removed.
         * @param {Ext.EventObject} e The {@link Ext.EventObject} encapsulating the DOM event.
         * @param {HTMLElement} t The target of the event.
         */
        unload(e: Ext.EventObject, t: HTMLElement);
    }

    /**
     * @extends Ext.dom.AbstractHelper
     * @requires Ext.dom.AbstractElement
     *
     * The actual class of which {@link Ext.DomHelper} is instance of.
     *
     * Use singleton {@link Ext.DomHelper} instead.
     */
    export class Helper extends Ext.dom.AbstractHelper {
        /**
         * True to force the use of DOM instead of html fragments.
         */
        useDom: boolean;

        /**
         * Creates new DOM element(s) without inserting them to the document.
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @return {HTMLElement} The new uninserted node
         */
        createDom(o: any|string): HTMLElement;

        /**
         * Alias for {@link #markup}.
         */
        createHtml();

        /**
         * Creates a new Ext.Template from the DOM object spec.
         * @param {Object} o The DOM object spec (and children)
         * @return {Ext.Template} The new template
         */
        createTemplate(o: any): Ext.Template;

        /**
         * Creates new DOM element(s) and overwrites the contents of el with them.
         * @param {String/HTMLElement/Ext.Element} el The context element
         * @param {Object/String} o The DOM object spec (and children) or raw HTML blob
         * @param {Boolean} [returnElement] true to return an Ext.Element
         * @return {HTMLElement/Ext.Element} The new node
         */
        overwrite(el: string|HTMLElement|Ext.dom.Element, o: any|string, returnElement?: boolean): HTMLElement|Ext.dom.Element;
    }

    interface LayerConfig {
        /**
         * CSS class to add to the element
         */
        cls?: string;

        /**
         * False to disable constrain to viewport.
         *
         * Optional, Defaults to: true
         */
        constrain?: boolean;

        /**
         * DomHelper object config to create element with.
         *
         * Optional, Defaults to: {tag: 'div', cls: 'x-layer'}
         */
        dh?: any;

        /**
         * A String which specifies how this Layer will be hidden.
         * Values may be:
         *
         * - ''display'' : The Component will be hidden using the 'display: none' style.
         * - ''visibility'' : The Component will be hidden using the 'visibility: hidden' style.
         * - ''offsets'' : The Component will be hidden by absolutely positioning it out of the visible area
         *   of the document. This is useful when a hidden Component must maintain measurable dimensions.
         *   Hiding using 'display' results in a Component having zero dimensions.
         */
        hideMode?: string;

        /**
         * True to automatically create an {@link Ext.Shadow}, or a string indicating the
         * shadow's display {@link Ext.Shadow#mode}. False to disable the shadow.
         *
         * Optional, Defaults to: false
         */
        shadow?: string|boolean;

        /**
         * Number of pixels to offset the shadow
         *
         * Optional, Defaults to: 4
         */
        shadowOffset?: number;

        /**
         * False to disable the iframe shim in browsers which need one.
         *
         * Optional, Defaults to: true
         */
        shim?: boolean;

        /**
         * Defaults to use css offsets to hide the Layer. Specify <tt>true</tt>
         * to use css style <tt>'display:none;'</tt> to hide the Layer.
         *
         * Optional, Defaults to: false
         */
        useDisplay?: boolean;

        /**
         * The CSS class name to add in order to hide this Layer if this layer
         * is configured with <code>{@link #hideMode}: 'asclass'</code>
         */
        visibilityCls?: string;

        /**
         * Starting z-index.
         *
         * Optional, Defaults to: 11000
         */
        zindex?: number;
    }

    /**
     * An extended {@link Ext.Element} object that supports a shadow and shim, constrain to viewport and
     * automatic maintaining of shadow/shim positions.
     */
    export class Layer extends Ext.dom.Element implements Ext.dom.LayerConfig {
        /**
         * CSS class to add to the element
         */
        cls: string;

        /**
         * False to disable constrain to viewport.
         *
         * Optional, Defaults to: true
         */
        constrain: boolean;

        /**
         * DomHelper object config to create element with.
         *
         * Optional, Defaults to: {tag: 'div', cls: 'x-layer'}
         */
        dh: any;

        /**
         * A String which specifies how this Layer will be hidden.
         * Values may be:
         *
         * - ''display'' : The Component will be hidden using the 'display: none' style.
         * - ''visibility'' : The Component will be hidden using the 'visibility: hidden' style.
         * - ''offsets'' : The Component will be hidden by absolutely positioning it out of the visible area
         *   of the document. This is useful when a hidden Component must maintain measurable dimensions.
         *   Hiding using 'display' results in a Component having zero dimensions.
         */
        hideMode: string;

        /**
         * True to automatically create an {@link Ext.Shadow}, or a string indicating the
         * shadow's display {@link Ext.Shadow#mode}. False to disable the shadow.
         *
         * Optional, Defaults to: false
         */
        shadow: string|boolean;

        /**
         * Number of pixels to offset the shadow
         *
         * Optional, Defaults to: 4
         */
        shadowOffset: number;

        /**
         * False to disable the iframe shim in browsers which need one.
         *
         * Optional, Defaults to: true
         */
        shim: boolean;

        /**
         * Defaults to use css offsets to hide the Layer. Specify <tt>true</tt>
         * to use css style <tt>'display:none;'</tt> to hide the Layer.
         *
         * Optional, Defaults to: false
         */
        useDisplay: boolean;

        /**
         * The CSS class name to add in order to hide this Layer if this layer
         * is configured with <code>{@link #hideMode}: 'asclass'</code>
         */
        visibilityCls: string;

        /**
         * Starting z-index.
         *
         * Optional, Defaults to: 11000
         */
        zindex: number;

        /**
         * Creates new Layer.
         * @param {Object} [config] An object with config options.
         * @param {String/HTMLElement} [existingEl] Uses an existing DOM element.
         * If the element is not found it creates it.
         */
        constructor(config?: Ext.dom.LayerConfig, existingEl?: string|HTMLElement);

        remove();

        /**
         * Sets the z-index of this layer and adjusts any shadow and shim z-indexes. The layer
         * z-index is automatically incremented depending upon the presence of a shim or a
         * shadow in so that it always shows above those two associated elements.
         *
         * Any shim, will be assigned the passed z-index. A shadow will be assigned the next
         * highet z-index, and the Layer's element will receive the highest  z-index.
         *
         * @param {Number} zindex The new z-index to set
         * @return {Ext.Layer} The Layer
         */
        setZIndex(zindex: number): Ext.dom.Layer;
    }

    /**
     * @alternateClassName Ext.DomQuery
     * @alternateClassName Ext.core.DomQuery
     *
     * Provides high performance selector/xpath processing by compiling queries into reusable functions. New pseudo classes
     * and matchers can be plugged. It works on HTML and XML documents (if a content node is passed in).
     *
     * DomQuery supports most of the [CSS3 selectors spec][1], along with some custom selectors and basic XPath.
     *
     * All selectors, attribute filters and pseudos below can be combined infinitely in any order. For example
     * 'div.foo:nth-child(odd)[@foo=bar].bar:first' would be a perfectly valid selector. Node filters are processed
     * in the order in which they appear, which allows you to optimize your queries for your document structure.
     *
     * ## Element Selectors:
     *
     *   - **'*'** any element
     *   - **'E'** an element with the tag E
     *   - **'E F'** All descendent elements of E that have the tag F
     *   - **'E > F'** or **E/F** all direct children elements of E that have the tag F
     *   - **'E + F'** all elements with the tag F that are immediately preceded by an element with the tag E
     *   - **'E ~ F'** all elements with the tag F that are preceded by a sibling element with the tag E
     *
     * ## Attribute Selectors:
     *
     * The use of '@' and quotes are optional. For example, 'div[@foo='bar']' is also a valid attribute selector.
     *
     *   - **'E[foo]'** has an attribute "foo"
     *   - **'E[foo=bar]'** has an attribute "foo" that equals "bar"
     *   - **'E[foo^=bar]'** has an attribute "foo" that starts with "bar"
     *   - **'E[foo$=bar]'** has an attribute "foo" that ends with "bar"
     *   - **'E[foo*=bar]'** has an attribute "foo" that contains the substring "bar"
     *   - **'E[foo%=2]'** has an attribute "foo" that is evenly divisible by 2
     *   - **'E[foo!=bar]'** attribute "foo" does not equal "bar"
     *
     * ## Pseudo Classes:
     *
     *   - **'E:first-child'** E is the first child of its parent
     *   - **'E:last-child'** E is the last child of its parent
     *   - **'E:nth-child(_n_)'** E is the _n_th child of its parent (1 based as per the spec)
     *   - **'E:nth-child(odd)'** E is an odd child of its parent
     *   - **'E:nth-child(even)'** E is an even child of its parent
     *   - **'E:only-child'** E is the only child of its parent
     *   - **'E:checked'** E is an element that is has a checked attribute that is true (e.g. a radio or checkbox)
     *   - **'E:first'** the first E in the resultset
     *   - **'E:last'** the last E in the resultset
     *   - **'E:nth(_n_)'** the _n_th E in the resultset (1 based)
     *   - **'E:odd'** shortcut for :nth-child(odd)
     *   - **'E:even'** shortcut for :nth-child(even)
     *   - **'E:contains(foo)'** E's innerHTML contains the substring "foo"
     *   - **'E:nodeValue(foo)'** E contains a textNode with a nodeValue that equals "foo"
     *   - **'E:not(S)'** an E element that does not match simple selector S
     *   - **'E:has(S)'** an E element that has a descendent that matches simple selector S
     *   - **'E:next(S)'** an E element whose next sibling matches simple selector S
     *   - **'E:prev(S)'** an E element whose previous sibling matches simple selector S
     *   - **'E:any(S1|S2|S2)'** an E element which matches any of the simple selectors S1, S2 or S3
     *   - **'E:visible(true)'** an E element which is deeply visible according to {@link Ext.dom.Element#isVisible}
     *
     * ## CSS Value Selectors:
     *
     *   - **'E{display=none}'** css value "display" that equals "none"
     *   - **'E{display^=none}'** css value "display" that starts with "none"
     *   - **'E{display$=none}'** css value "display" that ends with "none"
     *   - **'E{display*=none}'** css value "display" that contains the substring "none"
     *   - **'E{display%=2}'** css value "display" that is evenly divisible by 2
     *   - **'E{display!=none}'** css value "display" that does not equal "none"
     *
     * ## XML Namespaces:
     *   - **'ns|E'** an element with tag E and namespace prefix ns
     *
     * [1]: http://www.w3.org/TR/2005/WD-css3-selectors-20051215/#selectors
     */
    export class Query {
        /**
         * Collection of matching regular expressions and code snippets.
         * Each capture group within '()' will be replace the '{}' in the select
         * statement as specified by their index.
         */
        static matchers: any;

        /**
         * Collection of operator comparison functions.
         * The default operators are '=', '!=', '^=', '$=', '*=', '%=', '|=' and '~='.
         *
         * New operators can be added as long as the match the format *c*'=' where *c*
         * is any character other than space, '>', or '<'.
         *
         * Operator functions are passed the following parameters:
         *
         * * 'propValue' : The property value to test.
         * * 'compareTo' : The value to compare to.
         */
        static operators: any;

        /**
         * Object hash of "pseudo class" filter functions which are used when filtering selections.
         * Each function is passed two parameters:
         *
         * - **c** : Array
         *     An Array of DOM elements to filter.
         *
         * - **v** : String
         *     The argument (if any) supplied in the selector.
         *
         * A filter function returns an Array of DOM elements which conform to the pseudo class.
         * In addition to the provided pseudo classes listed above such as 'first-child' and 'nth-child',
         * developers may add additional, custom psuedo class filters to select elements according to application-specific requirements.
         *
         * For example, to filter 'a' elements to only return links to __external__ resources:
         *
         *     Ext.DomQuery.pseudos.external = function(c, v) {
         *         var r = [], ri = -1;
         *         for(var i = 0, ci; ci = c[i]; i++) {
         *             // Include in result set only if it's a link to an external resource
         *             if (ci.hostname != location.hostname) {
         *                 r[++ri] = ci;
         *             }
         *         }
         *         return r;
         *     };
         *
         * Then external links could be gathered with the following statement:
         *
         *     var externalLinks = Ext.select("a:external");
         */
        static pseudos: any;

        /**
         * Compiles a selector/xpath query into a reusable function. The returned function
         * takes one parameter "root" (optional), which is the context node from where the query should start.
         * @param {String} selector The selector/xpath query
         * @param {String} [type="select"] Either "select" or "simple" for a simple selector match
         * @return {Function}
         */
        static compile(selector: string, type?: string): Function;

        /**
         * Filters an array of elements to only include matches of a simple selector
         * (e.g. 'div.some-class' or 'span:first-child')
         * @param {HTMLElement[]} el An array of elements to filter
         * @param {String} selector The simple selector to test
         * @param {Boolean} nonMatches If true, it returns the elements that DON'T match the selector instead of the
         * ones that match
         * @return {HTMLElement[]} An Array of DOM elements which match the selector. If there are no matches, and empty
         * Array is returned.
         */
        static filter(el: HTMLElement, selector: string, nonMatches: boolean): HTMLElement;

        /**
         * Returns true if the passed element(s) match the passed simple selector
         * (e.g. 'div.some-class' or 'span:first-child')
         * @param {String/HTMLElement/HTMLElement[]} el An element id, element or array of elements
         * @param {String} selector The simple selector to test
         * @return {Boolean}
         */
        static is(el: string|HTMLElement, selector: string): boolean;

        /**
         * Selects an array of DOM nodes using JavaScript-only implementation.
         *
         * Use {@link #select} to take advantage of browsers built-in support for CSS selectors.
         * @param {String} selector The selector/xpath query (can be a comma separated list of selectors)
         * @param {HTMLElement/String} [root=document] The start of the query.
         * @return {HTMLElement[]} An Array of DOM elements which match the selector. If there are
         * no matches, and empty Array is returned.
         */
        static jsSelect(selector: string, root?: HTMLElement|string): HTMLElement;

        /**
         * Selects an array of DOM nodes by CSS/XPath selector.
         *
         * Uses [document.querySelectorAll][0] if browser supports that, otherwise falls back to
         * {@link Ext.dom.Query#jsSelect} to do the work.
         *
         * Aliased as {@link Ext#query}.
         *
         * [0]: https://developer.mozilla.org/en/DOM/document.querySelectorAll
         *
         * @param {String} path The selector/xpath query
         * @param {HTMLElement} [root=document] The start of the query.
         * @return {HTMLElement[]} An array of DOM elements (not a NodeList as returned by 'querySelectorAll').
         * @param {String} [type="select"] Either "select" or "simple" for a simple selector match (only valid when
         * used when the call is deferred to the jsSelect method)
         * @param {Boolean} [single] Pass 'true' to select only the first matching node using 'document.querySelector' (where available)
         */
        static select(path: string, root?: HTMLElement, type?: string, single?: boolean): HTMLElement;

        /**
         * Selects a single element.
         * @param {String} selector The selector/xpath query
         * @param {HTMLElement} [root=document] The start of the query.
         * @return {HTMLElement} The DOM element which matched the selector.
         */
        static selectNode(selector: string, root?: HTMLElement): HTMLElement;

        /**
         * Selects the value of a node, parsing integers and floats.
         * Returns the defaultValue, or 0 if none is specified.
         * @param {String} selector The selector/xpath query
         * @param {HTMLElement} [root=document] The start of the query.
         * @param {Number} [defaultValue] When specified, this is return as empty value.
         * @return {Number}
         */
        static selectNumber(selector: string, root?: HTMLElement, defaultValue?: number): number;

        /**
         * Selects the value of a node, optionally replacing null with the defaultValue.
         * @param {String} selector The selector/xpath query
         * @param {HTMLElement} [root=document] The start of the query.
         * @param {String} [defaultValue] When specified, this is return as empty value.
         * @return {String}
         */
        static selectValue(selector: string, root?: HTMLElement, defaultValue?: string): string;
    }
}

declare module Ext.dom.Element {
    /**
     * @alternateClassName Ext.dom.AbstractElement.Fly
     * @extends Ext.dom.Element
     *
     * A non-persistent wrapper for a DOM element which may be used to execute methods of {@link Ext.dom.Element}
     * upon a DOM element without creating an instance of {@link Ext.dom.Element}.
     *
     * A **singleton** instance of this class is returned when you use {@link Ext#fly}
     *
     * Because it is a singleton, this Flyweight does not have an ID, and must be used and discarded in a single line.
     * You should not keep and use the reference to this singleton over multiple lines because methods that you call
     * may themselves make use of {@link Ext#fly} and may change the DOM element to which the instance refers.
     */
    export class Fly extends Ext.dom.Element {
        /**
         * This is 'true' to identify Element flyweights
         */
        isFly: boolean;

        /**
         * @alternateClassName Ext.Element
         * @alternateClassName Ext.core.Element
         * @extends Ext.dom.AbstractElement
         *
         * Encapsulates a DOM element, adding simple DOM manipulation facilities, normalizing for browser differences.
         *
         * All instances of this class inherit the methods of {@link Ext.fx.Anim} making visual effects easily available to all
         * DOM elements.
         *
         * Note that the events documented in this class are not Ext events, they encapsulate browser events. Some older browsers
         * may not support the full range of events. Which events are supported is beyond the control of Ext JS.
         *
         * Usage:
         *
         *     // by id
         *     var el = Ext.get("my-div");
         *
         *     // by DOM element reference
         *     var el = Ext.get(myDivElement);
         *
         * # Animations
         *
         * When an element is manipulated, by default there is no animation.
         *
         *     var el = Ext.get("my-div");
         *
         *     // no animation
         *     el.setWidth(100);
         *
         * Many of the functions for manipulating an element have an optional "animate" parameter. This parameter can be
         * specified as boolean (true) for default animation effects.
         *
         *     // default animation
         *     el.setWidth(100, true);
         *
         * To configure the effects, an object literal with animation options to use as the Element animation configuration
         * object can also be specified. Note that the supported Element animation configuration options are a subset of the
         * {@link Ext.fx.Anim} animation options specific to Fx effects. The supported Element animation configuration options
         * are:
         *
         *     Option    Default   Description
         *     --------- --------  ---------------------------------------------
         *     {@link Ext.fx.Anim#duration duration}  350       The duration of the animation in milliseconds
         *     {@link Ext.fx.Anim#easing easing}    easeOut   The easing method
         *     {@link Ext.fx.Anim#callback callback}  none      A function to execute when the anim completes
         *     {@link Ext.fx.Anim#scope scope}     this      The scope (this) of the callback function
         *
         * Usage:
         *
         *     // Element animation options object
         *     var opt = {
         *         {@link Ext.fx.Anim#duration duration}: 1000,
         *         {@link Ext.fx.Anim#easing easing}: 'elasticIn',
         *         {@link Ext.fx.Anim#callback callback}: this.foo,
         *         {@link Ext.fx.Anim#scope scope}: this
         *     };
         *     // animation with some options set
         *     el.setWidth(100, opt);
         *
         * The Element animation object being used for the animation will be set on the options object as "anim", which allows
         * you to stop or manipulate the animation. Here is an example:
         *
         *     // using the "anim" property to get the Anim object
         *     if(opt.anim.isAnimated()){
         *         opt.anim.stop();
         *     }
         *
         * # Composite (Collections of) Elements
         *
         * For working with collections of Elements, see {@link Ext.CompositeElement}
         *
         * @constructor
         * Creates new Element directly.
         * @param {Boolean} [forceNew] By default the constructor checks to see if there is already an instance of this
         * element in the cache and if there is it returns the same instance. This will skip that check (useful for extending
         * this class).
         * @return {Object}
         */
        constructor(element: string|HTMLElement, forceNew?: boolean);
    }
}

declare module Ext.draw {
    interface ColorConfig {
        /**
         * The default factor to compute the lighter or darker color. Defaults to 0.2.
         */
        lightnessFactor?: number;
    }

    /**
     * Represents an RGB color and provides helper functions get
     * color components in HSL color space.
     */
    export class Color extends Ext.Base implements Ext.draw.ColorConfig {
        /**
         * The default factor to compute the lighter or darker color. Defaults to 0.2.
         */
        lightnessFactor: number;

        /**
         * Creates new Color.
         * @param {Number} red Red component (0..255)
         * @param {Number} green Green component (0..255)
         * @param {Number} blue Blue component (0..255)
         */
        constructor(red: number, green: number, blue: number);

        /**
         * Get the blue component of the color, in the range 0..255.
         * @return {Number}
         */
        getBlue(): number;

        /**
         * Return a new color that is darker than this color.
         * @param {Number} factor Darker factor (0..1), default to 0.2
         * @return Ext.draw.Color
         */
        getDarker(factor: number);

        /**
         * Returns the gray value (0 to 255) of the color.
         *
         * The gray value is calculated using the formula r*0.3 + g*0.59 + b*0.11.
         *
         * @returns {Number}
         */
        getGrayscale();

        /**
         * Get the green component of the color, in the range 0..255.
         * @return {Number}
         */
        getGreen(): number;

        /**
         * Get the equivalent HSL components of the color.
         * @return {Number[]}
         */
        getHSL(): number;

        /**
         * Return a new color that is lighter than this color.
         * @param {Number} factor Lighter factor (0..1), default to 0.2
         * @return Ext.draw.Color
         */
        getLighter(factor: number);

        /**
         * Get the red component of the color, in the range 0..255.
         * @return {Number}
         */
        getRed(): number;

        /**
         * Get the RGB values.
         * @return {Number[]}
         */
        getRGB(): number;

        /**
         * Return the color in the hex format, i.e. '#rrggbb'.
         * @return {String}
         */
        toString(): string;

        /**
         * Create a new color based on the specified HSL values.
         *
         * **Note:** This method is both static and instance.
         *
         * @param {Number} h Hue component (0..359)
         * @param {Number} s Saturation component (0..1)
         * @param {Number} l Lightness component (0..1)
         * @returns Ext.draw.Color
         */
        static fromHSL(h: number, s: number, l: number);

        /**
         * Parse the string and create a new color.
         *
         * Supported formats: '#rrggbb', '#rgb', and 'rgb(r,g,b)'.
         *
         * If the string is not recognized, an undefined will be returned instead.
         *
         * **Note:** This method is both static and instance.
         *
         * @param {String} str Color in string.
         * @returns Ext.draw.Color
         */
        static fromString(str: string);

        /**
         * Convert a color to hexadecimal format.
         *
         * **Note:** This method is both static and instance.
         *
         * @param {String/String[]} color The color value (i.e 'rgb(255, 255, 255)', 'color: #ffffff').
         * Can also be an Array, in this case the function handles the first member.
         * @returns {String} The color in hexadecimal format.
         */
        static toHex(color: string);
    }

    interface ComponentConfig extends Ext.ComponentConfig {
        /**
         * Turn on autoSize support which will set the bounding div's size to the natural size of the contents.
         */
        autoSize?: boolean;

        baseCls?: any;

        componentLayout?: any;

        /**
         * Defines the priority order for which Surface implementation to use. The first
         * one supported by the current environment will be used.
         */
        enginePriority?: string;

        /**
         * (optional) Define a set of gradients that can be used as 'fill' property in sprites.
         * The gradients array is an array of objects with the following properties:
         *
         *  - 'id' - string - The unique name of the gradient.
         *  - 'angle' - number, optional - The angle of the gradient in degrees.
         *  - 'stops' - object - An object with numbers as keys (from 0 to 100) and style objects as values
         *
         * ## Example
         *
         *     gradients: [{
         *         id: 'gradientId',
         *         angle: 45,
         *         stops: {
         *             0: {
         *                 color: '#555'
         *             },
         *             100: {
         *                 color: '#ddd'
         *             }
         *         }
         *     }, {
         *         id: 'gradientId2',
         *         angle: 0,
         *         stops: {
         *             0: {
         *                 color: '#590'
         *             },
         *             20: {
         *                 color: '#599'
         *             },
         *             100: {
         *                 color: '#ddd'
         *             }
         *         }
         *     }]
         *
         * Then the sprites can use 'gradientId' and 'gradientId2' by setting the fill attributes to those ids, for example:
         *
         *     sprite.setAttributes({
         *         fill: 'url(#gradientId)'
         *     }, true);
         */
        gradients?: any;

        /**
         * Array of sprites or sprite config objects to add initially to the surface.
         */
        items?: Ext.draw.Sprite;

        shrinkWrap?: any;

        /**
         * Turn on view box support which will scale and position items in the draw component to fit to the component while
         * maintaining aspect ratio. Note that this scaling can override other sizing settings on your items.
         */
        viewBox?: boolean;
    }

    /**
     * The Draw Component is a surface in which sprites can be rendered. The Draw Component
     * manages and holds an {@link Ext.draw.Surface} instance where
     * {@link Ext.draw.Sprite Sprites} can be appended.
     *
     * One way to create a draw component is:
     *
     *     @example
     *     var drawComponent = Ext.create('Ext.draw.Component', {
     *         viewBox: false,
     *         items: [{
     *             type: 'circle',
     *             fill: '#79BB3F',
     *             radius: 100,
     *             x: 100,
     *             y: 100
     *         }]
     *     });
     *
     *     Ext.create('Ext.Window', {
     *         width: 215,
     *         height: 235,
     *         layout: 'fit',
     *         items: [drawComponent]
     *     }).show();
     *
     * In this case we created a draw component and added a {@link Ext.draw.Sprite sprite} to it.
     * The {@link Ext.draw.Sprite#type type} of the sprite is 'circle' so if you run this code you'll see a yellow-ish
     * circle in a Window. When setting 'viewBox' to 'false' we are responsible for setting the object's position and
     * dimensions accordingly.
     *
     * You can also add sprites by using the surface's add method:
     *
     *     drawComponent.surface.add({
     *         type: 'circle',
     *         fill: '#79BB3F',
     *         radius: 100,
     *         x: 100,
     *         y: 100
     *     });
     *
     * ## Larger example
     *
     *     @example
     *     var drawComponent = Ext.create('Ext.draw.Component', {
     *         width: 800,
     *         height: 600,
     *         renderTo: document.body
     *     }), surface = drawComponent.surface;
     *
     *     surface.add([{
     *         type: 'circle',
     *         radius: 10,
     *         fill: '#f00',
     *         x: 10,
     *         y: 10,
     *         group: 'circles'
     *     }, {
     *         type: 'circle',
     *         radius: 10,
     *         fill: '#0f0',
     *         x: 50,
     *         y: 50,
     *         group: 'circles'
     *     }, {
     *         type: 'circle',
     *         radius: 10,
     *         fill: '#00f',
     *         x: 100,
     *         y: 100,
     *         group: 'circles'
     *     }, {
     *         type: 'rect',
     *         width: 20,
     *         height: 20,
     *         fill: '#f00',
     *         x: 10,
     *         y: 10,
     *         group: 'rectangles'
     *     }, {
     *         type: 'rect',
     *         width: 20,
     *         height: 20,
     *         fill: '#0f0',
     *         x: 50,
     *         y: 50,
     *         group: 'rectangles'
     *     }, {
     *         type: 'rect',
     *         width: 20,
     *         height: 20,
     *         fill: '#00f',
     *         x: 100,
     *         y: 100,
     *         group: 'rectangles'
     *     }]);
     *
     *     // Get references to my groups
     *     circles = surface.getGroup('circles');
     *     rectangles = surface.getGroup('rectangles');
     *
     *     // Animate the circles down
     *     circles.animate({
     *         duration: 1000,
     *         to: {
     *             translate: {
     *                 y: 200
     *             }
     *         }
     *     });
     *
     *     // Animate the rectangles across
     *     rectangles.animate({
     *         duration: 1000,
     *         to: {
     *             translate: {
     *                 x: 200
     *             }
     *         }
     *     });
     *
     * For more information on Sprites, the core elements added to a draw component's surface,
     * refer to the {@link Ext.draw.Sprite} documentation.
     */
    export class Component extends Ext.Component implements Ext.draw.ComponentConfig {
        /**
         * The Surface instance managed by this component.
         */
        surface: Ext.draw.Surface;

        /**
         * Turn on autoSize support which will set the bounding div's size to the natural size of the contents.
         */
        autoSize: boolean;

        baseCls: string;

        componentLayout: string|any;

        /**
         * Defines the priority order for which Surface implementation to use. The first
         * one supported by the current environment will be used.
         */
        enginePriority: string;

        /**
         * (optional) Define a set of gradients that can be used as 'fill' property in sprites.
         * The gradients array is an array of objects with the following properties:
         *
         *  - 'id' - string - The unique name of the gradient.
         *  - 'angle' - number, optional - The angle of the gradient in degrees.
         *  - 'stops' - object - An object with numbers as keys (from 0 to 100) and style objects as values
         *
         * ## Example
         *
         *     gradients: [{
         *         id: 'gradientId',
         *         angle: 45,
         *         stops: {
         *             0: {
         *                 color: '#555'
         *             },
         *             100: {
         *                 color: '#ddd'
         *             }
         *         }
         *     }, {
         *         id: 'gradientId2',
         *         angle: 0,
         *         stops: {
         *             0: {
         *                 color: '#590'
         *             },
         *             20: {
         *                 color: '#599'
         *             },
         *             100: {
         *                 color: '#ddd'
         *             }
         *         }
         *     }]
         *
         * Then the sprites can use 'gradientId' and 'gradientId2' by setting the fill attributes to those ids, for example:
         *
         *     sprite.setAttributes({
         *         fill: 'url(#gradientId)'
         *     }, true);
         */
        gradients: any;

        /**
         * Array of sprites or sprite config objects to add initially to the surface.
         */
        items: Ext.draw.Sprite;

        shrinkWrap: boolean|number;

        /**
         * Turn on view box support which will scale and position items in the draw component to fit to the component while
         * maintaining aspect ratio. Note that this scaling can override other sizing settings on your items.
         */
        viewBox: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Event forwarded from {@link Ext.draw.Surface surface}.
         */
        click();

        /**
         * Event forwarded from {@link Ext.draw.Surface surface}.
         */
        dblclick();

        /**
         * Event forwarded from {@link Ext.draw.Surface surface}.
         */
        mousedown();

        /**
         * Event forwarded from {@link Ext.draw.Surface surface}.
         */
        mouseenter();

        /**
         * Event forwarded from {@link Ext.draw.Surface surface}.
         */
        mouseleave();

        /**
         * Event forwarded from {@link Ext.draw.Surface surface}.
         */
        mousemove();

        /**
         * Event forwarded from {@link Ext.draw.Surface surface}.
         */
        mouseup();
    }

    /**
     * A composite Sprite handles a group of sprites with common methods to a sprite
     * such as 'hide', 'show', 'setAttributes'. These methods are applied to the set of sprites
     * added to the group.
     *
     * CompositeSprite extends {@link Ext.util.MixedCollection} so you can use the same methods
     * in 'MixedCollection' to iterate through sprites, add and remove elements, etc.
     *
     * In order to create a CompositeSprite, one has to provide a handle to the surface where it is
     * rendered:
     *
     *     var group = Ext.create('Ext.draw.CompositeSprite', {
     *         surface: drawComponent.surface
     *     });
     *
     * Then just by using 'MixedCollection' methods it's possible to add {@link Ext.draw.Sprite}s:
     *
     *     group.add(sprite1);
     *     group.add(sprite2);
     *     group.add(sprite3);
     *
     * And then apply common Sprite methods to them:
     *
     *     group.setAttributes({
     *         fill: '#f00'
     *     }, true);
     */
    export class CompositeSprite extends Ext.util.MixedCollection {
        /**
         * Adds class to all sprites.
         * @param {String} cls CSS class name
         */
        addCls(cls: string);

        constructor(config: any);

        /**
         * Destroys this CompositeSprite.
         */
        destroy();

        /**
         * Returns the group bounding box.
         * Behaves like {@link Ext.draw.Sprite#getBBox} method.
         * @return {Object} an object with x, y, width, and height properties.
         */
        getBBox(): any;

        /**
         * Hides all sprites. If 'true' is passed then a redraw will be forced for each sprite.
         * @param {Boolean} redraw Flag to immediately draw the change.
         * @return {Ext.draw.CompositeSprite} this
         */
        hide(redraw: boolean): Ext.draw.CompositeSprite;

        /**
         * Force redraw of all sprites.
         */
        redraw();

        /**
         * Removes class from all sprites.
         * @param {String} cls CSS class name
         */
        removeCls(cls: string);

        /**
         * Iterates through all sprites calling 'setAttributes' on each one. For more information {@link Ext.draw.Sprite}
         * provides a description of the attributes that can be set with this method.
         * @param {Object} attrs Attributes to be changed on the sprite.
         * @param {Boolean} redraw Flag to immediately draw the change.
         * @return {Ext.draw.CompositeSprite} this
         */
        setAttributes(attrs: any, redraw: boolean): Ext.draw.CompositeSprite;

        /**
         * Sets style for all sprites.
         * @param {String} style CSS Style definition.
         */
        setStyle(style: string);

        /**
         * Shows all sprites. If 'true' is passed then a redraw will be forced for each sprite.
         * @param {Boolean} redraw Flag to immediately draw the change.
         * @return {Ext.draw.CompositeSprite} this
         */
        show(redraw: boolean): Ext.draw.CompositeSprite;

        click();

        mousedown();

        mouseout();

        mouseover();

        mouseup();
    }

    /**
     * Base Drawing class.  Provides base drawing functions.
     */
    export class Draw {
        /**
         * snapEndsByDate is a utility method to deduce an appropriate tick configuration for the data set of given
         * feature. Refer to {@link #snapEnds}.
         *
         * @param {Date} from The minimum value in the data
         * @param {Date} to The maximum value in the data
         * @param {Number} stepsMax The maximum number of ticks
         * @param {Boolean} lockEnds If true, the 'from' and 'to' parameters will be used as fixed end values and will not be adjusted
         *
         * @return {Object} The calculated step and ends info; properties are:
         * - from: The result start value, which may be lower than the original start value
         * - to: The result end value, which may be higher than the original end value
         * - step: The fixed value size of each step, or undefined if the steps are not fixed.
         * - steps: The number of steps if the steps are fixed, or an array of step values.
         
         * NOTE: Even when the steps have a fixed value, they may not divide the from/to range perfectly evenly;
         * there may be a smaller distance between the last step and the end value than between prior
         * steps, particularly when the 'endsLocked' param is true. Therefore it is best to not use
         * the 'steps' result when finding the axis tick points, instead use the 'step', 'to', and
         * 'from' to find the correct point for each tick.
         */
        static snapEndsByDate(from: Date, to: Date, stepsMax: number, lockEnds: boolean): any;

        /**
         * snapEndsByDateAndStep is a utility method to deduce an appropriate tick configuration for the data set of given
         * feature and specific step size.
         *
         * @param {Date} from The minimum value in the data
         * @param {Date} to The maximum value in the data
         * @param {Array} step An array with two components: The first is the unit of the step (day, month, year, etc).
         * The second is the number of units for the step (1, 2, etc.).
         * If the number is an integer, it represents the number of units for the step ([Ext.Date.DAY, 2] means "Every other day").
         * If the number is a fraction, it represents the number of steps per unit ([Ext.Date.DAY, 1/2] means "Twice a day").
         * If the unit is the month, the steps may be adjusted depending on the month. For instance [Ext.Date.MONTH, 1/3], which means "Three times a month",
         * generates steps on the 1st, the 10th and the 20th of every month regardless of whether a month has 28 days or 31 days. The steps are generated
         * as follows:
         * - [Ext.Date.MONTH, n]: on the current date every 'n' months, maxed to the number of days in the month.
         * - [Ext.Date.MONTH, 1/2]: on the 1st and 15th of every month.
         * - [Ext.Date.MONTH, 1/3]: on the 1st, 10th and 20th of every month.
         * - [Ext.Date.MONTH, 1/4]: on the 1st, 8th, 15th and 22nd of every month.
         * @param {Boolean} lockEnds If true, the 'from' and 'to' parameters will be used as fixed end values
         *        and will not be adjusted
         *
         * @return {Object} The calculated step and ends info; properties are:
         * - from: The result start value, which may be lower than the original start value
         * - to: The result end value, which may be higher than the original end value
         * - step: The fixed value size of each step, or undefined if the steps are not fixed.
         * - steps: The number of steps if the steps are fixed, or an array of step values.
         
         * NOTE: Even when the steps have a fixed value, they may not divide the from/to range perfectly evenly;
         * there may be a smaller distance between the last step and the end value than between prior
         * steps, particularly when the 'endsLocked' param is true. Therefore it is best to not use
         * the 'steps' result when finding the axis tick points, instead use the 'step', 'to', and
         * 'from' to find the correct point for each tick.
         */
        static snapEndsByDateAndStep(from: Date, to: Date, step: any[], lockEnds: boolean): any;
    }

    export class Matrix extends Ext.Base {
        constructor();
    }

    interface SpriteConfig {
        /**
         * True to make the sprite draggable.
         */
        draggable?: boolean;

        /**
         * The fill color.
         */
        fill?: string;

        /**
         * Used with text type sprites. The full font description.
         * Uses the same syntax as the CSS font parameter
         */
        font?: string;

        /**
         * The group that this sprite belongs to, or an array of groups.
         * Only relevant when added to a {@link Ext.draw.Surface Surface}.
         */
        group?: string;

        /**
         * The height of the rect or image sprite.
         */
        height?: number;

        /**
         * The opacity of the sprite. A number between 0 and 1.
         */
        opacity?: number;

        /**
         * The path of the path sprite written in SVG-like path syntax.
         */
        path?: string;

        /**
         * The radius of the circle sprite. Or in case of rect sprite, the border radius.
         */
        radius?: number;

        /**
         * The radius of the ellipse sprite along x-axis.
         */
        radiusX?: number;

        /**
         * The radius of the ellipse sprite along y-axis.
         */
        radiusY?: number;

        /**
         * Path to the image to show in image sprites.
         */
        src?: string;

        /**
         * The stroke color.
         */
        stroke?: string;

        /**
         * The width of the stroke.
         *
         * Note that this attribute needs to be quoted when used.  Like so:
         *
         *     "stroke-width": 12,
         */
        'stroke-width'?: number;

        /**
         * The actual text to render in text sprites.
         */
        text?: string;

        /**
         * The type of the sprite.
         * Possible options are 'circle', 'ellipse', 'path', 'rect', 'text', 'image'.
         *
         * See {@link Ext.draw.Sprite} class documentation for examples of all types.
         */
        type?: string;

        /**
         * The width of the rect or image sprite.
         */
        width?: number;

        /**
         * Sprite position along the x-axis.
         */
        x?: number;

        /**
         * Sprite position along the y-axis.
         */
        y?: number;
    }

    /**
     * A Sprite is an object rendered in a Drawing surface.
     *
     * ## Types
     *
     * The following sprite types are supported:
     *
     * ### Rect
     *
     * Rectangle requires 'width' and 'height' attributes:
     *
     *     @example
     *     Ext.create('Ext.draw.Component', {
     *         renderTo: Ext.getBody(),
     *         width: 200,
     *         height: 200,
     *         items: [{
     *             type: 'rect',
     *             width: 100,
     *             height: 50,
     *             radius: 10,
     *             fill: 'green',
     *             opacity: 0.5,
     *             stroke: 'red',
     *             'stroke-width': 2
     *         }]
     *     });
     *
     * ### Circle
     *
     * Circle requires 'x', 'y' and 'radius' attributes:
     *
     *     @example
     *     Ext.create('Ext.draw.Component', {
     *         renderTo: Ext.getBody(),
     *         width: 200,
     *         height: 200,
     *         items: [{
     *             type: 'circle',
     *             radius: 90,
     *             x: 100,
     *             y: 100,
     *             fill: 'blue'
     *         }]
     *     });
     *
     * ### Ellipse
     *
     * Ellipse requires 'x', 'y', 'radiusX' and 'radiusY' attributes:
     *
     *     @example
     *     Ext.create('Ext.draw.Component', {
     *         renderTo: Ext.getBody(),
     *         width: 200,
     *         height: 200,
     *         items: [{
     *             type: "ellipse",
     *             radiusX: 100,
     *             radiusY: 50,
     *             x: 100,
     *             y: 100,
     *             fill: 'red'
     *         }]
     *     });
     *
     * ### Path
     *
     * Path requires the 'path' attribute:
     *
     *     @example
     *     Ext.create('Ext.draw.Component', {
     *         renderTo: Ext.getBody(),
     *         width: 200,
     *         height: 200,
     *         items: [{
     *             type: "path",
     *             path: "M-66.6 26C-66.6 26 -75 22 -78.2 18.4C-81.4 14.8 -80.948 19.966 " +
     *                   "-85.8 19.6C-91.647 19.159 -90.6 3.2 -90.6 3.2L-94.6 10.8C-94.6 " +
     *                   "10.8 -95.8 25.2 -87.8 22.8C-83.893 21.628 -82.6 23.2 -84.2 " +
     *                   "24C-85.8 24.8 -78.6 25.2 -81.4 26.8C-84.2 28.4 -69.8 23.2 -72.2 " +
     *                   "33.6L-66.6 26z",
     *             fill: "purple"
     *         }]
     *     });
     *
     * ### Text
     *
     * Text requires the 'text' attribute:
     *
     *     @example
     *     Ext.create('Ext.draw.Component', {
     *         renderTo: Ext.getBody(),
     *         width: 200,
     *         height: 200,
     *         items: [{
     *             type: "text",
     *             text: "Hello, Sprite!",
     *             fill: "green",
     *             font: "18px monospace"
     *         }]
     *     });
     *
     * ### Image
     *
     * Image requires 'width', 'height' and 'src' attributes:
     *
     *     @example
     *     Ext.create('Ext.draw.Component', {
     *         renderTo: Ext.getBody(),
     *         width: 200,
     *         height: 200,
     *         items: [{
     *             type: "image",
     *             src: "http://www.sencha.com/img/apple-touch-icon.png",
     *             width: 200,
     *             height: 200
     *         }]
     *     });
     *
     * ## Creating and adding a Sprite to a Surface
     *
     * See {@link Ext.draw.Surface} documentation.
     *
     * ## Transforming sprites
     *
     * See {@link #setAttributes} method documentation for examples on how to translate, scale and rotate the sprites.
     */
    export class Sprite extends Ext.Base implements Ext.draw.SpriteConfig {
        /**
         * If this Sprite is configured {@link #draggable}, this property will contain
         * an instance of {@link Ext.dd.DragSource} which handles dragging the Sprite.
         *
         * The developer must provide implementations of the abstract methods of {@link Ext.dd.DragSource}
         * in order to supply behaviour for each stage of the drag/drop process. See {@link #draggable}.
         */
        dd: Ext.dd.DragSource;

        /**
         * 'true' in this class to identify an object as an instantiated Sprite, or subclass thereof.
         */
        isSprite: boolean;

        /**
         * True to make the sprite draggable.
         */
        draggable: boolean;

        /**
         * The fill color.
         */
        fill: string;

        /**
         * Used with text type sprites. The full font description.
         * Uses the same syntax as the CSS font parameter
         */
        font: string;

        /**
         * The group that this sprite belongs to, or an array of groups.
         * Only relevant when added to a {@link Ext.draw.Surface Surface}.
         */
        group: string;

        /**
         * The height of the rect or image sprite.
         */
        height: number;

        /**
         * The opacity of the sprite. A number between 0 and 1.
         */
        opacity: number;

        /**
         * The path of the path sprite written in SVG-like path syntax.
         */
        path: string;

        /**
         * The radius of the circle sprite. Or in case of rect sprite, the border radius.
         */
        radius: number;

        /**
         * The radius of the ellipse sprite along x-axis.
         */
        radiusX: number;

        /**
         * The radius of the ellipse sprite along y-axis.
         */
        radiusY: number;

        /**
         * Path to the image to show in image sprites.
         */
        src: string;

        /**
         * The stroke color.
         */
        stroke: string;

        /**
         * The width of the stroke.
         *
         * Note that this attribute needs to be quoted when used.  Like so:
         *
         *     "stroke-width": 12,
         */
        'stroke-width': number;

        /**
         * The actual text to render in text sprites.
         */
        text: string;

        /**
         * The type of the sprite.
         * Possible options are 'circle', 'ellipse', 'path', 'rect', 'text', 'image'.
         *
         * See {@link Ext.draw.Sprite} class documentation for examples of all types.
         */
        type: string;

        /**
         * The width of the rect or image sprite.
         */
        width: number;

        /**
         * Sprite position along the x-axis.
         */
        x: number;

        /**
         * Sprite position along the y-axis.
         */
        y: number;

        /**
         * Adds one or more CSS classes to the element. Duplicate classes are automatically filtered out.  Note this method
         * is severly limited in VML.
         * @param {String/String[]} className The CSS class to add, or an array of classes
         * @return {Ext.draw.Sprite} this
         */
        addCls(className: string): Ext.draw.Sprite;

        constructor(config: Ext.draw.SpriteConfig);

        /**
         * Removes the sprite and clears all listeners.
         */
        destroy();

        /**
         * Retrieves the bounding box of the sprite.
         * This will be returned as an object with x, y, width, and height properties.
         * @return {Object} bbox
         */
        getBBox(): any;

        /**
         * Hides the sprite.
         * @param {Boolean} redraw Flag to immediately draw the change.
         * @return {Ext.draw.Sprite} this
         */
        hide(redraw: boolean): Ext.draw.Sprite;

        /**
         * Redraws the sprite.
         * @return {Ext.draw.Sprite} this
         */
        redraw(): Ext.draw.Sprite;

        /**
         * Removes the sprite.
         * @return {Boolean} True if sprite was successfully removed.
         * False when there was no surface to remove it from.
         */
        remove(): boolean;

        /**
         * Removes one or more CSS classes from the element.
         * @param {String/String[]} className The CSS class to remove, or an array of classes.  Note this method
         * is severly limited in VML.
         * @return {Ext.draw.Sprite} this
         */
        removeCls(className: string): Ext.draw.Sprite;

        /**
         * Change the attributes of the sprite.
         *
         * ## Translation
         *
         * For translate, the configuration object contains x and y attributes that indicate where to
         * translate the object. For example:
         *
         *     sprite.setAttributes({
         *       translate: {
         *        x: 10,
         *        y: 10
         *       }
         *     }, true);
         *
         *
         * ## Rotation
         *
         * For rotation, the configuration object contains x and y attributes for the center of the rotation (which are optional),
         * and a 'degrees' attribute that specifies the rotation in degrees. For example:
         *
         *     sprite.setAttributes({
         *       rotate: {
         *        degrees: 90
         *       }
         *     }, true);
         *
         * That example will create a 90 degrees rotation using the centroid of the Sprite as center of rotation, whereas:
         *
         *     sprite.setAttributes({
         *       rotate: {
         *        x: 0,
         *        y: 0,
         *        degrees: 90
         *       }
         *     }, true);
         *
         * will create a rotation around the '(0, 0)' axis.
         *
         *
         * ## Scaling
         *
         * For scaling, the configuration object contains x and y attributes for the x-axis and y-axis scaling. For example:
         *
         *     sprite.setAttributes({
         *       scale: {
         *        x: 10,
         *        y: 3
         *       }
         *     }, true);
         *
         * You can also specify the center of scaling by adding 'cx' and 'cy' as properties:
         *
         *     sprite.setAttributes({
         *       scale: {
         *        cx: 0,
         *        cy: 0,
         *        x: 10,
         *        y: 3
         *       }
         *     }, true);
         *
         * That last example will scale a sprite taking as centers of scaling the '(0, 0)' coordinate.
         *
         * @param {Object} attrs attributes to be changed on the sprite.
         * @param {Boolean} redraw Flag to immediately draw the change.
         * @return {Ext.draw.Sprite} this
         */
        setAttributes(attrs: any, redraw: boolean): Ext.draw.Sprite;

        /**
         * Wrapper for setting style properties, also takes single object parameter of multiple styles.
         * @param {String/Object} property The style property to be set, or an object of multiple styles.
         * @param {String} value (optional) The value to apply to the given property, or null if an object was passed.
         * @return {Ext.draw.Sprite} this
         */
        setStyle(property: string|any, value: string): Ext.draw.Sprite;

        /**
         * Shows the sprite.
         * @param {Boolean} redraw Flag to immediately draw the change.
         * @return {Ext.draw.Sprite} this
         */
        show(redraw: boolean): Ext.draw.Sprite;

        /**
         * Fires before the sprite is destroyed. Return false from an event handler to stop the destroy.
         */
        beforedestroy(that: Ext.draw.Sprite);

        click();

        mousedown();

        mousemove();

        mouseout();

        mouseover();

        mouseup();

        /**
         * Fires after the sprite markup is rendered.
         */
        render(that: Ext.draw.Sprite);
    }

    /**
     * DD implementation for Panels.
     */
    export class SpriteDD extends Ext.dd.DragSource {
        constructor(sprite: any, cfg: any);

        createFrame();
    }

    interface SurfaceConfig {
        /**
         * The height of this component in pixels (defaults to auto).
         */
        height?: number;

        /**
         * Array of sprites or sprite config objects to add initially to the surface.
         */
        items?: Ext.draw.Sprite;

        /**
         * The width of this component in pixels (defaults to auto).
         */
        width?: number;
    }

    /**
     * A Surface is an interface to render methods inside {@link Ext.draw.Component}.
     *
     * Most of the Surface methods are abstract and they have a concrete implementation
     * in {@link Ext.draw.engine.Vml VML} or {@link Ext.draw.engine.Svg SVG} engines.
     *
     * A Surface contains methods to render {@link Ext.draw.Sprite sprites}, get bounding
     * boxes of sprites, add sprites to the canvas, initialize other graphic components, etc.
     *
     * ## Adding sprites to surface
     *
     * One of the most used methods for this class is the {@link #add} method, to add Sprites to
     * the surface. For example:
     *
     *     drawComponent.surface.add({
     *         type: 'circle',
     *         fill: '#ffc',
     *         radius: 100,
     *         x: 100,
     *         y: 100
     *     });
     *
     * The configuration object passed in the 'add' method is the same as described in the
     * {@link Ext.draw.Sprite} class documentation.
     *
     * Sprites can also be added to surface by setting their surface config at creation time:
     *
     *     var sprite = Ext.create('Ext.draw.Sprite', {
     *         type: 'circle',
     *         fill: '#ff0',
     *         surface: drawComponent.surface,
     *         radius: 5
     *     });
     *
     * In order to properly apply properties and render the sprite we have to
     * 'show' the sprite setting the option 'redraw' to 'true':
     *
     *     sprite.show(true);
     */
    export class Surface extends Ext.Base implements Ext.draw.SurfaceConfig {
        /**
         * The height of this component in pixels (defaults to auto).
         */
        height: number;

        /**
         * Array of sprites or sprite config objects to add initially to the surface.
         */
        items: Ext.draw.Sprite;

        /**
         * The width of this component in pixels (defaults to auto).
         */
        width: number;

        /**
         * Adds a Sprite to the surface. See {@link Ext.draw.Sprite} for the configuration object to be
         * passed into this method.
         *
         * For example:
         *
         *     drawComponent.surface.add({
         *         type: 'circle',
         *         fill: '#ffc',
         *         radius: 100,
         *         x: 100,
         *         y: 100
         *     });
         *
         * @param {Ext.draw.Sprite[]/Ext.draw.Sprite...} args One or more Sprite objects or configs.
         * @return {Ext.draw.Sprite[]/Ext.draw.Sprite} The sprites added.
         */
        add(args: Ext.draw.Sprite[]): Ext.draw.Sprite;

        /**
         * Adds one or more CSS classes to the element. Duplicate classes are automatically filtered out.
         *
         * For example:
         *
         *     drawComponent.surface.addCls(sprite, 'x-visible');
         *
         * @param {Object} sprite The sprite to add the class to.
         * @param {String/String[]} className The CSS class to add, or an array of classes
         */
        addCls(sprite: any, className: string);

        /**
         * Adds a gradient definition to the Surface. Note that in some surface engines, adding
         * a gradient via this method will not take effect if the surface has already been rendered.
         * Therefore, it is preferred to pass the gradients as an item to the surface config, rather
         * than calling this method, especially if the surface is rendered immediately (e.g. due to
         * 'renderTo' in its config). For more information on how to create gradients in the Chart
         * configuration object please refer to {@link Ext.chart.Chart}.
         *
         * The gradient object to be passed into this method is composed by:
         *
         * - **id** - string - The unique name of the gradient.
         * - **angle** - number, optional - The angle of the gradient in degrees.
         * - **stops** - object - An object with numbers as keys (from 0 to 100) and style objects as values.
         *
         * For example:
         *
         *    drawComponent.surface.addGradient({
         *        id: 'gradientId',
         *        angle: 45,
         *        stops: {
         *            0: {
         *                color: '#555'
         *            },
         *            100: {
         *                color: '#ddd'
         *            }
         *        }
         *    });
         *
         * @param {Object} gradient A gradient config.
         */
        addGradient(gradient: any);

        /**
         * Creates new Surface.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.draw.SurfaceConfig);

        /**
         * Destroys the surface. This is done by removing all components from it and
         * also removing its reference to a DOM element.
         *
         * For example:
         *
         *      drawComponent.surface.destroy();
         */
        destroy();

        /**
         * Returns a new group or an existent group associated with the current surface.
         * The group returned is a {@link Ext.draw.CompositeSprite} group.
         *
         * For example:
         *
         *     var spriteGroup = drawComponent.surface.getGroup('someGroupId');
         *
         * @param {String} id The unique identifier of the group.
         * @return {Object} The {@link Ext.draw.CompositeSprite}.
         */
        getGroup(id: string): any;

        /**
         * Retrieves the id of this component.
         * Will autogenerate an id if one has not already been set.
         */
        getId();

        /**
         * Removes a given sprite from the surface, optionally destroying the sprite in the process.
         * You can also call the sprite own 'remove' method.
         *
         * For example:
         *
         *     drawComponent.surface.remove(sprite);
         *     //or...
         *     sprite.remove();
         */
        remove(sprite: Ext.draw.Sprite, destroySprite: boolean);

        /**
         * Removes all sprites from the surface, optionally destroying the sprites in the process.
         *
         * For example:
         *
         *     drawComponent.surface.removeAll();
         *
         * @param {Boolean} destroySprites Whether to destroy all sprites when removing them.
         */
        removeAll(destroySprites: boolean);

        /**
         * Removes one or more CSS classes from the element.
         *
         * For example:
         *
         *     drawComponent.surface.removeCls(sprite, 'x-visible');
         *
         * @param {Object} sprite The sprite to remove the class from.
         * @param {String/String[]} className The CSS class to remove, or an array of classes
         */
        removeCls(sprite: any, className: string);

        /**
         * Sets the size of the surface. Accomodates the background (if any) to fit the new size too.
         *
         * For example:
         *
         *     drawComponent.surface.setSize(500, 500);
         *
         * This method is generally called when also setting the size of the draw Component.
         *
         * @param {Number} w The new width of the canvas.
         * @param {Number} h The new height of the canvas.
         */
        setSize(w: number, h: number);

        /**
         * Sets CSS style attributes to an element.
         *
         * For example:
         *
         *     drawComponent.surface.setStyle(sprite, {
         *         'cursor': 'pointer'
         *     });
         *
         * @param {Object} sprite The sprite to add, or an array of classes to
         * @param {Object} styles An Object with CSS styles.
         */
        setStyle(sprite: any, styles: any);

        /**
         * Changes the text in the sprite element. The sprite must be a 'text' sprite.
         * This method can also be called from {@link Ext.draw.Sprite}.
         *
         * For example:
         *
         *     var spriteGroup = drawComponent.surface.setText(sprite, 'my new text');
         *
         * @param {Object} sprite The Sprite to change the text.
         * @param {String} text The new text to be set.
         */
        setText(sprite: any, text: string);

        /**
         * Fires when a click is detected within the surface.
         * @param {Ext.EventObject} e An object encapsulating the DOM event.
         */
        click(e: Ext.EventObject);

        /**
         * Fires when a dblclick is detected within the surface.
         * @param {Ext.EventObject} e An object encapsulating the DOM event.
         */
        dblclick(e: Ext.EventObject);

        /**
         * Fires when a mousedown is detected within the surface.
         * @param {Ext.EventObject} e An object encapsulating the DOM event.
         */
        mousedown(e: Ext.EventObject);

        /**
         * Fires when a mouseenter is detected within the surface.
         * @param {Ext.EventObject} e An object encapsulating the DOM event.
         */
        mouseenter(e: Ext.EventObject);

        /**
         * Fires when a mouseleave is detected within the surface.
         * @param {Ext.EventObject} e An object encapsulating the DOM event.
         */
        mouseleave(e: Ext.EventObject);

        /**
         * Fires when a mousemove is detected within the surface.
         * @param {Ext.EventObject} e An object encapsulating the DOM event.
         */
        mousemove(e: Ext.EventObject);

        /**
         * Fires when a mouseout is detected within the surface.
         * @param {Ext.EventObject} e An object encapsulating the DOM event.
         */
        mouseout(e: Ext.EventObject);

        /**
         * Fires when a mouseover is detected within the surface.
         * @param {Ext.EventObject} e An object encapsulating the DOM event.
         */
        mouseover(e: Ext.EventObject);

        /**
         * Fires when a mouseup is detected within the surface.
         * @param {Ext.EventObject} e An object encapsulating the DOM event.
         */
        mouseup(e: Ext.EventObject);

        /**
         * Exports a {@link Ext.draw.Surface surface} in a different format.
         * The surface may be exported to an SVG string, using the
         * {@link Ext.draw.engine.SvgExporter}. It may also be exported
         * as an image using the {@link Ext.draw.engine.ImageExporter ImageExporter}.
         * Note that this requires sending data to a remote server to process
         * the SVG into an image, see the {@link Ext.draw.engine.ImageExporter} for
         * more details.
         * @param {Ext.draw.Surface} surface The surface to export.
         * @param {Object} [config] The configuration to be passed to the exporter.
         * See the export method for the appropriate exporter for the relevant
         * configuration options
         * @return {Object} See the return types for the appropriate exporter
         */
        static save(surface: Ext.draw.Surface, config?: Ext.draw.SurfaceConfig): any;
    }

    interface TextConfig extends Ext.draw.ComponentConfig {
        autoSize?: any;

        baseCls?: any;

        /**
         * The angle by which to initially rotate the text clockwise. Defaults to zero.
         */
        degrees?: number;

        /**
         * A CSS selector string which matches a style rule in the document stylesheet from which
         * the text's font properties are read.
         *
         * **Drawn** text is not styled by CSS, but by properties set during its construction, so these styles
         * must be programatically read from a stylesheet rule found via a selector at construction time.
         */
        styleSelector?: string;

        /**
         * The text to display (html tags are <b>not</b> accepted)
         */
        text?: string;

        viewBox?: any;
    }

    export class Text extends Ext.draw.Component implements Ext.draw.TextConfig {
        autoSize: boolean;

        baseCls: string;

        /**
         * The angle by which to initially rotate the text clockwise. Defaults to zero.
         */
        degrees: number;

        /**
         * A CSS selector string which matches a style rule in the document stylesheet from which
         * the text's font properties are read.
         *
         * **Drawn** text is not styled by CSS, but by properties set during its construction, so these styles
         * must be programatically read from a stylesheet rule found via a selector at construction time.
         */
        styleSelector: string;

        /**
         * The text to display (html tags are <b>not</b> accepted)
         */
        text: string;

        viewBox: boolean;

        /**
         * This class encapsulates a drawn text item as rendered by the Ext.draw package within a Component which can be
         * then used anywhere in an ExtJS application just like any other Component.
         *
         * ## Example usage
         *
         *     @example
         *     Ext.create('Ext.panel.Panel', {
         *         title: 'Panel with VerticalTextItem',
         *         width: 300,
         *         height: 200,
         *         lbar: {
         *             layout: {
         *                 align: 'center'
         *             },
         *             items: [{
         *                 xtype: 'text',
         *                 text: 'Sample VerticalTextItem',
         *                 degrees: 90
         *             }]
         *         },
         *         renderTo: Ext.getBody()
         *     });
         *
         * @constructor
         * Creates a new Text Component
         * @param {Object} text A config object containing a 'text' property, a 'degrees' property,
         * and, optionally, a 'styleSelector' property which specifies a selector which provides CSS rules to
         * give font family, size and color to the drawn text.
         */
        constructor(text: any);

        protected initComponent();

        /**
         * Sets the clockwise rotation angle relative to the horizontal axis.
         * @param {Number} degrees The clockwise angle (in degrees) from the horizontal axis
         * by which the text should be rotated.
         */
        setAngle(degrees: number);

        /**
         * Updates this item's text.
         * @param {String} t The text to display (html **not** accepted).
         */
        setText(t: string);
    }
}

declare module Ext.draw.engine {
    /**
     * Exports a {@link Ext.draw.Surface Surface} to an image. To do this,
     * the svg string must be sent to a remote server and processed.
     *
     * # Sending the data
     *
     * A post request is made to the URL. The following fields are sent:
     *
     * + width: The width of the image
     * + height: The height of the image
     * + type: The image type to save as, see {@link #supportedTypes}
     * + svg: The svg string for the surface
     *
     * # The response
     *
     * It is expected that the user will be prompted with an image download.
     * As such, the following options should be set on the server:
     *
     * + Content-Disposition: 'attachment, filename="chart.png"'
     * + Content-Type: 'image/png'
     *
     * **Important**: By default, chart data is sent to a server operated
     * by Sencha to do data processing. You may change this default by
     * setting the {@link #defaultUrl} of this class.
     * In addition, please note that this service only creates PNG images.
     */
    export class ImageExporter {
        /**
         * The default URL to submit the form request.
         *
         * Optional, Defaults to: "http://svg.sencha.io"
         */
        static defaultUrl: string;

        /**
         * The name of the height parameter to be sent to the server.
         * The Sencha IO server expects it to be the default value.
         *
         * Optional, Defaults to: "height"
         */
        static heightParam: string;

        /**
         * A list of export types supported by the server
         *
         * Optional, Defaults to: ["image/png", "image/jpeg"
         */
        static supportedTypes: any[];

        /**
         * The name of the svg parameter to be sent to the server.
         * The Sencha IO server expects it to be the default value.
         *
         * Optional, Defaults to: "svg"
         */
        static svgParam: string;

        /**
         * The name of the type parameter to be sent to the server.
         * The Sencha IO server expects it to be the default value.
         *
         * Optional, Defaults to: "type"
         */
        static typeParam: string;

        /**
         * The name of the width parameter to be sent to the server.
         * The Sencha IO server expects it to be the default value.
         *
         * Optional, Defaults to: "width"
         */
        static widthParam: string;

        /**
         * Exports the surface to an image
         * @param {Ext.draw.Surface} surface The surface to export
         * @param {Object} [config] The following config options are supported:
         *
         * @param {Number} config.width A width to send to the server to for
         * configuring the image height
         *
         * @param {Number} config.height A height to send to the server for
         * configuring the image height
         *
         * @param {String} config.url The url to post the data to. Defaults to
         * the {@link #defaultUrl} configuration on the class.
         *
         * @param {String} config.type The type of image to export. See the
         * {@link #supportedTypes}
         *
         * @param {String} config.widthParam The name of the width parameter to send
         * to the server. Defaults to {@link #widthParam}
         *
         * @param {String} config.heightParam The name of the height parameter to send
         * to the server. Defaults to {@link #heightParam}
         *
         * @param {String} config.typeParam The name of the type parameter to send
         * to the server. Defaults to {@link #typeParam}
         *
         * @param {String} config.svgParam The name of the svg parameter to send
         * to the server. Defaults to {@link #svgParam}
         *
         * @return {Boolean} True if the surface was successfully sent to the server.
         */
        static generate(surface: Ext.draw.Surface, config?: any, config_width?: number, config_height?: number, config_url?: string, config_type?: string, config_widthParam?: string, config_heightParam?: string, config_typeParam?: string, config_svgParam?: string): boolean;
    }

    /**
     * Provides specific methods to draw with SVG.
     */
    export class Svg extends Ext.draw.Surface {
        addGradient(gradient: any);

        /**
         * Insert or move a given sprite's element to the correct place in the DOM list for its zIndex
         */
        applyZIndex(sprite: Ext.draw.Sprite);

        /**
         * Creates new Surface.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.draw.SurfaceConfig);

        destroy();

        /**
         * Get the region for the surface's canvas area
         * @returns {Ext.util.Region}
         */
        getRegion();

        /**
         * Checks if the specified CSS class exists on this element's DOM node.
         * @param {Ext.draw.Sprite} sprite The sprite to look into.
         * @param {String} className The CSS class to check for
         * @return {Boolean} True if the class exists, else false
         */
        hasCls(sprite: Ext.draw.Sprite, className: string): boolean;
    }

    /**
     * A utility class for exporting a {@link Ext.draw.Surface Surface} to a string
     * that may be saved or used for processing on the server.
     */
    export class SvgExporter {
        /**
         * Exports the passed surface to a SVG string representation
         * @param {Ext.draw.Surface} surface The surface to export
         * @param {Object} [config] Any configuration for the export. Currently this is
         * unused but may provide more options in the future
         * @return {String} The SVG as a string
         */
        static generate(surface: Ext.draw.Surface, config?: any): string;
    }

    /**
     * Provides specific methods to draw with VML.
     */
    export class Vml extends Ext.draw.Surface {
        /**
         * Adds a definition to this Surface for a linear gradient. We convert the gradient definition
         * to its corresponding VML attributes and store it for later use by individual sprites.
         */
        addGradient(gradient: any);

        /**
         * Creates new Surface.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.draw.SurfaceConfig);

        destroy();
    }
}

declare module Ext.enums {
    /**
     * @enum [Ext.enums.Feature=feature.*]
     * Enumeration of all ftypes.
     */
    export class Feature {
        abstractsummary: any;

        feature: any;

        grouping: any;

        groupingsummary: any;

        rowbody: any;

        summary: any;
    }

    /**
     * @enum [Ext.enums.Layout=layout.*]
     * Enumeration of all layout types.
     */
    export class Layout {
        absolute: any;

        accordion: any;

        anchor: any;

        auto: any;

        autocomponent: any;

        autocontainer: any;

        border: any;

        box: any;

        card: any;

        checkboxgroup: any;

        column: any;

        container: any;

        fit: any;

        form: any;

        hbox: any;

        table: any;

        vbox: any;
    }

    /**
     * @enum [Ext.enums.Plugin=plugin.*]
     * Enumeration of all ptypes.
     */
    export class Plugin {
        bufferedrenderer: any;

        cellediting: any;

        gridheaderresizer: any;

        gridviewdragdrop: any;

        rowediting: any;

        rowexpander: any;

        treeviewdragdrop: any;
    }

    /**
     * @enum [Ext.enums.Widget=widget.*]
     * Enumeration of all xtypes.
     */
    export class Widget {
        actioncolumn: any;

        booleancolumn: any;

        boundlist: any;

        box: any;

        button: any;

        buttongroup: any;

        chart: any;

        checkbox: any;

        checkboxfield: any;

        checkboxgroup: any;

        checkcolumn: any;

        colormenu: any;

        colorpicker: any;

        combo: any;

        combobox: any;

        component: any;

        container: any;

        cycle: any;

        dataview: any;

        datecolumn: any;

        datefield: any;

        datemenu: any;

        datepicker: any;

        displayfield: any;

        draw: any;

        editor: any;

        field: any;

        fieldcontainer: any;

        fieldset: any;

        filebutton: any;

        filefield: any;

        fileuploadfield: any;

        flash: any;

        form: any;

        grid: any;

        gridcolumn: any;

        gridpanel: any;

        gridview: any;

        header: any;

        headercontainer: any;

        hidden: any;

        hiddenfield: any;

        htmleditor: any;

        image: any;

        imagecomponent: any;

        jsonpstore: any;

        label: any;

        loadmask: any;

        menu: any;

        menucheckitem: any;

        menuitem: any;

        menuseparator: any;

        messagebox: any;

        multislider: any;

        numbercolumn: any;

        numberfield: any;

        pagingtoolbar: any;

        panel: any;

        pickerfield: any;

        progressbar: any;

        propertygrid: any;

        quicktip: any;

        radio: any;

        radiofield: any;

        radiogroup: any;

        rownumberer: any;

        slider: any;

        sliderfield: any;

        slidertip: any;

        spinnerfield: any;

        splitbutton: any;

        splitter: any;

        tab: any;

        tabbar: any;

        tablepanel: any;

        tableview: any;

        tabpanel: any;

        tbfill: any;

        tbitem: any;

        tbseparator: any;

        tbspacer: any;

        tbtext: any;

        templatecolumn: any;

        text: any;

        textarea: any;

        textareafield: any;

        textfield: any;

        timefield: any;

        timepicker: any;

        tip: any;

        tool: any;

        toolbar: any;

        tooltip: any;

        treepanel: any;

        treeview: any;

        trigger: any;

        triggerfield: any;

        viewport: any;

        window: any;
    }
}

declare module Ext.flash {
    interface ComponentConfig extends Ext.ComponentConfig {
        /**
         * The background color of the SWF movie.
         *
         * Optional, Defaults to: "#ffffff"
         */
        backgroundColor?: string;

        /**
         * True to prompt the user to install flash if not installed. Note that this uses
         * Ext.FlashComponent.EXPRESS_INSTALL_URL, which should be set to the local resource.
         *
         * Optional, Defaults to: false
         */
        expressInstall?: boolean;

        /**
         * A set of key value pairs to be passed to the flash object as attributes.
         */
        flashAttributes?: any;

        /**
         * A set of key value pairs to be passed to the flash object as parameters. Possible parameters can be found here:
         * http://kb2.adobe.com/cps/127/tn_12701.html
         */
        flashParams?: any;

        /**
         * A set of key value pairs to be passed to the flash object as flash variables.
         */
        flashVars?: any;

        /**
         * Indicates the version the flash content was published for.
         *
         * Optional, Defaults to: "9.0.115"
         */
        flashVersion?: string;

        /**
         * The height of the embedded SWF movie inside the component.
         *
         * Defaults to "100%" so that the movie matches the height of the component.
         *
         * Optional, Defaults to: "100%"
         */
        swfHeight?: string|number;

        /**
         * The width of the embedded SWF movie inside the component.
         *
         * Defaults to "100%" so that the movie matches the width of the component.
         *
         * Optional, Defaults to: "100%"
         */
        swfWidth?: string|number;

        /**
         * (required)
         * The URL of the SWF file to include.
         */
        url?: string;

        /**
         * The wmode of the flash object. This can be used to control layering.
         * Set to 'transparent' to ignore the {@link #backgroundColor} and make the background of the Flash
         * movie transparent.
         *
         * Optional, Defaults to: "opaque"
         */
        wmode?: string;
    }

    /**
     * A simple Component for displaying an Adobe Flash SWF movie. The movie will be sized and can participate
     * in layout like any other Component.
     *
     * This component requires the third-party SWFObject library version 2.2 or above. It is not included within
     * the ExtJS distribution, so you will have to include it into your page manually in order to use this component.
     * The SWFObject library can be downloaded from the [SWFObject project page](http://code.google.com/p/swfobject)
     * and then simply import it into the head of your HTML document:
     *
     *     <script type="text/javascript" src="path/to/local/swfobject.js"></script>
     *
     * ## Configuration
     *
     * This component allows several options for configuring how the target Flash movie is embedded. The most
     * important is the required {@link #url} which points to the location of the Flash movie to load. Other
     * configurations include:
     *
     * - {@link #backgroundColor}
     * - {@link #wmode}
     * - {@link #flashVars}
     * - {@link #flashParams}
     * - {@link #flashAttributes}
     *
     * ## Example usage:
     *
     *     var win = Ext.widget('window', {
     *         title: "It's a tiger!",
     *         layout: 'fit',
     *         width: 300,
     *         height: 300,
     *         x: 20,
     *         y: 20,
     *         resizable: true,
     *         items: {
     *             xtype: 'flash',
     *             url: 'tiger.swf'
     *         }
     *     });
     *     win.show();
     *
     * ## Express Install
     *
     * Adobe provides a tool called [Express Install](http://www.adobe.com/devnet/flashplayer/articles/express_install.html)
     * that offers users an easy way to upgrade their Flash player. If you wish to make use of this, you should set
     * the static EXPRESS\_INSTALL\_URL property to the location of your Express Install SWF file:
     *
     *     Ext.flash.Component.EXPRESS_INSTALL_URL = 'path/to/local/expressInstall.swf';
     *
     * @docauthor Jason Johnston <jason@sencha.com>
     */
    export class Component extends Ext.Component implements Ext.flash.ComponentConfig {
        /**
         * A reference to the object or embed element into which the SWF file is loaded. Only
         * populated after the component is rendered and the SWF has been successfully embedded.
         */
        swf: Ext.dom.Element;

        /**
         * The background color of the SWF movie.
         *
         * Optional, Defaults to: "#ffffff"
         */
        backgroundColor: string;

        /**
         * True to prompt the user to install flash if not installed. Note that this uses
         * Ext.FlashComponent.EXPRESS_INSTALL_URL, which should be set to the local resource.
         *
         * Optional, Defaults to: false
         */
        expressInstall: boolean;

        /**
         * A set of key value pairs to be passed to the flash object as attributes.
         */
        flashAttributes: any;

        /**
         * A set of key value pairs to be passed to the flash object as parameters. Possible parameters can be found here:
         * http://kb2.adobe.com/cps/127/tn_12701.html
         */
        flashParams: any;

        /**
         * A set of key value pairs to be passed to the flash object as flash variables.
         */
        flashVars: any;

        /**
         * Indicates the version the flash content was published for.
         *
         * Optional, Defaults to: "9.0.115"
         */
        flashVersion: string;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The height of the embedded SWF movie inside the component.
         *
         * Defaults to "100%" so that the movie matches the height of the component.
         *
         * Optional, Defaults to: "100%"
         */
        swfHeight: string|number;

        /**
         * The width of the embedded SWF movie inside the component.
         *
         * Defaults to "100%" so that the movie matches the width of the component.
         *
         * Optional, Defaults to: "100%"
         */
        swfWidth: string|number;

        /**
         * (required)
         * The URL of the SWF file to include.
         */
        url: string;

        /**
         * The wmode of the flash object. This can be used to control layering.
         * Set to 'transparent' to ignore the {@link #backgroundColor} and make the background of the Flash
         * movie transparent.
         *
         * Optional, Defaults to: "opaque"
         */
        wmode: string;

        protected afterRender();

        protected beforeDestroy();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Retrieves the id of the SWF object/embed element.
         */
        getSwfId();

        protected initComponent();

        /**
         * Fired when the Flash movie embedding fails
         */
        failure(that: Ext.flash.Component);

        /**
         * Fired when the Flash movie has been successfully embedded
         */
        success(that: Ext.flash.Component);

        /**
         * The url for installing flash if it doesn't exist. This should be set to a local resource.
         * See http://www.adobe.com/devnet/flashplayer/articles/express_install.html for details.
         */
        static EXPRESS_INSTALL_URL: any;
    }
}

declare module Ext.form {
    interface BasicConfig extends Ext.util.ObservableConfig {
        /**
         * If specified, load and submit actions will be handled with {@link Ext.form.action.DirectLoad DirectLoad}
         * and {@link Ext.form.action.DirectSubmit DirectSubmit}.  Methods which have been imported by
         * {@link Ext.direct.Manager} can be specified here to load and submit forms. API methods may also be
         * specified as strings. See {@link Ext.data.proxy.Direct#directFn}.  Such as the following:
         *
         *     api: {
         *         load: App.ss.MyProfile.load,
         *         submit: App.ss.MyProfile.submit
         *     }
         *
         * Load actions can use {@link #paramOrder} or {@link #paramsAsHash} to customize how the load method
         * is invoked.  Submit actions will always use a standard form submit. The 'formHandler' configuration
         * (see Ext.direct.RemotingProvider#action) must be set on the associated server-side method which has
         * been imported by {@link Ext.direct.Manager}.
         */
        api?: any;

        /**
         * Parameters to pass with all requests. e.g. baseParams: '{id: '123', foo: 'bar'}'.
         *
         * Parameters are encoded as standard HTTP parameters using {@link Ext.Object#toQueryString}.
         */
        baseParams?: any;

        /**
         * An Ext.data.reader.Reader (e.g. {@link Ext.data.reader.Xml}) instance or
         * configuration to be used to read field error messages returned from 'submit' actions.
         * This is optional as there is built-in support for processing JSON responses.
         *
         * The Records which provide messages for the invalid Fields must use the
         * Field name (or id) as the Record ID, and must contain a field called 'msg'
         * which contains the error message.
         *
         * The errorReader does not have to be a full-blown implementation of a
         * Reader. It simply needs to implement a 'read(xhr)' function
         * which returns an Array of Records in an object with the following
         * structure:
         *
         *     {
         *         records: recordArray
         *     }
         */
        errorReader?: any|Ext.data.reader.Reader;

        /**
         * If set to true, the field values are sent as JSON in the request body.
         * All of the field values, plus any additional params configured via {@link #baseParams}
         * and/or the 'options' to {@link #submit}, will be included in the values POSTed in the body of the request.
         */
        jsonSubmit?: boolean;

        /**
         * The request method to use (GET or POST) for form actions if one isn't supplied in the action options.
         */
        method?: string;

        /**
         * A list of params to be executed server side. Only used for the {@link #api} 'load'
         * configuration.
         *
         * Specify the params in the order in which they must be executed on the
         * server-side as either (1) an Array of String values, or (2) a String of params
         * delimited by either whitespace, comma, or pipe. For example,
         * any of the following would be acceptable:
         *
         *     paramOrder: ['param1','param2','param3']
         *     paramOrder: 'param1 param2 param3'
         *     paramOrder: 'param1,param2,param3'
         *     paramOrder: 'param1|param2|param'
         */
        paramOrder?: string;

        /**
         * Only used for the {@link #api} 'load' configuration. If true, parameters will be sent as a
         * single hash collection of named arguments. Providing a {@link #paramOrder} nullifies this
         * configuration.
         */
        paramsAsHash?: boolean;

        /**
         * An Ext.data.reader.Reader (e.g. {@link Ext.data.reader.Xml}) instance or
         * configuration to be used to read data when executing 'load' actions. This
         * is optional as there is built-in support for processing JSON responses.
         */
        reader?: any|Ext.data.reader.Reader;

        /**
         * If set to true, a standard HTML form submit is used instead of a XHR (Ajax) style form submission.
         * All of the field values, plus any additional params configured via {@link #baseParams}
         * and/or the 'options' to {@link #submit}, will be included in the values submitted in the form.
         */
        standardSubmit?: boolean;

        /**
         * Timeout for form actions in seconds.
         */
        timeout?: number;

        /**
         * If set to true, {@link #reset}() resets to the last loaded or {@link #setValues}() data instead of
         * when the form was first created.
         */
        trackResetOnLoad?: boolean;

        /**
         * The URL to use for form actions if one isn't supplied in the
         * {@link #doAction doAction} options.
         */
        url?: string;

        /**
         * By default wait messages are displayed with Ext.MessageBox.wait. You can target a specific
         * element by passing it or its id or mask the form itself by passing in true.
         */
        waitMsgTarget?: string|HTMLElement|Ext.dom.Element;

        /**
         * The default title to show for the waiting message box
         */
        waitTitle?: string;
    }

    /**
     * Provides input field management, validation, submission, and form loading services for the collection
     * of {@link Ext.form.field.Field Field} instances within a {@link Ext.container.Container}. It is recommended
     * that you use a {@link Ext.form.Panel} as the form container, as that has logic to automatically
     * hook up an instance of {@link Ext.form.Basic} (plus other conveniences related to field configuration.)
     *
     * ## Form Actions
     *
     * The Basic class delegates the handling of form loads and submits to instances of {@link Ext.form.action.Action}.
     * See the various Action implementations for specific details of each one's functionality, as well as the
     * documentation for {@link #doAction} which details the configuration options that can be specified in
     * each action call.
     *
     * The default submit Action is {@link Ext.form.action.Submit}, which uses an Ajax request to submit the
     * form's values to a configured URL. To enable normal browser submission of an Ext form, use the
     * {@link #standardSubmit} config option.
     *
     * ## File uploads
     *
     * File uploads are not performed using normal 'Ajax' techniques; see the description for
     * {@link #hasUpload} for details. If you're using file uploads you should read the method description.
     *
     * ## Example usage:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Basic Form',
     *         renderTo: Ext.getBody(),
     *         bodyPadding: 5,
     *         width: 350,
     *
     *         // Any configuration items here will be automatically passed along to
     *         // the Ext.form.Basic instance when it gets created.
     *
     *         // The form will submit an AJAX request to this URL when submitted
     *         url: 'save-form.php',
     *
     *         items: [{
     *             xtype: 'textfield',
     *             fieldLabel: 'Field',
     *             name: 'theField'
     *         }],
     *
     *         buttons: [{
     *             text: 'Submit',
     *             handler: function() {
     *                 // The getForm() method returns the Ext.form.Basic instance:
     *                 var form = this.up('form').getForm();
     *                 if (form.isValid()) {
     *                     // Submit the Ajax request and handle the response
     *                     form.submit({
     *                         success: function(form, action) {
     *                            Ext.Msg.alert('Success', action.result.message);
     *                         },
     *                         failure: function(form, action) {
     *                             Ext.Msg.alert('Failed', action.result ? action.result.message : 'No response');
     *                         }
     *                     });
     *                 }
     *             }
     *         }]
     *     });
     *
     * @docauthor Jason Johnston <jason@sencha.com>
     */
    export class Basic extends Ext.util.Observable implements Ext.form.BasicConfig {
        /**
         * The container component to which this BasicForm is attached.
         */
        owner: Ext.container.Container;

        /**
         * If specified, load and submit actions will be handled with {@link Ext.form.action.DirectLoad DirectLoad}
         * and {@link Ext.form.action.DirectSubmit DirectSubmit}.  Methods which have been imported by
         * {@link Ext.direct.Manager} can be specified here to load and submit forms. API methods may also be
         * specified as strings. See {@link Ext.data.proxy.Direct#directFn}.  Such as the following:
         *
         *     api: {
         *         load: App.ss.MyProfile.load,
         *         submit: App.ss.MyProfile.submit
         *     }
         *
         * Load actions can use {@link #paramOrder} or {@link #paramsAsHash} to customize how the load method
         * is invoked.  Submit actions will always use a standard form submit. The 'formHandler' configuration
         * (see Ext.direct.RemotingProvider#action) must be set on the associated server-side method which has
         * been imported by {@link Ext.direct.Manager}.
         */
        api: any;

        /**
         * Parameters to pass with all requests. e.g. baseParams: '{id: '123', foo: 'bar'}'.
         *
         * Parameters are encoded as standard HTTP parameters using {@link Ext.Object#toQueryString}.
         */
        baseParams: any;

        /**
         * An Ext.data.reader.Reader (e.g. {@link Ext.data.reader.Xml}) instance or
         * configuration to be used to read field error messages returned from 'submit' actions.
         * This is optional as there is built-in support for processing JSON responses.
         *
         * The Records which provide messages for the invalid Fields must use the
         * Field name (or id) as the Record ID, and must contain a field called 'msg'
         * which contains the error message.
         *
         * The errorReader does not have to be a full-blown implementation of a
         * Reader. It simply needs to implement a 'read(xhr)' function
         * which returns an Array of Records in an object with the following
         * structure:
         *
         *     {
         *         records: recordArray
         *     }
         */
        errorReader: any|Ext.data.reader.Reader;

        /**
         * If set to true, the field values are sent as JSON in the request body.
         * All of the field values, plus any additional params configured via {@link #baseParams}
         * and/or the 'options' to {@link #submit}, will be included in the values POSTed in the body of the request.
         */
        jsonSubmit: boolean;

        /**
         * The request method to use (GET or POST) for form actions if one isn't supplied in the action options.
         */
        method: string;

        /**
         * A list of params to be executed server side. Only used for the {@link #api} 'load'
         * configuration.
         *
         * Specify the params in the order in which they must be executed on the
         * server-side as either (1) an Array of String values, or (2) a String of params
         * delimited by either whitespace, comma, or pipe. For example,
         * any of the following would be acceptable:
         *
         *     paramOrder: ['param1','param2','param3']
         *     paramOrder: 'param1 param2 param3'
         *     paramOrder: 'param1,param2,param3'
         *     paramOrder: 'param1|param2|param'
         */
        paramOrder: string;

        /**
         * Only used for the {@link #api} 'load' configuration. If true, parameters will be sent as a
         * single hash collection of named arguments. Providing a {@link #paramOrder} nullifies this
         * configuration.
         */
        paramsAsHash: boolean;

        /**
         * An Ext.data.reader.Reader (e.g. {@link Ext.data.reader.Xml}) instance or
         * configuration to be used to read data when executing 'load' actions. This
         * is optional as there is built-in support for processing JSON responses.
         */
        reader: any|Ext.data.reader.Reader;

        /**
         * If set to true, a standard HTML form submit is used instead of a XHR (Ajax) style form submission.
         * All of the field values, plus any additional params configured via {@link #baseParams}
         * and/or the 'options' to {@link #submit}, will be included in the values submitted in the form.
         */
        standardSubmit: boolean;

        /**
         * Timeout for form actions in seconds.
         */
        timeout: number;

        /**
         * If set to true, {@link #reset}() resets to the last loaded or {@link #setValues}() data instead of
         * when the form was first created.
         */
        trackResetOnLoad: boolean;

        /**
         * The URL to use for form actions if one isn't supplied in the
         * {@link #doAction doAction} options.
         */
        url: string;

        /**
         * By default wait messages are displayed with Ext.MessageBox.wait. You can target a specific
         * element by passing it or its id or mask the form itself by passing in true.
         */
        waitMsgTarget: string|HTMLElement|Ext.dom.Element;

        /**
         * The default title to show for the waiting message box
         */
        waitTitle: string;

        /**
         * Calls {@link Ext#applyIf Ext.applyIf} for all field in this form with the passed object.
         * @param {Object} obj The object to be applied
         * @return {Ext.form.Basic} this
         */
        applyIfToFields(obj: any): Ext.form.Basic;

        /**
         * Calls {@link Ext#apply Ext.apply} for all fields in this form with the passed object.
         * @param {Object} obj The object to be applied
         * @return {Ext.form.Basic} this
         */
        applyToFields(obj: any): Ext.form.Basic;

        /**
         * Check whether the dirty state of the entire form has changed since it was last checked, and
         * if so fire the {@link #dirtychange dirtychange} event. This is automatically invoked
         * when an individual field's 'dirty' state changes.
         */
        checkDirty();

        /**
         * Check whether the validity of the entire form has changed since it was last checked, and
         * if so fire the {@link #validitychange validitychange} event. This is automatically invoked
         * when an individual field's validity changes.
         */
        checkValidity();

        /**
         * Clears all invalid field messages in this form.
         * @return {Ext.form.Basic} this
         */
        clearInvalid(): Ext.form.Basic;

        /**
         * Creates new form.
         * @param {Ext.container.Container} owner The component that is the container for the form, usually a {@link Ext.form.Panel}
         * @param {Object} config Configuration options. These are normally specified in the config to the
         * {@link Ext.form.Panel} constructor, which passes them along to the BasicForm automatically.
         */
        constructor(owner: Ext.container.Container, config: Ext.form.BasicConfig);

        /**
         * Destroys this object.
         */
        destroy();

        /**
         * Performs a predefined action (an implementation of {@link Ext.form.action.Action}) to perform application-
         * specific processing.
         *
         * @param {String/Ext.form.action.Action} action The name of the predefined action type, or instance of {@link
         * Ext.form.action.Action} to perform.
         *
         * @param {Object} [options] The options to pass to the {@link Ext.form.action.Action} that will get created,
         * if the action argument is a String.
         *
         * All of the config options listed below are supported by both the {@link Ext.form.action.Submit submit} and
         * {@link Ext.form.action.Load load} actions unless otherwise noted (custom actions could also accept other
         * config options):
         *
         * The url for the action (defaults to the form's {@link #url}.)
         *
         * The form method to use (defaults to the form's method, or POST if not defined)
         *
         * The params to pass (defaults to the form's baseParams, or none if not defined)
         *
         * Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode Ext.Object.toQueryString}.
         *
         * Request headers to set for the action.
         *
         * The callback that will be invoked after a successful response (see top of {@link Ext.form.action.Submit submit}
         * and {@link Ext.form.action.Load load} for a description of what constitutes a successful response).
         * @param {Ext.form.Basic} options.success.form The form that requested the action.
         * @param {Ext.form.action.Action} options.success.action The Action object which performed the operation.
         * The action object contains these properties of interest:
         *
         *  - {@link Ext.form.action.Action#response response}
         *  - {@link Ext.form.action.Action#result result} - interrogate for custom postprocessing
         *  - {@link Ext.form.action.Action#type type}
         *
         * The callback that will be invoked after a failed transaction attempt.
         * @param {Ext.form.Basic} options.failure.form The form that requested the action.
         * @param {Ext.form.action.Action} options.failure.action The Action object which performed the operation.
         * The action object contains these properties of interest:
         *
         * - {@link Ext.form.action.Action#failureType failureType}
         * - {@link Ext.form.action.Action#response response}
         * - {@link Ext.form.action.Action#result result} - interrogate for custom postprocessing
         * - {@link Ext.form.action.Action#type type}
         *
         * The scope in which to call the callback functions (The this reference for the callback functions).
         *
         * Submit Action only. Determines whether a Form's fields are validated in a final call to {@link
         * Ext.form.Basic#isValid isValid} prior to submission. Set to false to prevent this. If undefined, pre-submission
         * field validation is performed.
         *
         * @return {Ext.form.Basic} this
         */
        doAction(action: string|Ext.form.action.Action, options?: any, options_url?: string, options_method?: string, options_params?: string|any, options_headers?: any, options_success?: Function, options_success_form?: Ext.form.Basic, options_success_action?: Ext.form.action.Action, options_failure?: Function, options_failure_form?: Ext.form.Basic, options_failure_action?: Ext.form.action.Action, options_scope?: any, options_clientValidation?: boolean): Ext.form.Basic;

        /**
         * Find a specific {@link Ext.form.field.Field} in this form by id or name.
         * @param {String} id The value to search for (specify either a {@link Ext.Component#id id} or
         * {@link Ext.form.field.Field#getName name or hiddenName}).
         * @return {Ext.form.field.Field} The first matching field, or 'null' if none was found.
         */
        findField(id: string): Ext.form.field.Field;

        /**
         * Return all the {@link Ext.form.field.Field} components in the owner container.
         * @return {Ext.util.MixedCollection} Collection of the Field objects
         */
        getFields(): Ext.util.MixedCollection;

        /**
         * Retrieves the fields in the form as a set of key/value pairs, using their
         * {@link Ext.form.field.Field#getModelData getModelData()} method to collect the values.
         * If multiple fields return values under the same name those values will be combined into an Array.
         * This is similar to {@link #getValues} except that this method collects type-specific data values
         * (e.g. Date objects for date fields) while getValues returns only String values for submission.
         *
         * @param {Boolean} [dirtyOnly=false] If true, only fields that are dirty will be included in the result.
         * @return {Object}
         */
        getFieldValues(dirtyOnly?: boolean): any;

        /**
         * Returns the last Ext.data.Model instance that was loaded via {@link #loadRecord}
         * @return {Ext.data.Model} The record
         */
        getRecord(): Ext.data.Model;

        /**
         * Retrieves the fields in the form as a set of key/value pairs, using their
         * {@link Ext.form.field.Field#getSubmitData getSubmitData()} method to collect the values.
         * If multiple fields return values under the same name those values will be combined into an Array.
         * This is similar to {@link Ext.form.Basic#getFieldValues getFieldValues} except that this method
         * collects only String values for submission, while getFieldValues collects type-specific data
         * values (e.g. Date objects for date fields.)
         *
         * @param {Boolean} [asString=false] If true, will return the key/value collection as a single
         * URL-encoded param string.
         * @param {Boolean} [dirtyOnly=false] If true, only fields that are dirty will be included in the result.
         * @param {Boolean} [includeEmptyText=false] If true, the configured emptyText of empty fields will be used.
         * @param {Boolean} [useDataValues=false] If true, the {@link Ext.form.field.Field#getModelData getModelData}
         * method is used to retrieve values from fields, otherwise the {@link Ext.form.field.Field#getSubmitData getSubmitData}
         * method is used.
         * @return {String/Object}
         */
        getValues(asString?: boolean, dirtyOnly?: boolean, includeEmptyText?: boolean, useDataValues?: boolean): string|any;

        /**
         * Returns true if the form contains any invalid fields. No fields will be marked as invalid
         * as a result of calling this; to trigger marking of fields use {@link #isValid} instead.
         */
        hasInvalidField();

        /**
         * Returns 'true' if the form contains a file upload field. This is used to determine the method for submitting the
         * form: File uploads are not performed using normal 'Ajax' techniques, that is they are **not** performed using
         * XMLHttpRequests. Instead a hidden '<form>' element containing all the fields is created temporarily and submitted
         * with its [target][1] set to refer to a dynamically generated, hidden '<iframe>' which is inserted into the document
         * but removed after the return data has been gathered.
         *
         * The server response is parsed by the browser to create the document for the IFRAME. If the server is using JSON
         * to send the return object, then the [Content-Type][2] header must be set to "text/html" in order to tell the
         * browser to insert the text unchanged into the document body.
         *
         * Characters which are significant to an HTML parser must be sent as HTML entities, so encode '"<"' as '"&lt;"',
         * '"&"' as '"&amp;"' etc.
         *
         * The response text is retrieved from the document, and a fake XMLHttpRequest object is created containing a
         * responseText property in order to conform to the requirements of event handlers and callbacks.
         *
         * Be aware that file upload packets are sent with the content type [multipart/form][3] and some server technologies
         * (notably JEE) may require some custom processing in order to retrieve parameter names and parameter values from
         * the packet content.
         *
         * [1]: http://www.w3.org/TR/REC-html40/present/frames.html#adef-target
         * [2]: http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17
         * [3]: http://www.faqs.org/rfcs/rfc2388.html
         *
         * @return {Boolean}
         */
        hasUpload(): boolean;

        /**
         * Returns 'true' if any fields in this form have changed from their original values.
         *
         * Note that if this BasicForm was configured with {@link Ext.form.Basic#trackResetOnLoad
         * trackResetOnLoad} then the Fields' *original values* are updated when the values are
         * loaded by {@link Ext.form.Basic#setValues setValues} or {@link #loadRecord}.
         *
         * @return {Boolean}
         */
        isDirty(): boolean;

        /**
         * Returns true if client-side validation on the form is successful. Any invalid fields will be
         * marked as invalid. If you only want to determine overall form validity without marking anything,
         * use {@link #hasInvalidField} instead.
         * @return {Boolean}
         */
        isValid(): boolean;

        /**
         * Shortcut to {@link #doAction do} a {@link Ext.form.action.Load load action}.
         * @param {Object} options The options to pass to the action (see {@link #doAction} for details)
         * @return {Ext.form.Basic} this
         */
        load(options: any): Ext.form.Basic;

        /**
         * Loads an {@link Ext.data.Model} into this form by calling {@link #setValues} with the
         * {@link Ext.data.Model#raw record data}.
         * See also {@link #trackResetOnLoad}.
         * @param {Ext.data.Model} record The record to load
         * @return {Ext.form.Basic} this
         */
        loadRecord(record: Ext.data.Model): Ext.form.Basic;

        /**
         * Mark fields in this form invalid in bulk.
         * Either an array in the form '[{id:'fieldId', msg:'The message'}, ...]',
         * an object hash of '{id: msg, id2: msg2}', or a {@link Ext.data.Errors} object.
         * @return {Ext.form.Basic} this
         */
        markInvalid(errors: any|Ext.data.Errors): Ext.form.Basic;

        /**
         * Resets all fields in this form. By default, any record bound by {@link #loadRecord}
         * will be retained.
         * @param {Boolean} [resetRecord=false] True to unbind any record set
         * by {@link #loadRecord}
         * @return {Ext.form.Basic} this
         */
        reset(resetRecord?: boolean): Ext.form.Basic;

        /**
         * Set values for fields in this form in bulk.
         *
         * @param {Object/Object[]} values Either an array in the form:
         *
         *     [{id:'clientName', value:'Fred. Olsen Lines'},
         *      {id:'portOfLoading', value:'FXT'},
         *      {id:'portOfDischarge', value:'OSL'} ]
         *
         * or an object hash of the form:
         *
         *     {
         *         clientName: 'Fred. Olsen Lines',
         *         portOfLoading: 'FXT',
         *         portOfDischarge: 'OSL'
         *     }
         *
         * @return {Ext.form.Basic} this
         */
        setValues(values: any): Ext.form.Basic;

        /**
         * Shortcut to {@link #doAction do} a {@link Ext.form.action.Submit submit action}. This will use the
         * {@link Ext.form.action.Submit AJAX submit action} by default. If the {@link #standardSubmit} config
         * is enabled it will use a standard form element to submit, or if the {@link #api} config is present
         * it will use the {@link Ext.form.action.DirectLoad Ext.direct.Direct submit action}.
         *
         * The following code:
         *
         *     myFormPanel.getForm().submit({
         *         clientValidation: true,
         *         url: 'updateConsignment.php',
         *         params: {
         *             newStatus: 'delivered'
         *         },
         *         success: function(form, action) {
         *            Ext.Msg.alert('Success', action.result.msg);
         *         },
         *         failure: function(form, action) {
         *             switch (action.failureType) {
         *                 case Ext.form.action.Action.CLIENT_INVALID:
         *                     Ext.Msg.alert('Failure', 'Form fields may not be submitted with invalid values');
         *                     break;
         *                 case Ext.form.action.Action.CONNECT_FAILURE:
         *                     Ext.Msg.alert('Failure', 'Ajax communication failed');
         *                     break;
         *                 case Ext.form.action.Action.SERVER_INVALID:
         *                    Ext.Msg.alert('Failure', action.result.msg);
         *            }
         *         }
         *     });
         *
         * would process the following server response for a successful submission:
         *
         *     {
         *         "success":true, // note this is Boolean, not string
         *         "msg":"Consignment updated"
         *     }
         *
         * and the following server response for a failed submission:
         *
         *     {
         *         "success":false, // note this is Boolean, not string
         *         "msg":"You do not have permission to perform this operation"
         *     }
         *
         * @param {Object} options The options to pass to the action (see {@link #doAction} for details).
         * @return {Ext.form.Basic} this
         */
        submit(options: any): Ext.form.Basic;

        /**
         * Persists the values in this form into the passed {@link Ext.data.Model} object in a beginEdit/endEdit block.
         * If the record is not specified, it will attempt to update (if it exists) the record provided to loadRecord.
         * @param {Ext.data.Model} [record] The record to edit
         * @return {Ext.form.Basic} this
         */
        updateRecord(record?: Ext.data.Model): Ext.form.Basic;

        /**
         * Fires when an action is completed.
         * @param {Ext.form.action.Action} action The {@link Ext.form.action.Action} that completed
         */
        actioncomplete(that: Ext.form.Basic, action: Ext.form.action.Action);

        /**
         * Fires when an action fails.
         * @param {Ext.form.action.Action} action The {@link Ext.form.action.Action} that failed
         */
        actionfailed(that: Ext.form.Basic, action: Ext.form.action.Action);

        /**
         * Fires before any action is performed. Return false to cancel the action.
         * @param {Ext.form.action.Action} action The {@link Ext.form.action.Action} to be performed
         */
        beforeaction(that: Ext.form.Basic, action: Ext.form.action.Action);

        /**
         * Fires when the dirty state of the entire form changes.
         * @param {Boolean} dirty 'true' if the form is now dirty, 'false' if it is no longer dirty.
         */
        dirtychange(that: Ext.form.Basic, dirty: boolean);

        /**
         * Fires when the validity of the entire form changes.
         * @param {Boolean} valid 'true' if the form is now valid, 'false' if it is now invalid.
         */
        validitychange(that: Ext.form.Basic, valid: boolean);
    }

    interface CheckboxGroupConfig extends Ext.form.FieldContainerConfig {
        /**
         * False to validate that at least one item in the group is checked. If no items are selected at
         * validation time, {@link #blankText} will be used as the error text.
         */
        allowBlank?: boolean;

        /**
         * Error text to display if the {@link #allowBlank} validation fails
         */
        blankText?: string;

        /**
         * Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout.
         * This config can take several types of values:
         *
         * - 'auto' - The controls will be rendered one per column on one row and the width of each column will be evenly
         *   distributed based on the width of the overall field container. This is the default.
         * - Number - If you specific a number (e.g., 3) that number of columns will be created and the contained controls
         *   will be automatically distributed based on the value of {@link #vertical}.
         * - Array - You can also specify an array of column widths, mixing integer (fixed width) and float (percentage
         *   width) values as needed (e.g., [100, .25, .75]). Any integer values will be rendered first, then any float
         *   values will be calculated as a percentage of the remaining space. Float values do not have to add up to 1
         *   (100%) although if you want the controls to take up the entire field container you should do so.
         */
        columns?: string|number;

        componentCls?: any;

        defaultType?: any;

        layout?: any;

        /**
         * True to distribute contained controls across columns, completely filling each column top to bottom before
         * starting on the next column. The number of controls in each column will be automatically calculated to keep
         * columns as even as possible. The default value is false, so that controls will be added to columns one at a time,
         * completely filling each row left to right before starting on the next row.
         */
        vertical?: boolean;
    }

    /**
     * A {@link Ext.form.FieldContainer field container} which has a specialized layout for arranging
     * {@link Ext.form.field.Checkbox} controls into columns, and provides convenience
     * {@link Ext.form.field.Field} methods for {@link #getValue getting}, {@link #setValue setting},
     * and {@link #validate validating} the group of checkboxes as a whole.
     *
     * # Validation
     *
     * Individual checkbox fields themselves have no default validation behavior, but
     * sometimes you want to require a user to select at least one of a group of checkboxes. CheckboxGroup
     * allows this by setting the config '{@link #allowBlank}:false'; when the user does not check at
     * least one of the checkboxes, the entire group will be highlighted as invalid and the
     * {@link #blankText error message} will be displayed according to the {@link #msgTarget} config.
     *
     * # Layout
     *
     * The default layout for CheckboxGroup makes it easy to arrange the checkboxes into
     * columns; see the {@link #columns} and {@link #vertical} config documentation for details. You may also
     * use a completely different layout by setting the {@link #layout} to one of the other supported layout
     * types; for instance you may wish to use a custom arrangement of hbox and vbox containers. In that case
     * the checkbox components at any depth will still be managed by the CheckboxGroup's validation.
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Checkbox Group',
     *         width: 300,
     *         height: 125,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items:[{
     *             xtype: 'checkboxgroup',
     *             fieldLabel: 'Two Columns',
     *             // Arrange checkboxes into two columns, distributed vertically
     *             columns: 2,
     *             vertical: true,
     *             items: [
     *                 { boxLabel: 'Item 1', name: 'rb', inputValue: '1' },
     *                 { boxLabel: 'Item 2', name: 'rb', inputValue: '2', checked: true },
     *                 { boxLabel: 'Item 3', name: 'rb', inputValue: '3' },
     *                 { boxLabel: 'Item 4', name: 'rb', inputValue: '4' },
     *                 { boxLabel: 'Item 5', name: 'rb', inputValue: '5' },
     *                 { boxLabel: 'Item 6', name: 'rb', inputValue: '6' }
     *             ]
     *         }]
     *     });
     */
    export class CheckboxGroup extends Ext.form.FieldContainer implements Ext.form.CheckboxGroupConfig {
        /**
         * False to validate that at least one item in the group is checked. If no items are selected at
         * validation time, {@link #blankText} will be used as the error text.
         */
        allowBlank: boolean;

        /**
         * Error text to display if the {@link #allowBlank} validation fails
         */
        blankText: string;

        /**
         * Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout.
         * This config can take several types of values:
         *
         * - 'auto' - The controls will be rendered one per column on one row and the width of each column will be evenly
         *   distributed based on the width of the overall field container. This is the default.
         * - Number - If you specific a number (e.g., 3) that number of columns will be created and the contained controls
         *   will be automatically distributed based on the value of {@link #vertical}.
         * - Array - You can also specify an array of column widths, mixing integer (fixed width) and float (percentage
         *   width) values as needed (e.g., [100, .25, .75]). Any integer values will be rendered first, then any float
         *   values will be calculated as a percentage of the remaining space. Float values do not have to add up to 1
         *   (100%) although if you want the controls to take up the entire field container you should do so.
         */
        columns: string|number;

        componentCls: string;

        defaultType: string;

        layout: Ext.enums.Layout|any;

        /**
         * True to distribute contained controls across columns, completely filling each column top to bottom before
         * starting on the next column. The number of controls in each column will be automatically calculated to keep
         * columns as even as possible. The default value is false, so that controls will be added to columns one at a time,
         * completely filling each row left to right before starting on the next row.
         */
        vertical: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Returns an Array of all checkboxes in the container which are currently checked
         * @return {Ext.form.field.Checkbox[]} Array of Ext.form.field.Checkbox components
         */
        getChecked(): Ext.form.field.Checkbox;

        /**
         * Runs CheckboxGroup's validations and returns an array of any errors. The only error by default is if allowBlank
         * is set to true and no items are checked.
         * @return {String[]} Array of all validation errors
         */
        getErrors(): string;

        getModelData();

        getSubmitData();

        /**
         * Returns an object containing the values of all checked checkboxes within the group. Each key-value pair in the
         * object corresponds to a checkbox {@link Ext.form.field.Checkbox#name name}. If there is only one checked checkbox
         * with a particular name, the value of that pair will be the String {@link Ext.form.field.Checkbox#inputValue
         * inputValue} of that checkbox. If there are multiple checked checkboxes with that name, the value of that pair
         * will be an Array of the selected inputValues.
         *
         * The object format returned from this method can also be passed directly to the {@link #setValue} method.
         *
         * NOTE: In Ext 3, this method returned an array of Checkbox components; this was changed to make it more consistent
         * with other field components and with the {@link #setValue} argument signature. If you need the old behavior in
         * Ext 4+, use the {@link #getChecked} method instead.
         */
        getValue();

        /**
         * Initializes the field's value based on the initial config. If the {@link #value} config is specified then we use
         * that to set the value; otherwise we initialize the originalValue by querying the values of all sub-checkboxes
         * after they have been initialized.
         */
        protected initValue();

        isDirty();

        isEqual();

        /**
         * Resets the checked state of all {@link Ext.form.field.Checkbox checkboxes} in the group to their originally
         * loaded values and clears any validation messages.
         * See {@link Ext.form.Basic}.{@link Ext.form.Basic#trackResetOnLoad trackResetOnLoad}
         */
        reset();

        resetOriginalValue();

        /**
         * Sets the value(s) of all checkboxes in the group. The expected format is an Object of name-value pairs
         * corresponding to the names of the checkboxes in the group. Each pair can have either a single or multiple values:
         *
         *   - A single Boolean or String value will be passed to the 'setValue' method of the checkbox with that name.
         *     See the rules in {@link Ext.form.field.Checkbox#setValue} for accepted values.
         *   - An Array of String values will be matched against the {@link Ext.form.field.Checkbox#inputValue inputValue}
         *     of checkboxes in the group with that name; those checkboxes whose inputValue exists in the array will be
         *     checked and others will be unchecked.
         *
         * If a checkbox's name is not in the mapping at all, it will be unchecked.
         *
         * An example:
         *
         *     var myCheckboxGroup = new Ext.form.CheckboxGroup({
         *         columns: 3,
         *         items: [{
         *             name: 'cb1',
         *             boxLabel: 'Single 1'
         *         }, {
         *             name: 'cb2',
         *             boxLabel: 'Single 2'
         *         }, {
         *             name: 'cb3',
         *             boxLabel: 'Single 3'
         *         }, {
         *             name: 'cbGroup',
         *             boxLabel: 'Grouped 1'
         *             inputValue: 'value1'
         *         }, {
         *             name: 'cbGroup',
         *             boxLabel: 'Grouped 2'
         *             inputValue: 'value2'
         *         }, {
         *             name: 'cbGroup',
         *             boxLabel: 'Grouped 3'
         *             inputValue: 'value3'
         *         }]
         *     });
         *
         *     myCheckboxGroup.setValue({
         *         cb1: true,
         *         cb3: false,
         *         cbGroup: ['value1', 'value3']
         *     });
         *
         * The above code will cause the checkbox named 'cb1' to be checked, as well as the first and third checkboxes named
         * 'cbGroup'. The other three checkboxes will be unchecked.
         *
         * @param {Object} value The mapping of checkbox names to values.
         * @return {Ext.form.CheckboxGroup} this
         */
        setValue(value: any): Ext.form.CheckboxGroup;

        validate();
    }

    /**
     * Private utility class for managing all {@link Ext.form.field.Checkbox} fields grouped by name.
     */
    export class CheckboxManager {
        /**
         * Creates new MixedCollection.
         * @param {Object} config A configuration object.
         *  @param {Boolean} [config.allowFunctions=false] Specify 'true' if the {@link #addAll}
         * function should add function references to the collection.
         *  @param {Function} [config.getKey] A function that can accept an item of the type(s) stored in this MixedCollection
         * and return the key value for that item.  This is used when available to look up the key on items that
         * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
         * equivalent to overriding the {@link #method-getKey} method.
         */
        constructor(config: Ext.util.MixedCollectionConfig);
    }

    interface FieldAncestorConfig {
        /**
         * If specified, the properties in this object are used as default config values for each {@link Ext.form.Labelable}
         * instance (e.g. {@link Ext.form.field.Base} or {@link Ext.form.FieldContainer}) that is added as a descendant of
         * this container. Corresponding values specified in an individual field's own configuration, or from the {@link
         * Ext.container.Container#defaults defaults config} of its parent container, will take precedence. See the
         * documentation for {@link Ext.form.Labelable} to see what config options may be specified in the fieldDefaults.
         *
         * Example:
         *
         *     new Ext.form.Panel({
         *         fieldDefaults: {
         *             labelAlign: 'left',
         *             labelWidth: 100
         *         },
         *         items: [{
         *             xtype: 'fieldset',
         *             defaults: {
         *                 labelAlign: 'top'
         *             },
         *             items: [{
         *                 name: 'field1'
         *             }, {
         *                 name: 'field2'
         *             }]
         *         }, {
         *             xtype: 'fieldset',
         *             items: [{
         *                 name: 'field3',
         *                 labelWidth: 150
         *             }, {
         *                 name: 'field4'
         *             }]
         *         }]
         *     });
         *
         * In this example, field1 and field2 will get labelAlign:'top' (from the fieldset's defaults) and labelWidth:100
         * (from fieldDefaults), field3 and field4 will both get labelAlign:'left' (from fieldDefaults and field3 will use
         * the labelWidth:150 from its own config.
         */
        fieldDefaults?: any;
    }

    /**
     * A mixin for {@link Ext.container.Container} components that are likely to have form fields in their
     * items subtree. Adds the following capabilities:
     *
     * - Methods for handling the addition and removal of {@link Ext.form.Labelable} and {@link Ext.form.field.Field}
     *   instances at any depth within the container.
     * - Events ({@link #fieldvaliditychange} and {@link #fielderrorchange}) for handling changes to the state
     *   of individual fields at the container level.
     * - Automatic application of {@link #fieldDefaults} config properties to each field added within the
     *   container, to facilitate uniform configuration of all fields.
     *
     * This mixin is primarily for internal use by {@link Ext.form.Panel} and {@link Ext.form.FieldContainer},
     * and should not normally need to be used directly.
     *
     * @docauthor Jason Johnston <jason@sencha.com>
     */
    export class FieldAncestor extends Ext.Base implements Ext.form.FieldAncestorConfig {
        /**
         * If specified, the properties in this object are used as default config values for each {@link Ext.form.Labelable}
         * instance (e.g. {@link Ext.form.field.Base} or {@link Ext.form.FieldContainer}) that is added as a descendant of
         * this container. Corresponding values specified in an individual field's own configuration, or from the {@link
         * Ext.container.Container#defaults defaults config} of its parent container, will take precedence. See the
         * documentation for {@link Ext.form.Labelable} to see what config options may be specified in the fieldDefaults.
         *
         * Example:
         *
         *     new Ext.form.Panel({
         *         fieldDefaults: {
         *             labelAlign: 'left',
         *             labelWidth: 100
         *         },
         *         items: [{
         *             xtype: 'fieldset',
         *             defaults: {
         *                 labelAlign: 'top'
         *             },
         *             items: [{
         *                 name: 'field1'
         *             }, {
         *                 name: 'field2'
         *             }]
         *         }, {
         *             xtype: 'fieldset',
         *             items: [{
         *                 name: 'field3',
         *                 labelWidth: 150
         *             }, {
         *                 name: 'field4'
         *             }]
         *         }]
         *     });
         *
         * In this example, field1 and field2 will get labelAlign:'top' (from the fieldset's defaults) and labelWidth:100
         * (from fieldDefaults), field3 and field4 will both get labelAlign:'left' (from fieldDefaults and field3 will use
         * the labelWidth:150 from its own config.
         */
        fieldDefaults: any;

        /**
         * Initializes the FieldAncestor's state; this must be called from the initComponent method of any components
         * importing this mixin.
         */
        protected initFieldAncestor();

        /**
         * Fired when the error message of any field within the container changes.
         * @param {Ext.form.Labelable} field The sub-field whose active error changed
         * @param {String} error The new active error message
         */
        protected onFieldErrorChange(field: Ext.form.Labelable, error: string);

        /**
         * Fired when the validity of any field within the container changes.
         * @param {Ext.form.field.Field} field The sub-field whose validity changed
         * @param {Boolean} valid The new validity state
         */
        protected onFieldValidityChange(field: Ext.form.field.Field, valid: boolean);

        /**
         * Fires when the active error message is changed for any one of the {@link Ext.form.Labelable} instances
         * within this container.
         * @param {Ext.form.Labelable} The Labelable instance whose active error was changed
         * @param {String} error The active error message
         */
        fielderrorchange(that: Ext.form.FieldAncestor, The: Ext.form.Labelable, error: string);

        /**
         * Fires when the validity state of any one of the {@link Ext.form.field.Field} instances within this
         * container changes.
         * @param {Ext.form.Labelable} The Field instance whose validity changed
         * @param {String} isValid The field's new validity state
         */
        fieldvaliditychange(that: Ext.form.FieldAncestor, The: Ext.form.Labelable, isValid: string);
    }

    interface FieldContainerConfig extends Ext.container.ContainerConfig {
        /**
         * If set to true, the field container will automatically combine and display the validation errors from
         * all the fields it contains as a single error on the container, according to the configured
         * {@link #msgTarget}. Defaults to false.
         */
        combineErrors?: boolean;

        /**
         * If set to true, and there is no defined {@link #fieldLabel}, the field container will automatically
         * generate its label by combining the labels of all the fields it contains. Defaults to false.
         */
        combineLabels?: boolean;

        componentCls?: any;

        componentLayout?: any;

        invalidCls?: any;

        /**
         * The string to use when joining the labels of individual sub-fields, when {@link #combineLabels} is
         * set to true. Defaults to ', '.
         */
        labelConnector?: string;
    }

    /**
     * FieldContainer is a derivation of {@link Ext.container.Container Container} that implements the
     * {@link Ext.form.Labelable Labelable} mixin. This allows it to be configured so that it is rendered with
     * a {@link #fieldLabel field label} and optional {@link #msgTarget error message} around its sub-items.
     * This is useful for arranging a group of fields or other components within a single item in a form, so
     * that it lines up nicely with other fields. A common use is for grouping a set of related fields under
     * a single label in a form.
     *
     * The container's configured {@link #cfg-items} will be layed out within the field body area according to the
     * configured {@link #layout} type. The default layout is ''autocontainer''.
     *
     * Like regular fields, FieldContainer can inherit its decoration configuration from the
     * {@link Ext.form.Panel#fieldDefaults fieldDefaults} of an enclosing FormPanel. In addition,
     * FieldContainer itself can pass {@link #fieldDefaults} to any {@link Ext.form.Labelable fields}
     * it may itself contain.
     *
     * If you are grouping a set of {@link Ext.form.field.Checkbox Checkbox} or {@link Ext.form.field.Radio Radio}
     * fields in a single labeled container, consider using a {@link Ext.form.CheckboxGroup}
     * or {@link Ext.form.RadioGroup} instead as they are specialized for handling those types.
     *
     * # Example
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'FieldContainer Example',
     *         width: 550,
     *         bodyPadding: 10,
     *
     *         items: [{
     *             xtype: 'fieldcontainer',
     *             fieldLabel: 'Last Three Jobs',
     *             labelWidth: 100,
     *
     *             // The body area will contain three text fields, arranged
     *             // horizontally, separated by draggable splitters.
     *             layout: 'hbox',
     *             items: [{
     *                 xtype: 'textfield',
     *                 flex: 1
     *             }, {
     *                 xtype: 'splitter'
     *             }, {
     *                 xtype: 'textfield',
     *                 flex: 1
     *             }, {
     *                 xtype: 'splitter'
     *             }, {
     *                 xtype: 'textfield',
     *                 flex: 1
     *             }]
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     *
     * # Usage of fieldDefaults
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'FieldContainer Example',
     *         width: 350,
     *         bodyPadding: 10,
     *
     *         items: [{
     *             xtype: 'fieldcontainer',
     *             fieldLabel: 'Your Name',
     *             labelWidth: 75,
     *             defaultType: 'textfield',
     *
     *             // Arrange fields vertically, stretched to full width
     *             layout: 'anchor',
     *             defaults: {
     *                 layout: '100%'
     *             },
     *
     *             // These config values will be applied to both sub-fields, except
     *             // for Last Name which will use its own msgTarget.
     *             fieldDefaults: {
     *                 msgTarget: 'under',
     *                 labelAlign: 'top'
     *             },
     *
     *             items: [{
     *                 fieldLabel: 'First Name',
     *                 name: 'firstName'
     *             }, {
     *                 fieldLabel: 'Last Name',
     *                 name: 'lastName',
     *                 msgTarget: 'under'
     *             }]
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     *
     * @docauthor Jason Johnston <jason@sencha.com>
     */
    export class FieldContainer extends Ext.container.Container implements Ext.form.FieldContainerConfig {
        maskOnDisable: boolean;

        /**
         * If set to true, the field container will automatically combine and display the validation errors from
         * all the fields it contains as a single error on the container, according to the configured
         * {@link #msgTarget}. Defaults to false.
         */
        combineErrors: boolean;

        /**
         * If set to true, and there is no defined {@link #fieldLabel}, the field container will automatically
         * generate its label by combining the labels of all the fields it contains. Defaults to false.
         */
        combineLabels: boolean;

        componentCls: string;

        componentLayout: string|any;

        invalidCls: any;

        /**
         * The string to use when joining the labels of individual sub-fields, when {@link #combineLabels} is
         * set to true. Defaults to ', '.
         */
        labelConnector: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Takes an Array of invalid {@link Ext.form.field.Field} objects and builds a combined list of error
         * messages from them. Defaults to prepending each message by the field name and a colon. This
         * can be overridden to provide custom combined error message handling, for instance changing
         * the format of each message or sorting the array (it is sorted in order of appearance by default).
         * @param {Ext.form.field.Field[]} invalidFields An Array of the sub-fields which are currently invalid.
         * @return {String[]} The combined list of error messages
         */
        getCombinedErrors(invalidFields: Ext.form.field.Field): string;

        /**
         * Returns the combined field label if {@link #combineLabels} is set to true and if there is no
         * set {@link #fieldLabel}. Otherwise returns the fieldLabel like normal. You can also override
         * this method to provide a custom generated label.
         * @return {String} The label, or empty string if none.
         */
        getFieldLabel(): string;

        protected getSubTplMarkup();

        protected initRenderData();
    }

    interface FieldSetConfig extends Ext.container.ContainerConfig {
        autoEl?: any;

        /**
         * The base CSS class applied to the fieldset.
         *
         * Optional, Defaults to: 'x-fieldset'
         */
        baseCls?: string;

        /**
         * The name to assign to the fieldset's checkbox if {@link #checkboxToggle} = true
         * (defaults to '[fieldset id]-checkbox').
         */
        checkboxName?: string;

        /**
         * Set to true to render a checkbox into the fieldset frame just in front of the legend to expand/collapse the
         * fieldset when the checkbox is toggled.. This checkbox will be included in form submits using
         * the {@link #checkboxName}.
         *
         * Optional, Defaults to: false
         */
        checkboxToggle?: boolean;

        /**
         * Set to true to render the fieldset as collapsed by default. If {@link #checkboxToggle} is specified, the checkbox
         * will also be unchecked by default.
         */
        collapsed?: boolean;

        /**
         * Set to true to make the fieldset collapsible and have the expand/collapse toggle button automatically rendered
         * into the legend element, false to keep the fieldset statically sized with no collapse button.
         * Another option is to configure {@link #checkboxToggle}. Use the {@link #collapsed} config to collapse the
         * fieldset by default.
         *
         * Optional, Defaults to: false
         */
        collapsible?: boolean;

        componentLayout?: any;

        /**
         * The {@link Ext.container.Container#layout} for the fieldset's immediate child items.
         */
        layout?: Ext.enums.Layout|any;

        stateEvents?: any;

        /**
         * A title to be displayed in the fieldset's legend. May contain HTML markup.
         */
        title?: string;

        /**
         * Set to true will add a listener to the titleCmp property for the click event which will execute the
         * {@link #toggle} method. This option is only used when the {@link #collapsible} property is set to true.
         *
         * Optional, Defaults to: true
         */
        toggleOnTitleClick?: boolean;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * A container for grouping sets of fields, rendered as a HTML 'fieldset' element. The {@link #title}
     * config will be rendered as the fieldset's 'legend'.
     *
     * While FieldSets commonly contain simple groups of fields, they are general {@link Ext.container.Container Containers}
     * and may therefore contain any type of components in their {@link #cfg-items}, including other nested containers.
     * The default {@link #layout} for the FieldSet's items is ''anchor'', but it can be configured to use any other
     * layout type.
     *
     * FieldSets may also be collapsed if configured to do so; this can be done in two ways:
     *
     * 1. Set the {@link #collapsible} config to true; this will result in a collapse button being rendered next to
     *    the {@link #title legend title}, or:
     * 2. Set the {@link #checkboxToggle} config to true; this is similar to using {@link #collapsible} but renders
     *    a {@link Ext.form.field.Checkbox checkbox} in place of the toggle button. The fieldset will be expanded when the
     *    checkbox is checked and collapsed when it is unchecked. The checkbox will also be included in the
     *    {@link Ext.form.Basic#submit form submit parameters} using the {@link #checkboxName} as its parameter name.
     *
     * # Example usage
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Simple Form with FieldSets',
     *         labelWidth: 75, // label settings here cascade unless overridden
     *         url: 'save-form.php',
     *         frame: true,
     *         bodyStyle: 'padding:5px 5px 0',
     *         width: 550,
     *         renderTo: Ext.getBody(),
     *         layout: 'column', // arrange fieldsets side by side
     *         items: [{
     *             // Fieldset in Column 1 - collapsible via toggle button
     *             xtype:'fieldset',
     *             columnWidth: 0.5,
     *             title: 'Fieldset 1',
     *             collapsible: true,
     *             defaultType: 'textfield',
     *             defaults: {anchor: '100%'},
     *             layout: 'anchor',
     *             items :[{
     *                 fieldLabel: 'Field 1',
     *                 name: 'field1'
     *             }, {
     *                 fieldLabel: 'Field 2',
     *                 name: 'field2'
     *             }]
     *         }, {
     *             // Fieldset in Column 2 - collapsible via checkbox, collapsed by default, contains a panel
     *             xtype:'fieldset',
     *             title: 'Show Panel', // title or checkboxToggle creates fieldset header
     *             columnWidth: 0.5,
     *             checkboxToggle: true,
     *             collapsed: true, // fieldset initially collapsed
     *             layout:'anchor',
     *             items :[{
     *                 xtype: 'panel',
     *                 anchor: '100%',
     *                 title: 'Panel inside a fieldset',
     *                 frame: true,
     *                 height: 52
     *             }]
     *         }]
     *     });
     */
    export class FieldSet extends Ext.container.Container implements Ext.form.FieldSetConfig {
        /**
         * Refers to the {@link Ext.form.field.Checkbox} component that is added next to the title in the legend. Only
         * populated if the fieldset is configured with {@link #checkboxToggle}:true.
         */
        checkboxCmp: Ext.form.field.Checkbox;

        /**
         * The component for the fieldset's legend. Will only be defined if the configuration requires a legend to be
         * created, by setting the {@link #title} or {@link #checkboxToggle} options.
         */
        legend: Ext.Component;

        maskOnDisable: boolean;

        /**
         * Refers to the {@link Ext.panel.Tool} component that is added as the collapse/expand button next to the title in
         * the legend. Only populated if the fieldset is configured with {@link #collapsible}:true.
         */
        toggleCmp: Ext.panel.Tool;

        autoEl: string|any;

        /**
         * The base CSS class applied to the fieldset.
         *
         * Optional, Defaults to: 'x-fieldset'
         */
        baseCls: string;

        /**
         * The name to assign to the fieldset's checkbox if {@link #checkboxToggle} = true
         * (defaults to '[fieldset id]-checkbox').
         */
        checkboxName: string;

        /**
         * Set to true to render a checkbox into the fieldset frame just in front of the legend to expand/collapse the
         * fieldset when the checkbox is toggled.. This checkbox will be included in form submits using
         * the {@link #checkboxName}.
         *
         * Optional, Defaults to: false
         */
        checkboxToggle: boolean;

        /**
         * Set to true to render the fieldset as collapsed by default. If {@link #checkboxToggle} is specified, the checkbox
         * will also be unchecked by default.
         */
        collapsed: boolean;

        /**
         * Set to true to make the fieldset collapsible and have the expand/collapse toggle button automatically rendered
         * into the legend element, false to keep the fieldset statically sized with no collapse button.
         * Another option is to configure {@link #checkboxToggle}. Use the {@link #collapsed} config to collapse the
         * fieldset by default.
         *
         * Optional, Defaults to: false
         */
        collapsible: boolean;

        componentLayout: string|any;

        /**
         * The {@link Ext.container.Container#layout} for the fieldset's immediate child items.
         */
        layout: Ext.enums.Layout|any;

        protected renderTpl: Ext.XTemplate|string;

        stateEvents: any;

        /**
         * A title to be displayed in the fieldset's legend. May contain HTML markup.
         */
        title: string;

        /**
         * Set to true will add a listener to the titleCmp property for the click event which will execute the
         * {@link #toggle} method. This option is only used when the {@link #collapsible} property is set to true.
         *
         * Optional, Defaults to: true
         */
        toggleOnTitleClick: boolean;

        /**
         * Collapses the fieldset.
         * @return {Ext.form.FieldSet} this
         */
        collapse(): Ext.form.FieldSet;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Creates the checkbox component. This is only called internally, but could be overridden in subclasses to
         * customize the checkbox's configuration or even return an entirely different component type.
         * @return {Ext.Component}
         */
        protected createCheckboxCmp(): Ext.Component;

        /**
         * Creates the legend title component. This is only called internally, but could be overridden in subclasses to
         * customize the title component. If {@link #toggleOnTitleClick} is set to true, a listener for the click event
         * will toggle the collapsed state of the FieldSet.
         * @return {Ext.Component}
         */
        protected createTitleCmp(): Ext.Component;

        /**
         * Creates the toggle button component. This is only called internally, but could be overridden in subclasses to
         * customize the toggle component.
         * @return {Ext.Component}
         */
        protected createToggleCmp(): Ext.Component;

        /**
         * Expands the fieldset.
         * @return {Ext.form.FieldSet} this
         */
        expand(): Ext.form.FieldSet;

        /**
         * Sets the title of this fieldset.
         * @param {String} title The new title.
         * @return {Ext.form.FieldSet} this
         */
        setTitle(title: string): Ext.form.FieldSet;

        /**
         * Toggle the fieldset's collapsed state to the opposite of what it is currently.
         */
        toggle();

        /**
         * Fires before this FieldSet is collapsed. Return false to prevent the collapse.
         * @param {Ext.form.FieldSet} f The FieldSet being collapsed.
         */
        beforecollapse(f: Ext.form.FieldSet);

        /**
         * Fires before this FieldSet is expanded. Return false to prevent the expand.
         * @param {Ext.form.FieldSet} f The FieldSet being expanded.
         */
        beforeexpand(f: Ext.form.FieldSet);
    }

    interface LabelableConfig {
        /**
         * If specified, then the component will be displayed with this value as its active error when first rendered. Use
         * {@link #setActiveError} or {@link #unsetActiveError} to change it after component creation.
         */
        activeError?: string;

        /**
         * The template used to format the Array of error messages passed to {@link #setActiveErrors} into a single HTML
         * string. if the {@link #msgTarget} is title, it defaults to a list separated by new lines. Otherwise, it
         * renders each message as an item in an unordered list.
         */
        activeErrorsTpl?: string|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * at the end of the input containing element. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        afterBodyEl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the label text. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        afterLabelTextTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the label element. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        afterLabelTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the {@link #getSubTplMarkup subTpl markup}. If an 'XTemplate' is used, the
         * component's {@link Ext.AbstractComponent#renderData render data} serves as the context.
         */
        afterSubTpl?: string|any[]|Ext.XTemplate;

        /**
         * Whether to adjust the component's body area to make room for 'side' or 'under' {@link #msgTarget error messages}.
         */
        autoFitErrors?: boolean;

        /**
         * The CSS class to be applied to the body content element.
         */
        baseBodyCls?: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * at the beginning of the input containing element. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        beforeBodyEl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the label text. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        beforeLabelTextTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the label element. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        beforeLabelTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the {@link #getSubTplMarkup subTpl markup}. If an 'XTemplate' is used, the
         * component's {@link Ext.AbstractComponent#renderData render data} serves as the context.
         */
        beforeSubTpl?: string|any[]|Ext.XTemplate;

        /**
         * The CSS class to be applied to the special clearing div rendered directly after the field contents wrapper to
         * provide field clearing.
         */
        clearCls?: string;

        /**
         * The CSS class to be applied to the error message element.
         */
        errorMsgCls?: string;

        /**
         * An extra CSS class to be applied to the body content element in addition to {@link #baseBodyCls}.
         */
        fieldBodyCls?: string;

        /**
         * The label for the field. It gets appended with the {@link #labelSeparator}, and its position and sizing is
         * determined by the {@link #labelAlign}, {@link #labelWidth}, and {@link #labelPad} configs.
         */
        fieldLabel?: string;

        /**
         * A CSS class to be applied to the outermost element to denote that it is participating in the form field layout.
         */
        formItemCls?: string;

        /**
         * When set to true, the label element ({@link #fieldLabel} and {@link #labelSeparator}) will be automatically
         * hidden if the {@link #fieldLabel} is empty. Setting this to false will cause the empty label element to be
         * rendered and space to be reserved for it; this is useful if you want a field without a label to line up with
         * other labeled fields in the same form.
         *
         * If you wish to unconditionall hide the label even if a non-empty fieldLabel is configured, then set the
         * {@link #hideLabel} config to true.
         */
        hideEmptyLabel?: boolean;

        /**
         * Set to true to completely hide the label element ({@link #fieldLabel} and {@link #labelSeparator}). Also see
         * {@link #hideEmptyLabel}, which controls whether space will be reserved for an empty fieldLabel.
         */
        hideLabel?: boolean;

        /**
         * The CSS class to use when marking the component invalid.
         */
        invalidCls?: string;

        /**
         * Controls the position and alignment of the {@link #fieldLabel}. Valid values are:
         *
         *   - "left" (the default) - The label is positioned to the left of the field, with its text aligned to the left.
         *     Its width is determined by the {@link #labelWidth} config.
         *   - "top" - The label is positioned above the field.
         *   - "right" - The label is positioned to the left of the field, with its text aligned to the right.
         *     Its width is determined by the {@link #labelWidth} config.
         */
        labelAlign?: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * inside the label element (as attributes). If an 'XTemplate' is used, the component's
         * {@link Ext.AbstractComponent#renderData render data} serves as the context.
         */
        labelAttrTpl?: string|any[]|Ext.XTemplate;

        /**
         * The CSS class to be applied to the label element. This (single) CSS class is used to formulate the renderSelector
         * and drives the field layout where it is concatenated with a hyphen ('-') and {@link #labelAlign}. To add
         * additional classes, use {@link #labelClsExtra}.
         */
        labelCls?: string;

        /**
         * An optional string of one or more additional CSS classes to add to the label element. Defaults to empty.
         */
        labelClsExtra?: string;

        /**
         * The amount of space in pixels between the {@link #fieldLabel} and the input field.
         */
        labelPad?: number;

        /**
         * Character(s) to be inserted at the end of the {@link #fieldLabel label text}.
         *
         * Set to empty string to hide the separator completely.
         */
        labelSeparator?: string;

        /**
         * A CSS style specification string to apply directly to this field's label.
         */
        labelStyle?: string;

        /**
         * The width of the {@link #fieldLabel} in pixels. Only applicable if the {@link #labelAlign} is set to "left" or
         * "right".
         */
        labelWidth?: number;

        /**
         * The location where the error message text should display. Must be one of the following values:
         *
         *   - 'qtip' Display a quick tip containing the message when the user hovers over the field.
         *     This is the default.
         *
         *     **{@link Ext.tip.QuickTipManager#init} must have been called for this setting to work.**
         *
         *   - 'title' Display the message in a default browser title attribute popup.
         *   - 'under' Add a block div beneath the field containing the error message.
         *   - 'side' Add an error icon to the right of the field, displaying the message in a popup on hover.
         *   - 'none' Don't display any error message. This might be useful if you are implementing custom error display.
         *   - '[element id]' Add the error message directly to the innerHTML of the specified element.
         */
        msgTarget?: string;

        /**
         * true to disable displaying any {@link #setActiveError error message} set on this object.
         */
        preventMark?: boolean;
    }

    /**
     * A mixin which allows a component to be configured and decorated with a label and/or error message as is
     * common for form fields. This is used by e.g. Ext.form.field.Base and Ext.form.FieldContainer
     * to let them be managed by the Field layout.
     *
     * NOTE: This mixin is mainly for internal library use and most users should not need to use it directly. It
     * is more likely you will want to use one of the component classes that import this mixin, such as
     * Ext.form.field.Base or Ext.form.FieldContainer.
     *
     * Use of this mixin does not make a component a field in the logical sense, meaning it does not provide any
     * logic or state related to values or validation; that is handled by the related Ext.form.field.Field
     * mixin. These two mixins may be used separately (for example Ext.form.FieldContainer is Labelable but not a
     * Field), or in combination (for example Ext.form.field.Base implements both and has logic for connecting the
     * two.)
     *
     * Component classes which use this mixin should use the Field layout
     * or a derivation thereof to properly size and position the label and message according to the component config.
     * They must also call the {@link #initLabelable} method during component initialization to ensure the mixin gets
     * set up correctly.
     *
     * @docauthor Jason Johnston <jason@sencha.com>
     */
    export class Labelable extends Ext.Base implements Ext.form.LabelableConfig {
        /**
         * The div Element wrapping the component's contents. Only available after the component has been rendered.
         */
        bodyEl: Ext.dom.Element;

        /**
         * The div Element that will contain the component's error message(s). Note that depending on the configured
         * {@link #msgTarget}, this element may be hidden in favor of some other form of presentation, but will always
         * be present in the DOM for use by assistive technologies.
         */
        errorEl: Ext.dom.Element;

        /**
         * Flag denoting that this object is labelable as a field. Always true.
         */
        isFieldLabelable: boolean;

        /**
         * The '<TD>' Element which contains the label Element for this component. Only available after the component has been rendered.
         */
        labelCell: Ext.dom.Element;

        /**
         * The label Element for this component. Only available after the component has been rendered.
         */
        labelEl: Ext.dom.Element;

        /**
         * If specified, then the component will be displayed with this value as its active error when first rendered. Use
         * {@link #setActiveError} or {@link #unsetActiveError} to change it after component creation.
         */
        activeError: string;

        /**
         * The template used to format the Array of error messages passed to {@link #setActiveErrors} into a single HTML
         * string. if the {@link #msgTarget} is title, it defaults to a list separated by new lines. Otherwise, it
         * renders each message as an item in an unordered list.
         */
        activeErrorsTpl: string|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * at the end of the input containing element. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        afterBodyEl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the label text. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        afterLabelTextTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the label element. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        afterLabelTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the {@link #getSubTplMarkup subTpl markup}. If an 'XTemplate' is used, the
         * component's {@link Ext.AbstractComponent#renderData render data} serves as the context.
         */
        afterSubTpl: string|any[]|Ext.XTemplate;

        /**
         * Whether to adjust the component's body area to make room for 'side' or 'under' {@link #msgTarget error messages}.
         */
        autoFitErrors: boolean;

        /**
         * The CSS class to be applied to the body content element.
         */
        baseBodyCls: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * at the beginning of the input containing element. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        beforeBodyEl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the label text. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        beforeLabelTextTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the label element. If an 'XTemplate' is used, the component's {@link Ext.AbstractComponent#renderData render data}
         * serves as the context.
         */
        beforeLabelTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the {@link #getSubTplMarkup subTpl markup}. If an 'XTemplate' is used, the
         * component's {@link Ext.AbstractComponent#renderData render data} serves as the context.
         */
        beforeSubTpl: string|any[]|Ext.XTemplate;

        /**
         * The CSS class to be applied to the special clearing div rendered directly after the field contents wrapper to
         * provide field clearing.
         */
        clearCls: string;

        /**
         * The CSS class to be applied to the error message element.
         */
        errorMsgCls: string;

        /**
         * An extra CSS class to be applied to the body content element in addition to {@link #baseBodyCls}.
         */
        fieldBodyCls: string;

        /**
         * The label for the field. It gets appended with the {@link #labelSeparator}, and its position and sizing is
         * determined by the {@link #labelAlign}, {@link #labelWidth}, and {@link #labelPad} configs.
         */
        fieldLabel: string;

        /**
         * A CSS class to be applied to the outermost element to denote that it is participating in the form field layout.
         */
        formItemCls: string;

        /**
         * When set to true, the label element ({@link #fieldLabel} and {@link #labelSeparator}) will be automatically
         * hidden if the {@link #fieldLabel} is empty. Setting this to false will cause the empty label element to be
         * rendered and space to be reserved for it; this is useful if you want a field without a label to line up with
         * other labeled fields in the same form.
         *
         * If you wish to unconditionall hide the label even if a non-empty fieldLabel is configured, then set the
         * {@link #hideLabel} config to true.
         */
        hideEmptyLabel: boolean;

        /**
         * Set to true to completely hide the label element ({@link #fieldLabel} and {@link #labelSeparator}). Also see
         * {@link #hideEmptyLabel}, which controls whether space will be reserved for an empty fieldLabel.
         */
        hideLabel: boolean;

        /**
         * The CSS class to use when marking the component invalid.
         */
        invalidCls: string;

        /**
         * Controls the position and alignment of the {@link #fieldLabel}. Valid values are:
         *
         *   - "left" (the default) - The label is positioned to the left of the field, with its text aligned to the left.
         *     Its width is determined by the {@link #labelWidth} config.
         *   - "top" - The label is positioned above the field.
         *   - "right" - The label is positioned to the left of the field, with its text aligned to the right.
         *     Its width is determined by the {@link #labelWidth} config.
         */
        labelAlign: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * inside the label element (as attributes). If an 'XTemplate' is used, the component's
         * {@link Ext.AbstractComponent#renderData render data} serves as the context.
         */
        labelAttrTpl: string|any[]|Ext.XTemplate;

        /**
         * The CSS class to be applied to the label element. This (single) CSS class is used to formulate the renderSelector
         * and drives the field layout where it is concatenated with a hyphen ('-') and {@link #labelAlign}. To add
         * additional classes, use {@link #labelClsExtra}.
         */
        labelCls: string;

        /**
         * An optional string of one or more additional CSS classes to add to the label element. Defaults to empty.
         */
        labelClsExtra: string;

        /**
         * The amount of space in pixels between the {@link #fieldLabel} and the input field.
         */
        labelPad: number;

        /**
         * Character(s) to be inserted at the end of the {@link #fieldLabel label text}.
         *
         * Set to empty string to hide the separator completely.
         */
        labelSeparator: string;

        /**
         * A CSS style specification string to apply directly to this field's label.
         */
        labelStyle: string;

        /**
         * The width of the {@link #fieldLabel} in pixels. Only applicable if the {@link #labelAlign} is set to "left" or
         * "right".
         */
        labelWidth: number;

        /**
         * The location where the error message text should display. Must be one of the following values:
         *
         *   - 'qtip' Display a quick tip containing the message when the user hovers over the field.
         *     This is the default.
         *
         *     **{@link Ext.tip.QuickTipManager#init} must have been called for this setting to work.**
         *
         *   - 'title' Display the message in a default browser title attribute popup.
         *   - 'under' Add a block div beneath the field containing the error message.
         *   - 'side' Add an error icon to the right of the field, displaying the message in a popup on hover.
         *   - 'none' Don't display any error message. This might be useful if you are implementing custom error display.
         *   - '[element id]' Add the error message directly to the innerHTML of the specified element.
         */
        msgTarget: string;

        /**
         * true to disable displaying any {@link #setActiveError error message} set on this object.
         */
        preventMark: boolean;

        /**
         * Gets the active error message for this component, if any. This does not trigger validation on its own, it merely
         * returns any message that the component may already hold.
         * @return {String} The active error message on the component; if there is no error, an empty string is returned.
         */
        getActiveError(): string;

        /**
         * Gets an Array of any active error messages currently applied to the field. This does not trigger validation on
         * its own, it merely returns any messages that the component may already hold.
         * @return {String[]} The active error messages on the component; if there are no errors, an empty Array is
         * returned.
         */
        getActiveErrors(): string;

        /**
         * Returns the label for the field. Defaults to simply returning the {@link #fieldLabel} config. Can be overridden
         * to provide a custom generated label.
         * @return {String} The configured field label, or empty string if not defined
         */
        getFieldLabel(): string;

        /**
         * Get the input id, if any, for this component. This is used as the "for" attribute on the label element.
         * Implementing subclasses may also use this as e.g. the id for their own input element.
         * @return {String} The input id
         */
        getInputId(): string;

        /**
         * Generates the arguments for the field decorations {@link #labelableRenderTpl rendering template}.
         * @return {Object} The template arguments
         */
        protected getLabelableRenderData(): any;

        /**
         * Gets the width of the label (if visible)
         * @return {Number} The label width
         */
        getLabelWidth(): number;

        /**
         * Gets the markup to be inserted into the outer template's bodyEl. Defaults to empty string, should be implemented
         * by classes including this mixin as needed.
         * @return {String} The markup to be inserted
         */
        protected getSubTplMarkup(): string;

        /**
         * Tells whether the field currently has an active error message. This does not trigger validation on its own, it
         * merely looks for any message that the component may already hold.
         * @return {Boolean}
         */
        hasActiveError(): boolean;

        /**
         * Checks if the field has a visible label
         * @return {Boolean} True if the field has a visible label
         */
        hasVisibleLabel(): boolean;

        /**
         * Performs initialization of this mixin. Component classes using this mixin should call this method during their
         * own initialization.
         */
        initLabelable();

        /**
         * Sets the active error message to the given string. This replaces the entire error message contents with the given
         * string. Also see {@link #setActiveErrors} which accepts an Array of messages and formats them according to the
         * {@link #activeErrorsTpl}. Note that this only updates the error message element's text and attributes, you'll
         * have to call doComponentLayout to actually update the field's layout to match. If the field extends {@link
         * Ext.form.field.Base} you should call {@link Ext.form.field.Base#markInvalid markInvalid} instead.
         * @param {String} msg The error message
         */
        setActiveError(msg: string);

        /**
         * Set the active error message to an Array of error messages. The messages are formatted into a single message
         * string using the {@link #activeErrorsTpl}. Also see {@link #setActiveError} which allows setting the entire error
         * contents with a single string. Note that this only updates the error message element's text and attributes,
         * you'll have to call doComponentLayout to actually update the field's layout to match. If the field extends
         * {@link Ext.form.field.Base} you should call {@link Ext.form.field.Base#markInvalid markInvalid} instead.
         * @param {String[]} errors The error messages
         */
        setActiveErrors(errors: string);

        /**
         * Applies a set of default configuration values to this Labelable instance. For each of the properties in the given
         * object, check if this component hasOwnProperty that config; if not then it's inheriting a default value from its
         * prototype and we should apply the default value.
         * @param {Object} defaults The defaults to apply to the object.
         */
        setFieldDefaults(defaults: any);

        /**
         * Set the label of this field.
         * @param {String} label The new label. The {@link #labelSeparator} will be automatically appended to the label
         * string.
         */
        setFieldLabel(label: string);

        /**
         * Returns the trimmed label by slicing off the label separator character. Can be overridden.
         * @return {String} The trimmed field label, or empty string if not defined
         */
        trimLabelSeparator(): string;

        /**
         * Clears the active error message(s). Note that this only clears the error message element's text and attributes,
         * you'll have to call doComponentLayout to actually update the field's layout to match. If the field extends {@link
         * Ext.form.field.Base} you should call {@link Ext.form.field.Base#clearInvalid clearInvalid} instead.
         */
        unsetActiveError();

        /**
         * Fires when the active error message is changed via {@link #setActiveError}.
         * @param {String} error The active error message
         */
        errorchange(that: Ext.form.Labelable, error: string);
    }

    interface LabelConfig extends Ext.ComponentConfig {
        autoEl?: any;

        /**
         * The id of the input element to which this label will be bound via the standard HTML 'for'
         * attribute. If not specified, the attribute will not be added to the label. In most cases you will be
         * associating the label with a {@link Ext.form.field.Base} component, so you should make sure this matches
         * the {@link Ext.form.field.Base#inputId inputId} of that field.
         */
        forId?: string;

        /**
         * The plain text to display within the label. If you need to include HTML
         * tags within the label's innerHTML, use the {@link #html} config instead.
         *
         * Optional, Defaults to: ''
         */
        text?: string;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * Produces a standalone '<label />' element which can be inserted into a form and be associated with a field
     * in that form using the {@link #forId} property.
     *
     * **NOTE:** in most cases it will be more appropriate to use the {@link Ext.form.Labelable#fieldLabel fieldLabel}
     * and associated config properties ({@link Ext.form.Labelable#labelAlign}, {@link Ext.form.Labelable#labelWidth},
     * etc.) in field components themselves, as that allows labels to be uniformly sized throughout the form.
     * Ext.form.Label should only be used when your layout can not be achieved with the standard
     * {@link Ext.form.Labelable field layout}.
     *
     * You will likely be associating the label with a field component that extends {@link Ext.form.field.Base}, so
     * you should make sure the {@link #forId} is set to the same value as the {@link Ext.form.field.Base#inputId inputId}
     * of that field.
     *
     * The label's text can be set using either the {@link #text} or {@link #html} configuration properties; the
     * difference between the two is that the former will automatically escape HTML characters when rendering, while
     * the latter will not.
     *
     * # Example
     *
     * This example creates a Label after its associated Text field, an arrangement that cannot currently
     * be achieved using the standard Field layout's labelAlign.
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Field with Label',
     *         width: 400,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         layout: {
     *             type: 'hbox',
     *             align: 'middle'
     *         },
     *         items: [{
     *             xtype: 'textfield',
     *             hideLabel: true,
     *             flex: 1
     *         }, {
     *             xtype: 'label',
     *             forId: 'myFieldId',
     *             text: 'My Awesome Field',
     *             margin: '0 0 0 10'
     *         }]
     *     });
     */
    export class Label extends Ext.Component implements Ext.form.LabelConfig {
        autoEl: string|any;

        /**
         * The id of the input element to which this label will be bound via the standard HTML 'for'
         * attribute. If not specified, the attribute will not be added to the label. In most cases you will be
         * associating the label with a {@link Ext.form.field.Base} component, so you should make sure this matches
         * the {@link Ext.form.field.Base#inputId inputId} of that field.
         */
        forId: string;

        /**
         * The plain text to display within the label. If you need to include HTML
         * tags within the label's innerHTML, use the {@link #html} config instead.
         *
         * Optional, Defaults to: ''
         */
        text: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Updates the label's innerHTML with the specified string.
         * @param {String} text The new label text
         * @param {Boolean} [encode=true] False to skip HTML-encoding the text when rendering it
         * to the label. This might be useful if you want to include tags in the label's innerHTML rather
         * than rendering them as string literals per the default logic.
         * @return {Ext.form.Label} this
         */
        setText(text: string, encode?: boolean): Ext.form.Label;
    }

    interface PanelConfig extends Ext.panel.PanelConfig {
        /**
         * The {@link Ext.container.Container#layout} for the form panel's immediate child items.
         */
        layout?: Ext.enums.Layout|any;

        /**
         * If set to 'true', sets up an interval task (using the {@link #pollInterval}) in which the
         * panel's fields are repeatedly checked for changes in their values. This is in addition to the normal detection
         * each field does on its own input element, and is not needed in most cases. It does, however, provide a
         * means to absolutely guarantee detection of all changes including some edge cases in some browsers which
         * do not fire native events. Defaults to 'false'.
         */
        pollForChanges?: boolean;

        /**
         * Interval in milliseconds at which the form's fields are checked for value changes. Only used if
         * the {@link #pollForChanges} option is set to 'true'. Defaults to 500 milliseconds.
         */
        pollInterval?: number;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * FormPanel provides a standard container for forms. It is essentially a standard {@link Ext.panel.Panel} which
     * automatically creates a {@link Ext.form.Basic BasicForm} for managing any {@link Ext.form.field.Field}
     * objects that are added as descendants of the panel. It also includes conveniences for configuring and
     * working with the BasicForm and the collection of Fields.
     *
     * # Layout
     *
     * By default, FormPanel is configured with '{@link Ext.layout.container.Anchor layout:'anchor'}' for
     * the layout of its immediate child items. This can be changed to any of the supported container layouts.
     * The layout of sub-containers is configured in {@link Ext.container.Container#layout the standard way}.
     *
     * # BasicForm
     *
     * Although **not listed** as configuration options of FormPanel, the FormPanel class accepts all
     * of the config options supported by the {@link Ext.form.Basic} class, and will pass them along to
     * the internal BasicForm when it is created.
     *
     * The following events fired by the BasicForm will be re-fired by the FormPanel and can therefore be
     * listened for on the FormPanel itself:
     *
     * - {@link Ext.form.Basic#beforeaction beforeaction}
     * - {@link Ext.form.Basic#actionfailed actionfailed}
     * - {@link Ext.form.Basic#actioncomplete actioncomplete}
     * - {@link Ext.form.Basic#validitychange validitychange}
     * - {@link Ext.form.Basic#dirtychange dirtychange}
     *
     * # Field Defaults
     *
     * The {@link #fieldDefaults} config option conveniently allows centralized configuration of default values
     * for all fields added as descendants of the FormPanel. Any config option recognized by implementations
     * of {@link Ext.form.Labelable} may be included in this object. See the {@link #fieldDefaults} documentation
     * for details of how the defaults are applied.
     *
     * # Form Validation
     *
     * With the default configuration, form fields are validated on-the-fly while the user edits their values.
     * This can be controlled on a per-field basis (or via the {@link #fieldDefaults} config) with the field
     * config properties {@link Ext.form.field.Field#validateOnChange} and {@link Ext.form.field.Base#checkChangeEvents},
     * and the FormPanel's config properties {@link #pollForChanges} and {@link #pollInterval}.
     *
     * Any component within the FormPanel can be configured with 'formBind: true'. This will cause that
     * component to be automatically disabled when the form is invalid, and enabled when it is valid. This is most
     * commonly used for Button components to prevent submitting the form in an invalid state, but can be used on
     * any component type.
     *
     * For more information on form validation see the following:
     *
     * - {@link Ext.form.field.Field#validateOnChange}
     * - {@link #pollForChanges} and {@link #pollInterval}
     * - {@link Ext.form.field.VTypes}
     * - {@link Ext.form.Basic#doAction BasicForm.doAction clientValidation notes}
     *
     * # Form Submission
     *
     * By default, Ext Forms are submitted through Ajax, using {@link Ext.form.action.Action}. See the documentation for
     * {@link Ext.form.Basic} for details.
     *
     * # Example usage
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Simple Form',
     *         bodyPadding: 5,
     *         width: 350,
     *
     *         // The form will submit an AJAX request to this URL when submitted
     *         url: 'save-form.php',
     *
     *         // Fields will be arranged vertically, stretched to full width
     *         layout: 'anchor',
     *         defaults: {
     *             anchor: '100%'
     *         },
     *
     *         // The fields
     *         defaultType: 'textfield',
     *         items: [{
     *             fieldLabel: 'First Name',
     *             name: 'first',
     *             allowBlank: false
     *         },{
     *             fieldLabel: 'Last Name',
     *             name: 'last',
     *             allowBlank: false
     *         }],
     *
     *         // Reset and Submit buttons
     *         buttons: [{
     *             text: 'Reset',
     *             handler: function() {
     *                 this.up('form').getForm().reset();
     *             }
     *         }, {
     *             text: 'Submit',
     *             formBind: true, //only enabled once the form is valid
     *             disabled: true,
     *             handler: function() {
     *                 var form = this.up('form').getForm();
     *                 if (form.isValid()) {
     *                     form.submit({
     *                         success: function(form, action) {
     *                            Ext.Msg.alert('Success', action.result.msg);
     *                         },
     *                         failure: function(form, action) {
     *                             Ext.Msg.alert('Failed', action.result.msg);
     *                         }
     *                     });
     *                 }
     *             }
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Panel extends Ext.panel.Panel implements Ext.form.PanelConfig {
        /**
         * The {@link Ext.container.Container#layout} for the form panel's immediate child items.
         */
        layout: Ext.enums.Layout|any;

        /**
         * If set to 'true', sets up an interval task (using the {@link #pollInterval}) in which the
         * panel's fields are repeatedly checked for changes in their values. This is in addition to the normal detection
         * each field does on its own input element, and is not needed in most cases. It does, however, provide a
         * means to absolutely guarantee detection of all changes including some edge cases in some browsers which
         * do not fire native events. Defaults to 'false'.
         */
        pollForChanges: boolean;

        /**
         * Interval in milliseconds at which the form's fields are checked for value changes. Only used if
         * the {@link #pollForChanges} option is set to 'true'. Defaults to 500 milliseconds.
         */
        pollInterval: number;

        /**
         * Forces each field within the form panel to
         * {@link Ext.form.field.Field#checkChange check if its value has changed}.
         */
        checkChange();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Provides access to the {@link Ext.form.Basic Form} which this Panel contains.
         * @return {Ext.form.Basic} The {@link Ext.form.Basic Form} which this Panel contains.
         */
        getForm(): Ext.form.Basic;

        /**
         * Returns the currently loaded Ext.data.Model instance if one was loaded via {@link #loadRecord}.
         * @return {Ext.data.Model} The loaded instance
         */
        getRecord(): Ext.data.Model;

        /**
         * Convenience function for fetching the current value of each field in the form. This is the same as calling
         * {@link Ext.form.Basic#getValues this.getForm().getValues()}.
         */
        getValues();

        /**
         * Convenience function to check if the form has any invalid fields. This is the same as calling
         * {@link Ext.form.Basic#hasInvalidField this.getForm().hasInvalidField()}.
         */
        hasInvalidField();

        /**
         * Convenience function to check if the form has any dirty fields. This is the same as calling
         * {@link Ext.form.Basic#isDirty this.getForm().isDirty()}.
         */
        isDirty();

        /**
         * Convenience function to check if the form has all valid fields. This is the same as calling
         * {@link Ext.form.Basic#isValid this.getForm().isValid()}.
         */
        isValid();

        /**
         * This is a proxy for the underlying BasicForm's {@link Ext.form.Basic#load} call.
         * @param {Object} options The options to pass to the action (see {@link Ext.form.Basic#load} and
         * {@link Ext.form.Basic#doAction} for details)
         */
        load(options: any);

        /**
         * Loads an {@link Ext.data.Model} into this form (internally just calls {@link Ext.form.Basic#loadRecord})
         * See also {@link Ext.form.Basic#trackResetOnLoad trackResetOnLoad}.
         * @param {Ext.data.Model} record The record to load
         * @return {Ext.form.Basic} The Ext.form.Basic attached to this FormPanel
         */
        loadRecord(record: Ext.data.Model): Ext.form.Basic;

        /**
         * Start an interval task to continuously poll all the fields in the form for changes in their
         * values. This is normally started automatically by setting the {@link #pollForChanges} config.
         * @param {Number} interval The interval in milliseconds at which the check should run.
         */
        startPolling(interval: number);

        /**
         * Stop a running interval task that was started by {@link #startPolling}.
         */
        stopPolling();

        /**
         * This is a proxy for the underlying BasicForm's {@link Ext.form.Basic#submit} call.
         * @param {Object} options The options to pass to the action (see {@link Ext.form.Basic#submit} and
         * {@link Ext.form.Basic#doAction} for details)
         */
        submit(options: any);

        /**
         * Persists the values in this form into the passed {@link Ext.data.Model} object in a beginEdit/endEdit block.
         * If the record is not specified, it will attempt to update (if it exists) the record provided to {@link #loadRecord}.
         * @param {Ext.data.Model} [record] The record to edit
         * @return {Ext.form.Basic} The Ext.form.Basic attached to this FormPanel
         */
        updateRecord(record?: Ext.data.Model): Ext.form.Basic;

        actioncomplete();

        actionfailed();

        beforeaction();

        dirtychange();

        validitychange();
    }

    interface RadioGroupConfig extends Ext.form.CheckboxGroupConfig {
        /**
         * True to allow every item in the group to be blank.
         * If allowBlank = false and no items are selected at validation time, {@link #blankText} will
         * be used as the error text.
         */
        allowBlank?: boolean;

        /**
         * Error text to display if the {@link #allowBlank} validation fails
         */
        blankText?: string;

        defaultType?: any;
    }

    /**
     * A {@link Ext.form.FieldContainer field container} which has a specialized layout for arranging
     * {@link Ext.form.field.Radio} controls into columns, and provides convenience {@link Ext.form.field.Field}
     * methods for {@link #getValue getting}, {@link #setValue setting}, and {@link #validate validating} the
     * group of radio buttons as a whole.
     *
     * # Validation
     *
     * Individual radio buttons themselves have no default validation behavior, but
     * sometimes you want to require a user to select one of a group of radios. RadioGroup
     * allows this by setting the config '{@link #allowBlank}:false'; when the user does not check at
     * one of the radio buttons, the entire group will be highlighted as invalid and the
     * {@link #blankText error message} will be displayed according to the {@link #msgTarget} config.
     *
     * # Layout
     *
     * The default layout for RadioGroup makes it easy to arrange the radio buttons into
     * columns; see the {@link #columns} and {@link #vertical} config documentation for details. You may also
     * use a completely different layout by setting the {@link #layout} to one of the other supported layout
     * types; for instance you may wish to use a custom arrangement of hbox and vbox containers. In that case
     * the Radio components at any depth will still be managed by the RadioGroup's validation.
     *
     * # Example usage
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'RadioGroup Example',
     *         width: 300,
     *         height: 125,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items:[{
     *             xtype: 'radiogroup',
     *             fieldLabel: 'Two Columns',
     *             // Arrange radio buttons into two columns, distributed vertically
     *             columns: 2,
     *             vertical: true,
     *             items: [
     *                 { boxLabel: 'Item 1', name: 'rb', inputValue: '1' },
     *                 { boxLabel: 'Item 2', name: 'rb', inputValue: '2', checked: true},
     *                 { boxLabel: 'Item 3', name: 'rb', inputValue: '3' },
     *                 { boxLabel: 'Item 4', name: 'rb', inputValue: '4' },
     *                 { boxLabel: 'Item 5', name: 'rb', inputValue: '5' },
     *                 { boxLabel: 'Item 6', name: 'rb', inputValue: '6' }
     *             ]
     *         }]
     *     });
     */
    export class RadioGroup extends Ext.form.CheckboxGroup implements Ext.form.RadioGroupConfig {
        /**
         * True to allow every item in the group to be blank.
         * If allowBlank = false and no items are selected at validation time, {@link #blankText} will
         * be used as the error text.
         */
        allowBlank: boolean;

        /**
         * Error text to display if the {@link #allowBlank} validation fails
         */
        blankText: string;

        defaultType: string;

        checkChange();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Sets the value of the radio group. The radio with corresponding name and value will be set.
         * This method is simpler than {@link Ext.form.CheckboxGroup#setValue} because only 1 value is allowed
         * for each name.
         *
         * @param {Object} value The map from names to values to be set.
         * @return {Ext.form.CheckboxGroup} this
         */
        setValue(value: any): Ext.form.CheckboxGroup;
    }

    /**
     * Private utility class for managing all {@link Ext.form.field.Radio} fields grouped by name.
     */
    export class RadioManager {
        /**
         * Creates new MixedCollection.
         * @param {Object} config A configuration object.
         *  @param {Boolean} [config.allowFunctions=false] Specify 'true' if the {@link #addAll}
         * function should add function references to the collection.
         *  @param {Function} [config.getKey] A function that can accept an item of the type(s) stored in this MixedCollection
         * and return the key value for that item.  This is used when available to look up the key on items that
         * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
         * equivalent to overriding the {@link #method-getKey} method.
         */
        constructor(config: Ext.util.MixedCollectionConfig);
    }
}

declare module Ext.form.action {
    interface ActionConfig {
        /**
         * The function to call when a failure packet was received, or when an error ocurred in the Ajax communication.
         * The form that requested the action
         * The Action class. If an Ajax error ocurred, the failure type will
         * be in {@link #failureType}. The {@link #result} property of this object may be examined to perform custom
         * postprocessing.
         */
        failure?: Function;

        /**
         * The {@link Ext.form.Basic BasicForm} instance that is invoking this Action. Required.
         */
        form?: Ext.form.Basic;

        /**
         * Extra headers to be sent in the AJAX request for submit and load actions.
         * See {@link Ext.data.proxy.Ajax#headers}.
         *
         * **Note:** Headers are not sent during file upload.
         */
        headers?: any;

        /**
         * The HTTP method to use to access the requested URL.
         * Defaults to the {@link Ext.form.Basic#method BasicForm's method}, or 'POST' if not specified.
         */
        method?: string;

        /**
         * Extra parameter values to pass. These are added to the Form's {@link Ext.form.Basic#baseParams} and passed to the
         * specified URL along with the Form's input fields.
         *
         * Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode Ext.Object.toQueryString}.
         */
        params?: any|string;

        /**
         * When set to **true**, causes the Form to be {@link Ext.form.Basic#reset reset} on Action success. If specified,
         * this happens before the {@link #success} callback is called and before the Form's
         * {@link Ext.form.Basic#actioncomplete actioncomplete} event fires.
         */
        reset?: boolean;

        /**
         * The scope in which to call the configured #success and #failure callback functions
         * (the 'this' reference for the callback functions).
         */
        scope?: any;

        /**
         * If set to true, the emptyText value will be sent with the form when it is submitted.
         */
        submitEmptyText?: boolean;

        /**
         * The function to call when a valid success return packet is received.
         * The form that requested the action
         * The Action class. The {@link #result} property of this object may
         * be examined to perform custom postprocessing.
         */
        success?: Function;

        /**
         * The number of seconds to wait for a server response before failing with the {@link #failureType} as
         * {@link Ext.form.action.Action#CONNECT_FAILURE}. If not specified, defaults to the configured
         * {@link Ext.form.Basic#timeout timeout} of the {@link #form}.
         */
        timeout?: number;

        /**
         * The URL that the Action is to invoke. Will default to the {@link Ext.form.Basic#url url} configured on the
         * {@link #form}.
         */
        url?: string;

        /**
         * The message to be displayed by a call to {@link Ext.window.MessageBox#wait} during the time the action is being
         * processed.
         */
        waitMsg?: string;

        /**
         * The title to be displayed by a call to {@link Ext.window.MessageBox#wait} during the time the action is being
         * processed.
         */
        waitTitle?: string;
    }

    /**
     * The subclasses of this class provide actions to perform upon {@link Ext.form.Basic Form}s.
     *
     * Instances of this class are only created by a {@link Ext.form.Basic Form} when the Form needs to perform an action
     * such as submit or load. The Configuration options listed for this class are set through the Form's action methods:
     * {@link Ext.form.Basic#submit submit}, {@link Ext.form.Basic#load load} and {@link Ext.form.Basic#doAction doAction}
     *
     * The instance of Action which performed the action is passed to the success and failure callbacks of the Form's action
     * methods ({@link Ext.form.Basic#submit submit}, {@link Ext.form.Basic#load load} and
     * {@link Ext.form.Basic#doAction doAction}), and to the {@link Ext.form.Basic#actioncomplete actioncomplete} and
     * {@link Ext.form.Basic#actionfailed actionfailed} event handlers.
     */
    export class Action extends Ext.Base implements Ext.form.action.ActionConfig {
        /**
         * The type of failure detected will be one of these:
         * {@link #CLIENT_INVALID}, {@link #SERVER_INVALID}, {@link #CONNECT_FAILURE}, or {@link #LOAD_FAILURE}.
         *
         * Usage:
         *
         *     var fp = new Ext.form.Panel({
         *     ...
         *     buttons: [{
         *         text: 'Save',
         *         formBind: true,
         *         handler: function(){
         *             if(fp.getForm().isValid()){
         *                 fp.getForm().submit({
         *                     url: 'form-submit.php',
         *                     waitMsg: 'Submitting your data...',
         *                     success: function(form, action){
         *                         // server responded with success = true
         *                         var result = action.{@link #result};
         *                     },
         *                     failure: function(form, action){
         *                         if (action.{@link #failureType} === Ext.form.action.Action.CONNECT_FAILURE) {
         *                             Ext.Msg.alert('Error',
         *                                 'Status:'+action.{@link #response}.status+': '+
         *                                 action.{@link #response}.statusText);
         *                         }
         *                         if (action.failureType === Ext.form.action.Action.SERVER_INVALID){
         *                             // server responded with success = false
         *                             Ext.Msg.alert('Invalid', action.{@link #result}.errormsg);
         *                         }
         *                     }
         *                 });
         *             }
         *         }
         *     },{
         *         text: 'Reset',
         *         handler: function(){
         *             fp.getForm().reset();
         *         }
         *     }]
         */
        failureType: string;

        /**
         * The raw XMLHttpRequest object used to perform the action.
         */
        response: any;

        /**
         * The decoded response object containing a boolean 'success' property and other, action-specific properties.
         */
        result: any;

        /**
         * The type of action this Action instance performs. Currently only "submit" and "load" are supported.
         */
        type: string;

        /**
         * The function to call when a failure packet was received, or when an error ocurred in the Ajax communication.
         * The form that requested the action
         * The Action class. If an Ajax error ocurred, the failure type will
         * be in {@link #failureType}. The {@link #result} property of this object may be examined to perform custom
         * postprocessing.
         */
        failure: Function;

        /**
         * The {@link Ext.form.Basic BasicForm} instance that is invoking this Action. Required.
         */
        form: Ext.form.Basic;

        /**
         * Extra headers to be sent in the AJAX request for submit and load actions.
         * See {@link Ext.data.proxy.Ajax#headers}.
         *
         * **Note:** Headers are not sent during file upload.
         */
        headers: any;

        /**
         * The HTTP method to use to access the requested URL.
         * Defaults to the {@link Ext.form.Basic#method BasicForm's method}, or 'POST' if not specified.
         */
        method: string;

        /**
         * Extra parameter values to pass. These are added to the Form's {@link Ext.form.Basic#baseParams} and passed to the
         * specified URL along with the Form's input fields.
         *
         * Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode Ext.Object.toQueryString}.
         */
        params: any|string;

        /**
         * When set to **true**, causes the Form to be {@link Ext.form.Basic#reset reset} on Action success. If specified,
         * this happens before the {@link #success} callback is called and before the Form's
         * {@link Ext.form.Basic#actioncomplete actioncomplete} event fires.
         */
        reset: boolean;

        /**
         * The scope in which to call the configured #success and #failure callback functions
         * (the 'this' reference for the callback functions).
         */
        scope: any;

        /**
         * If set to true, the emptyText value will be sent with the form when it is submitted.
         */
        submitEmptyText: boolean;

        /**
         * The function to call when a valid success return packet is received.
         * The form that requested the action
         * The Action class. The {@link #result} property of this object may
         * be examined to perform custom postprocessing.
         */
        success: Function;

        /**
         * The number of seconds to wait for a server response before failing with the {@link #failureType} as
         * {@link Ext.form.action.Action#CONNECT_FAILURE}. If not specified, defaults to the configured
         * {@link Ext.form.Basic#timeout timeout} of the {@link #form}.
         */
        timeout: number;

        /**
         * The URL that the Action is to invoke. Will default to the {@link Ext.form.Basic#url url} configured on the
         * {@link #form}.
         */
        url: string;

        /**
         * The message to be displayed by a call to {@link Ext.window.MessageBox#wait} during the time the action is being
         * processed.
         */
        waitMsg: string;

        /**
         * The title to be displayed by a call to {@link Ext.window.MessageBox#wait} during the time the action is being
         * processed.
         */
        waitTitle: string;

        /**
         * Creates new Action.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.form.action.ActionConfig);

        /**
         * Invokes this action using the current configuration.
         */
        run();

        /**
         * Failure type returned when client side validation of the Form fails thus aborting a submit action. Client
         * side validation is performed unless {@link Ext.form.action.Submit#clientValidation} is explicitly set to
         * false.
         */
        static CLIENT_INVALID: any;

        /**
         * Failure type returned when a communication error happens when attempting to send a request to the remote
         * server. The {@link #response} may be examined to provide further information.
         */
        static CONNECT_FAILURE: any;

        /**
         * Failure type returned when the response's 'success' property is set to false, or no field values are returned
         * in the response's data property.
         */
        static LOAD_FAILURE: any;

        /**
         * Failure type returned when server side processing fails and the {@link #result}'s 'success' property is set to
         * false.
         *
         * In the case of a form submission, field-specific error messages may be returned in the {@link #result}'s
         * errors property.
         */
        static SERVER_INVALID: any;
    }

    /**
     * Provides {@link Ext.direct.Manager} support for loading form data.
     *
     * This example illustrates usage of Ext.direct.Direct to **load** a form through Ext.Direct.
     *
     *     var myFormPanel = new Ext.form.Panel({
     *         // configs for FormPanel
     *         title: 'Basic Information',
     *         renderTo: document.body,
     *         width: 300, height: 160,
     *         padding: 10,
     *
     *         // configs apply to child items
     *         defaults: {anchor: '100%'},
     *         defaultType: 'textfield',
     *         items: [{
     *             fieldLabel: 'Name',
     *             name: 'name'
     *         },{
     *             fieldLabel: 'Email',
     *             name: 'email'
     *         },{
     *             fieldLabel: 'Company',
     *             name: 'company'
     *         }],
     *
     *         // configs for BasicForm
     *         api: {
     *             // The server-side method to call for load() requests
     *             load: Profile.getBasicInfo,
     *             // The server-side must mark the submit handler as a 'formHandler'
     *             submit: Profile.updateBasicInfo
     *         },
     *         // specify the order for the passed params
     *         paramOrder: ['uid', 'foo']
     *     });
     *
     *     // load the form
     *     myFormPanel.getForm().load({
     *         // pass 2 arguments to server side getBasicInfo method (len=2)
     *         params: {
     *             foo: 'bar',
     *             uid: 34
     *         }
     *     });
     *
     * The data packet sent to the server will resemble something like:
     *
     *     [
     *         {
     *             "action":"Profile","method":"getBasicInfo","type":"rpc","tid":2,
     *             "data":[34,"bar"] // note the order of the params
     *         }
     *     ]
     *
     * The form will process a data packet returned by the server that is similar to the following format:
     *
     *     [
     *         {
     *             "action":"Profile","method":"getBasicInfo","type":"rpc","tid":2,
     *             "result":{
     *                 "success":true,
     *                 "data":{
     *                     "name":"Fred Flintstone",
     *                     "company":"Slate Rock and Gravel",
     *                     "email":"fred.flintstone@slaterg.com"
     *                 }
     *             }
     *         }
     *     ]
     */
    export class DirectLoad extends Ext.form.action.Load {
        type: string;

        /**
         * Creates new Action.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.form.action.ActionConfig);
    }

    /**
     * Provides Ext.direct support for submitting form data.
     *
     * This example illustrates usage of Ext.direct.Direct to **submit** a form through Ext.Direct.
     *
     *     var myFormPanel = new Ext.form.Panel({
     *         // configs for FormPanel
     *         title: 'Basic Information',
     *         renderTo: document.body,
     *         width: 300, height: 160,
     *         padding: 10,
     *         buttons:[{
     *             text: 'Submit',
     *             handler: function(){
     *                 myFormPanel.getForm().submit({
     *                     params: {
     *                         foo: 'bar',
     *                         uid: 34
     *                     }
     *                 });
     *             }
     *         }],
     *
     *         // configs apply to child items
     *         defaults: {anchor: '100%'},
     *         defaultType: 'textfield',
     *         items: [{
     *             fieldLabel: 'Name',
     *             name: 'name'
     *         },{
     *             fieldLabel: 'Email',
     *             name: 'email'
     *         },{
     *             fieldLabel: 'Company',
     *             name: 'company'
     *         }],
     *
     *         // configs for BasicForm
     *         api: {
     *             // The server-side method to call for load() requests
     *             load: Profile.getBasicInfo,
     *             // The server-side must mark the submit handler as a 'formHandler'
     *             submit: Profile.updateBasicInfo
     *         },
     *         // specify the order for the passed params
     *         paramOrder: ['uid', 'foo']
     *     });
     *
     * The data packet sent to the server will resemble something like:
     *
     *     {
     *         "action":"Profile","method":"updateBasicInfo","type":"rpc","tid":"6",
     *         "result":{
     *             "success":true,
     *             "id":{
     *                 "extAction":"Profile","extMethod":"updateBasicInfo",
     *                 "extType":"rpc","extTID":"6","extUpload":"false",
     *                 "name":"Aaron Conran","email":"aaron@sencha.com","company":"Sencha Inc."
     *             }
     *         }
     *     }
     *
     * The form will process a data packet returned by the server that is similar to the following:
     *
     *     // sample success packet (batched requests)
     *     [
     *         {
     *             "action":"Profile","method":"updateBasicInfo","type":"rpc","tid":3,
     *             "result":{
     *                 "success":true
     *             }
     *         }
     *     ]
     *
     *     // sample failure packet (one request)
     *     {
     *             "action":"Profile","method":"updateBasicInfo","type":"rpc","tid":"6",
     *             "result":{
     *                 "errors":{
     *                     "email":"already taken"
     *                 },
     *                 "success":false,
     *                 "foo":"bar"
     *             }
     *     }
     *
     * Also see the discussion in {@link Ext.form.action.DirectLoad}.
     */
    export class DirectSubmit extends Ext.form.action.Submit {
        type: string;

        /**
         * Creates new Action.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.form.action.ActionConfig);
    }

    /**
     * A class which handles loading of data from a server into the Fields of an {@link Ext.form.Basic}.
     *
     * Instances of this class are only created by a {@link Ext.form.Basic Form} when {@link Ext.form.Basic#load load}ing.
     *
     * ## Response Packet Criteria
     *
     * A response packet **must** contain:
     *
     *   - **'success'** property : Boolean
     *   - **'data'** property : Object
     *
     * The 'data' property contains the values of Fields to load. The individual value object for each Field is passed to
     * the Field's {@link Ext.form.field.Field#setValue setValue} method.
     *
     * ## JSON Packets
     *
     * By default, response packets are assumed to be JSON, so for the following form load call:
     *
     *     var myFormPanel = new Ext.form.Panel({
     *         title: 'Client and routing info',
     *         renderTo: Ext.getBody(),
     *         defaults: {
     *             xtype: 'textfield'
     *         },
     *         items: [{
     *             fieldLabel: 'Client',
     *             name: 'clientName'
     *         }, {
     *             fieldLabel: 'Port of loading',
     *             name: 'portOfLoading'
     *         }, {
     *             fieldLabel: 'Port of discharge',
     *             name: 'portOfDischarge'
     *         }]
     *     });
     *     myFormPanel.{@link Ext.form.Panel#getForm getForm}().{@link Ext.form.Basic#load load}({
     *         url: '/getRoutingInfo.php',
     *         params: {
     *             consignmentRef: myConsignmentRef
     *         },
     *         failure: function(form, action) {
     *             Ext.Msg.alert("Load failed", action.result.errorMessage);
     *         }
     *     });
     *
     * a **success response** packet may look like this:
     *
     *     {
     *         success: true,
     *         data: {
     *             clientName: "Fred. Olsen Lines",
     *             portOfLoading: "FXT",
     *             portOfDischarge: "OSL"
     *         }
     *     }
     *
     * while a **failure response** packet may look like this:
     *
     *     {
     *         success: false,
     *         errorMessage: "Consignment reference not found"
     *     }
     *
     * Other data may be placed into the response for processing the {@link Ext.form.Basic Form}'s callback or event handler
     * methods. The object decoded from this JSON is available in the {@link Ext.form.action.Action#result result} property.
     */
    export class Load extends Ext.form.action.Action {
        type: string;

        /**
         * Creates new Action.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.form.action.ActionConfig);
    }

    interface StandardSubmitConfig extends Ext.form.action.SubmitConfig {
        /**
         * Optional target attribute to be used for the form when submitting.
         *
         * Defaults to the current window/frame.
         */
        target?: string;
    }

    /**
     * A class which handles submission of data from {@link Ext.form.Basic Form}s using a standard '<form>' element submit.
     * It does not handle the response from the submit.
     *
     * If validation of the form fields fails, the Form's afterAction method will be called. Otherwise, afterAction will not
     * be called.
     *
     * Instances of this class are only created by a {@link Ext.form.Basic Form} when
     * {@link Ext.form.Basic#submit submit}ting, when the form's {@link Ext.form.Basic#standardSubmit} config option is true.
     */
    export class StandardSubmit extends Ext.form.action.Submit implements Ext.form.action.StandardSubmitConfig {
        /**
         * Optional target attribute to be used for the form when submitting.
         *
         * Defaults to the current window/frame.
         */
        target: string;

        /**
         * Creates new Action.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.form.action.ActionConfig);
    }

    interface SubmitConfig extends Ext.form.action.ActionConfig {
        /**
         * Determines whether a Form's fields are validated in a final call to {@link Ext.form.Basic#isValid isValid} prior
         * to submission. Pass false in the Form's submit options to prevent this.
         *
         * Optional, Defaults to: true
         */
        clientValidation?: boolean;
    }

    /**
     * A class which handles submission of data from {@link Ext.form.Basic Form}s and processes the returned response.
     *
     * Instances of this class are only created by a {@link Ext.form.Basic Form} when
     * {@link Ext.form.Basic#submit submit}ting.
     *
     * # Response Packet Criteria
     *
     * A response packet may contain:
     *
     *   - **'success'** property : Boolean - required.
     *
     *   - **'errors'** property : Object - optional, contains error messages for invalid fields.
     *
     * # JSON Packets
     *
     * By default, response packets are assumed to be JSON, so a typical response packet may look like this:
     *
     *     {
     *         success: false,
     *         errors: {
     *             clientCode: "Client not found",
     *             portOfLoading: "This field must not be null"
     *         }
     *     }
     *
     * Other data may be placed into the response for processing by the {@link Ext.form.Basic}'s callback or event handler
     * methods. The object decoded from this JSON is available in the {@link Ext.form.action.Action#result result} property.
     *
     * Alternatively, if an {@link Ext.form.Basic#errorReader errorReader} is specified as an
     * {@link Ext.data.reader.Xml XmlReader}:
     *
     *     errorReader: new Ext.data.reader.Xml({
     *             record : 'field',
     *             success: '@success'
     *         }, [
     *             'id', 'msg'
     *         ]
     *     )
     *
     * then the results may be sent back in XML format:
     *
     *     <?xml version="1.0" encoding="UTF-8"?>
     *     <message success="false">
     *     <errors>
     *         <field>
     *             <id>clientCode</id>
     *             <msg><![CDATA[Code not found. <br /><i>This is a test validation message from the server </i>]]></msg>
     *         </field>
     *         <field>
     *             <id>portOfLoading</id>
     *             <msg><![CDATA[Port not found. <br /><i>This is a test validation message from the server </i>]]></msg>
     *         </field>
     *     </errors>
     *     </message>
     *
     * Other elements may be placed into the response XML for processing by the {@link Ext.form.Basic}'s callback or event
     * handler methods. The XML document is available in the {@link Ext.form.Basic#errorReader errorReader}'s
     * {@link Ext.data.reader.Xml#xmlData xmlData} property.
     */
    export class Submit extends Ext.form.action.Action implements Ext.form.action.SubmitConfig {
        type: string;

        /**
         * Determines whether a Form's fields are validated in a final call to {@link Ext.form.Basic#isValid isValid} prior
         * to submission. Pass false in the Form's submit options to prevent this.
         *
         * Optional, Defaults to: true
         */
        clientValidation: boolean;

        /**
         * Creates new Action.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.form.action.ActionConfig);

        run();
    }
}

declare module Ext.form.field {
    interface BaseConfig extends Ext.ComponentConfig {
        baseCls?: any;

        /**
         * Defines a timeout in milliseconds for buffering {@link #checkChangeEvents} that fire in rapid succession.
         * Defaults to 50 milliseconds.
         */
        checkChangeBuffer?: number;

        /**
         * A list of event names that will be listened for on the field's {@link #inputEl input element}, which will cause
         * the field's value to be checked for changes. If a change is detected, the {@link #change change event} will be
         * fired, followed by validation if the {@link #validateOnChange} option is enabled.
         *
         * Defaults to ['change', 'propertychange', 'keyup'] in Internet Explorer, and ['change', 'input', 'textInput', 'keyup',
         * 'dragdrop'] in other browsers. This catches all the ways that field values can be changed in most supported
         * browsers; the only known exceptions at the time of writing are:
         *
         *   - Safari 3.2 and older: cut/paste in textareas via the context menu, and dragging text into textareas
         *   - Opera 10 and 11: dragging text into text fields and textareas, and cut via the context menu in text fields
         *     and textareas
         *   - Opera 9: Same as Opera 10 and 11, plus paste from context menu in text fields and textareas
         *
         * If you need to guarantee on-the-fly change notifications including these edge cases, you can call the
         * {@link #checkChange} method on a repeating interval, e.g. using {@link Ext.TaskManager}, or if the field is within
         * a {@link Ext.form.Panel}, you can use the FormPanel's {@link Ext.form.Panel#pollForChanges} configuration to set up
         * such a task automatically.
         */
        checkChangeEvents?: string;

        componentLayout?: any;

        /**
         * The CSS class to use when the field value {@link #isDirty is dirty}.
         */
        dirtyCls?: string;

        /**
         * The default CSS class for the field input
         *
         * Optional, Defaults to: 'x-form-field'
         */
        fieldCls?: string;

        /**
         * Optional CSS style(s) to be applied to the {@link #inputEl field input element}. Should be a valid argument to
         * {@link Ext.Element#applyStyles}. Defaults to undefined. See also the {@link #setFieldStyle} method for changing
         * the style after initialization.
         */
        fieldStyle?: string;

        /**
         * The CSS class to use when the field receives focus
         *
         * Optional, Defaults to: 'x-form-focus'
         */
        focusCls?: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * inside the input element (as attributes). If an 'XTemplate' is used, the component's
         * {@link #getSubTplData subTpl data} serves as the context.
         */
        inputAttrTpl?: string|any[]|Ext.XTemplate;

        /**
         * The id that will be given to the generated input DOM element. Defaults to an automatically generated id. If you
         * configure this manually, you must make sure it is unique in the document.
         */
        inputId?: string;

        /**
         * The type attribute for input fields -- e.g. radio, text, password, file. The extended types
         * supported by HTML5 inputs (url, email, etc.) may also be used, though using them will cause older browsers to
         * fall back to 'text'.
         *
         * The type 'password' must be used to render that field type currently -- there is no separate Ext component for
         * that. You can use {@link Ext.form.field.File} which creates a custom-rendered file upload field, but if you want
         * a plain unstyled file input you can use a Base with inputType:'file'.
         */
        inputType?: string;

        /**
         * The error text to use when marking a field invalid and no message is provided
         */
        invalidText?: string;

        /**
         * The name of the field. This is used as the parameter name when including the field value
         * in a {@link Ext.form.Basic#submit form submit()}. If no name is configured, it falls back to the {@link #inputId}.
         * To prevent the field from being included in the form submit, set {@link #submitValue} to false.
         */
        name?: string;

        /**
         * true to mark the field as readOnly in HTML.
         *
         * **Note**: this only sets the element's readOnly DOM attribute. Setting 'readOnly=true', for example, will not
         * disable triggering a ComboBox or Date; it gives you the option of forcing the user to choose via the trigger
         * without typing in the text box. To hide the trigger use '{@link Ext.form.field.Trigger#hideTrigger hideTrigger}'.
         */
        readOnly?: boolean;

        /**
         * The CSS class applied to the component's main element when it is {@link #readOnly}.
         */
        readOnlyCls?: string;

        /**
         * The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via
         * applyTo
         */
        tabIndex?: number;

        /**
         * Whether the field should validate when it loses focus. This will cause fields to be validated
         * as the user steps through the fields in the form regardless of whether they are making changes to those fields
         * along the way. See also {@link #validateOnChange}.
         */
        validateOnBlur?: boolean;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * Base class for form fields that provides default event handling, rendering, and other common functionality
     * needed by all form field types. Utilizes the {@link Ext.form.field.Field} mixin for value handling and validation,
     * and the {@link Ext.form.Labelable} mixin to provide label and error message display.
     *
     * In most cases you will want to use a subclass, such as {@link Ext.form.field.Text} or {@link Ext.form.field.Checkbox},
     * rather than creating instances of this class directly. However if you are implementing a custom form field,
     * using this as the parent class is recommended.
     *
     * # Values and Conversions
     *
     * Because Base implements the Field mixin, it has a main value that can be initialized with the
     * {@link #value} config and manipulated via the {@link #getValue} and {@link #setValue} methods. This main
     * value can be one of many data types appropriate to the current field, for instance a {@link Ext.form.field.Date Date}
     * field would use a JavaScript Date object as its value type. However, because the field is rendered as a HTML
     * input, this value data type can not always be directly used in the rendered field.
     *
     * Therefore Base introduces the concept of a "raw value". This is the value of the rendered HTML input field,
     * and is normally a String. The {@link #getRawValue} and {@link #setRawValue} methods can be used to directly
     * work with the raw value, though it is recommended to use getValue and setValue in most cases.
     *
     * Conversion back and forth between the main value and the raw value is handled by the {@link #valueToRaw} and
     * {@link #rawToValue} methods. If you are implementing a subclass that uses a non-String value data type, you
     * should override these methods to handle the conversion.
     *
     * # Rendering
     *
     * The content of the field body is defined by the {@link #fieldSubTpl} XTemplate, with its argument data
     * created by the {@link #getSubTplData} method. Override this template and/or method to create custom
     * field renderings.
     *
     * # Example usage:
     *
     *     @example
     *     // A simple subclass of Base that creates a HTML5 search field. Redirects to the
     *     // searchUrl when the Enter key is pressed.222
     *     Ext.define('Ext.form.SearchField', {
     *         extend: 'Ext.form.field.Base',
     *         alias: 'widget.searchfield',
     *
     *         inputType: 'search',
     *
     *         // Config defining the search URL
     *         searchUrl: 'http://www.google.com/search?q={0}',
     *
     *         // Add specialkey listener
     *         initComponent: function() {
     *             this.callParent();
     *             this.on('specialkey', this.checkEnterKey, this);
     *         },
     *
     *         // Handle enter key presses, execute the search if the field has a value
     *         checkEnterKey: function(field, e) {
     *             var value = this.getValue();
     *             if (e.getKey() === e.ENTER && !Ext.isEmpty(value)) {
     *                 location.href = Ext.String.format(this.searchUrl, value);
     *             }
     *         }
     *     });
     *
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Base Example',
     *         bodyPadding: 5,
     *         width: 250,
     *
     *         // Fields will be arranged vertically, stretched to full width
     *         layout: 'anchor',
     *         defaults: {
     *             anchor: '100%'
     *         },
     *         items: [{
     *             xtype: 'searchfield',
     *             fieldLabel: 'Search',
     *             name: 'query'
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Base extends Ext.Component implements Ext.form.field.BaseConfig {
        /**
         * The input Element for this Field. Only available after the field has been rendered.
         */
        inputEl: Ext.dom.Element;

        maskOnDisable: boolean;

        baseCls: string;

        /**
         * Defines a timeout in milliseconds for buffering {@link #checkChangeEvents} that fire in rapid succession.
         * Defaults to 50 milliseconds.
         */
        checkChangeBuffer: number;

        /**
         * A list of event names that will be listened for on the field's {@link #inputEl input element}, which will cause
         * the field's value to be checked for changes. If a change is detected, the {@link #change change event} will be
         * fired, followed by validation if the {@link #validateOnChange} option is enabled.
         *
         * Defaults to ['change', 'propertychange', 'keyup'] in Internet Explorer, and ['change', 'input', 'textInput', 'keyup',
         * 'dragdrop'] in other browsers. This catches all the ways that field values can be changed in most supported
         * browsers; the only known exceptions at the time of writing are:
         *
         *   - Safari 3.2 and older: cut/paste in textareas via the context menu, and dragging text into textareas
         *   - Opera 10 and 11: dragging text into text fields and textareas, and cut via the context menu in text fields
         *     and textareas
         *   - Opera 9: Same as Opera 10 and 11, plus paste from context menu in text fields and textareas
         *
         * If you need to guarantee on-the-fly change notifications including these edge cases, you can call the
         * {@link #checkChange} method on a repeating interval, e.g. using {@link Ext.TaskManager}, or if the field is within
         * a {@link Ext.form.Panel}, you can use the FormPanel's {@link Ext.form.Panel#pollForChanges} configuration to set up
         * such a task automatically.
         */
        checkChangeEvents: string;

        componentLayout: string|any;

        /**
         * The CSS class to use when the field value {@link #isDirty is dirty}.
         */
        dirtyCls: string;

        /**
         * The default CSS class for the field input
         *
         * Optional, Defaults to: 'x-form-field'
         */
        fieldCls: string;

        /**
         * Optional CSS style(s) to be applied to the {@link #inputEl field input element}. Should be a valid argument to
         * {@link Ext.Element#applyStyles}. Defaults to undefined. See also the {@link #setFieldStyle} method for changing
         * the style after initialization.
         */
        fieldStyle: string;

        /**
         * The CSS class to use when the field receives focus
         *
         * Optional, Defaults to: 'x-form-focus'
         */
        focusCls: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * inside the input element (as attributes). If an 'XTemplate' is used, the component's
         * {@link #getSubTplData subTpl data} serves as the context.
         */
        inputAttrTpl: string|any[]|Ext.XTemplate;

        /**
         * The id that will be given to the generated input DOM element. Defaults to an automatically generated id. If you
         * configure this manually, you must make sure it is unique in the document.
         */
        inputId: string;

        /**
         * The type attribute for input fields -- e.g. radio, text, password, file. The extended types
         * supported by HTML5 inputs (url, email, etc.) may also be used, though using them will cause older browsers to
         * fall back to 'text'.
         *
         * The type 'password' must be used to render that field type currently -- there is no separate Ext component for
         * that. You can use {@link Ext.form.field.File} which creates a custom-rendered file upload field, but if you want
         * a plain unstyled file input you can use a Base with inputType:'file'.
         */
        inputType: string;

        /**
         * The error text to use when marking a field invalid and no message is provided
         */
        invalidText: string;

        /**
         * The name of the field. This is used as the parameter name when including the field value
         * in a {@link Ext.form.Basic#submit form submit()}. If no name is configured, it falls back to the {@link #inputId}.
         * To prevent the field from being included in the form submit, set {@link #submitValue} to false.
         */
        name: string;

        /**
         * true to mark the field as readOnly in HTML.
         *
         * **Note**: this only sets the element's readOnly DOM attribute. Setting 'readOnly=true', for example, will not
         * disable triggering a ComboBox or Date; it gives you the option of forcing the user to choose via the trigger
         * without typing in the text box. To hide the trigger use '{@link Ext.form.field.Trigger#hideTrigger hideTrigger}'.
         */
        readOnly: boolean;

        /**
         * The CSS class applied to the component's main element when it is {@link #readOnly}.
         */
        readOnlyCls: string;

        /**
         * The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via
         * applyTo
         */
        tabIndex: number;

        /**
         * Whether the field should validate when it loses focus. This will cause fields to be validated
         * as the user steps through the fields in the form regardless of whether they are making changes to those fields
         * along the way. See also {@link #validateOnChange}.
         */
        validateOnBlur: boolean;

        /**
         * Clear any invalid styles/messages for this field.
         *
         * **Note**: this method does not cause the Field's {@link #validate} or {@link #isValid} methods to return 'true'
         * if the value does not _pass_ validation. So simply clearing a field's errors will not necessarily allow
         * submission of forms submitted with the {@link Ext.form.action.Submit#clientValidation} option set.
         */
        clearInvalid();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Returns the input id for this field. If none was specified via the {@link #inputId} config, then an id will be
         * automatically generated.
         */
        getInputId();

        /**
         * Returns the raw value of the field, without performing any normalization, conversion, or validation. To get a
         * normalized and converted value see {@link #getValue}.
         * @return {String} value The raw String value of the field
         */
        getRawValue(): string;

        getSubmitData();

        /**
         * Returns the value that would be included in a standard form submit for this field. This will be combined with the
         * field's name to form a name=value pair in the {@link #getSubmitData submitted parameters}. If an empty string is
         * returned then just the name= will be submitted; if null is returned then nothing will be submitted.
         *
         * Note that the value returned will have been {@link #processRawValue processed} but may or may not have been
         * successfully {@link #validate validated}.
         *
         * @return {String} The value to be submitted, or null.
         */
        getSubmitValue(): string;

        /**
         * Creates and returns the data object to be used when rendering the {@link #fieldSubTpl}.
         * @return {Object} The template data
         */
        getSubTplData(): any;

        /**
         * Gets the markup to be inserted into the outer template's bodyEl. For fields this is the actual input element.
         */
        getSubTplMarkup();

        /**
         * Returns the current data value of the field. The type of value returned is particular to the type of the
         * particular field (e.g. a Date object for {@link Ext.form.field.Date}), as the result of calling {@link #rawToValue} on
         * the field's {@link #processRawValue processed} String value. To return the raw String value, see {@link #getRawValue}.
         * @return {Object} value The field value
         */
        getValue(): any;

        protected initComponent();

        protected initEvents();

        protected initRenderData();

        isFileUpload();

        /**
         * Returns whether or not the field value is currently valid by {@link #getErrors validating} the
         * {@link #processRawValue processed raw value} of the field. **Note**: {@link #disabled} fields are
         * always treated as valid.
         *
         * @return {Boolean} True if the value is valid, else false
         */
        isValid(): boolean;

        /**
         * Display one or more error messages associated with this field, using {@link #msgTarget} to determine how to
         * display the messages and applying {@link #invalidCls} to the field's UI element.
         *
         * **Note**: this method does not cause the Field's {@link #validate} or {@link #isValid} methods to return 'false'
         * if the value does _pass_ validation. So simply marking a Field as invalid will not prevent submission of forms
         * submitted with the {@link Ext.form.action.Submit#clientValidation} option set.
         *
         * @param {String/String[]} errors The validation message(s) to display.
         */
        markInvalid(errors: string);

        protected onDisable();

        protected onEnable();

        protected onRender();

        /**
         * Performs any necessary manipulation of a raw field value to prepare it for {@link #rawToValue conversion} and/or
         * {@link #validate validation}, for instance stripping out ignored characters. In the base implementation it does
         * nothing; individual subclasses may override this as needed.
         *
         * @param {Object} value The unprocessed string value
         * @return {Object} The processed string value
         */
        processRawValue(value: any): any;

        /**
         * Converts a raw input field value into a mixed-type value that is suitable for this particular field type. This
         * allows controlling the normalization and conversion of user-entered values into field-type-appropriate values,
         * e.g. a Date object for {@link Ext.form.field.Date}, and is invoked by {@link #getValue}.
         *
         * It is up to individual implementations to decide how to handle raw values that cannot be successfully converted
         * to the desired object type.
         *
         * See {@link #valueToRaw} for the opposite conversion.
         *
         * The base implementation does no conversion, returning the raw value untouched.
         *
         * @return {Object} The converted value.
         */
        rawToValue(rawValue: any): any;

        /**
         * Set the {@link #fieldStyle CSS style} of the {@link #inputEl field input element}.
         * @param {String/Object/Function} style The style(s) to apply. Should be a valid argument to {@link
         * Ext.Element#applyStyles}.
         */
        setFieldStyle(style: string|any|Function);

        /**
         * Sets the field's raw value directly, bypassing {@link #valueToRaw value conversion}, change detection, and
         * validation. To set the value with these additional inspections see {@link #setValue}.
         * @param {Object} value The value to set
         * @return {Object} value The field value that is set
         */
        setRawValue(value: any): any;

        /**
         * Sets the read only state of this field.
         * @param {Boolean} readOnly Whether the field should be read only.
         */
        setReadOnly(readOnly: boolean);

        /**
         * Sets a data value into the field and runs the change detection and validation. To set the value directly
         * without these inspections see {@link #setRawValue}.
         * @param {Object} value The value to set
         * @return {Ext.form.field.Field} this
         */
        setValue(value: any): Ext.form.field.Field;

        /**
         * Transform the raw value before it is set
         * @param {Object} value The value
         * @return {Object} The value to set
         */
        protected transformRawValue(value: any): any;

        /**
         * Uses {@link #getErrors} to build an array of validation errors. If any errors are found, they are passed to
         * {@link #markInvalid} and false is returned, otherwise true is returned.
         *
         * Previously, subclasses were invited to provide an implementation of this to process validations - from 3.2
         * onwards {@link #getErrors} should be overridden instead.
         *
         * @param {Object} value The value to validate
         * @return {Boolean} True if all validations passed, false if one or more failed
         */
        validateValue(value: any): boolean;

        /**
         * Converts a mixed-type value to a raw representation suitable for displaying in the field. This allows controlling
         * how value objects passed to {@link #setValue} are shown to the user, including localization. For instance, for a
         * {@link Ext.form.field.Date}, this would control how a Date object passed to {@link #setValue} would be converted
         * to a String for display in the field.
         *
         * See {@link #rawToValue} for the opposite conversion.
         *
         * The base implementation simply does a standard toString conversion, and converts {@link Ext#isEmpty empty values}
         * to an empty string.
         *
         * @param {Object} value The mixed-type value to convert to the raw representation.
         * @return {Object} The converted raw value.
         */
        valueToRaw(value: any): any;

        /**
         * Fires when any key related to navigation (arrows, tab, enter, esc, etc.) is pressed. To handle other keys
         * see {@link Ext.util.KeyMap}. You can check {@link Ext.EventObject#getKey} to determine which key was
         * pressed. For example:
         *
         *     var form = new Ext.form.Panel({
         *         ...
         *         items: [{
         *                 fieldLabel: 'Field 1',
         *                 name: 'field1',
         *                 allowBlank: false
         *             },{
         *                 fieldLabel: 'Field 2',
         *                 name: 'field2',
         *                 listeners: {
         *                     specialkey: function(field, e){
         *                         // e.HOME, e.END, e.PAGE_UP, e.PAGE_DOWN,
         *                         // e.TAB, e.ESC, arrow keys: e.LEFT, e.RIGHT, e.UP, e.DOWN
         *                         if (e.{@link Ext.EventObject#getKey getKey()} == e.ENTER) {
         *                             var form = field.up('form').getForm();
         *                             form.submit();
         *                         }
         *                     }
         *                 }
         *             }
         *         ],
         *         ...
         *     });
         *
         * @param {Ext.EventObject} e The event object
         */
        specialkey(that: Ext.form.field.Base, e: Ext.EventObject);

        /**
         * Fires when this field changes its read-only status.
         * @param {Boolean} Read only flag
         */
        writeablechange(that: Ext.form.field.Base, Read: boolean);
    }

    interface CheckboxConfig extends Ext.form.field.BaseConfig {
        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the box label text. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        afterBoxLabelTextTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the box label element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        afterBoxLabelTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the box label text. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        beforeBoxLabelTextTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the box label element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        beforeBoxLabelTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional text label that will appear next to the checkbox. Whether it appears before or after the checkbox is
         * determined by the {@link #boxLabelAlign} config.
         */
        boxLabel?: string;

        /**
         * The position relative to the checkbox where the {@link #boxLabel} should appear. Recognized values are 'before'
         * and 'after'.
         */
        boxLabelAlign?: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * inside the box label element (as attributes). If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        boxLabelAttrTpl?: string|any[]|Ext.XTemplate;

        /**
         * The CSS class to be applied to the {@link #boxLabel} element
         *
         * Optional, Defaults to: 'x-form-cb-label'
         */
        boxLabelCls?: string;

        checkChangeEvents?: any;

        /**
         * true if the checkbox should render initially checked
         */
        checked?: boolean;

        /**
         * The CSS class(es) added to the component's main element when it is in the checked state.
         * You can add your own class (checkedCls='myClass x-form-cb-checked') or replace the default
         * class altogether (checkedCls='myClass').
         *
         * Optional, Defaults to: 'x-form-cb-checked'
         */
        checkedCls?: string;

        componentLayout?: any;

        /**
         * The default CSS class for the checkbox
         *
         * Optional, Defaults to: 'x-form-field'
         */
        fieldCls?: string;

        /**
         * The CSS class to use when the checkbox receives focus
         *
         * Optional, Defaults to: 'x-form-checkbox-focus'
         */
        focusCls?: string;

        /**
         * A function called when the {@link #checked} value changes (can be used instead of handling the {@link #change
         * change event}).
         * The Checkbox being toggled.
         * The new checked state of the checkbox.
         */
        handler?: Function;

        inputType?: any;

        /**
         * The value that should go into the generated input element's value attribute and should be used as the parameter
         * value when submitting as part of a form.
         */
        inputValue?: string;

        /**
         * An object to use as the scope ('this' reference) of the {@link #handler} function.
         *
         * Defaults to this Checkbox.
         */
        scope?: any;

        /**
         * If configured, this will be submitted as the checkbox's value during form submit if the checkbox is unchecked. By
         * default this is undefined, which results in nothing being submitted for the checkbox field when the form is
         * submitted (the default behavior of HTML checkboxes).
         */
        uncheckedValue?: string;
    }

    /**
     * @docauthor Robert Dougan <rob@sencha.com>
     *
     * Single checkbox field. Can be used as a direct replacement for traditional checkbox fields. Also serves as a
     * parent class for {@link Ext.form.field.Radio radio buttons}.
     *
     * # Labeling
     *
     * In addition to the {@link Ext.form.Labelable standard field labeling options}, checkboxes
     * may be given an optional {@link #boxLabel} which will be displayed immediately after checkbox. Also see
     * {@link Ext.form.CheckboxGroup} for a convenient method of grouping related checkboxes.
     *
     * # Values
     *
     * The main value of a checkbox is a boolean, indicating whether or not the checkbox is checked.
     * The following values will check the checkbox:
     *
     * - 'true'
     * - ''true''
     * - ''1''
     * - ''on''
     *
     * Any other value will uncheck the checkbox.
     *
     * In addition to the main boolean value, you may also specify a separate {@link #inputValue}. This will be
     * sent as the parameter value when the form is {@link Ext.form.Basic#submit submitted}. You will want to set
     * this value if you have multiple checkboxes with the same {@link #name}. If not specified, the value 'on'
     * will be used.
     *
     * # Example usage
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         bodyPadding: 10,
     *         width: 300,
     *         title: 'Pizza Order',
     *         items: [
     *             {
     *                 xtype: 'fieldcontainer',
     *                 fieldLabel: 'Toppings',
     *                 defaultType: 'checkboxfield',
     *                 items: [
     *                     {
     *                         boxLabel  : 'Anchovies',
     *                         name      : 'topping',
     *                         inputValue: '1',
     *                         id        : 'checkbox1'
     *                     }, {
     *                         boxLabel  : 'Artichoke Hearts',
     *                         name      : 'topping',
     *                         inputValue: '2',
     *                         checked   : true,
     *                         id        : 'checkbox2'
     *                     }, {
     *                         boxLabel  : 'Bacon',
     *                         name      : 'topping',
     *                         inputValue: '3',
     *                         id        : 'checkbox3'
     *                     }
     *                 ]
     *             }
     *         ],
     *         bbar: [
     *             {
     *                 text: 'Select Bacon',
     *                 handler: function() {
     *                     Ext.getCmp('checkbox3').setValue(true);
     *                 }
     *             },
     *             '-',
     *             {
     *                 text: 'Select All',
     *                 handler: function() {
     *                     Ext.getCmp('checkbox1').setValue(true);
     *                     Ext.getCmp('checkbox2').setValue(true);
     *                     Ext.getCmp('checkbox3').setValue(true);
     *                 }
     *             },
     *             {
     *                 text: 'Deselect All',
     *                 handler: function() {
     *                     Ext.getCmp('checkbox1').setValue(false);
     *                     Ext.getCmp('checkbox2').setValue(false);
     *                     Ext.getCmp('checkbox3').setValue(false);
     *                 }
     *             }
     *         ],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Checkbox extends Ext.form.field.Base implements Ext.form.field.CheckboxConfig {
        /**
         * A reference to the label element created for the {@link #boxLabel}. Only present if the component has been
         * rendered and has a boxLabel configured.
         */
        boxLabelEl: Ext.dom.Element;

        /**
         * The original value of the field as configured in the {@link #checked} configuration, or as loaded by the last
         * form load operation if the form's {@link Ext.form.Basic#trackResetOnLoad trackResetOnLoad} setting is 'true'.
         */
        originalValue: any;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the box label text. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        afterBoxLabelTextTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the box label element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        afterBoxLabelTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the box label text. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        beforeBoxLabelTextTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the box label element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        beforeBoxLabelTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional text label that will appear next to the checkbox. Whether it appears before or after the checkbox is
         * determined by the {@link #boxLabelAlign} config.
         */
        boxLabel: string;

        /**
         * The position relative to the checkbox where the {@link #boxLabel} should appear. Recognized values are 'before'
         * and 'after'.
         */
        boxLabelAlign: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * inside the box label element (as attributes). If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        boxLabelAttrTpl: string|any[]|Ext.XTemplate;

        /**
         * The CSS class to be applied to the {@link #boxLabel} element
         *
         * Optional, Defaults to: 'x-form-cb-label'
         */
        boxLabelCls: string;

        checkChangeEvents: string;

        /**
         * true if the checkbox should render initially checked
         */
        checked: boolean;

        /**
         * The CSS class(es) added to the component's main element when it is in the checked state.
         * You can add your own class (checkedCls='myClass x-form-cb-checked') or replace the default
         * class altogether (checkedCls='myClass').
         *
         * Optional, Defaults to: 'x-form-cb-checked'
         */
        checkedCls: string;

        componentLayout: string|any;

        /**
         * The default CSS class for the checkbox
         *
         * Optional, Defaults to: 'x-form-field'
         */
        fieldCls: string;

        /**
         * The CSS class to use when the checkbox receives focus
         *
         * Optional, Defaults to: 'x-form-checkbox-focus'
         */
        focusCls: string;

        /**
         * A function called when the {@link #checked} value changes (can be used instead of handling the {@link #change
         * change event}).
         * The Checkbox being toggled.
         * The new checked state of the checkbox.
         */
        handler: Function;

        inputType: string;

        /**
         * The value that should go into the generated input element's value attribute and should be used as the parameter
         * value when submitting as part of a form.
         */
        inputValue: string;

        /**
         * An object to use as the scope ('this' reference) of the {@link #handler} function.
         *
         * Defaults to this Checkbox.
         */
        scope: any;

        /**
         * If configured, this will be submitted as the checkbox's value during form submit if the checkbox is unchecked. By
         * default this is undefined, which results in nothing being submitted for the checkbox field when the form is
         * submitted (the default behavior of HTML checkboxes).
         */
        uncheckedValue: string;

        protected beforeDestroy();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Returns the submit value for the checkbox which can be used when submitting forms.
         * @return {String} If checked the {@link #inputValue} is returned; otherwise the {@link #uncheckedValue}
         * (or null if the latter is not configured).
         */
        getSubmitValue(): string;

        protected initComponent();

        protected initEvents();

        initValue();

        protected onEnable();

        resetOriginalValue(fromBoxInGroup: any);

        /**
         * Sets the {@link #boxLabel} for this checkbox.
         * @param {String} boxLabel The new label
         */
        setBoxLabel(boxLabel: string);
    }

    interface ComboBoxConfig extends Ext.form.field.PickerConfig {
        /**
         * The text query to send to the server to return all records for the list with no filtering
         */
        allQuery?: string;

        /**
         * Configure as 'true' to allow match the typed characters at any position in the {@link #valueField}'s value.
         *
         * Optional, Defaults to: false
         */
        anyMatch?: boolean;

        /**
         * 'true' to automatically highlight the first result gathered by the data store in the dropdown list when it is
         * opened. A false value would cause nothing in the list to be highlighted automatically, so
         * the user would have to manually highlight an item before pressing the enter or {@link #selectOnTab tab} key to
         * select it (unless the value of ({@link #typeAhead}) were true), or use the mouse to select a value.
         */
        autoSelect?: boolean;

        /**
         * Configure as 'true' to make the filtering match with exact case matching
         *
         * Optional, Defaults to: false
         */
        caseSensitive?: boolean;

        componentLayout?: any;

        /**
         * Set of options that will be used as defaults for the user-configured {@link #listConfig} object.
         */
        defaultListConfig?: any;

        /**
         * The character(s) used to separate the {@link #displayField display values} of multiple selected items when
         * '{@link #multiSelect} = true'.
         */
        delimiter?: string;

        /**
         * The underlying {@link Ext.data.Field#name data field name} to bind to this ComboBox.
         *
         * See also '{@link #valueField}'.
         */
        displayField?: string;

        /**
         * *When {@link #queryMode} is ''local'' only*
         *
         * Set to 'true' to have the ComboBox use the typed value as a RegExp source to filter the store to get possible matches.
         */
        enableRegEx?: boolean;

        fieldSubTpl?: any;

        /**
         * 'true' to restrict the selected value to one of the values in the list, 'false' to allow the user to set
         * arbitrary text into the field.
         */
        forceSelection?: boolean;

        /**
         * 'false' to not allow the component to resize itself when its data changes
         * (and its {@link #grow} property is 'true')
         */
        growToLongestValue?: boolean;

        /**
         * The name of an underlying hidden field which will be synchronized with the underlying value of the combo.
         * This option is useful if the combo is part of a form element doing a regular form post. The hidden field
         * will not be created unless a hiddenName is specified.
         *
         * Optional, Defaults to: ""
         */
        hiddenName?: string;

        /**
         * An optional set of configuration properties that will be passed to the {@link Ext.view.BoundList}'s constructor.
         * Any configuration that is valid for BoundList can be included. Some of the more useful ones are:
         *
         *   - {@link Ext.view.BoundList#cls cls} - defaults to empty
         *   - {@link Ext.view.BoundList#emptyText emptyText} - defaults to empty string
         *   - {@link Ext.view.BoundList#itemSelector itemSelector} - defaults to the value defined in BoundList
         *   - {@link Ext.view.BoundList#loadingText loadingText} - defaults to ''Loading...''
         *   - {@link Ext.view.BoundList#minWidth minWidth} - defaults to '70'
         *   - {@link Ext.view.BoundList#maxWidth maxWidth} - defaults to 'undefined'
         *   - {@link Ext.view.BoundList#maxHeight maxHeight} - defaults to '300'
         *   - {@link Ext.view.BoundList#resizable resizable} - defaults to 'false'
         *   - {@link Ext.view.BoundList#shadow shadow} - defaults to ''sides''
         *   - {@link Ext.view.BoundList#width width} - defaults to 'undefined' (automatically set to the width of the ComboBox
         *     field if {@link #matchFieldWidth} is true)
         *     {@link Ext.view.BoundList#getInnerTpl getInnerTpl} A function which returns a template string which renders
         *     the ComboBox's {@link #displayField} value in the dropdown. This defaults to just outputting the raw value,
         *     but may use any {@link Ext.XTemplate XTemplate} methods to produce output.
         *
         *     The running template is configured with some extra properties that provide some context:
         *         - field {@link Ext.form.field.ComboBox ComboBox} This combobox
         *         - store {@link Ext.data.Store Store} This combobox's data store
         */
        listConfig?: any;

        /**
         * The minimum number of characters the user must type before autocomplete and {@link #typeAhead} activate.
         *
         * Defaults to '4' if '{@link #queryMode} = 'remote'' or '0' if '{@link #queryMode} = 'local'',
         * does not apply if '{@link Ext.form.field.Trigger#editable editable} = false'.
         */
        minChars?: number;

        /**
         * If set to 'true', allows the combo field to hold more than one value at a time, and allows selecting multiple
         * items from the dropdown list. The combo's text field will show all selected values separated by the
         * {@link #delimiter}.
         */
        multiSelect?: boolean;

        /**
         * If greater than '0', a {@link Ext.toolbar.Paging} is displayed in the footer of the dropdown list and the
         * {@link #doQuery filter queries} will execute with page start and {@link Ext.view.BoundList#pageSize limit}
         * parameters. Only applies when '{@link #queryMode} = 'remote''.
         */
        pageSize?: number;

        /**
         * When true, this prevents the combo from re-querying (either locally or remotely) when the current query
         * is the same as the previous query.
         *
         * Optional, Defaults to: true
         */
        queryCaching?: boolean;

        /**
         * The length of time in milliseconds to delay between the start of typing and sending the query to filter the
         * dropdown list.
         *
         * Defaults to '500' if '{@link #queryMode} = 'remote'' or '10' if '{@link #queryMode} = 'local''
         */
        queryDelay?: number;

        /**
         * The mode in which the ComboBox uses the configured Store. Acceptable values are:
         *
         *   - **''remote''** :
         *
         *     In 'queryMode: 'remote'', the ComboBox loads its Store dynamically based upon user interaction.
         *
         *     This is typically used for "autocomplete" type inputs, and after the user finishes typing, the Store is {@link
         *     Ext.data.Store#method-load load}ed.
         *
         *     A parameter containing the typed string is sent in the load request. The default parameter name for the input
         *     string is 'query', but this can be configured using the {@link #queryParam} config.
         *
         *     In 'queryMode: 'remote'', the Store may be configured with '{@link Ext.data.Store#remoteFilter remoteFilter}:
         *     true', and further filters may be _programatically_ added to the Store which are then passed with every load
         *     request which allows the server to further refine the returned dataset.
         *
         *     Typically, in an autocomplete situation, {@link #hideTrigger} is configured 'true' because it has no meaning for
         *     autocomplete.
         *
         *   - **''local''** :
         *
         *     ComboBox loads local data
         *
         *         var combo = new Ext.form.field.ComboBox({
         *             renderTo: document.body,
         *             queryMode: 'local',
         *             store: new Ext.data.ArrayStore({
         *                 id: 0,
         *                 fields: [
         *                     'myId',  // numeric value is the key
         *                     'displayText'
         *                 ],
         *                 data: [[1, 'item1'], [2, 'item2']]  // data is local
         *             }),
         *             valueField: 'myId',
         *             displayField: 'displayText',
         *             triggerAction: 'all'
         *         });
         */
        queryMode?: string;

        /**
         * Name of the parameter used by the Store to pass the typed string when the ComboBox is configured with
         * '{@link #queryMode}: 'remote''. If explicitly set to a falsy value it will not be sent.
         */
        queryParam?: string;

        /**
         * Whether the Tab key should select the currently highlighted item.
         */
        selectOnTab?: boolean;

        /**
         * The data source to which this combo is bound. Acceptable values for this property are:
         *
         *   - **any {@link Ext.data.Store Store} subclass**
         *   - **an {@link Ext.data.Store#storeId ID of a store}**
         *   - **an Array** : Arrays will be converted to a {@link Ext.data.Store} internally, automatically generating
         *     {@link Ext.data.Field#name field names} to work with all data components.
         *
         *     - **1-dimensional array** : (e.g., '['Foo','Bar']')
         *
         *       A 1-dimensional array will automatically be expanded (each array item will be used for both the combo
         *       {@link #valueField} and {@link #displayField})
         *
         *     - **2-dimensional array** : (e.g., '[['f','Foo'],['b','Bar']]')
         *
         *       For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo
         *       {@link #valueField}, while the value at index 1 is assumed to be the combo {@link #displayField}.
         *
         * See also {@link #queryMode}.
         */
        store?: Ext.data.Store|string|any[];

        /**
         * The id, DOM node or {@link Ext.Element} of an existing HTML '<select>' element to convert into a ComboBox. The
         * target select's options will be used to build the options in the ComboBox dropdown; a configured {@link #store}
         * will take precedence over this.
         */
        transform?: string|HTMLElement|Ext.dom.Element;

        /**
         * The action to execute when the trigger is clicked.
         *
         *   - **''all''** :
         *
         *     {@link #doQuery run the query} specified by the '{@link #allQuery}' config option
         *
         *   - **''last''** :
         *
         *     {@link #doQuery run the query} using the '{@link #lastQuery last query value}'.
         *
         *   - **''query''** :
         *
         *     {@link #doQuery run the query} using the {@link Ext.form.field.Base#getRawValue raw value}.
         *
         * See also '{@link #queryParam}'.
         */
        triggerAction?: string;

        /**
         * An additional CSS class used to style the trigger button. The trigger will always get the {@link #triggerBaseCls}
         * by default and 'triggerCls' will be **appended** if specified.
         *
         * Optional, Defaults to: 'x-form-arrow-trigger'
         */
        triggerCls?: string;

        /**
         * 'true' to populate and autoselect the remainder of the text being typed after a configurable delay
         * ({@link #typeAheadDelay}) if it matches a known value.
         */
        typeAhead?: boolean;

        /**
         * The length of time in milliseconds to wait until the typeahead text is displayed if '{@link #typeAhead} = true'
         */
        typeAheadDelay?: number;

        /**
         * (required)
         * The underlying {@link Ext.data.Field#name data value name} to bind to this ComboBox.
         *
         * **Note**: use of a 'valueField' requires the user to make a selection in order for a value to be mapped. See also
         * '{@link #displayField}'.
         *
         * Defaults to match the value of the {@link #displayField} config.
         */
        valueField?: string;

        /**
         * When using a name/value combo, if the value passed to setValue is not found in the store, valueNotFoundText will
         * be displayed as the field text if defined. If this default text is used, it means there
         * is no value set and no validation will occur on this field.
         */
        valueNotFoundText?: string;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * A combobox control with support for autocomplete, remote loading, and many other features.
     *
     * A ComboBox is like a combination of a traditional HTML text '<input>' field and a '<select>'
     * field; the user is able to type freely into the field, and/or pick values from a dropdown selection
     * list. The user can input any value by default, even if it does not appear in the selection list;
     * to prevent free-form values and restrict them to items in the list, set {@link #forceSelection} to 'true'.
     *
     * The selection list's options are populated from any {@link Ext.data.Store}, including remote
     * stores. The data items in the store are mapped to each option's displayed text and backing value via
     * the {@link #valueField} and {@link #displayField} configurations, respectively.
     *
     * If your store is not remote, i.e. it depends only on local data and is loaded up front, you should be
     * sure to set the {@link #queryMode} to ''local'', as this will improve responsiveness for the user.
     *
     * # Example usage:
     *
     *     @example
     *     // The data store containing the list of states
     *     var states = Ext.create('Ext.data.Store', {
     *         fields: ['abbr', 'name'],
     *         data : [
     *             {"abbr":"AL", "name":"Alabama"},
     *             {"abbr":"AK", "name":"Alaska"},
     *             {"abbr":"AZ", "name":"Arizona"}
     *             //...
     *         ]
     *     });
     *
     *     // Create the combo box, attached to the states data store
     *     Ext.create('Ext.form.ComboBox', {
     *         fieldLabel: 'Choose State',
     *         store: states,
     *         queryMode: 'local',
     *         displayField: 'name',
     *         valueField: 'abbr',
     *         renderTo: Ext.getBody()
     *     });
     *
     * # Events
     *
     * To do something when something in ComboBox is selected, configure the select event:
     *
     *     var cb = Ext.create('Ext.form.ComboBox', {
     *         // all of your config options
     *         listeners:{
     *              scope: yourScope,
     *              'select': yourFunction
     *         }
     *     });
     *
     *     // Alternatively, you can assign events after the object is created:
     *     var cb = new Ext.form.field.ComboBox(yourOptions);
     *     cb.on('select', yourFunction, yourScope);
     *
     * # Multiple Selection
     *
     * ComboBox also allows selection of multiple items from the list; to enable multi-selection set the
     * {@link #multiSelect} config to 'true'.
     *
     * # Filtered Stores
     *
     * If you have a local store that is already filtered, you can use the {@link #lastQuery} config option
     * to prevent the store from having the filter being cleared on first expand.
     *
     * ## Customized combobox
     *
     * Both the text shown in dropdown menu and text field can be easily customized:
     *
     *     @example
     *     var states = Ext.create('Ext.data.Store', {
     *         fields: ['abbr', 'name'],
     *         data : [
     *             {"abbr":"AL", "name":"Alabama"},
     *             {"abbr":"AK", "name":"Alaska"},
     *             {"abbr":"AZ", "name":"Arizona"}
     *         ]
     *     });
     *
     *     Ext.create('Ext.form.ComboBox', {
     *         fieldLabel: 'Choose State',
     *         store: states,
     *         queryMode: 'local',
     *         valueField: 'abbr',
     *         renderTo: Ext.getBody(),
     *         // Template for the dropdown menu.
     *         // Note the use of "x-boundlist-item" class,
     *         // this is required to make the items selectable.
     *         tpl: Ext.create('Ext.XTemplate',
     *             '<tpl for=".">',
     *                 '<div class="x-boundlist-item">{abbr} - {name}</div>',
     *             '</tpl>'
     *         ),
     *         // template for the content inside text field
     *         displayTpl: Ext.create('Ext.XTemplate',
     *             '<tpl for=".">',
     *                 '{abbr} - {name}',
     *             '</tpl>'
     *         )
     *     });
     *
     * See also the {@link #listConfig} option for additional configuration of the dropdown.
     */
    export class ComboBox extends Ext.form.field.Picker implements Ext.form.field.ComboBoxConfig {
        /**
         * The value of the match string used to filter the store. Delete this property to force a requery. Example use:
         *
         *     var combo = new Ext.form.field.ComboBox({
         *         ...
         *         queryMode: 'remote',
         *         listeners: {
         *             // delete the previous query in the beforequery event or set
         *             // combo.lastQuery = null (this will reload the store the next time it expands)
         *             beforequery: function(qe){
         *                 delete qe.combo.lastQuery;
         *             }
         *         }
         *     });
         *
         * To make sure the filter in the store is not cleared the first time the ComboBox trigger is used configure the
         * combo with 'lastQuery='''. Example use:
         *
         *     var combo = new Ext.form.field.ComboBox({
         *         ...
         *         queryMode: 'local',
         *         triggerAction: 'all',
         *         lastQuery: ''
         *     });
         */
        lastQuery: string;

        /**
         * The text query to send to the server to return all records for the list with no filtering
         */
        allQuery: string;

        /**
         * Configure as 'true' to allow match the typed characters at any position in the {@link #valueField}'s value.
         *
         * Optional, Defaults to: false
         */
        anyMatch: boolean;

        /**
         * 'true' to automatically highlight the first result gathered by the data store in the dropdown list when it is
         * opened. A false value would cause nothing in the list to be highlighted automatically, so
         * the user would have to manually highlight an item before pressing the enter or {@link #selectOnTab tab} key to
         * select it (unless the value of ({@link #typeAhead}) were true), or use the mouse to select a value.
         */
        autoSelect: boolean;

        /**
         * Configure as 'true' to make the filtering match with exact case matching
         *
         * Optional, Defaults to: false
         */
        caseSensitive: boolean;

        componentLayout: string|any;

        /**
         * Set of options that will be used as defaults for the user-configured {@link #listConfig} object.
         */
        defaultListConfig: any;

        /**
         * The character(s) used to separate the {@link #displayField display values} of multiple selected items when
         * '{@link #multiSelect} = true'.
         */
        delimiter: string;

        /**
         * The underlying {@link Ext.data.Field#name data field name} to bind to this ComboBox.
         *
         * See also '{@link #valueField}'.
         */
        displayField: string;

        /**
         * *When {@link #queryMode} is ''local'' only*
         *
         * Set to 'true' to have the ComboBox use the typed value as a RegExp source to filter the store to get possible matches.
         */
        enableRegEx: boolean;

        fieldSubTpl: any;

        /**
         * 'true' to restrict the selected value to one of the values in the list, 'false' to allow the user to set
         * arbitrary text into the field.
         */
        forceSelection: boolean;

        /**
         * 'false' to not allow the component to resize itself when its data changes
         * (and its {@link #grow} property is 'true')
         */
        growToLongestValue: boolean;

        /**
         * The name of an underlying hidden field which will be synchronized with the underlying value of the combo.
         * This option is useful if the combo is part of a form element doing a regular form post. The hidden field
         * will not be created unless a hiddenName is specified.
         *
         * Optional, Defaults to: ""
         */
        hiddenName: string;

        /**
         * An optional set of configuration properties that will be passed to the {@link Ext.view.BoundList}'s constructor.
         * Any configuration that is valid for BoundList can be included. Some of the more useful ones are:
         *
         *   - {@link Ext.view.BoundList#cls cls} - defaults to empty
         *   - {@link Ext.view.BoundList#emptyText emptyText} - defaults to empty string
         *   - {@link Ext.view.BoundList#itemSelector itemSelector} - defaults to the value defined in BoundList
         *   - {@link Ext.view.BoundList#loadingText loadingText} - defaults to ''Loading...''
         *   - {@link Ext.view.BoundList#minWidth minWidth} - defaults to '70'
         *   - {@link Ext.view.BoundList#maxWidth maxWidth} - defaults to 'undefined'
         *   - {@link Ext.view.BoundList#maxHeight maxHeight} - defaults to '300'
         *   - {@link Ext.view.BoundList#resizable resizable} - defaults to 'false'
         *   - {@link Ext.view.BoundList#shadow shadow} - defaults to ''sides''
         *   - {@link Ext.view.BoundList#width width} - defaults to 'undefined' (automatically set to the width of the ComboBox
         *     field if {@link #matchFieldWidth} is true)
         *     {@link Ext.view.BoundList#getInnerTpl getInnerTpl} A function which returns a template string which renders
         *     the ComboBox's {@link #displayField} value in the dropdown. This defaults to just outputting the raw value,
         *     but may use any {@link Ext.XTemplate XTemplate} methods to produce output.
         *
         *     The running template is configured with some extra properties that provide some context:
         *         - field {@link Ext.form.field.ComboBox ComboBox} This combobox
         *         - store {@link Ext.data.Store Store} This combobox's data store
         */
        listConfig: any;

        /**
         * The minimum number of characters the user must type before autocomplete and {@link #typeAhead} activate.
         *
         * Defaults to '4' if '{@link #queryMode} = 'remote'' or '0' if '{@link #queryMode} = 'local'',
         * does not apply if '{@link Ext.form.field.Trigger#editable editable} = false'.
         */
        minChars: number;

        /**
         * If set to 'true', allows the combo field to hold more than one value at a time, and allows selecting multiple
         * items from the dropdown list. The combo's text field will show all selected values separated by the
         * {@link #delimiter}.
         */
        multiSelect: boolean;

        /**
         * If greater than '0', a {@link Ext.toolbar.Paging} is displayed in the footer of the dropdown list and the
         * {@link #doQuery filter queries} will execute with page start and {@link Ext.view.BoundList#pageSize limit}
         * parameters. Only applies when '{@link #queryMode} = 'remote''.
         */
        pageSize: number;

        /**
         * When true, this prevents the combo from re-querying (either locally or remotely) when the current query
         * is the same as the previous query.
         *
         * Optional, Defaults to: true
         */
        queryCaching: boolean;

        /**
         * The length of time in milliseconds to delay between the start of typing and sending the query to filter the
         * dropdown list.
         *
         * Defaults to '500' if '{@link #queryMode} = 'remote'' or '10' if '{@link #queryMode} = 'local''
         */
        queryDelay: number;

        /**
         * The mode in which the ComboBox uses the configured Store. Acceptable values are:
         *
         *   - **''remote''** :
         *
         *     In 'queryMode: 'remote'', the ComboBox loads its Store dynamically based upon user interaction.
         *
         *     This is typically used for "autocomplete" type inputs, and after the user finishes typing, the Store is {@link
         *     Ext.data.Store#method-load load}ed.
         *
         *     A parameter containing the typed string is sent in the load request. The default parameter name for the input
         *     string is 'query', but this can be configured using the {@link #queryParam} config.
         *
         *     In 'queryMode: 'remote'', the Store may be configured with '{@link Ext.data.Store#remoteFilter remoteFilter}:
         *     true', and further filters may be _programatically_ added to the Store which are then passed with every load
         *     request which allows the server to further refine the returned dataset.
         *
         *     Typically, in an autocomplete situation, {@link #hideTrigger} is configured 'true' because it has no meaning for
         *     autocomplete.
         *
         *   - **''local''** :
         *
         *     ComboBox loads local data
         *
         *         var combo = new Ext.form.field.ComboBox({
         *             renderTo: document.body,
         *             queryMode: 'local',
         *             store: new Ext.data.ArrayStore({
         *                 id: 0,
         *                 fields: [
         *                     'myId',  // numeric value is the key
         *                     'displayText'
         *                 ],
         *                 data: [[1, 'item1'], [2, 'item2']]  // data is local
         *             }),
         *             valueField: 'myId',
         *             displayField: 'displayText',
         *             triggerAction: 'all'
         *         });
         */
        queryMode: string;

        /**
         * Name of the parameter used by the Store to pass the typed string when the ComboBox is configured with
         * '{@link #queryMode}: 'remote''. If explicitly set to a falsy value it will not be sent.
         */
        queryParam: string;

        /**
         * Whether the Tab key should select the currently highlighted item.
         */
        selectOnTab: boolean;

        /**
         * The data source to which this combo is bound. Acceptable values for this property are:
         *
         *   - **any {@link Ext.data.Store Store} subclass**
         *   - **an {@link Ext.data.Store#storeId ID of a store}**
         *   - **an Array** : Arrays will be converted to a {@link Ext.data.Store} internally, automatically generating
         *     {@link Ext.data.Field#name field names} to work with all data components.
         *
         *     - **1-dimensional array** : (e.g., '['Foo','Bar']')
         *
         *       A 1-dimensional array will automatically be expanded (each array item will be used for both the combo
         *       {@link #valueField} and {@link #displayField})
         *
         *     - **2-dimensional array** : (e.g., '[['f','Foo'],['b','Bar']]')
         *
         *       For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo
         *       {@link #valueField}, while the value at index 1 is assumed to be the combo {@link #displayField}.
         *
         * See also {@link #queryMode}.
         */
        store: Ext.data.Store|string|any[];

        /**
         * The id, DOM node or {@link Ext.Element} of an existing HTML '<select>' element to convert into a ComboBox. The
         * target select's options will be used to build the options in the ComboBox dropdown; a configured {@link #store}
         * will take precedence over this.
         */
        transform: string|HTMLElement|Ext.dom.Element;

        /**
         * The action to execute when the trigger is clicked.
         *
         *   - **''all''** :
         *
         *     {@link #doQuery run the query} specified by the '{@link #allQuery}' config option
         *
         *   - **''last''** :
         *
         *     {@link #doQuery run the query} using the '{@link #lastQuery last query value}'.
         *
         *   - **''query''** :
         *
         *     {@link #doQuery run the query} using the {@link Ext.form.field.Base#getRawValue raw value}.
         *
         * See also '{@link #queryParam}'.
         */
        triggerAction: string;

        /**
         * An additional CSS class used to style the trigger button. The trigger will always get the {@link #triggerBaseCls}
         * by default and 'triggerCls' will be **appended** if specified.
         *
         * Optional, Defaults to: 'x-form-arrow-trigger'
         */
        triggerCls: string;

        /**
         * 'true' to populate and autoselect the remainder of the text being typed after a configurable delay
         * ({@link #typeAheadDelay}) if it matches a known value.
         */
        typeAhead: boolean;

        /**
         * The length of time in milliseconds to wait until the typeahead text is displayed if '{@link #typeAhead} = true'
         */
        typeAheadDelay: number;

        /**
         * (required)
         * The underlying {@link Ext.data.Field#name data value name} to bind to this ComboBox.
         *
         * **Note**: use of a 'valueField' requires the user to make a selection in order for a value to be mapped. See also
         * '{@link #displayField}'.
         *
         * Defaults to match the value of the {@link #displayField} config.
         */
        valueField: string;

        /**
         * When using a name/value combo, if the value passed to setValue is not found in the store, valueNotFoundText will
         * be displayed as the field text if defined. If this default text is used, it means there
         * is no value set and no validation will occur on this field.
         */
        valueNotFoundText: string;

        /**
         * A method called when the filtering caused by the {@link #doQuery} call is complete and the store has been
         * either filtered locally (if {@link #queryMode} is '"local"'), or has been loaded using the specified filtering.
         *
         * @param {Object} queryPlan An object containing details about the query was executed.
         * @param {String} queryPlan.query The query value to be used to match against the ComboBox's {@link #valueField}.
         * @param {Boolean} queryPlan.forceAll If 'true', causes the query to be executed even if the minChars threshold is not met.
         * @param {Boolean} queryPlan.cancel A boolean value which, if set to 'true' upon return, causes the query not to be executed.
         * @param {Boolean} queryPlan.rawQuery If 'true' indicates that the raw input field value is being used, and upon store load,
         * the input field value should **not** be overwritten.
         */
        afterQuery(queryPlan: any, queryPlan_query: string, queryPlan_forceAll: boolean, queryPlan_cancel: boolean, queryPlan_rawQuery: boolean);

        protected afterRender();

        protected alignPicker();

        /**
         * A method which may modify aspects of how the store is to be filtered (if {@link #queryMode} is '"local"')
         * of loaded (if {@link #queryMode} is '"remote"').
         *
         * This is called by the {@link #doQuery method, and may be overridden in subclasses to modify
         * the default behaviour.
         *
         * This method is passed an object containing information about the upcoming query operation which it may modify
         * before returning.
         *
         * @param {Object} queryPlan An object containing details about the query to be executed.
         * @param {String} queryPlan.query The query value to be used to match against the ComboBox's {@link #valueField}.
         * @param {Boolean} queryPlan.forceAll If 'true', causes the query to be executed even if the minChars threshold is not met.
         * @param {Boolean} queryPlan.cancel A boolean value which, if set to 'true' upon return, causes the query not to be executed.
         * @param {Boolean} queryPlan.rawQuery If 'true' indicates that the raw input field value is being used, and upon store load,
         * the input field value should **not** be overwritten.
         */
        beforeQuery(queryPlan: any, queryPlan_query: string, queryPlan_forceAll: boolean, queryPlan_cancel: boolean, queryPlan_rawQuery: boolean);

        protected beforeReset();

        /**
         * Clears any value currently set in the ComboBox.
         */
        clearValue();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        createPicker();

        /**
         * Executes a query to filter the dropdown list. Fires the {@link #beforequery} event prior to performing the query
         * allowing the query action to be canceled if needed.
         *
         * @param {String} queryString The string to use to filter available items by matching against the configured {@link #valueField}.
         * @param {Boolean} [forceAll=false] 'true' to force the query to execute even if there are currently fewer characters in
         * the field than the minimum specified by the '{@link #minChars}' config option. It also clears any filter
         * previously saved in the current store.
         * @param {Boolean} [rawQuery=false] Pass as true if the raw typed value is being used as the query string. This causes the
         * resulting store load to leave the raw value undisturbed.
         * @return {Boolean} true if the query was permitted to run, false if it was cancelled by a {@link #beforequery}
         * handler.
         */
        doQuery(queryString: string, forceAll?: boolean, rawQuery?: boolean): boolean;

        /**
         * Finds the record by searching for a specific field/value combination.
         * @param {String} field The name of the field to test.
         * @param {Object} value The value to match the field against.
         * @return {Ext.data.Model} The matched record or false.
         */
        findRecord(field: string, value: any): Ext.data.Model;

        /**
         * Finds the record by searching values in the {@link #displayField}.
         * @param {Object} value The value to match the field against.
         * @return {Ext.data.Model} The matched record or false.
         */
        findRecordByDisplay(value: any): Ext.data.Model;

        /**
         * Finds the record by searching values in the {@link #valueField}.
         * @param {Object} value The value to match the field against.
         * @return {Ext.data.Model} The matched record or false.
         */
        findRecordByValue(value: any): Ext.data.Model;

        /**
         * Returns the store associated with this ComboBox.
         * @return {Ext.data.Store} The store
         */
        getStore(): Ext.data.Store;

        protected getStoreListeners();

        protected initComponent();

        protected initEvents();

        protected onBindStore(store: any, initial: any);

        protected onUnbindStore(store: any);

        /**
         * Fires before the deselected item is removed from the collection
         * @param {Ext.form.field.ComboBox} combo This combo box
         * @param {Ext.data.Record} record The deselected record
         * @param {Number} index The index of the deselected record
         */
        beforedeselect(combo: Ext.form.field.ComboBox, record: Ext.data.Model, index: number);

        /**
         * Fires before all queries are processed. Return false to cancel the query or set the queryPlan's cancel
         * property to true.
         *
         * @param {Object} queryPlan An object containing details about the query to be executed.
         * @param {Ext.form.field.ComboBox} queryPlan.combo A reference to this ComboBox.
         * @param {String} queryPlan.query The query value to be used to match against the ComboBox's {@link #valueField}.
         * @param {Boolean} queryPlan.forceAll If 'true', causes the query to be executed even if the minChars threshold is not met.
         * @param {Boolean} queryPlan.cancel A boolean value which, if set to 'true' upon return, causes the query not to be executed.
         * @param {Boolean} queryPlan.rawQuery If 'true' indicates that the raw input field value is being used, and upon store load,
         */
        beforequery(queryPlan: any, queryPlan_combo: Ext.form.field.ComboBox, queryPlan_query: string, queryPlan_forceAll: boolean, queryPlan_cancel: boolean, queryPlan_rawQuery: boolean);

        /**
         * Fires before the selected item is added to the collection
         * @param {Ext.form.field.ComboBox} combo This combo box
         * @param {Ext.data.Record} record The selected record
         * @param {Number} index The index of the selected record
         */
        beforeselect(combo: Ext.form.field.ComboBox, record: Ext.data.Model, index: number);
    }

    interface DateConfig extends Ext.form.field.PickerConfig {
        /**
         * Multiple date formats separated by "|" to try when parsing a user input value and it does not match the defined
         * format.
         */
        altFormats?: string;

        /**
         * An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular expression so
         * they are very powerful. Some examples:
         *
         *     // disable these exact dates:
         *     disabledDates: ["03/08/2003", "09/16/2003"]
         *     // disable these days for every year:
         *     disabledDates: ["03/08", "09/16"]
         *     // only match the beginning (useful if you are using short years):
         *     disabledDates: ["^03/08"]
         *     // disable every day in March 2006:
         *     disabledDates: ["03/../2006"]
         *     // disable every day in every March:
         *     disabledDates: ["^03"]
         *
         * Note that the format of the dates included in the array should exactly match the {@link #format} config. In order
         * to support regular expressions, if you are using a {@link #format date format} that has "." in it, you will have
         * to escape the dot when restricting dates. For example: '["03\\.08\\.03"]'.
         */
        disabledDates?: string;

        /**
         * The tooltip text to display when the date falls on a disabled date.
         */
        disabledDatesText?: string;

        /**
         * An array of days to disable, 0 based. Some examples:
         *
         *     // disable Sunday and Saturday:
         *     disabledDays:  [0, 6]
         *     // disable weekdays:
         *     disabledDays: [1,2,3,4,5]
         */
        disabledDays?: number;

        /**
         * The tooltip to display when the date falls on a disabled day.
         */
        disabledDaysText?: string;

        /**
         * The default date format string which can be overriden for localization support. The format must be valid
         * according to {@link Ext.Date#parse}.
         */
        format?: string;

        /**
         * The error text to display when the date in the field is invalid.
         */
        invalidText?: string;

        matchFieldWidth?: any;

        /**
         * The error text to display when the date in the cell is after {@link #maxValue}.
         */
        maxText?: string;

        /**
         * The maximum allowed date. Can be either a Javascript date object or a string date in a valid format.
         */
        maxValue?: Date|string;

        /**
         * The error text to display when the date in the cell is before {@link #minValue}.
         */
        minText?: string;

        /**
         * The minimum allowed date. Can be either a Javascript date object or a string date in a valid format.
         */
        minValue?: Date|string;

        /**
         * false to hide the footer area of the Date picker containing the Today button and disable the keyboard handler for
         * spacebar that selects the current date.
         */
        showToday?: boolean;

        /**
         * Day index at which the week should begin, 0-based.
         *
         * Defaults to '0' (Sunday).
         *
         * Optional, Defaults to: undefined
         */
        startDay?: number;

        /**
         * The date format string which will be submitted to the server. The format must be valid according to
         * {@link Ext.Date#parse}.
         *
         * Defaults to {@link #format}.
         */
        submitFormat?: string;

        /**
         * An additional CSS class used to style the trigger button. The trigger will always get the class 'x-form-trigger'
         * and triggerCls will be **appended** if specified (default class displays a calendar icon).
         *
         * Optional, Defaults to: 'x-form-date-trigger'
         */
        triggerCls?: string;

        /**
         * True to enforce strict date parsing to prevent the default Javascript "date rollover".
         * Defaults to the useStrict parameter set on Ext.Date
         * See {@link Ext.Date#parse}.
         */
        useStrict?: boolean;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * Provides a date input field with a {@link Ext.picker.Date date picker} dropdown and automatic date
     * validation.
     *
     * This field recognizes and uses the JavaScript Date object as its main {@link #value} type. In addition,
     * it recognizes string values which are parsed according to the {@link #format} and/or {@link #altFormats}
     * configs. These may be reconfigured to use date formats appropriate for the user's locale.
     *
     * The field may be limited to a certain range of dates by using the {@link #minValue}, {@link #maxValue},
     * {@link #disabledDays}, and {@link #disabledDates} config parameters. These configurations will be used both
     * in the field's validation, and in the date picker dropdown by preventing invalid dates from being selected.
     *
     * # Example usage
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         renderTo: Ext.getBody(),
     *         width: 300,
     *         bodyPadding: 10,
     *         title: 'Dates',
     *         items: [{
     *             xtype: 'datefield',
     *             anchor: '100%',
     *             fieldLabel: 'From',
     *             name: 'from_date',
     *             maxValue: new Date()  // limited to the current date or prior
     *         }, {
     *             xtype: 'datefield',
     *             anchor: '100%',
     *             fieldLabel: 'To',
     *             name: 'to_date',
     *             value: new Date()  // defaults to today
     *         }]
     *     });
     *
     * # Date Formats Examples
     *
     * This example shows a couple of different date format parsing scenarios. Both use custom date format
     * configurations; the first one matches the configured 'format' while the second matches the 'altFormats'.
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         renderTo: Ext.getBody(),
     *         width: 300,
     *         bodyPadding: 10,
     *         title: 'Dates',
     *         items: [{
     *             xtype: 'datefield',
     *             anchor: '100%',
     *             fieldLabel: 'Date',
     *             name: 'date',
     *             // The value matches the format; will be parsed and displayed using that format.
     *             format: 'm d Y',
     *             value: '2 4 1978'
     *         }, {
     *             xtype: 'datefield',
     *             anchor: '100%',
     *             fieldLabel: 'Date',
     *             name: 'date',
     *             // The value does not match the format, but does match an altFormat; will be parsed
     *             // using the altFormat and displayed using the format.
     *             format: 'm d Y',
     *             altFormats: 'm,d,Y|m.d.Y',
     *             value: '2.4.1978'
     *         }]
     *     });
     */
    export class Date extends Ext.form.field.Picker implements Ext.form.field.DateConfig {
        /**
         * Multiple date formats separated by "|" to try when parsing a user input value and it does not match the defined
         * format.
         */
        altFormats: string;

        /**
         * An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular expression so
         * they are very powerful. Some examples:
         *
         *     // disable these exact dates:
         *     disabledDates: ["03/08/2003", "09/16/2003"]
         *     // disable these days for every year:
         *     disabledDates: ["03/08", "09/16"]
         *     // only match the beginning (useful if you are using short years):
         *     disabledDates: ["^03/08"]
         *     // disable every day in March 2006:
         *     disabledDates: ["03/../2006"]
         *     // disable every day in every March:
         *     disabledDates: ["^03"]
         *
         * Note that the format of the dates included in the array should exactly match the {@link #format} config. In order
         * to support regular expressions, if you are using a {@link #format date format} that has "." in it, you will have
         * to escape the dot when restricting dates. For example: '["03\\.08\\.03"]'.
         */
        disabledDates: string;

        /**
         * The tooltip text to display when the date falls on a disabled date.
         */
        disabledDatesText: string;

        /**
         * An array of days to disable, 0 based. Some examples:
         *
         *     // disable Sunday and Saturday:
         *     disabledDays:  [0, 6]
         *     // disable weekdays:
         *     disabledDays: [1,2,3,4,5]
         */
        disabledDays: number;

        /**
         * The tooltip to display when the date falls on a disabled day.
         */
        disabledDaysText: string;

        /**
         * The default date format string which can be overriden for localization support. The format must be valid
         * according to {@link Ext.Date#parse}.
         */
        format: string;

        /**
         * The error text to display when the date in the field is invalid.
         */
        invalidText: string;

        matchFieldWidth: boolean;

        /**
         * The error text to display when the date in the cell is after {@link #maxValue}.
         */
        maxText: string;

        /**
         * The maximum allowed date. Can be either a Javascript date object or a string date in a valid format.
         */
        maxValue: Date|string;

        /**
         * The error text to display when the date in the cell is before {@link #minValue}.
         */
        minText: string;

        /**
         * The minimum allowed date. Can be either a Javascript date object or a string date in a valid format.
         */
        minValue: Date|string;

        /**
         * false to hide the footer area of the Date picker containing the Today button and disable the keyboard handler for
         * spacebar that selects the current date.
         */
        showToday: boolean;

        /**
         * Day index at which the week should begin, 0-based.
         *
         * Defaults to '0' (Sunday).
         *
         * Optional, Defaults to: undefined
         */
        startDay: number;

        /**
         * The date format string which will be submitted to the server. The format must be valid according to
         * {@link Ext.Date#parse}.
         *
         * Defaults to {@link #format}.
         */
        submitFormat: string;

        /**
         * An additional CSS class used to style the trigger button. The trigger will always get the class 'x-form-trigger'
         * and triggerCls will be **appended** if specified (default class displays a calendar icon).
         *
         * Optional, Defaults to: 'x-form-date-trigger'
         */
        triggerCls: string;

        /**
         * True to enforce strict date parsing to prevent the default Javascript "date rollover".
         * Defaults to the useStrict parameter set on Ext.Date
         * See {@link Ext.Date#parse}.
         */
        useStrict: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        createPicker();

        protected initComponent();

        initValue();

        /**
         * Attempts to parse a given string value using a given {@link Ext.Date#parse date format}.
         * @param {String} value The value to attempt to parse
         * @param {String} format A valid date format (see {@link Ext.Date#parse})
         * @return {Date} The parsed Date object, or null if the value could not be successfully parsed.
         */
        safeParse(value: string, format: string): Date;

        /**
         * Replaces any existing disabled dates with new values and refreshes the Date picker.
         * @param {String[]} disabledDates An array of date strings (see the {@link #disabledDates} config for details on
         * supported values) used to disable a pattern of dates.
         */
        setDisabledDates(disabledDates: string);

        /**
         * Replaces any existing disabled days (by index, 0-6) with new values and refreshes the Date picker.
         * @param {Number[]} disabledDays An array of disabled day indexes. See the {@link #disabledDays} config for details on
         * supported values.
         */
        setDisabledDays(disabledDays: number);

        /**
         * Replaces any existing {@link #maxValue} with the new value and refreshes the Date picker.
         * @param {Date} value The maximum date that can be selected
         */
        setMaxValue(value: Date);

        /**
         * Replaces any existing {@link #minValue} with the new value and refreshes the Date picker.
         * @param {Date} value The minimum date that can be selected
         */
        setMinValue(value: Date);
    }

    interface DisplayConfig extends Ext.form.field.BaseConfig {
        fieldBodyCls?: any;

        /**
         * The default CSS class for the field.
         *
         * Optional, Defaults to: "x-form-display-field"
         */
        fieldCls?: string;

        /**
         * True to escape HTML in text when rendering it.
         */
        htmlEncode?: boolean;

        /**
         * A function to transform the raw value for display in the field. The function will receive 2 arguments, the raw value
         * and the {@link Ext.form.field.Display} object.
         */
        renderer?: Function;

        /**
         * The scope to execute the {@link #renderer} function. Defaults to this.
         */
        scope?: any;

        submitValue?: any;
    }

    /**
     * A display-only text field which is not validated and not submitted. This is useful for when you want to display a
     * value from a form's {@link Ext.form.Basic#load loaded data} but do not want to allow the user to edit or submit that
     * value. The value can be optionally {@link #htmlEncode HTML encoded} if it contains HTML markup that you do not want
     * to be rendered.
     *
     * If you have more complex content, or need to include components within the displayed content, also consider using a
     * {@link Ext.form.FieldContainer} instead.
     *
     * Example:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         renderTo: Ext.getBody(),
     *         width: 175,
     *         height: 120,
     *         bodyPadding: 10,
     *         title: 'Final Score',
     *         items: [{
     *             xtype: 'displayfield',
     *             fieldLabel: 'Home',
     *             name: 'home_score',
     *             value: '10'
     *         }, {
     *             xtype: 'displayfield',
     *             fieldLabel: 'Visitor',
     *             name: 'visitor_score',
     *             value: '11'
     *         }],
     *         buttons: [{
     *             text: 'Update'
     *         }]
     *     });
     */
    export class Display extends Ext.form.field.Base implements Ext.form.field.DisplayConfig {
        fieldBodyCls: any;

        /**
         * The default CSS class for the field.
         *
         * Optional, Defaults to: "x-form-display-field"
         */
        fieldCls: string;

        /**
         * True to escape HTML in text when rendering it.
         */
        htmlEncode: boolean;

        /**
         * A function to transform the raw value for display in the field. The function will receive 2 arguments, the raw value
         * and the {@link Ext.form.field.Display} object.
         */
        renderer: Function;

        /**
         * The scope to execute the {@link #renderer} function. Defaults to this.
         */
        scope: any;

        submitValue: any;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected initEvents();

        isDirty();

        validate();
    }

    interface FieldConfig {
        /**
         * True to disable the field. Disabled Fields will not be {@link Ext.form.Basic#submit submitted}.
         */
        disabled?: boolean;

        /**
         * The name of the field. By default this is used as the parameter name when including the
         * {@link #getSubmitData field value} in a {@link Ext.form.Basic#submit form submit()}. To prevent the field from
         * being included in the form submit, set {@link #submitValue} to false.
         */
        name?: string;

        /**
         * Setting this to false will prevent the field from being {@link Ext.form.Basic#submit submitted} even when it is
         * not disabled.
         */
        submitValue?: boolean;

        /**
         * Specifies whether this field should be validated immediately whenever a change in its value is detected.
         * If the validation results in a change in the field's validity, a {@link #validitychange} event will be
         * fired. This allows the field to show feedback about the validity of its contents immediately as the user is
         * typing.
         *
         * When set to false, feedback will not be immediate. However the form will still be validated before submitting if
         * the clientValidation option to {@link Ext.form.Basic#doAction} is enabled, or if the field or form are validated
         * manually.
         *
         * See also {@link Ext.form.field.Base#checkChangeEvents} for controlling how changes to the field's value are
         * detected.
         */
        validateOnChange?: boolean;

        /**
         * A value to initialize this field with.
         */
        value?: any;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * This mixin provides a common interface for the logical behavior and state of form fields, including:
     *
     * - Getter and setter methods for field values
     * - Events and methods for tracking value and validity changes
     * - Methods for triggering validation
     *
     * **NOTE**: When implementing custom fields, it is most likely that you will want to extend the {@link Ext.form.field.Base}
     * component class rather than using this mixin directly, as BaseField contains additional logic for generating an
     * actual DOM complete with {@link Ext.form.Labelable label and error message} display and a form input field,
     * plus methods that bind the Field value getters and setters to the input field's value.
     *
     * If you do want to implement this mixin directly and don't want to extend {@link Ext.form.field.Base}, then
     * you will most likely want to override the following methods with custom implementations: {@link #getValue},
     * {@link #setValue}, and {@link #getErrors}. Other methods may be overridden as needed but their base
     * implementations should be sufficient for common cases. You will also need to make sure that {@link #initField}
     * is called during the component's initialization.
     */
    export class Field extends Ext.Base implements Ext.form.field.FieldConfig {
        /**
         * Flag denoting that this component is a Field. Always true.
         */
        isFormField: boolean;

        /**
         * The original value of the field as configured in the {@link #value} configuration, or as loaded by the last
         * form load operation if the form's {@link Ext.form.Basic#trackResetOnLoad trackResetOnLoad} setting is 'true'.
         */
        originalValue: any;

        /**
         * True to disable the field. Disabled Fields will not be {@link Ext.form.Basic#submit submitted}.
         */
        disabled: boolean;

        /**
         * The name of the field. By default this is used as the parameter name when including the
         * {@link #getSubmitData field value} in a {@link Ext.form.Basic#submit form submit()}. To prevent the field from
         * being included in the form submit, set {@link #submitValue} to false.
         */
        name: string;

        /**
         * Setting this to false will prevent the field from being {@link Ext.form.Basic#submit submitted} even when it is
         * not disabled.
         */
        submitValue: boolean;

        /**
         * Specifies whether this field should be validated immediately whenever a change in its value is detected.
         * If the validation results in a change in the field's validity, a {@link #validitychange} event will be
         * fired. This allows the field to show feedback about the validity of its contents immediately as the user is
         * typing.
         *
         * When set to false, feedback will not be immediate. However the form will still be validated before submitting if
         * the clientValidation option to {@link Ext.form.Basic#doAction} is enabled, or if the field or form are validated
         * manually.
         *
         * See also {@link Ext.form.field.Base#checkChangeEvents} for controlling how changes to the field's value are
         * detected.
         */
        validateOnChange: boolean;

        /**
         * A value to initialize this field with.
         */
        value: any;

        /**
         * A utility for grouping a set of modifications which may trigger value changes into a single transaction, to
         * prevent excessive firing of {@link #change} events. This is useful for instance if the field has sub-fields which
         * are being updated as a group; you don't want the container field to check its own changed state for each subfield
         * change.
         * @param {Object} fn A function containing the transaction code
         */
        batchChanges(fn: any);

        /**
         * Template method before a field is reset.
         */
        protected beforeReset();

        /**
         * Checks whether the value of the field has changed since the last time it was checked.
         * If the value has changed, it:
         *
         * 1. Fires the {@link #change change event},
         * 2. Performs validation if the {@link #validateOnChange} config is enabled, firing the
         *    {@link #validitychange validitychange event} if the validity has changed, and
         * 3. Checks the {@link #isDirty dirty state} of the field and fires the {@link #dirtychange dirtychange event}
         *    if it has changed.
         */
        checkChange();

        /**
         * Checks the {@link #isDirty} state of the field and if it has changed since the last time it was checked,
         * fires the {@link #dirtychange} event.
         */
        checkDirty();

        /**
         * Clear any invalid styles/messages for this field. Components using this mixin should implement this method to
         * update the components rendering to clear any existing messages.
         *
         * **Note**: this method does not cause the Field's {@link #validate} or {@link #isValid} methods to return 'true'
         * if the value does not _pass_ validation. So simply clearing a field's errors will not necessarily allow
         * submission of forms submitted with the {@link Ext.form.action.Submit#clientValidation} option set.
         */
        clearInvalid();

        /**
         * Only relevant if the instance's {@link #isFileUpload} method returns true. Returns a reference to the file input
         * DOM element holding the user's selected file. The input will be appended into the submission form and will not be
         * returned, so this method should also create a replacement.
         * @return {HTMLElement}
         */
        extractFileInput(): HTMLElement;

        /**
         * Runs this field's validators and returns an array of error messages for any validation failures. This is called
         * internally during validation and would not usually need to be used manually.
         *
         * Each subclass should override or augment the return value to provide their own errors.
         *
         * @param {Object} value The value to get errors for (defaults to the current field value)
         * @return {String[]} All error messages for this field; an empty Array if none.
         */
        getErrors(value: any): string;

        /**
         * Returns the value(s) that should be saved to the {@link Ext.data.Model} instance for this field, when {@link
         * Ext.form.Basic#updateRecord} is called. Typically this will be an object with a single name-value pair, the name
         * being this field's {@link #getName name} and the value being its current data value. More advanced field
         * implementations may return more than one name-value pair. The returned values will be saved to the corresponding
         * field names in the Model.
         *
         * Note that the values returned from this method are not guaranteed to have been successfully {@link #validate
         * validated}.
         *
         * @return {Object} A mapping of submit parameter names to values; each value should be a string, or an array of
         * strings if that particular name has multiple values. It can also return null if there are no parameters to be
         * submitted.
         */
        getModelData(): any;

        /**
         * Returns the parameter(s) that would be included in a standard form submit for this field. Typically this will be
         * an object with a single name-value pair, the name being this field's {@link #getName name} and the value being
         * its current stringified value. More advanced field implementations may return more than one name-value pair.
         *
         * Note that the values returned from this method are not guaranteed to have been successfully {@link #validate
         * validated}.
         *
         * @return {Object} A mapping of submit parameter names to values; each value should be a string, or an array of
         * strings if that particular name has multiple values. It can also return null if there are no parameters to be
         * submitted.
         */
        getSubmitData(): any;

        /**
         * Returns the current data value of the field. The type of value returned is particular to the type of the
         * particular field (e.g. a Date object for {@link Ext.form.field.Date}).
         * @return {Object} value The field value
         */
        getValue(): any;

        /**
         * Initializes this Field mixin on the current instance. Components using this mixin should call this method during
         * their own initialization process.
         */
        initField();

        /**
         * Initializes the field's value based on the initial config.
         */
        initValue();

        /**
         * Returns true if the value of this Field has been changed from its {@link #originalValue}.
         * Will always return false if the field is disabled.
         *
         * Note that if the owning {@link Ext.form.Basic form} was configured with
         * {@link Ext.form.Basic#trackResetOnLoad trackResetOnLoad} then the {@link #originalValue} is updated when
         * the values are loaded by {@link Ext.form.Basic}.{@link Ext.form.Basic#setValues setValues}.
         * @return {Boolean} True if this field has been changed from its original value (and is not disabled),
         * false otherwise.
         */
        isDirty(): boolean;

        /**
         * Returns whether two field {@link #getValue values} are logically equal. Field implementations may override this
         * to provide custom comparison logic appropriate for the particular field's data type.
         * @param {Object} value1 The first value to compare
         * @param {Object} value2 The second value to compare
         * @return {Boolean} True if the values are equal, false if inequal.
         */
        isEqual(value1: any, value2: any): boolean;

        /**
         * Returns whether this Field is a file upload field; if it returns true, forms will use special techniques for
         * {@link Ext.form.Basic#submit submitting the form} via AJAX. See {@link Ext.form.Basic#hasUpload} for details. If
         * this returns true, the {@link #extractFileInput} method must also be implemented to return the corresponding file
         * input element.
         * @return {Boolean}
         */
        isFileUpload(): boolean;

        /**
         * Returns whether or not the field value is currently valid by {@link #getErrors validating} the field's current
         * value. The {@link #validitychange} event will not be fired; use {@link #validate} instead if you want the event
         * to fire. **Note**: {@link #disabled} fields are always treated as valid.
         *
         * Implementations are encouraged to ensure that this method does not have side-effects such as triggering error
         * message display.
         *
         * @return {Boolean} True if the value is valid, else false
         */
        isValid(): boolean;

        /**
         * Associate one or more error messages with this field. Components using this mixin should implement this method to
         * update the component's rendering to display the messages.
         *
         * **Note**: this method does not cause the Field's {@link #validate} or {@link #isValid} methods to return 'false'
         * if the value does _pass_ validation. So simply marking a Field as invalid will not prevent submission of forms
         * submitted with the {@link Ext.form.action.Submit#clientValidation} option set.
         *
         * @param {String/String[]} errors The error message(s) for the field.
         */
        markInvalid(errors: string);

        /**
         * Resets the current field value to the originally loaded value and clears any validation messages. See {@link
         * Ext.form.Basic}.{@link Ext.form.Basic#trackResetOnLoad trackResetOnLoad}
         */
        reset();

        /**
         * Resets the field's {@link #originalValue} property so it matches the current {@link #getValue value}. This is
         * called by {@link Ext.form.Basic}.{@link Ext.form.Basic#setValues setValues} if the form's
         * {@link Ext.form.Basic#trackResetOnLoad trackResetOnLoad} property is set to true.
         */
        resetOriginalValue();

        /**
         * Sets a data value into the field and runs the change detection and validation.
         * @param {Object} value The value to set
         * @return {Ext.form.field.Field} this
         */
        setValue(value: any): Ext.form.field.Field;

        /**
         * Allows for any necessary modifications before the original
         * value is set
         * @param {Object} value The initial value
         * @return {Object} The modified initial value
         */
        protected transformOriginalValue(value: any): any;

        /**
         * Returns whether or not the field value is currently valid by {@link #getErrors validating} the field's current
         * value, and fires the {@link #validitychange} event if the field's validity has changed since the last validation.
         * **Note**: {@link #disabled} fields are always treated as valid.
         *
         * Custom implementations of this method are allowed to have side-effects such as triggering error message display.
         * To validate without side-effects, use {@link #isValid}.
         *
         * @return {Boolean} True if the value is valid, else false
         */
        validate(): boolean;

        /**
         * Fires when the value of a field is changed via the {@link #setValue} method.
         * @param {Object} newValue The new value
         * @param {Object} oldValue The original value
         */
        change(that: Ext.form.field.Field, newValue: any, oldValue: any);

        /**
         * Fires when a change in the field's {@link #isDirty} state is detected.
         * @param {Boolean} isDirty Whether or not the field is now dirty
         */
        dirtychange(that: Ext.form.field.Field, isDirty: boolean);

        /**
         * Fires when a change in the field's validity is detected.
         * @param {Boolean} isValid Whether or not the field is now valid
         */
        validitychange(that: Ext.form.field.Field, isValid: boolean);
    }

    interface FileButtonConfig extends Ext.button.ButtonConfig {
        cls?: any;

        preventDefault?: any;
    }

    export class FileButton extends Ext.button.Button implements Ext.form.field.FileButtonConfig {
        cls: string;

        preventDefault: boolean;

        protected renderTpl: Ext.XTemplate|string;

        protected afterRender();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected onDisable();

        protected onEnable();
    }

    interface FileConfig extends Ext.form.field.TriggerConfig {
        /**
         * A standard {@link Ext.button.Button} config object.
         */
        buttonConfig?: any;

        /**
         * The number of pixels of space reserved between the button and the text field. Note that this only
         * applies if {@link #buttonOnly} = false.
         */
        buttonMargin?: number;

        /**
         * True to display the file upload field as a button with no visible text field. If true, all
         * inherited Text members will still be available.
         */
        buttonOnly?: boolean;

        /**
         * The button text to display on the upload button. Note that if you supply a value for
         * {@link #buttonConfig}, the buttonConfig.text value will be used instead if available.
         */
        buttonText?: string;

        /**
         * True to clear the selected file value when the form this field belongs to
         * is submitted to the server.
         */
        clearOnSubmit?: boolean;

        componentLayout?: any;

        /**
         * Unlike with other form fields, the readOnly config defaults to true in File field.
         */
        readOnly?: boolean;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * A file upload field which has custom styling and allows control over the button text and other
     * features of {@link Ext.form.field.Text text fields} like {@link Ext.form.field.Text#emptyText empty text}.
     * It uses a hidden file input element behind the scenes to allow user selection of a file and to
     * perform the actual upload during {@link Ext.form.Basic#submit form submit}.
     *
     * Because there is no secure cross-browser way to programmatically set the value of a file input,
     * the standard Field 'setValue' method is not implemented. The '{@link #getValue}' method will return
     * a value that is browser-dependent; some have just the file name, some have a full path, some use
     * a fake path.
     *
     * **IMPORTANT:** File uploads are not performed using normal 'Ajax' techniques; see the description for
     * {@link Ext.form.Basic#hasUpload} for details.
     *
     * # Example Usage
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Upload a Photo',
     *         width: 400,
     *         bodyPadding: 10,
     *         frame: true,
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             xtype: 'filefield',
     *             name: 'photo',
     *             fieldLabel: 'Photo',
     *             labelWidth: 50,
     *             msgTarget: 'side',
     *             allowBlank: false,
     *             anchor: '100%',
     *             buttonText: 'Select Photo...'
     *         }],
     *
     *         buttons: [{
     *             text: 'Upload',
     *             handler: function() {
     *                 var form = this.up('form').getForm();
     *                 if(form.isValid()){
     *                     form.submit({
     *                         url: 'photo-upload.php',
     *                         waitMsg: 'Uploading your photo...',
     *                         success: function(fp, o) {
     *                             Ext.Msg.alert('Success', 'Your photo "' + o.result.file + '" has been uploaded.');
     *                         }
     *                     });
     *                 }
     *             }
     *         }]
     *     });
     */
    export class File extends Ext.form.field.Trigger implements Ext.form.field.FileConfig {
        /**
         * A reference to the trigger Button component created for this upload field. Only populated after this component is
         * rendered.
         */
        button: Ext.button.Button;

        /**
         * A reference to the invisible file input element created for this upload field. Only populated after this
         * component is rendered.
         */
        fileInputEl: Ext.dom.Element;

        /**
         * A standard {@link Ext.button.Button} config object.
         */
        buttonConfig: any;

        /**
         * The number of pixels of space reserved between the button and the text field. Note that this only
         * applies if {@link #buttonOnly} = false.
         */
        buttonMargin: number;

        /**
         * True to display the file upload field as a button with no visible text field. If true, all
         * inherited Text members will still be available.
         */
        buttonOnly: boolean;

        /**
         * The button text to display on the upload button. Note that if you supply a value for
         * {@link #buttonConfig}, the buttonConfig.text value will be used instead if available.
         */
        buttonText: string;

        /**
         * True to clear the selected file value when the form this field belongs to
         * is submitted to the server.
         */
        clearOnSubmit: boolean;

        componentLayout: string|any;

        /**
         * Unlike with other form fields, the readOnly config defaults to true in File field.
         */
        readOnly: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        extractFileInput();

        /**
         * Gets the markup to be inserted into the subTplMarkup.
         */
        getTriggerMarkup();

        isFileUpload();

        protected onDisable();

        protected onEnable();

        protected onRender();

        reset();

        /**
         * Fires when the underlying file input field's value has changed from the user selecting a new file from the system
         * file selection dialog.
         * @param {String} value The file value returned by the underlying file input field
         */
        change(that: Ext.form.field.File, value: string);
    }

    interface HiddenConfig extends Ext.form.field.BaseConfig {
        hidden?: any;

        hideLabel?: any;

        inputType?: any;
    }

    /**
     * A basic hidden field for storing hidden values in forms that need to be passed in the form submit.
     *
     * This creates an actual input element with type="submit" in the DOM. While its label is
     * {@link #hideLabel not rendered} by default, it is still a real component and may be sized according
     * to its owner container's layout.
     *
     * Because of this, in most cases it is more convenient and less problematic to simply
     * {@link Ext.form.action.Action#params pass hidden parameters} directly when
     * {@link Ext.form.Basic#submit submitting the form}.
     *
     * Example:
     *
     *     new Ext.form.Panel({
     *         title: 'My Form',
     *         items: [{
     *             xtype: 'textfield',
     *             fieldLabel: 'Text Field',
     *             name: 'text_field',
     *             value: 'value from text field'
     *         }, {
     *             xtype: 'hiddenfield',
     *             name: 'hidden_field_1',
     *             value: 'value from hidden field'
     *         }],
     *
     *         buttons: [{
     *             text: 'Submit',
     *             handler: function() {
     *                 this.up('form').getForm().submit({
     *                     params: {
     *                         hidden_field_2: 'value from submit call'
     *                     }
     *                 });
     *             }
     *         }]
     *     });
     *
     * Submitting the above form will result in three values sent to the server:
     *
     *     text_field=value+from+text+field&hidden;_field_1=value+from+hidden+field&hidden_field_2=value+from+submit+call
     */
    export class Hidden extends Ext.form.field.Base implements Ext.form.field.HiddenConfig {
        hidden: boolean;

        hideLabel: any;

        inputType: string;

        clearInvalid();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected initComponent();

        protected initEvents();
    }

    interface HtmlEditorConfig extends Ext.form.FieldContainerConfig {
        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the iframe element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        afterIFrameTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the textarea element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        afterTextAreaTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the iframe element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        beforeIFrameTpl?: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the textarea element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        beforeTextAreaTpl?: string|any[]|Ext.XTemplate;

        componentLayout?: any;

        /**
         * The default text for the create link prompt
         */
        createLinkText?: string;

        /**
         * A default {@link Ext.Component#ui ui} to use for the HtmlEditor's toolbar
         * {@link Ext.button.Button Buttons}
         */
        defaultButtonUI?: string;

        /**
         * The default value for the create link prompt
         *
         * Optional, Defaults to: 'http://'
         */
        defaultLinkValue?: string;

        /**
         * A default value to be put into the editor to resolve focus issues.
         *
         * Defaults to (Non-breaking space) in Opera and IE6,
         * (Zero-width space) in all other browsers.
         */
        defaultValue?: string;

        /**
         * Enable the left, center, right alignment buttons
         */
        enableAlignments?: boolean;

        /**
         * Enable the fore/highlight color buttons
         */
        enableColors?: boolean;

        /**
         * Enable font selection. Not available in Safari 2.
         */
        enableFont?: boolean;

        /**
         * Enable the increase/decrease font size buttons
         */
        enableFontSize?: boolean;

        /**
         * Enable the bold, italic and underline buttons
         */
        enableFormat?: boolean;

        /**
         * Enable the create link button. Not available in Safari 2.
         */
        enableLinks?: boolean;

        /**
         * Enable the bullet and numbered list buttons. Not available in Safari 2.
         */
        enableLists?: boolean;

        /**
         * Enable the switch to source edit button. Not available in Safari 2.
         */
        enableSourceEdit?: boolean;

        /**
         * An array of available font families
         */
        fontFamilies?: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * inside the iframe element (as attributes). If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        iframeAttrTpl?: string|any[]|Ext.XTemplate;
    }

    /**
     * Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be
     * automatically hidden when needed. These are noted in the config options where appropriate.
     *
     * The editor's toolbar buttons have tooltips defined in the {@link #buttonTips} property, but they are not
     * enabled by default unless the global {@link Ext.tip.QuickTipManager} singleton is
     * {@link Ext.tip.QuickTipManager#init initialized}.
     *
     * An Editor is a sensitive component that can't be used in all spots standard fields can be used. Putting an
     * Editor within any element that has display set to 'none' can cause problems in Safari and Firefox due to their
     * default iframe reloading bugs.
     *
     * # Example usage
     *
     * Simple example rendered with default options:
     *
     *     @example
     *     Ext.tip.QuickTipManager.init();  // enable tooltips
     *     Ext.create('Ext.form.HtmlEditor', {
     *         width: 580,
     *         height: 250,
     *         renderTo: Ext.getBody()
     *     });
     *
     * Passed via xtype into a container and with custom options:
     *
     *     @example
     *     Ext.tip.QuickTipManager.init();  // enable tooltips
     *     new Ext.panel.Panel({
     *         title: 'HTML Editor',
     *         renderTo: Ext.getBody(),
     *         width: 550,
     *         height: 250,
     *         frame: true,
     *         layout: 'fit',
     *         items: {
     *             xtype: 'htmleditor',
     *             enableColors: false,
     *             enableAlignments: false
     *         }
     *     });
     *
     * # Reflow issues
     *
     * In some browsers, a layout reflow will cause the underlying editor iframe to be reset. This
     * is most commonly seen when using the editor in collapsed panels with animation. In these cases
     * it is best to avoid animation. More information can be found here: https://bugzilla.mozilla.org/show_bug.cgi?id=90268
     */
    export class HtmlEditor extends Ext.form.FieldContainer implements Ext.form.field.HtmlEditorConfig {
        /**
         * Object collection of toolbar tooltips for the buttons in the editor. The key is the command id associated with
         * that button and the value is a valid QuickTips object. For example:
         *
         *     {
         *         bold: {
         *             title: 'Bold (Ctrl+B)',
         *             text: 'Make the selected text bold.',
         *             cls: 'x-html-editor-tip'
         *         },
         *         italic: {
         *             title: 'Italic (Ctrl+I)',
         *             text: 'Make the selected text italic.',
         *             cls: 'x-html-editor-tip'
         *         }
         *         // ...
         *     }
         */
        buttonTips: any;

        maskOnDisable: boolean;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the iframe element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        afterIFrameTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * after the textarea element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        afterTextAreaTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the iframe element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        beforeIFrameTpl: string|any[]|Ext.XTemplate;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * before the textarea element. If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        beforeTextAreaTpl: string|any[]|Ext.XTemplate;

        componentLayout: string|any;

        /**
         * The default text for the create link prompt
         */
        createLinkText: string;

        /**
         * A default {@link Ext.Component#ui ui} to use for the HtmlEditor's toolbar
         * {@link Ext.button.Button Buttons}
         */
        defaultButtonUI: string;

        /**
         * The default value for the create link prompt
         *
         * Optional, Defaults to: 'http://'
         */
        defaultLinkValue: string;

        /**
         * A default value to be put into the editor to resolve focus issues.
         *
         * Defaults to (Non-breaking space) in Opera and IE6,
         * (Zero-width space) in all other browsers.
         */
        defaultValue: string;

        /**
         * Enable the left, center, right alignment buttons
         */
        enableAlignments: boolean;

        /**
         * Enable the fore/highlight color buttons
         */
        enableColors: boolean;

        /**
         * Enable font selection. Not available in Safari 2.
         */
        enableFont: boolean;

        /**
         * Enable the increase/decrease font size buttons
         */
        enableFontSize: boolean;

        /**
         * Enable the bold, italic and underline buttons
         */
        enableFormat: boolean;

        /**
         * Enable the create link button. Not available in Safari 2.
         */
        enableLinks: boolean;

        /**
         * Enable the bullet and numbered list buttons. Not available in Safari 2.
         */
        enableLists: boolean;

        /**
         * Enable the switch to source edit button. Not available in Safari 2.
         */
        enableSourceEdit: boolean;

        /**
         * An array of available font families
         */
        fontFamilies: string;

        /**
         * An optional string or 'XTemplate' configuration to insert in the field markup
         * inside the iframe element (as attributes). If an 'XTemplate' is used, the component's
         * {@link Ext.form.field.Base#getSubTplData subTpl data} serves as the context.
         */
        iframeAttrTpl: string|any[]|Ext.XTemplate;

        /**
         * If you need/want custom HTML cleanup, this is the method you should override.
         * @param {String} html The HTML to be cleaned
         * @return {String} The cleaned HTML
         */
        protected cleanHtml(html: string): string;

        clearInvalid();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Executes a Midas editor command directly on the editor document. For visual commands, you should use
         * {@link #relayCmd} instead. **This should only be called after the editor is initialized.**
         * @param {String} cmd The Midas command
         * @param {String/Boolean} [value=null] The value to pass to the command
         */
        execCmd(cmd: string, value?: string|boolean);

        /**
         * Called when the editor initializes the iframe with HTML contents. Override this method if you
         * want to change the initialization markup of the iframe (e.g. to add stylesheets).
         *
         * **Note:** IE8-Standards has unwanted scroller behavior, so the default meta tag forces IE7 compatibility.
         * Also note that forcing IE7 mode works when the page is loaded normally, but if you are using IE's Web
         * Developer Tools to manually set the document mode, that will take precedence and override what this
         * code sets by default. This can be confusing when developing, but is not a user-facing issue.
         */
        protected getDocMarkup();

        /**
         * Returns the editor's toolbar. **This is only available after the editor has been rendered.**
         * @return {Ext.toolbar.Toolbar}
         */
        getToolbar(): Ext.toolbar.Toolbar;

        getValue();

        /**
         * Inserts the passed text at the current cursor position.
         * __Note:__ the editor must be initialized and activated to insert text.
         */
        insertAtCursor(text: string);

        isEqual(value1: any, value2: any);

        /**
         * Pushes the value of the textarea into the iframe editor.
         */
        protected pushValue();

        /**
         * Executes a Midas editor command on the editor document and performs necessary focus and toolbar updates.
         * **This should only be called after the editor is initialized.**
         * @param {String} cmd The Midas command
         * @param {String/Boolean} [value=null] The value to pass to the command
         */
        relayCmd(cmd: string, value?: string|boolean);

        /**
         * Sets the read only state of this field.
         * @param {Boolean} readOnly Whether the field should be read only.
         */
        setReadOnly(readOnly: boolean);

        setValue(value: any);

        /**
         * Syncs the contents of the editor iframe with the textarea.
         */
        protected syncValue();

        /**
         * Toggles the editor between standard and source edit mode.
         * @param {Boolean} [sourceEditMode] True for source edit, false for standard
         */
        toggleSourceEdit(sourceEditMode?: boolean);

        /**
         * Triggers a toolbar update by reading the markup state of the current selection in the editor.
         */
        protected updateToolbar();

        /**
         * Fires before the iframe editor is updated with content from the textarea. Return false to cancel the
         * push.
         */
        beforepush(that: Ext.form.field.HtmlEditor, html: string);

        /**
         * Fires before the textarea is updated with content from the editor iframe. Return false to cancel the
         * sync.
         */
        beforesync(that: Ext.form.field.HtmlEditor, html: string);

        /**
         * Fires when the editor switches edit modes
         * @param {Boolean} sourceEdit True if source edit, false if standard editing.
         */
        editmodechange(that: Ext.form.field.HtmlEditor, sourceEdit: boolean);

        /**
         * Fires when the editor is fully initialized (including the iframe)
         */
        initialize(that: Ext.form.field.HtmlEditor);

        /**
         * Fires when the iframe editor is updated with content from the textarea.
         */
        push(that: Ext.form.field.HtmlEditor, html: string);

        /**
         * Fires when the textarea is updated with content from the editor iframe.
         */
        sync(that: Ext.form.field.HtmlEditor, html: string);
    }

    interface NumberConfig extends Ext.form.field.SpinnerConfig {
        /**
         * False to disallow decimal values
         *
         * Optional, Defaults to: true
         */
        allowDecimals?: boolean;

        /**
         * Set to 'false' to disallow Exponential number notation
         *
         * Optional, Defaults to: true
         */
        allowExponential?: boolean;

        /**
         * True to automatically strip not allowed characters from the field.
         */
        autoStripChars?: boolean;

        /**
         * The base set of characters to evaluate as valid numbers.
         */
        baseChars?: string;

        /**
         * The maximum precision to display after the decimal separator
         */
        decimalPrecision?: number;

        /**
         * Character(s) to allow as the decimal separator
         */
        decimalSeparator?: string;

        /**
         * Error text to display if the maximum value validation fails.
         */
        maxText?: string;

        /**
         * The maximum allowed value. Will be used by the field's validation logic, and for
         * {@link Ext.form.field.Spinner#setSpinUpEnabled enabling/disabling the up spinner button}.
         *
         * Defaults to Number.MAX_VALUE.
         */
        maxValue?: number;

        /**
         * Error text to display if the minimum value validation fails.
         */
        minText?: string;

        /**
         * The minimum allowed value. Will be used by the field's validation logic,
         * and for {@link Ext.form.field.Spinner#setSpinUpEnabled enabling/disabling the down spinner button}.
         *
         * Defaults to Number.NEGATIVE_INFINITY.
         */
        minValue?: number;

        /**
         * Error text to display if the value is not a valid number. For example, this can happen if a valid character like
         * '.' or '-' is left in the field with no number.
         */
        nanText?: string;

        /**
         * Error text to display if the value is negative and {@link #minValue} is set to 0. This is used instead of the
         * {@link #minText} in that circumstance only.
         */
        negativeText?: string;

        /**
         * Specifies a numeric interval by which the field's value will be incremented or decremented when the user invokes
         * the spinner.
         */
        step?: number;

        /**
         * False to ensure that the {@link #getSubmitValue} method strips
         * always uses '.' as the separator, regardless of the {@link #decimalSeparator}
         * configuration.
         *
         * Optional, Defaults to: true
         */
        submitLocaleSeparator?: boolean;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * A numeric text field that provides automatic keystroke filtering to disallow non-numeric characters,
     * and numeric validation to limit the value to a range of valid numbers. The range of acceptable number
     * values can be controlled by setting the {@link #minValue} and {@link #maxValue} configs, and fractional
     * decimals can be disallowed by setting {@link #allowDecimals} to 'false'.
     *
     * By default, the number field is also rendered with a set of up/down spinner buttons and has
     * up/down arrow key and mouse wheel event listeners attached for incrementing/decrementing the value by the
     * {@link #step} value. To hide the spinner buttons set '{@link #hideTrigger hideTrigger}:true'; to disable
     * the arrow key and mouse wheel handlers set '{@link #keyNavEnabled keyNavEnabled}:false' and
     * '{@link #mouseWheelEnabled mouseWheelEnabled}:false'. See the example below.
     *
     * # Example usage
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'On The Wall',
     *         width: 300,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             xtype: 'numberfield',
     *             anchor: '100%',
     *             name: 'bottles',
     *             fieldLabel: 'Bottles of Beer',
     *             value: 99,
     *             maxValue: 99,
     *             minValue: 0
     *         }],
     *         buttons: [{
     *             text: 'Take one down, pass it around',
     *             handler: function() {
     *                 this.up('form').down('[name=bottles]').spinDown();
     *             }
     *         }]
     *     });
     *
     * # Removing UI Enhancements
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Personal Info',
     *         width: 300,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             xtype: 'numberfield',
     *             anchor: '100%',
     *             name: 'age',
     *             fieldLabel: 'Age',
     *             minValue: 0, //prevents negative numbers
     *
     *             // Remove spinner buttons, and arrow key and mouse wheel listeners
     *             hideTrigger: true,
     *             keyNavEnabled: false,
     *             mouseWheelEnabled: false
     *         }]
     *     });
     *
     * # Using Step
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         renderTo: Ext.getBody(),
     *         title: 'Step',
     *         width: 300,
     *         bodyPadding: 10,
     *         items: [{
     *             xtype: 'numberfield',
     *             anchor: '100%',
     *             name: 'evens',
     *             fieldLabel: 'Even Numbers',
     *
     *             // Set step so it skips every other number
     *             step: 2,
     *             value: 0,
     *
     *             // Add change handler to force user-entered numbers to evens
     *             listeners: {
     *                 change: function(field, value) {
     *                     value = parseInt(value, 10);
     *                     field.setValue(value + value % 2);
     *                 }
     *             }
     *         }]
     *     });
     */
    export class Number extends Ext.form.field.Spinner implements Ext.form.field.NumberConfig {
        /**
         * False to disallow decimal values
         *
         * Optional, Defaults to: true
         */
        allowDecimals: boolean;

        /**
         * Set to 'false' to disallow Exponential number notation
         *
         * Optional, Defaults to: true
         */
        allowExponential: boolean;

        /**
         * True to automatically strip not allowed characters from the field.
         */
        autoStripChars: boolean;

        /**
         * The base set of characters to evaluate as valid numbers.
         */
        baseChars: string;

        /**
         * The maximum precision to display after the decimal separator
         */
        decimalPrecision: number;

        /**
         * Character(s) to allow as the decimal separator
         */
        decimalSeparator: string;

        /**
         * Error text to display if the maximum value validation fails.
         */
        maxText: string;

        /**
         * The maximum allowed value. Will be used by the field's validation logic, and for
         * {@link Ext.form.field.Spinner#setSpinUpEnabled enabling/disabling the up spinner button}.
         *
         * Defaults to Number.MAX_VALUE.
         */
        maxValue: number;

        /**
         * Error text to display if the minimum value validation fails.
         */
        minText: string;

        /**
         * The minimum allowed value. Will be used by the field's validation logic,
         * and for {@link Ext.form.field.Spinner#setSpinUpEnabled enabling/disabling the down spinner button}.
         *
         * Defaults to Number.NEGATIVE_INFINITY.
         */
        minValue: number;

        /**
         * Error text to display if the value is not a valid number. For example, this can happen if a valid character like
         * '.' or '-' is left in the field with no number.
         */
        nanText: string;

        /**
         * Error text to display if the value is negative and {@link #minValue} is set to 0. This is used instead of the
         * {@link #minText} in that circumstance only.
         */
        negativeText: string;

        /**
         * Specifies a numeric interval by which the field's value will be incremented or decremented when the user invokes
         * the spinner.
         */
        step: number;

        /**
         * False to ensure that the {@link #getSubmitValue} method strips
         * always uses '.' as the separator, regardless of the {@link #decimalSeparator}
         * configuration.
         *
         * Optional, Defaults to: true
         */
        submitLocaleSeparator: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected initComponent();

        protected onSpinDown();

        protected onSpinUp();

        /**
         * Replaces any existing {@link #maxValue} with the new value.
         * @param {Number} value The maximum value
         */
        setMaxValue(value: number);

        /**
         * Replaces any existing {@link #minValue} with the new value.
         * @param {Number} value The minimum value
         */
        setMinValue(value: number);
    }

    interface PickerConfig extends Ext.form.field.TriggerConfig {
        /**
         * False to prevent the user from typing text directly into the field; the field can only have its value set via
         * selecting a value from the picker. In this state, the picker can also be opened by clicking directly on the input
         * field itself.
         */
        editable?: boolean;

        /**
         * Whether the picker dropdown's width should be explicitly set to match the width of the field. Defaults to true.
         */
        matchFieldWidth?: boolean;

        /**
         * A class to be added to the field's {@link #bodyEl} element when the picker is opened.
         *
         * Optional, Defaults to: 'x-pickerfield-open'
         */
        openCls?: string;

        /**
         * The {@link Ext.util.Positionable#alignTo alignment position} with which to align the picker. Defaults to "tl-bl?"
         */
        pickerAlign?: string;

        /**
         * An offset [x,y] to use in addition to the {@link #pickerAlign} when positioning the picker.
         * Defaults to undefined.
         */
        pickerOffset?: number;
    }

    /**
     * An abstract class for fields that have a single trigger which opens a "picker" popup below the field, e.g. a combobox
     * menu list or a date picker. It provides a base implementation for toggling the picker's visibility when the trigger
     * is clicked, as well as keyboard navigation and some basic events. Sizing and alignment of the picker can be
     * controlled via the {@link #matchFieldWidth} and {@link #pickerAlign}/{@link #pickerOffset} config properties
     * respectively.
     *
     * You would not normally use this class directly, but instead use it as the parent class for a specific picker field
     * implementation. Subclasses must implement the {@link #createPicker} method to create a picker component appropriate
     * for the field.
     */
    export class Picker extends Ext.form.field.Trigger implements Ext.form.field.PickerConfig {
        /**
         * True if the picker is currently expanded, false if not.
         */
        isExpanded: boolean;

        /**
         * False to prevent the user from typing text directly into the field; the field can only have its value set via
         * selecting a value from the picker. In this state, the picker can also be opened by clicking directly on the input
         * field itself.
         */
        editable: boolean;

        /**
         * Whether the picker dropdown's width should be explicitly set to match the width of the field. Defaults to true.
         */
        matchFieldWidth: boolean;

        /**
         * A class to be added to the field's {@link #bodyEl} element when the picker is opened.
         *
         * Optional, Defaults to: 'x-pickerfield-open'
         */
        openCls: string;

        /**
         * The {@link Ext.util.Positionable#alignTo alignment position} with which to align the picker. Defaults to "tl-bl?"
         */
        pickerAlign: string;

        /**
         * An offset [x,y] to use in addition to the {@link #pickerAlign} when positioning the picker.
         * Defaults to undefined.
         */
        pickerOffset: number;

        /**
         * Aligns the picker to the input element
         */
        protected alignPicker();

        /**
         * Collapses this field's picker dropdown.
         */
        collapse();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Creates and returns the component to be used as this field's picker. Must be implemented by subclasses of Picker.
         * The current field should also be passed as a configuration option to the picker component as the pickerField
         * property.
         */
        createPicker();

        /**
         * Expands this field's picker dropdown.
         */
        expand();

        /**
         * Returns a reference to the picker component for this field, creating it if necessary by
         * calling {@link #createPicker}.
         * @return {Ext.Component} The picker component
         */
        getPicker(): Ext.Component;

        protected initComponent();

        protected initEvents();

        /**
         * Fires when a value is selected via the picker.
         * @param {Ext.form.field.Picker} field This field instance
         * @param {Object} value The value that was selected. The exact type of this value is dependent on
         * the individual field and picker implementations.
         */
        select(field: Ext.form.field.Picker, value: any);
    }

    interface RadioConfig extends Ext.form.field.CheckboxConfig {
        /**
         * The CSS class to use when the radio field receives focus
         *
         * Optional, Defaults to: 'x-form-radio-focus'
         */
        focusCls?: string;

        inputType?: any;
    }

    /**
     * @docauthor Robert Dougan <rob@sencha.com>
     *
     * Single radio field. Similar to checkbox, but automatically handles making sure only one radio is checked
     * at a time within a group of radios with the same name.
     *
     * # Labeling
     *
     * In addition to the {@link Ext.form.Labelable standard field labeling options}, radio buttons
     * may be given an optional {@link #boxLabel} which will be displayed immediately to the right of the input. Also
     * see {@link Ext.form.RadioGroup} for a convenient method of grouping related radio buttons.
     *
     * # Values
     *
     * The main value of a Radio field is a boolean, indicating whether or not the radio is checked.
     *
     * The following values will check the radio:
     *
     * - 'true'
     * - ''true''
     * - ''1''
     * - ''on''
     *
     * Any other value will uncheck it.
     *
     * In addition to the main boolean value, you may also specify a separate {@link #inputValue}. This will be sent
     * as the parameter value when the form is {@link Ext.form.Basic#submit submitted}. You will want to set this
     * value if you have multiple radio buttons with the same {@link #name}, as is almost always the case.
     *
     * # Example usage
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title      : 'Order Form',
     *         width      : 300,
     *         bodyPadding: 10,
     *         renderTo   : Ext.getBody(),
     *         items: [
     *             {
     *                 xtype      : 'fieldcontainer',
     *                 fieldLabel : 'Size',
     *                 defaultType: 'radiofield',
     *                 defaults: {
     *                     flex: 1
     *                 },
     *                 layout: 'hbox',
     *                 items: [
     *                     {
     *                         boxLabel  : 'M',
     *                         name      : 'size',
     *                         inputValue: 'm',
     *                         id        : 'radio1'
     *                     }, {
     *                         boxLabel  : 'L',
     *                         name      : 'size',
     *                         inputValue: 'l',
     *                         id        : 'radio2'
     *                     }, {
     *                         boxLabel  : 'XL',
     *                         name      : 'size',
     *                         inputValue: 'xl',
     *                         id        : 'radio3'
     *                     }
     *                 ]
     *             },
     *             {
     *                 xtype      : 'fieldcontainer',
     *                 fieldLabel : 'Color',
     *                 defaultType: 'radiofield',
     *                 defaults: {
     *                     flex: 1
     *                 },
     *                 layout: 'hbox',
     *                 items: [
     *                     {
     *                         boxLabel  : 'Blue',
     *                         name      : 'color',
     *                         inputValue: 'blue',
     *                         id        : 'radio4'
     *                     }, {
     *                         boxLabel  : 'Grey',
     *                         name      : 'color',
     *                         inputValue: 'grey',
     *                         id        : 'radio5'
     *                     }, {
     *                         boxLabel  : 'Black',
     *                         name      : 'color',
     *                         inputValue: 'black',
     *                         id        : 'radio6'
     *                     }
     *                 ]
     *             }
     *         ],
     *         bbar: [
     *             {
     *                 text: 'Smaller Size',
     *                 handler: function() {
     *                     var radio1 = Ext.getCmp('radio1'),
     *                         radio2 = Ext.getCmp('radio2'),
     *                         radio3 = Ext.getCmp('radio3');
     *
     *                     //if L is selected, change to M
     *                     if (radio2.getValue()) {
     *                         radio1.setValue(true);
     *                         return;
     *                     }
     *
     *                     //if XL is selected, change to L
     *                     if (radio3.getValue()) {
     *                         radio2.setValue(true);
     *                         return;
     *                     }
     *
     *                     //if nothing is set, set size to S
     *                     radio1.setValue(true);
     *                 }
     *             },
     *             {
     *                 text: 'Larger Size',
     *                 handler: function() {
     *                     var radio1 = Ext.getCmp('radio1'),
     *                         radio2 = Ext.getCmp('radio2'),
     *                         radio3 = Ext.getCmp('radio3');
     *
     *                     //if M is selected, change to L
     *                     if (radio1.getValue()) {
     *                         radio2.setValue(true);
     *                         return;
     *                     }
     *
     *                     //if L is selected, change to XL
     *                     if (radio2.getValue()) {
     *                         radio3.setValue(true);
     *                         return;
     *                     }
     *
     *                     //if nothing is set, set size to XL
     *                     radio3.setValue(true);
     *                 }
     *             },
     *             '-',
     *             {
     *                 text: 'Select color',
     *                 menu: {
     *                     indent: false,
     *                     items: [
     *                         {
     *                             text: 'Blue',
     *                             handler: function() {
     *                                 var radio = Ext.getCmp('radio4');
     *                                 radio.setValue(true);
     *                             }
     *                         },
     *                         {
     *                             text: 'Grey',
     *                             handler: function() {
     *                                 var radio = Ext.getCmp('radio5');
     *                                 radio.setValue(true);
     *                             }
     *                         },
     *                         {
     *                             text: 'Black',
     *                             handler: function() {
     *                                 var radio = Ext.getCmp('radio6');
     *                                 radio.setValue(true);
     *                             }
     *                         }
     *                     ]
     *                 }
     *             }
     *         ]
     *     });
     */
    export class Radio extends Ext.form.field.Checkbox implements Ext.form.field.RadioConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Radio, or subclass thereof.
         */
        isRadio: boolean;

        /**
         * The CSS class to use when the radio field receives focus
         *
         * Optional, Defaults to: 'x-form-radio-focus'
         */
        focusCls: string;

        inputType: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * If this radio is part of a group, it will return the selected value
         * @return {String}
         */
        getGroupValue(): string;

        getModelData();
    }

    interface SpinnerConfig extends Ext.form.field.TriggerConfig {
        /**
         * Specifies whether the up and down arrow keys should trigger spinning up and down. Defaults to true.
         */
        keyNavEnabled?: boolean;

        /**
         * Specifies whether the mouse wheel should trigger spinning up and down while the field has focus.
         * Defaults to true.
         */
        mouseWheelEnabled?: boolean;

        /**
         * Whether a {@link Ext.util.ClickRepeater click repeater} should be attached to the spinner buttons.
         * Defaults to true.
         */
        repeatTriggerClick?: boolean;

        /**
         * Specifies whether the down spinner button is enabled. Defaults to true. To change this after the component is
         * created, use the {@link #setSpinDownEnabled} method.
         */
        spinDownEnabled?: boolean;

        /**
         * Specifies whether the up spinner button is enabled. Defaults to true. To change this after the component is
         * created, use the {@link #setSpinUpEnabled} method.
         */
        spinUpEnabled?: boolean;
    }

    /**
     * A field with a pair of up/down spinner buttons. This class is not normally instantiated directly,
     * instead it is subclassed and the {@link #onSpinUp} and {@link #onSpinDown} methods are implemented
     * to handle when the buttons are clicked. A good example of this is the {@link Ext.form.field.Number}
     * field which uses the spinner to increment and decrement the field's value by its
     * {@link Ext.form.field.Number#step step} config value.
     *
     * For example:
     *
     *     @example
     *     Ext.define('Ext.ux.CustomSpinner', {
     *         extend: 'Ext.form.field.Spinner',
     *         alias: 'widget.customspinner',
     *
     *         // override onSpinUp (using step isn't neccessary)
     *         onSpinUp: function() {
     *             var me = this;
     *             if (!me.readOnly) {
     *                 var val = parseInt(me.getValue().split(' '), 10)||0; // gets rid of " Pack", defaults to zero on parse failure
     *                 me.setValue((val + me.step) + ' Pack');
     *             }
     *         },
     *
     *         // override onSpinDown
     *         onSpinDown: function() {
     *             var me = this;
     *             if (!me.readOnly) {
     *                var val = parseInt(me.getValue().split(' '), 10)||0; // gets rid of " Pack", defaults to zero on parse failure
     *                if (val <= me.step) {
     *                    me.setValue('Dry!');
     *                } else {
     *                    me.setValue((val - me.step) + ' Pack');
     *                }
     *             }
     *         }
     *     });
     *
     *     Ext.create('Ext.form.FormPanel', {
     *         title: 'Form with SpinnerField',
     *         bodyPadding: 5,
     *         width: 350,
     *         renderTo: Ext.getBody(),
     *         items:[{
     *             xtype: 'customspinner',
     *             fieldLabel: 'How Much Beer?',
     *             step: 6
     *         }]
     *     });
     *
     * By default, pressing the up and down arrow keys will also trigger the onSpinUp and onSpinDown methods;
     * to prevent this, set '{@link #keyNavEnabled} = false'.
     */
    export class Spinner extends Ext.form.field.Trigger implements Ext.form.field.SpinnerConfig {
        /**
         * The spinner down button element
         */
        spinDownEl: Ext.dom.Element;

        /**
         * The spinner up button element
         */
        spinUpEl: Ext.dom.Element;

        /**
         * Specifies whether the up and down arrow keys should trigger spinning up and down. Defaults to true.
         */
        keyNavEnabled: boolean;

        /**
         * Specifies whether the mouse wheel should trigger spinning up and down while the field has focus.
         * Defaults to true.
         */
        mouseWheelEnabled: boolean;

        /**
         * Whether a {@link Ext.util.ClickRepeater click repeater} should be attached to the spinner buttons.
         * Defaults to true.
         */
        repeatTriggerClick: boolean;

        /**
         * Specifies whether the down spinner button is enabled. Defaults to true. To change this after the component is
         * created, use the {@link #setSpinDownEnabled} method.
         */
        spinDownEnabled: boolean;

        /**
         * Specifies whether the up spinner button is enabled. Defaults to true. To change this after the component is
         * created, use the {@link #setSpinUpEnabled} method.
         */
        spinUpEnabled: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Get the total width of the spinner button area.
         * @return {Number} The total spinner button width
         */
        getTriggerWidth(): number;

        protected initComponent();

        /**
         * This method is called when the spinner down button is clicked, or when the down arrow key is pressed if
         * {@link #keyNavEnabled} is true. Must be implemented by subclasses.
         */
        protected onSpinDown();

        /**
         * This method is called when the spinner up button is clicked, or when the up arrow key is pressed if
         * {@link #keyNavEnabled} is true. Must be implemented by subclasses.
         */
        protected onSpinUp();

        /**
         * Sets whether the spinner down button is enabled.
         * @param {Boolean} enabled true to enable the button, false to disable it.
         */
        setSpinDownEnabled(enabled: boolean);

        /**
         * Sets whether the spinner up button is enabled.
         * @param {Boolean} enabled true to enable the button, false to disable it.
         */
        setSpinUpEnabled(enabled: boolean);

        /**
         * Triggers the spinner to step down; fires the {@link #spin} and {@link #spindown} events and calls the
         * {@link #onSpinDown} method. Does nothing if the field is {@link #disabled} or if {@link #spinDownEnabled}
         * is false.
         */
        spinDown();

        /**
         * Triggers the spinner to step up; fires the {@link #spin} and {@link #spinup} events and calls the
         * {@link #onSpinUp} method. Does nothing if the field is {@link #disabled} or if {@link #spinUpEnabled}
         * is false.
         */
        spinUp();

        /**
         * Fires when the spinner is made to spin up or down.
         * @param {String} direction Either 'up' if spinning up, or 'down' if spinning down.
         */
        spin(that: Ext.form.field.Spinner, direction: string);

        /**
         * Fires when the spinner is made to spin down.
         */
        spindown(that: Ext.form.field.Spinner);

        /**
         * Fires when the spinner is made to spin up.
         */
        spinup(that: Ext.form.field.Spinner);
    }

    interface TextAreaConfig extends Ext.form.field.TextConfig {
        /**
         * An initial value for the 'cols' attribute on the textarea element. This is only used if the component has no
         * configured {@link #width} and is not given a width by its container's layout.
         */
        cols?: number;

        componentLayout?: any;

        /**
         * True if you want the ENTER key to be classed as a special key and the {@link #specialkey} event to be fired
         * when ENTER is pressed.
         */
        enterIsSpecial?: boolean;

        /**
         * A string that will be appended to the field's current value for the purposes of calculating the target field
         * size. Only used when the {@link #grow} config is true. Defaults to a newline for TextArea to ensure there is
         * always a space below the current line.
         */
        growAppend?: string;

        /**
         * The maximum height to allow when {@link #grow}=true
         */
        growMax?: number;

        /**
         * The minimum height to allow when {@link #grow}=true
         */
        growMin?: number;

        /**
         * true to prevent scrollbars from appearing regardless of how much text is in the field. This option is only
         * relevant when {@link #grow} is true. Equivalent to setting overflow: hidden.
         */
        preventScrollbars?: boolean;

        /**
         * An initial value for the 'rows' attribute on the textarea element. This is only used if the component has no
         * configured {@link #height} and is not given a height by its container's layout. Defaults to 4.
         */
        rows?: number;
    }

    /**
     * @docauthor Robert Dougan <rob@sencha.com>
     *
     * This class creates a multiline text field, which can be used as a direct replacement for traditional
     * textarea fields. In addition, it supports automatically {@link #grow growing} the height of the textarea to
     * fit its content.
     *
     * All of the configuration options from {@link Ext.form.field.Text} can be used on TextArea.
     *
     * Example usage:
     *
     *     @example
     *     Ext.create('Ext.form.FormPanel', {
     *         title      : 'Sample TextArea',
     *         width      : 400,
     *         bodyPadding: 10,
     *         renderTo   : Ext.getBody(),
     *         items: [{
     *             xtype     : 'textareafield',
     *             grow      : true,
     *             name      : 'message',
     *             fieldLabel: 'Message',
     *             anchor    : '100%'
     *         }]
     *     });
     *
     * Some other useful configuration options when using {@link #grow} are {@link #growMin} and {@link #growMax}.
     * These allow you to set the minimum and maximum grow heights for the textarea.
     *
     * **NOTE:** In some browsers, carriage returns ('\r', not to be confused with new lines)
     * will be automatically stripped out the value is set to the textarea. Since we cannot
     * use any reasonable method to attempt to re-insert these, they will automatically be
     * stripped out to ensure the behaviour is consistent across browser.
     */
    export class TextArea extends Ext.form.field.Text implements Ext.form.field.TextAreaConfig {
        /**
         * An initial value for the 'cols' attribute on the textarea element. This is only used if the component has no
         * configured {@link #width} and is not given a width by its container's layout.
         */
        cols: number;

        componentLayout: string|any;

        /**
         * True if you want the ENTER key to be classed as a special key and the {@link #specialkey} event to be fired
         * when ENTER is pressed.
         */
        enterIsSpecial: boolean;

        /**
         * A string that will be appended to the field's current value for the purposes of calculating the target field
         * size. Only used when the {@link #grow} config is true. Defaults to a newline for TextArea to ensure there is
         * always a space below the current line.
         */
        growAppend: string;

        /**
         * The maximum height to allow when {@link #grow}=true
         */
        growMax: number;

        /**
         * The minimum height to allow when {@link #grow}=true
         */
        growMin: number;

        /**
         * true to prevent scrollbars from appearing regardless of how much text is in the field. This option is only
         * relevant when {@link #grow} is true. Equivalent to setting overflow: hidden.
         */
        preventScrollbars: boolean;

        /**
         * An initial value for the 'rows' attribute on the textarea element. This is only used if the component has no
         * configured {@link #height} and is not given a height by its container's layout. Defaults to 4.
         */
        rows: number;

        protected afterRender();

        /**
         * Automatically grows the field to accomodate the height of the text up to the maximum field height allowed. This
         * only takes effect if {@link #grow} = true, and fires the {@link #autosize} event if the height changes.
         */
        autoSize();

        protected beforeDestroy();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected transformOriginalValue(value: any);
    }

    interface TextConfig extends Ext.form.field.BaseConfig {
        /**
         * Specify false to validate that the value's length must be > 0. If 'true', then a blank value is **always** taken to be valid regardless of any {@link #vtype}
         * validation that may be applied.
         *
         * If {@link #vtype} validation must still be applied to blank values, configure {@link #validateBlank} as 'true';
         *
         * Optional, Defaults to: true
         */
        allowBlank?: boolean;

        /**
         * Specify false to automatically trim the value before validating
         * the whether the value is blank. Setting this to false automatically
         * sets {@link #allowBlank} to false.
         */
        allowOnlyWhitespace?: boolean;

        /**
         * The error text to display if the **{@link #allowBlank}** validation fails
         */
        blankText?: string;

        /**
         * Specify true to disable input keystroke filtering
         *
         * Optional, Defaults to: false
         */
        disableKeyFilter?: boolean;

        /**
         * The CSS class to apply to an empty field to style the **{@link #emptyText}**.
         * This class is automatically added and removed as needed depending on the current field value.
         *
         * Optional, Defaults to: 'x-form-empty-field'
         */
        emptyCls?: string;

        /**
         * The default text to place into an empty field.
         *
         * Note that normally this value will be submitted to the server if this field is enabled; to prevent this you can
         * set the {@link Ext.form.action.Action#submitEmptyText submitEmptyText} option of {@link Ext.form.Basic#submit} to
         * false.
         *
         * Also note that if you use {@link #inputType inputType}:'file', {@link #emptyText} is not supported and should be
         * avoided.
         *
         * Note that for browsers that support it, setting this property will use the HTML 5 placeholder attribute, and for
         * older browsers that don't support the HTML 5 placeholder attribute the value will be placed directly into the input
         * element itself as the raw value. This means that older browsers will obfuscate the {@link #emptyText} value for
         * password input fields.
         */
        emptyText?: string;

        /**
         * true to enable the proxying of key events for the HTML input field
         *
         * Optional, Defaults to: false
         */
        enableKeyEvents?: boolean;

        /**
         * True to set the maxLength property on the underlying input field. Defaults to false
         */
        enforceMaxLength?: boolean;

        /**
         * true if this field should automatically grow and shrink to its content
         *
         * Optional, Defaults to: false
         */
        grow?: boolean;

        /**
         * A string that will be appended to the field's current value for the purposes of calculating the target field
         * size. Only used when the {@link #grow} config is true. Defaults to a single capital "W" (the widest character in
         * common fonts) to leave enough space for the next typed character and avoid the field value shifting before the
         * width is adjusted.
         */
        growAppend?: string;

        /**
         * The maximum width to allow when '{@link #grow} = true'
         */
        growMax?: number;

        /**
         * The minimum width to allow when '{@link #grow} = true'
         */
        growMin?: number;

        /**
         * An input mask regular expression that will be used to filter keystrokes (character being
         * typed) that do not match.
         * Note: It does not filter characters already in the input.
         */
        maskRe?: RegExp;

        /**
         * Maximum input field length allowed by validation. This behavior is intended to
         * provide instant feedback to the user by improving usability to allow pasting and editing or overtyping and back
         * tracking. To restrict the maximum number of characters that can be entered into the field use the
         * **{@link Ext.form.field.Text#enforceMaxLength enforceMaxLength}** option.
         *
         * Defaults to Number.MAX_VALUE.
         */
        maxLength?: number;

        /**
         * Error text to display if the **{@link #maxLength maximum length}** validation fails
         */
        maxLengthText?: string;

        /**
         * Minimum input field length required
         */
        minLength?: number;

        /**
         * Error text to display if the **{@link #minLength minimum length}** validation fails.
         */
        minLengthText?: string;

        /**
         * A JavaScript RegExp object to be tested against the field value during validation.
         * If the test fails, the field will be marked invalid using
         * either **{@link #regexText}** or **{@link #invalidText}**.
         */
        regex?: RegExp;

        /**
         * The error text to display if **{@link #regex}** is used and the test fails during validation
         */
        regexText?: string;

        /**
         * The CSS class to apply to a required field, i.e. a field where **{@link #allowBlank}** is false.
         *
         * Optional, Defaults to: 'x-form-required-field'
         */
        requiredCls?: string;

        /**
         * true to automatically select any existing field text when the field receives input focus
         *
         * Optional, Defaults to: false
         */
        selectOnFocus?: boolean;

        /**
         * An initial value for the 'size' attribute on the text input element. This is only used if the field has no
         * configured {@link #width} and is not given a width by its container's layout. Defaults to 20.
         */
        size?: number;

        /**
         * A JavaScript RegExp object used to strip unwanted content from the value
         * during input. If 'stripCharsRe' is specified,
         * every *character sequence* matching 'stripCharsRe' will be removed.
         */
        stripCharsRe?: RegExp;

        /**
         * Specify as 'true' to modify the behaviour of {@link #allowBlank} so that blank values are not passed as valid, but are subject to any configure {@link #vtype} validation.
         *
         * Optional, Defaults to: false
         */
        validateBlank?: boolean;

        /**
         * A custom validation function to be called during field validation ({@link #getErrors}).
         * If specified, this function will be called first, allowing the developer to override the default validation
         * process.
         *
         * This function will be passed the following parameters:
         *
         * The current field value
         *
         * - True if the value is valid
         * - An error message if the value is invalid
         */
        validator?: Function;

        /**
         * A validation type name as defined in {@link Ext.form.field.VTypes}
         */
        vtype?: string;

        /**
         * A custom error message to display in place of the default message provided for the **'{@link #vtype}'** currently
         * set for this field. **Note**: only applies if **'{@link #vtype}'** is set, else ignored.
         */
        vtypeText?: string;
    }

    /**
     * @docauthor Jason Johnston <jason@sencha.com>
     *
     * A basic text field.  Can be used as a direct replacement for traditional text inputs,
     * or as the base class for more sophisticated input controls (like {@link Ext.form.field.TextArea}
     * and {@link Ext.form.field.ComboBox}). Has support for empty-field placeholder values (see {@link #emptyText}).
     *
     * # Validation
     *
     * The Text field has a useful set of validations built in:
     *
     * - {@link #allowBlank} for making the field required
     * - {@link #minLength} for requiring a minimum value length
     * - {@link #maxLength} for setting a maximum value length (with {@link #enforceMaxLength} to add it
     *   as the 'maxlength' attribute on the input element)
     * - {@link #regex} to specify a custom regular expression for validation
     *
     * In addition, custom validations may be added:
     *
     * - {@link #vtype} specifies a virtual type implementation from {@link Ext.form.field.VTypes} which can contain
     *   custom validation logic
     * - {@link #validator} allows a custom arbitrary function to be called during validation
     *
     * The details around how and when each of these validation options get used are described in the
     * documentation for {@link #getErrors}.
     *
     * By default, the field value is checked for validity immediately while the user is typing in the
     * field. This can be controlled with the {@link #validateOnChange}, {@link #checkChangeEvents}, and
     * {@link #checkChangeBuffer} configurations. Also see the details on Form Validation in the
     * {@link Ext.form.Panel} class documentation.
     *
     * # Masking and Character Stripping
     *
     * Text fields can be configured with custom regular expressions to be applied to entered values before
     * validation: see {@link #maskRe} and {@link #stripCharsRe} for details.
     *
     * # Example usage
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Contact Info',
     *         width: 300,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             xtype: 'textfield',
     *             name: 'name',
     *             fieldLabel: 'Name',
     *             allowBlank: false  // requires a non-empty value
     *         }, {
     *             xtype: 'textfield',
     *             name: 'email',
     *             fieldLabel: 'Email Address',
     *             vtype: 'email'  // requires value to be a valid email address format
     *         }]
     *     });
     */
    export class Text extends Ext.form.field.Base implements Ext.form.field.TextConfig {
        /**
         * Specify false to validate that the value's length must be > 0. If 'true', then a blank value is **always** taken to be valid regardless of any {@link #vtype}
         * validation that may be applied.
         *
         * If {@link #vtype} validation must still be applied to blank values, configure {@link #validateBlank} as 'true';
         *
         * Optional, Defaults to: true
         */
        allowBlank: boolean;

        /**
         * Specify false to automatically trim the value before validating
         * the whether the value is blank. Setting this to false automatically
         * sets {@link #allowBlank} to false.
         */
        allowOnlyWhitespace: boolean;

        /**
         * The error text to display if the **{@link #allowBlank}** validation fails
         */
        blankText: string;

        /**
         * Specify true to disable input keystroke filtering
         *
         * Optional, Defaults to: false
         */
        disableKeyFilter: boolean;

        /**
         * The CSS class to apply to an empty field to style the **{@link #emptyText}**.
         * This class is automatically added and removed as needed depending on the current field value.
         *
         * Optional, Defaults to: 'x-form-empty-field'
         */
        emptyCls: string;

        /**
         * The default text to place into an empty field.
         *
         * Note that normally this value will be submitted to the server if this field is enabled; to prevent this you can
         * set the {@link Ext.form.action.Action#submitEmptyText submitEmptyText} option of {@link Ext.form.Basic#submit} to
         * false.
         *
         * Also note that if you use {@link #inputType inputType}:'file', {@link #emptyText} is not supported and should be
         * avoided.
         *
         * Note that for browsers that support it, setting this property will use the HTML 5 placeholder attribute, and for
         * older browsers that don't support the HTML 5 placeholder attribute the value will be placed directly into the input
         * element itself as the raw value. This means that older browsers will obfuscate the {@link #emptyText} value for
         * password input fields.
         */
        emptyText: string;

        /**
         * true to enable the proxying of key events for the HTML input field
         *
         * Optional, Defaults to: false
         */
        enableKeyEvents: boolean;

        /**
         * True to set the maxLength property on the underlying input field. Defaults to false
         */
        enforceMaxLength: boolean;

        /**
         * true if this field should automatically grow and shrink to its content
         *
         * Optional, Defaults to: false
         */
        grow: boolean;

        /**
         * A string that will be appended to the field's current value for the purposes of calculating the target field
         * size. Only used when the {@link #grow} config is true. Defaults to a single capital "W" (the widest character in
         * common fonts) to leave enough space for the next typed character and avoid the field value shifting before the
         * width is adjusted.
         */
        growAppend: string;

        /**
         * The maximum width to allow when '{@link #grow} = true'
         */
        growMax: number;

        /**
         * The minimum width to allow when '{@link #grow} = true'
         */
        growMin: number;

        /**
         * An input mask regular expression that will be used to filter keystrokes (character being
         * typed) that do not match.
         * Note: It does not filter characters already in the input.
         */
        maskRe: RegExp;

        /**
         * Maximum input field length allowed by validation. This behavior is intended to
         * provide instant feedback to the user by improving usability to allow pasting and editing or overtyping and back
         * tracking. To restrict the maximum number of characters that can be entered into the field use the
         * **{@link Ext.form.field.Text#enforceMaxLength enforceMaxLength}** option.
         *
         * Defaults to Number.MAX_VALUE.
         */
        maxLength: number;

        /**
         * Error text to display if the **{@link #maxLength maximum length}** validation fails
         */
        maxLengthText: string;

        /**
         * Minimum input field length required
         */
        minLength: number;

        /**
         * Error text to display if the **{@link #minLength minimum length}** validation fails.
         */
        minLengthText: string;

        /**
         * A JavaScript RegExp object to be tested against the field value during validation.
         * If the test fails, the field will be marked invalid using
         * either **{@link #regexText}** or **{@link #invalidText}**.
         */
        regex: RegExp;

        /**
         * The error text to display if **{@link #regex}** is used and the test fails during validation
         */
        regexText: string;

        /**
         * The CSS class to apply to a required field, i.e. a field where **{@link #allowBlank}** is false.
         *
         * Optional, Defaults to: 'x-form-required-field'
         */
        requiredCls: string;

        /**
         * true to automatically select any existing field text when the field receives input focus
         *
         * Optional, Defaults to: false
         */
        selectOnFocus: boolean;

        /**
         * An initial value for the 'size' attribute on the text input element. This is only used if the field has no
         * configured {@link #width} and is not given a width by its container's layout. Defaults to 20.
         */
        size: number;

        /**
         * A JavaScript RegExp object used to strip unwanted content from the value
         * during input. If 'stripCharsRe' is specified,
         * every *character sequence* matching 'stripCharsRe' will be removed.
         */
        stripCharsRe: RegExp;

        /**
         * Specify as 'true' to modify the behaviour of {@link #allowBlank} so that blank values are not passed as valid, but are subject to any configure {@link #vtype} validation.
         *
         * Optional, Defaults to: false
         */
        validateBlank: boolean;

        /**
         * A custom validation function to be called during field validation ({@link #getErrors}).
         * If specified, this function will be called first, allowing the developer to override the default validation
         * process.
         *
         * This function will be passed the following parameters:
         *
         * The current field value
         *
         * - True if the value is valid
         * - An error message if the value is invalid
         */
        validator: Function;

        /**
         * A validation type name as defined in {@link Ext.form.field.VTypes}
         */
        vtype: string;

        /**
         * A custom error message to display in place of the default message provided for the **'{@link #vtype}'** currently
         * set for this field. **Note**: only applies if **'{@link #vtype}'** is set, else ignored.
         */
        vtypeText: string;

        protected afterRender();

        applyState(state: any);

        /**
         * Automatically grows the field to accomodate the width of the text up to the maximum field width allowed. This
         * only takes effect if {@link #grow} = true, and fires the {@link #autosize} event if the width changes.
         */
        autoSize();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Validates a value according to the field's validation rules and returns an array of errors
         * for any failing validations. Validation rules are processed in the following order:
         *
         * 1. **Field specific validator**
         *
         *     A validator offers a way to customize and reuse a validation specification.
         *     If a field is configured with a '{@link #validator}'
         *     function, it will be passed the current field value.  The '{@link #validator}'
         *     function is expected to return either:
         *
         *     - Boolean 'true'  if the value is valid (validation continues).
         *     - a String to represent the invalid message if invalid (validation halts).
         *
         * 2. **Basic Validation**
         *
         *     If the '{@link #validator}' has not halted validation,
         *     basic validation proceeds as follows:
         *
         *     - '{@link #allowBlank}' : (Invalid message = '{@link #blankText}')
         *
         *         Depending on the configuration of '{@link #allowBlank}', a
         *         blank field will cause validation to halt at this step and return
         *         Boolean true or false accordingly.
         *
         *     - '{@link #minLength}' : (Invalid message = '{@link #minLengthText}')
         *
         *         If the passed value does not satisfy the '{@link #minLength}'
         *         specified, validation halts.
         *
         *     -  '{@link #maxLength}' : (Invalid message = '{@link #maxLengthText}')
         *
         *         If the passed value does not satisfy the '{@link #maxLength}'
         *         specified, validation halts.
         *
         * 3. **Preconfigured Validation Types (VTypes)**
         *
         *     If none of the prior validation steps halts validation, a field
         *     configured with a '{@link #vtype}' will utilize the
         *     corresponding {@link Ext.form.field.VTypes VTypes} validation function.
         *     If invalid, either the field's '{@link #vtypeText}' or
         *     the VTypes vtype Text property will be used for the invalid message.
         *     Keystrokes on the field will be filtered according to the VTypes
         *     vtype Mask property.
         *
         * 4. **Field specific regex test**
         *
         *     If none of the prior validation steps halts validation, a field's
         *     configured '{@link #regex}' test will be processed.
         *     The invalid message for this test is configured with '{@link #regexText}'
         *
         * @param {Object} value The value to validate. The processed raw value will be used if nothing is passed.
         * @return {String[]} Array of any validation errors
         */
        getErrors(value: any): string;

        /**
         * Returns the raw String value of the field, without performing any normalization, conversion, or validation. Gets
         * the current value of the input element if the field has been rendered, ignoring the value if it is the
         * {@link #emptyText}. To get a normalized and converted value see {@link #getValue}.
         * @return {String} The raw String value of the field
         */
        getRawValue(): string;

        protected initComponent();

        protected initEvents();

        protected onDestroy();

        protected onDisable();

        protected onEnable();

        /**
         * Resets the current field value to the originally-loaded value and clears any validation messages.
         * Also adds **{@link #emptyText}** and **{@link #emptyCls}** if the original value was blank.
         */
        reset();

        /**
         * Selects text in this field
         * @param {Number} [start=0] The index where the selection should start
         * @param {Number} [end] The index where the selection should end (defaults to the text length)
         */
        selectText(start?: number, end?: number);

        /**
         * Fires when the **{@link #autoSize}** function is triggered and the field is resized according to the
         * {@link #grow}/{@link #growMin}/{@link #growMax} configs as a result. This event provides a hook for the
         * developer to apply additional logic at runtime to resize the field if needed.
         * @param {Ext.form.field.Text} this This text field
         * @param {Number} width The new field width
         */
        autosize(that: Ext.form.field.Text, width: number);

        /**
         * Keydown input field event. This event only fires if **{@link #enableKeyEvents}** is set to true.
         * @param {Ext.form.field.Text} this This text field
         */
        keydown(that: Ext.form.field.Text, e: Ext.EventObject);

        /**
         * Keypress input field event. This event only fires if **{@link #enableKeyEvents}** is set to true.
         * @param {Ext.form.field.Text} this This text field
         */
        keypress(that: Ext.form.field.Text, e: Ext.EventObject);

        /**
         * Keyup input field event. This event only fires if **{@link #enableKeyEvents}** is set to true.
         * @param {Ext.form.field.Text} this This text field
         */
        keyup(that: Ext.form.field.Text, e: Ext.EventObject);
    }

    interface TimeConfig extends Ext.form.field.ComboBoxConfig {
        /**
         * Multiple date formats separated by "|" to try when parsing a user input value and it doesn't match the defined
         * format.
         */
        altFormats?: string;

        displayField?: any;

        /**
         * The default time format string which can be overriden for localization support. The format must be valid
         * according to {@link Ext.Date#parse}.
         *
         * Defaults to ''g:i A'', e.g., ''3:15 PM''. For 24-hour time format try ''H:i'' instead.
         *
         * Optional, Defaults to: undefined
         */
        format?: string;

        /**
         * The number of minutes between each time value in the list.
         */
        increment?: number;

        /**
         * The error text to display when the time in the field is invalid.
         */
        invalidText?: string;

        /**
         * The error text to display when the entered time is after {@link #maxValue}.
         */
        maxText?: string;

        /**
         * The maximum allowed time. Can be either a Javascript date object with a valid time value or a string time in a
         * valid format -- see {@link #format} and {@link #altFormats}.
         */
        maxValue?: Date|string;

        /**
         * The error text to display when the entered time is before {@link #minValue}.
         */
        minText?: string;

        /**
         * The minimum allowed time. Can be either a Javascript date object with a valid time value or a string time in a
         * valid format -- see {@link #format} and {@link #altFormats}.
         */
        minValue?: Date|string;

        /**
         * The maximum height of the {@link Ext.picker.Time} dropdown.
         */
        pickerMaxHeight?: number;

        queryMode?: any;

        /**
         * Whether the Tab key should select the currently highlighted item.
         */
        selectOnTab?: boolean;

        /**
         * Specify as 'true' to enforce that only values on the {@link #increment} boundary are accepted.
         *
         * Optional, Defaults to: false
         */
        snapToIncrement?: boolean;

        /**
         * The date format string which will be submitted to the server. The format must be valid according to
         * {@link Ext.Date#parse}.
         *
         * Defaults to {@link #format}.
         *
         * Optional, Defaults to: undefined
         */
        submitFormat?: string;

        /**
         * An additional CSS class used to style the trigger button. The trigger will always get the {@link #triggerBaseCls}
         * by default and triggerCls will be **appended** if specified.
         *
         * Optional, Defaults to: 'x-form-time-trigger'
         */
        triggerCls?: string;

        valueField?: any;
    }

    /**
     * Provides a time input field with a time dropdown and automatic time validation.
     *
     * This field recognizes and uses JavaScript Date objects as its main {@link #value} type (only the time portion of the
     * date is used; the month/day/year are ignored). In addition, it recognizes string values which are parsed according to
     * the {@link #format} and/or {@link #altFormats} configs. These may be reconfigured to use time formats appropriate for
     * the user's locale.
     *
     * The field may be limited to a certain range of times by using the {@link #minValue} and {@link #maxValue} configs,
     * and the interval between time options in the dropdown can be changed with the {@link #increment} config.
     *
     * Example usage:
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Time Card',
     *         width: 300,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             xtype: 'timefield',
     *             name: 'in',
     *             fieldLabel: 'Time In',
     *             minValue: '6:00 AM',
     *             maxValue: '8:00 PM',
     *             increment: 30,
     *             anchor: '100%'
     *         }, {
     *             xtype: 'timefield',
     *             name: 'out',
     *             fieldLabel: 'Time Out',
     *             minValue: '6:00 AM',
     *             maxValue: '8:00 PM',
     *             increment: 30,
     *             anchor: '100%'
     *        }]
     *     });
     */
    export class Time extends Ext.form.field.ComboBox implements Ext.form.field.TimeConfig {
        /**
         * Multiple date formats separated by "|" to try when parsing a user input value and it doesn't match the defined
         * format.
         */
        altFormats: string;

        displayField: string;

        /**
         * The default time format string which can be overriden for localization support. The format must be valid
         * according to {@link Ext.Date#parse}.
         *
         * Defaults to ''g:i A'', e.g., ''3:15 PM''. For 24-hour time format try ''H:i'' instead.
         *
         * Optional, Defaults to: undefined
         */
        format: string;

        /**
         * The number of minutes between each time value in the list.
         */
        increment: number;

        /**
         * The error text to display when the time in the field is invalid.
         */
        invalidText: string;

        /**
         * The error text to display when the entered time is after {@link #maxValue}.
         */
        maxText: string;

        /**
         * The maximum allowed time. Can be either a Javascript date object with a valid time value or a string time in a
         * valid format -- see {@link #format} and {@link #altFormats}.
         */
        maxValue: Date|string;

        /**
         * The error text to display when the entered time is before {@link #minValue}.
         */
        minText: string;

        /**
         * The minimum allowed time. Can be either a Javascript date object with a valid time value or a string time in a
         * valid format -- see {@link #format} and {@link #altFormats}.
         */
        minValue: Date|string;

        /**
         * The maximum height of the {@link Ext.picker.Time} dropdown.
         */
        pickerMaxHeight: number;

        queryMode: string;

        /**
         * Whether the Tab key should select the currently highlighted item.
         */
        selectOnTab: boolean;

        /**
         * Specify as 'true' to enforce that only values on the {@link #increment} boundary are accepted.
         *
         * Optional, Defaults to: false
         */
        snapToIncrement: boolean;

        /**
         * The date format string which will be submitted to the server. The format must be valid according to
         * {@link Ext.Date#parse}.
         *
         * Defaults to {@link #format}.
         *
         * Optional, Defaults to: undefined
         */
        submitFormat: string;

        /**
         * An additional CSS class used to style the trigger button. The trigger will always get the {@link #triggerBaseCls}
         * by default and triggerCls will be **appended** if specified.
         *
         * Optional, Defaults to: 'x-form-time-trigger'
         */
        triggerCls: string;

        valueField: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected initComponent();

        /**
         * Replaces any existing {@link #maxValue} with the new time and refreshes the picker's range.
         * @param {Date/String} value The maximum time that can be selected
         */
        setMaxValue(value: Date|string);

        /**
         * Replaces any existing {@link #minValue} with the new time and refreshes the picker's range.
         * @param {Date/String} value The minimum time that can be selected
         */
        setMinValue(value: Date|string);
    }

    interface TriggerConfig extends Ext.form.field.TextConfig {
        componentLayout?: any;

        /**
         * false to prevent the user from typing text directly into the field; the field can only have its value set via an
         * action invoked by the trigger.
         */
        editable?: boolean;

        /**
         * true to hide the trigger element and display only the base text field
         */
        hideTrigger?: boolean;

        /**
         * true to prevent the user from changing the field, and hides the trigger. Supercedes the editable and hideTrigger
         * options if the value is true.
         */
        readOnly?: boolean;

        /**
         * true to attach a {@link Ext.util.ClickRepeater click repeater} to the trigger.
         */
        repeatTriggerClick?: boolean;

        /**
         * true to select any existing text in the field immediately on focus. Only applies when
         * {@link #editable editable} = true
         *
         * Optional, Defaults to: false
         */
        selectOnFocus?: boolean;

        /**
         * The base CSS class that is always added to the trigger button. The {@link #triggerCls} will be appended in
         * addition to this class.
         */
        triggerBaseCls?: any;

        /**
         * An additional CSS class used to style the trigger button. The trigger will always get the {@link #triggerBaseCls}
         * by default and triggerCls will be **appended** if specified.
         */
        triggerCls?: string;

        /**
         * The CSS class that is added to the text field when component is read-only or not editable.
         */
        triggerNoEditCls?: any;

        /**
         * The CSS class that is added to the div wrapping the trigger button(s).
         */
        triggerWrapCls?: any;
    }

    /**
     * Provides a convenient wrapper for TextFields that adds a clickable trigger button (looks like a combobox by default).
     * The trigger has no default action, so you must assign a function to implement the trigger click handler by overriding
     * {@link #onTriggerClick}. You can create a Trigger field directly, as it renders exactly like a combobox for which you
     * can provide a custom implementation.
     *
     * For example:
     *
     *     @example
     *     Ext.define('Ext.ux.CustomTrigger', {
     *         extend: 'Ext.form.field.Trigger',
     *         alias: 'widget.customtrigger',
     *
     *         // override onTriggerClick
     *         onTriggerClick: function() {
     *             Ext.Msg.alert('Status', 'You clicked my trigger!');
     *         }
     *     });
     *
     *     Ext.create('Ext.form.FormPanel', {
     *         title: 'Form with TriggerField',
     *         bodyPadding: 5,
     *         width: 350,
     *         renderTo: Ext.getBody(),
     *         items:[{
     *             xtype: 'customtrigger',
     *             fieldLabel: 'Sample Trigger',
     *             emptyText: 'click the trigger'
     *         }]
     *     });
     *
     * However, in general you will most likely want to use Trigger as the base class for a reusable component.
     * {@link Ext.form.field.Date} and {@link Ext.form.field.ComboBox} are perfect examples of this.
     */
    export class Trigger extends Ext.form.field.Text implements Ext.form.field.TriggerConfig {
        /**
         * A reference to the 'TD' element wrapping the input element. Only set after the field has been rendered.
         */
        inputCell: Ext.dom.Element;

        /**
         * A composite of all the trigger button elements. Only set after the field has been rendered.
         */
        triggerEl: Ext.dom.CompositeElement;

        /**
         * A reference to the 'TABLE' element which encapsulates the input field and all trigger button(s). Only set after the field has been rendered.
         */
        triggerWrap: Ext.dom.Element;

        componentLayout: string|any;

        /**
         * false to prevent the user from typing text directly into the field; the field can only have its value set via an
         * action invoked by the trigger.
         */
        editable: boolean;

        /**
         * true to hide the trigger element and display only the base text field
         */
        hideTrigger: boolean;

        /**
         * true to prevent the user from changing the field, and hides the trigger. Supercedes the editable and hideTrigger
         * options if the value is true.
         */
        readOnly: boolean;

        /**
         * true to attach a {@link Ext.util.ClickRepeater click repeater} to the trigger.
         */
        repeatTriggerClick: boolean;

        /**
         * true to select any existing text in the field immediately on focus. Only applies when
         * {@link #editable editable} = true
         *
         * Optional, Defaults to: false
         */
        selectOnFocus: boolean;

        /**
         * The base CSS class that is always added to the trigger button. The {@link #triggerCls} will be appended in
         * addition to this class.
         */
        triggerBaseCls: any;

        /**
         * An additional CSS class used to style the trigger button. The trigger will always get the {@link #triggerBaseCls}
         * by default and triggerCls will be **appended** if specified.
         */
        triggerCls: string;

        /**
         * The CSS class that is added to the text field when component is read-only or not editable.
         */
        triggerNoEditCls: any;

        /**
         * The CSS class that is added to the div wrapping the trigger button(s).
         */
        triggerWrapCls: any;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected getLabelableRenderData();

        /**
         * Get the total width of the trigger button area.
         * @return {Number} The total trigger width
         */
        getTriggerWidth(): number;

        protected initComponent();

        protected onRender();

        /**
         * The function that should handle the trigger's click event. This method does nothing by default until overridden
         * by an implementing function. See Ext.form.field.ComboBox and Ext.form.field.Date for sample implementations.
         */
        protected onTriggerClick(e: Ext.EventObject);

        /**
         * Sets the editable state of this field. This method is the runtime equivalent of setting the 'editable' config
         * option at config time.
         * @param {Boolean} editable True to allow the user to directly edit the field text. If false is passed, the user
         * will only be able to modify the field using the trigger. Will also add a click event to the text field which
         * will call the trigger.
         */
        setEditable(editable: boolean);

        /**
         * Sets the read-only state of this field. This method is the runtime equivalent of setting the 'readOnly' config
         * option at config time.
         * @param {Boolean} readOnly True to prevent the user changing the field and explicitly hide the trigger. Setting
         * this to true will supercede settings editable and hideTrigger. Setting this to false will defer back to editable
         * and hideTrigger.
         */
        setReadOnly(readOnly: boolean);
    }

    /**
     * @alternateClassName Ext.form.VTypes
     *
     * This is a singleton object which contains a set of commonly used field validation functions
     * and provides a mechanism for creating reusable custom field validations.
     * The following field validation functions are provided out of the box:
     *
     * - {@link #alpha}
     * - {@link #alphanum}
     * - {@link #email}
     * - {@link #url}
     *
     * VTypes can be applied to a {@link Ext.form.field.Text Text Field} using the '{@link Ext.form.field.Text#vtype vtype}' configuration:
     *
     *     Ext.create('Ext.form.field.Text', {
     *         fieldLabel: 'Email Address',
     *         name: 'email',
     *         vtype: 'email' // applies email validation rules to this field
     *     });
     *
     * To create custom VTypes:
     *
     *     // custom Vtype for vtype:'time'
     *     var timeTest = /^([1-9]|1[0-9]):([0-5][0-9])(\s[a|p]m)$/i;
     *     Ext.apply(Ext.form.field.VTypes, {
     *         //  vtype validation function
     *         time: function(val, field) {
     *             return timeTest.test(val);
     *         },
     *         // vtype Text property: The error text to display when the validation function returns false
     *         timeText: 'Not a valid time.  Must be in the format "12:34 PM".',
     *         // vtype Mask property: The keystroke filter mask
     *         timeMask: /[\d\s:amp]/i
     *     });
     *
     * In the above example the 'time' function is the validator that will run when field validation occurs,
     * 'timeText' is the error message, and 'timeMask' limits what characters can be typed into the field.
     * Note that the 'Text' and 'Mask' functions must begin with the same name as the validator function.
     *
     * Using a custom validator is the same as using one of the build-in validators - just use the name of the validator function
     * as the '{@link Ext.form.field.Text#vtype vtype}' configuration on a {@link Ext.form.field.Text Text Field}:
     *
     *     Ext.create('Ext.form.field.Text', {
     *         fieldLabel: 'Departure Time',
     *         name: 'departureTime',
     *         vtype: 'time' // applies custom time validation rules to this field
     *     });
     *
     * Another example of a custom validator:
     *
     *     // custom Vtype for vtype:'IPAddress'
     *     Ext.apply(Ext.form.field.VTypes, {
     *         IPAddress:  function(v) {
     *             return /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(v);
     *         },
     *         IPAddressText: 'Must be a numeric IP address',
     *         IPAddressMask: /[\d\.]/i
     *     });
     *
     * It's important to note that using {@link Ext#apply Ext.apply()} means that the custom validator function
     * as well as 'Text' and 'Mask' fields are added as properties of the 'Ext.form.field.VTypes' singleton.
     */
    export class VTypes {
        /**
         * The keystroke filter mask to be applied on alpha input. Defaults to: /[a-z_]/i
         */
        static alphaMask: RegExp;

        /**
         * The keystroke filter mask to be applied on alphanumeric input. Defaults to: /[a-z0-9_]/i
         */
        static alphanumMask: RegExp;

        /**
         * The error text to display when the alphanumeric validation function returns false.
         * Defaults to: 'This field should only contain letters, numbers and _'
         */
        static alphanumText: string;

        /**
         * The error text to display when the alpha validation function returns false.
         * Defaults to: 'This field should only contain letters and _'
         */
        static alphaText: string;

        /**
         * The keystroke filter mask to be applied on email input. See the {@link #email} method for information about
         * more complex email validation. Defaults to: /[a-z0-9_\.\-@]/i
         */
        static emailMask: RegExp;

        /**
         * The error text to display when the email validation function returns false.
         * Defaults to: 'This field should be an e-mail address in the format "user@example.com"'
         */
        static emailText: string;

        /**
         * The error text to display when the url validation function returns false.
         * Defaults to: 'This field should be a URL in the format "http:/'+'/www.example.com"'
         */
        static urlText: string;

        /**
         * The function used to validate alpha values
         * @param {String} value The value
         * @return {Boolean} true if the RegExp test passed, and false if not.
         */
        static alpha(value: string): boolean;

        /**
         * The function used to validate alphanumeric values
         * @param {String} value The value
         * @return {Boolean} true if the RegExp test passed, and false if not.
         */
        static alphanum(value: string): boolean;

        /**
         * The function used to validate email addresses. Note that complete validation per the email RFC
         * specifications is very complex and beyond the scope of this class, although this function can be
         * overridden if a more comprehensive validation scheme is desired. See the validation section
         * of the [Wikipedia article on email addresses][1] for additional information. This implementation is
         * intended to validate the following types of emails:
         *
         * - 'barney@example.de'
         * - 'barney.rubble@example.com'
         * - 'barney-rubble@example.coop'
         * - 'barney+rubble@example.com'
         * - 'barney'rubble@example.com'
         * - 'b.arne.y_r.ubbl.e@example.com'
         * - 'barney4rubble@example.com'
         * - 'barney4rubble!@example.com'
         * - '_barney+rubble@example.com'
         * - '"barney+rubble"@example.com'
         *
         * [1]: http://en.wikipedia.org/wiki/E-mail_address
         *
         * @param {String} value The email address
         * @return {Boolean} true if the RegExp test passed, and false if not.
         */
        static email(value: string): boolean;

        /**
         * The function used to validate URLs
         * @param {String} value The URL
         * @return {Boolean} true if the RegExp test passed, and false if not.
         */
        static url(value: string): boolean;
    }
}

declare module Ext.fx {
    interface AnimatorConfig {
        /**
         * Time to delay before starting the animation. Defaults to 0.
         */
        delay?: number;

        /**
         * Time in milliseconds for the animation to last. Defaults to 250.
         */
        duration?: number;

        /**
         * Currently only for Component Animation: Only set a component's outer element size bypassing layouts.  Set to true to do full layouts for every frame of the animation.  Defaults to false.
         */
        dynamic?: boolean;

        /**
         * This describes how the intermediate values used during a transition will be calculated. It allows for a transition to change
         * speed over its duration.
         *
         *  - backIn
         *  - backOut
         *  - bounceIn
         *  - bounceOut
         *  - ease
         *  - easeIn
         *  - easeOut
         *  - easeInOut
         *  - elasticIn
         *  - elasticOut
         *  - cubic-bezier(x1, y1, x2, y2)
         *
         * Note that cubic-bezier will create a custom easing curve following the CSS3 [transition-timing-function][0]
         * specification.  The four values specify points P1 and P2 of the curve as (x1, y1, x2, y2). All values must
         * be in the range [0, 1] or the definition is invalid.
         *
         * [0]: http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
         */
        easing?: string;

        /**
         * Number of times to execute the animation. Defaults to 1.
         */
        iterations?: number;

        /**
         * Animation keyframes follow the CSS3 Animation configuration pattern. 'from' is always considered '0%' and 'to'
         * is considered '100%'.<b>Every keyframe declaration must have a keyframe rule for 0% and 100%, possibly defined using
         * "from" or "to"</b>.  A keyframe declaration without these keyframe selectors is invalid and will not be available for
         * animation.  The keyframe declaration for a keyframe rule consists of properties and values. Properties that are unable to
         * be animated are ignored in these rules, with the exception of 'easing' which can be changed at each keyframe. For example:
         <pre><code>
         keyframes : {
         '0%': {
         left: 100
         },
         '40%': {
         left: 150
         },
         '60%': {
         left: 75
         },
         '100%': {
         left: 100
         }
         }
         </code></pre>
         */
        keyframes?: any;

        /**
         * The Ext.fx.target to apply the animation to.  If not specified during initialization, this can be passed to the applyAnimator
         * method to apply the same animation to many targets.
         */
        target?: Ext.fx.target.Target;
    }

    /**
     * This class is used to run keyframe based animations, which follows the CSS3 based animation structure.
     * Keyframe animations differ from typical from/to animations in that they offer the ability to specify values
     * at various points throughout the animation.
     *
     * ## Using Keyframes
     *
     * The {@link #keyframes} option is the most important part of specifying an animation when using this
     * class. A key frame is a point in a particular animation. We represent this as a percentage of the
     * total animation duration. At each key frame, we can specify the target values at that time. Note that
     * you *must* specify the values at 0% and 100%, the start and ending values. There is also a {@link #keyframe}
     * event that fires after each key frame is reached.
     *
     * ## Example
     *
     * In the example below, we modify the values of the element at each fifth throughout the animation.
     *
     *     @example
     *     Ext.create('Ext.fx.Animator', {
     *         target: Ext.getBody().createChild({
     *             style: {
     *                 width: '100px',
     *                 height: '100px',
     *                 'background-color': 'red'
     *             }
     *         }),
     *         duration: 10000, // 10 seconds
     *         keyframes: {
     *             0: {
     *                 opacity: 1,
     *                 backgroundColor: 'FF0000'
     *             },
     *             20: {
     *                 x: 30,
     *                 opacity: 0.5
     *             },
     *             40: {
     *                 x: 130,
     *                 backgroundColor: '0000FF'
     *             },
     *             60: {
     *                 y: 80,
     *                 opacity: 0.3
     *             },
     *             80: {
     *                 width: 200,
     *                 y: 200
     *             },
     *             100: {
     *                 opacity: 1,
     *                 backgroundColor: '00FF00'
     *             }
     *         }
     *     });
     */
    export class Animator extends Ext.Base implements Ext.fx.AnimatorConfig {
        /**
         * Current iteration the animation is running.
         */
        currentIteration: number;

        /**
         * 'true' in this class to identify an object as an instantiated Animator, or subclass thereof.
         */
        isAnimator: boolean;

        /**
         * Current keyframe step of the animation.
         */
        keyframeStep: number;

        /**
         * Flag to determine if the animation is paused. Only set this to true if you need to
         * keep the Anim instance around to be unpaused later; otherwise call {@link #end}.
         */
        paused: boolean;

        /**
         * Flag to determine if the animation has started
         */
        running: boolean;

        /**
         * Time to delay before starting the animation. Defaults to 0.
         */
        delay: number;

        /**
         * Time in milliseconds for the animation to last. Defaults to 250.
         */
        duration: number;

        /**
         * Currently only for Component Animation: Only set a component's outer element size bypassing layouts.  Set to true to do full layouts for every frame of the animation.  Defaults to false.
         */
        dynamic: boolean;

        /**
         * This describes how the intermediate values used during a transition will be calculated. It allows for a transition to change
         * speed over its duration.
         *
         *  - backIn
         *  - backOut
         *  - bounceIn
         *  - bounceOut
         *  - ease
         *  - easeIn
         *  - easeOut
         *  - easeInOut
         *  - elasticIn
         *  - elasticOut
         *  - cubic-bezier(x1, y1, x2, y2)
         *
         * Note that cubic-bezier will create a custom easing curve following the CSS3 [transition-timing-function][0]
         * specification.  The four values specify points P1 and P2 of the curve as (x1, y1, x2, y2). All values must
         * be in the range [0, 1] or the definition is invalid.
         *
         * [0]: http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
         */
        easing: string;

        /**
         * Number of times to execute the animation. Defaults to 1.
         */
        iterations: number;

        /**
         * Animation keyframes follow the CSS3 Animation configuration pattern. 'from' is always considered '0%' and 'to'
         * is considered '100%'.<b>Every keyframe declaration must have a keyframe rule for 0% and 100%, possibly defined using
         * "from" or "to"</b>.  A keyframe declaration without these keyframe selectors is invalid and will not be available for
         * animation.  The keyframe declaration for a keyframe rule consists of properties and values. Properties that are unable to
         * be animated are ignored in these rules, with the exception of 'easing' which can be changed at each keyframe. For example:
         <pre><code>
         keyframes : {
         '0%': {
         left: 100
         },
         '40%': {
         left: 150
         },
         '60%': {
         left: 75
         },
         '100%': {
         left: 100
         }
         }
         </code></pre>
         */
        keyframes: any;

        /**
         * The Ext.fx.target to apply the animation to.  If not specified during initialization, this can be passed to the applyAnimator
         * method to apply the same animation to many targets.
         */
        target: Ext.fx.target.Target;

        /**
         * Fire afteranimate event and end the animation. Usually called automatically when the
         * animation reaches its final frame, but can also be called manually to pre-emptively
         * stop and destroy the running animation.
         */
        end();

        /**
         * Fires when the animation is complete.
         */
        afteranimate(that: Ext.fx.Animator, startTime: Date);

        /**
         * Fires before the animation starts. A handler can return false to cancel the animation.
         */
        beforeanimate(that: Ext.fx.Animator);

        /**
         * Fires at each keyframe.
         * @param {Number} keyframe step number
         */
        keyframe(that: Ext.fx.Animator, keyframe: number);
    }

    interface AnimConfig {
        /**
         * Used in conjunction with iterations to reverse the animation each time an iteration completes.
         */
        alternate?: boolean;

        /**
         * A function to be run after the animation has completed.
         */
        callback?: Function;

        /**
         * Time to delay before starting the animation.
         */
        delay?: number;

        /**
         * Time in milliseconds for a single animation to last. If the {@link #iterations} property is
         * specified, then each animate will take the same duration for each iteration.
         */
        duration?: number;

        /**
         * Currently only for Component Animation: Only set a component's outer element size bypassing layouts.
         * Set to true to do full layouts for every frame of the animation.
         */
        dynamic?: boolean;

        /**
         * This describes how the intermediate values used during a transition will be calculated.
         * It allows for a transition to change speed over its duration.
         *
         * - backIn
         * - backOut
         * - bounceIn
         * - bounceOut
         * - ease
         * - easeIn
         * - easeOut
         * - easeInOut
         * - elasticIn
         * - elasticOut
         * - cubic-bezier(x1, y1, x2, y2)
         *
         * Note that cubic-bezier will create a custom easing curve following the CSS3 [transition-timing-function][0]
         * specification.  The four values specify points P1 and P2 of the curve as (x1, y1, x2, y2). All values must
         * be in the range [0, 1] or the definition is invalid.
         *
         * [0]: http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
         */
        easing?: string;

        /**
         * An object containing property/value pairs for the beginning of the animation.  If not specified, the current state of the
         * Ext.fx.target will be used. For example:
         *
         *     from: {
         *         opacity: 0,       // Transparent
         *         color: '#ffffff', // White
         *         left: 0
         *     }
         */
        from?: any;

        /**
         * Number of times to execute the animation.
         */
        iterations?: number;

        /**
         * Animation keyframes follow the CSS3 Animation configuration pattern. 'from' is always considered '0%' and 'to'
         * is considered '100%'. **Every keyframe declaration must have a keyframe rule for 0% and 100%, possibly defined using
         * "from" or "to".**  A keyframe declaration without these keyframe selectors is invalid and will not be available for
         * animation.  The keyframe declaration for a keyframe rule consists of properties and values. Properties that are unable to
         * be animated are ignored in these rules, with the exception of 'easing' which can be changed at each keyframe. For example:
         *
         *     keyframes : {
         *         '0%': {
         *             left: 100
         *         },
         *         '40%': {
         *             left: 150
         *         },
         *         '60%': {
         *             left: 75
         *         },
         *         '100%': {
         *             left: 100
         *         }
         *     }
         */
        keyframes?: any;

        /**
         * Run the animation from the end to the beginning
         * Defaults to false.
         */
        reverse?: boolean;

        /**
         * The scope that the {@link #callback} function will be called with
         */
        scope?: Function;

        /**
         * The {@link Ext.fx.target.Target} to apply the animation to.  This should only be specified when creating an Ext.fx.Anim directly.
         * The target does not need to be a {@link Ext.fx.target.Target} instance, it can be the underlying object. For example, you can
         * pass a Component, Element or Sprite as the target and the Anim will create the appropriate {@link Ext.fx.target.Target} object
         * automatically.
         */
        target?: string|any;

        /**
         * (required)
         * An object containing property/value pairs for the end of the animation. For example:
         *
         *     to: {
         *         opacity: 1,       // Opaque
         *         color: '#00ff00', // Green
         *         left: 500
         *     }
         */
        to?: any;
    }

    /**
     * This class manages animation for a specific {@link #target}. The animation allows
     * animation of various properties on the target, such as size, position, color and others.
     *
     * ## Starting Conditions
     *
     * The starting conditions for the animation are provided by the {@link #from} configuration.
     * Any/all of the properties in the {@link #from} configuration can be specified. If a particular
     * property is not defined, the starting value for that property will be read directly from the target.
     *
     * ## End Conditions
     *
     * The ending conditions for the animation are provided by the {@link #to} configuration. These mark
     * the final values once the animations has finished. The values in the {@link #from} can mirror
     * those in the {@link #to} configuration to provide a starting point.
     *
     * ## Other Options
     *
     *  - {@link #duration}: Specifies the time period of the animation.
     *  - {@link #easing}: Specifies the easing of the animation.
     *  - {@link #iterations}: Allows the animation to repeat a number of times.
     *  - {@link #alternate}: Used in conjunction with {@link #iterations}, reverses the direction every second iteration.
     *
     * ## Example Code
     *
     *     @example
     *     var myComponent = Ext.create('Ext.Component', {
     *         renderTo: document.body,
     *         width: 200,
     *         height: 200,
     *         style: 'border: 1px solid red;'
     *     });
     *
     *     Ext.create('Ext.fx.Anim', {
     *         target: myComponent,
     *         duration: 1000,
     *         from: {
     *             width: 400 //starting width 400
     *         },
     *         to: {
     *             width: 300, //end width 300
     *             height: 300 // end height 300
     *         }
     *     });
     */
    export class Anim extends Ext.Base implements Ext.fx.AnimConfig {
        /**
         * Current iteration the animation is running.
         */
        currentIteration: number;

        /**
         * 'true' in this class to identify an object as an instantiated Anim, or subclass thereof.
         */
        isAnimation: boolean;

        /**
         * Flag to determine if the animation is paused. Only set this to true if you need to
         * keep the Anim instance around to be unpaused later; otherwise call {@link #end}.
         */
        paused: boolean;

        /**
         * Flag to determine if the animation has started
         */
        running: boolean;

        /**
         * Starting time of the animation.
         */
        startTime: Date;

        /**
         * Used in conjunction with iterations to reverse the animation each time an iteration completes.
         */
        alternate: boolean;

        /**
         * A function to be run after the animation has completed.
         */
        callback: Function;

        /**
         * Time to delay before starting the animation.
         */
        delay: number;

        /**
         * Time in milliseconds for a single animation to last. If the {@link #iterations} property is
         * specified, then each animate will take the same duration for each iteration.
         */
        duration: number;

        /**
         * Currently only for Component Animation: Only set a component's outer element size bypassing layouts.
         * Set to true to do full layouts for every frame of the animation.
         */
        dynamic: boolean;

        /**
         * This describes how the intermediate values used during a transition will be calculated.
         * It allows for a transition to change speed over its duration.
         *
         * - backIn
         * - backOut
         * - bounceIn
         * - bounceOut
         * - ease
         * - easeIn
         * - easeOut
         * - easeInOut
         * - elasticIn
         * - elasticOut
         * - cubic-bezier(x1, y1, x2, y2)
         *
         * Note that cubic-bezier will create a custom easing curve following the CSS3 [transition-timing-function][0]
         * specification.  The four values specify points P1 and P2 of the curve as (x1, y1, x2, y2). All values must
         * be in the range [0, 1] or the definition is invalid.
         *
         * [0]: http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
         */
        easing: string;

        /**
         * An object containing property/value pairs for the beginning of the animation.  If not specified, the current state of the
         * Ext.fx.target will be used. For example:
         *
         *     from: {
         *         opacity: 0,       // Transparent
         *         color: '#ffffff', // White
         *         left: 0
         *     }
         */
        from: any;

        /**
         * Number of times to execute the animation.
         */
        iterations: number;

        /**
         * Animation keyframes follow the CSS3 Animation configuration pattern. 'from' is always considered '0%' and 'to'
         * is considered '100%'. **Every keyframe declaration must have a keyframe rule for 0% and 100%, possibly defined using
         * "from" or "to".**  A keyframe declaration without these keyframe selectors is invalid and will not be available for
         * animation.  The keyframe declaration for a keyframe rule consists of properties and values. Properties that are unable to
         * be animated are ignored in these rules, with the exception of 'easing' which can be changed at each keyframe. For example:
         *
         *     keyframes : {
         *         '0%': {
         *             left: 100
         *         },
         *         '40%': {
         *             left: 150
         *         },
         *         '60%': {
         *             left: 75
         *         },
         *         '100%': {
         *             left: 100
         *         }
         *     }
         */
        keyframes: any;

        /**
         * Run the animation from the end to the beginning
         * Defaults to false.
         */
        reverse: boolean;

        /**
         * The scope that the {@link #callback} function will be called with
         */
        scope: Function;

        /**
         * The {@link Ext.fx.target.Target} to apply the animation to.  This should only be specified when creating an Ext.fx.Anim directly.
         * The target does not need to be a {@link Ext.fx.target.Target} instance, it can be the underlying object. For example, you can
         * pass a Component, Element or Sprite as the target and the Anim will create the appropriate {@link Ext.fx.target.Target} object
         * automatically.
         */
        target: string|any;

        /**
         * (required)
         * An object containing property/value pairs for the end of the animation. For example:
         *
         *     to: {
         *         opacity: 1,       // Opaque
         *         color: '#00ff00', // Green
         *         left: 500
         *     }
         */
        to: any;

        /**
         * Fire afteranimate event and end the animation. Usually called automatically when the
         * animation reaches its final frame, but can also be called manually to pre-emptively
         * stop and destroy the running animation.
         */
        end();

        /**
         * Fires when the animation is complete.
         */
        afteranimate(that: Ext.fx.Anim, startTime: Date);

        /**
         * Fires before the animation starts. A handler can return false to cancel the animation.
         */
        beforeanimate(that: Ext.fx.Anim);

        /**
         * Fires when the animation's last frame has been set.
         */
        lastframe(that: Ext.fx.Anim, startTime: Date);
    }

    export class CubicBezier {
    }

    /**
     * This class contains a series of function definitions used to modify values during an animation.
     * They describe how the intermediate values used during a transition will be calculated. It allows for a transition to change
     * speed over its duration. The following options are available:
     *
     * - linear The default easing type
     * - backIn
     * - backOut
     * - bounceIn
     * - bounceOut
     * - ease
     * - easeIn
     * - easeOut
     * - easeInOut
     * - elasticIn
     * - elasticOut
     * - cubic-bezier(x1, y1, x2, y2)
     *
     * Note that cubic-bezier will create a custom easing curve following the CSS3 [transition-timing-function][0]
     * specification.  The four values specify points P1 and P2 of the curve as (x1, y1, x2, y2). All values must
     * be in the range [0, 1] or the definition is invalid.
     *
     * [0]: http://www.w3.org/TR/css3-transitions/#transition-timing-function_tag
     */
    export class Easing {
    }

    /**
     * Animation Manager which keeps track of all current animations and manages them on a frame by frame basis.
     */
    export class Manager {
        /**
         * Force the use of JavaScript-based animation instead of CSS3 animation, even when CSS3
         * animation is supported by the browser. This defaults to true currently, as CSS3 animation support is still
         * considered experimental at this time, and if used should be thouroughly tested across all targeted browsers.
         */
        protected static forceJS: boolean;

        /**
         * Default interval in miliseconds to calculate each frame.  Defaults to 16ms (~60fps)
         */
        static interval: number;

        /**
         * Add an Anim to the manager. This is done automatically when an Anim instance is created.
         */
        static addAnim(anim: Ext.fx.Anim);

        /**
         * Remove an Anim from the manager. This is done automatically when an Anim ends.
         */
        static removeAnim(anim: Ext.fx.Anim);
    }

    export class PropertyHandler extends Ext.Base {
    }

    /**
     * Animation Queue mixin to handle chaining and queueing by target.
     */
    export class Queue extends Ext.Base {
        constructor();
    }
}

declare module Ext.fx.target {
    /**
     * This class represents a animation target for a {@link Ext.Component}. In general this class will not be
     * created directly, the {@link Ext.Component} will be passed to the animation and
     * and the appropriate target will be created.
     */
    export class Component extends Ext.fx.target.Target {
        /**
         * Creates new Target.
         * @param {Ext.Component/Ext.Element/Ext.draw.Sprite} target The object to be animated
         */
        constructor(target: Ext.Component|Ext.dom.Element|Ext.draw.Sprite);
    }

    /**
     * This class represents a animation target for a {@link Ext.CompositeElement}. It allows
     * each {@link Ext.Element} in the group to be animated as a whole. In general this class will not be
     * created directly, the {@link Ext.CompositeElement} will be passed to the animation and
     * and the appropriate target will be created.
     */
    export class CompositeElement extends Ext.fx.target.Element {
        /**
         * 'true' in this class to identify an object as an instantiated CompositeElement, or subclass thereof.
         */
        isComposite: boolean;

        constructor(target: any);
    }

    /**
     * This class represents a animation target for a {@link Ext.CompositeElement}, where the
     * constituent elements support CSS based animation. It allows each {@link Ext.Element} in
     * the group to be animated as a whole. In general this class will not be created directly,
     * the {@link Ext.CompositeElement} will be passed to the animation and the appropriate target
     * will be created.
     */
    export class CompositeElementCSS extends Ext.fx.target.CompositeElement {
        constructor(target: any);
    }

    /**
     This class represents a animation target for a {@link Ext.draw.CompositeSprite}. It allows
     each {@link Ext.draw.Sprite} in the group to be animated as a whole. In general this class will not be
     created directly, the {@link Ext.draw.CompositeSprite} will be passed to the animation and
     and the appropriate target will be created.
     * @markdown
     */
    export class CompositeSprite extends Ext.fx.target.Sprite {
        /**
         * Creates new Target.
         * @param {Ext.Component/Ext.Element/Ext.draw.Sprite} target The object to be animated
         */
        constructor(target: Ext.Component|Ext.dom.Element|Ext.draw.Sprite);
    }

    /**
     * This class represents a animation target for an {@link Ext.Element}. In general this class will not be
     * created directly, the {@link Ext.Element} will be passed to the animation and
     * and the appropriate target will be created.
     */
    export class Element extends Ext.fx.target.Target {
        /**
         * Creates new Target.
         * @param {Ext.Component/Ext.Element/Ext.draw.Sprite} target The object to be animated
         */
        constructor(target: Ext.Component|Ext.dom.Element|Ext.draw.Sprite);
    }

    /**
     * This class represents a animation target for an {@link Ext.Element} that supports CSS
     * based animation. In general this class will not be created directly, the {@link Ext.Element}
     * will be passed to the animation and the appropriate target will be created.
     */
    export class ElementCSS extends Ext.fx.target.Element {
        /**
         * Creates new Target.
         * @param {Ext.Component/Ext.Element/Ext.draw.Sprite} target The object to be animated
         */
        constructor(target: Ext.Component|Ext.dom.Element|Ext.draw.Sprite);
    }

    /**
     This class represents an animation target for a {@link Ext.draw.Sprite}. In general this class will not be
     created directly, the {@link Ext.draw.Sprite} will be passed to the animation and
     and the appropriate target will be created.
     * @markdown
     */
    export class Sprite extends Ext.fx.target.Target {
        /**
         * Creates new Target.
         * @param {Ext.Component/Ext.Element/Ext.draw.Sprite} target The object to be animated
         */
        constructor(target: Ext.Component|Ext.dom.Element|Ext.draw.Sprite);
    }

    /**
     This class specifies a generic target for an animation. It provides a wrapper around a
     series of different types of objects to allow for a generic animation API.
     A target can be a single object or a Composite object containing other objects that are
     to be animated. This class and it's subclasses are generally not created directly, the
     underlying animation will create the appropriate Ext.fx.target.Target object by passing
     the instance to be animated.
     The following types of objects can be animated:
     - {@link Ext.fx.target.Component Components}
     - {@link Ext.fx.target.Element Elements}
     - {@link Ext.fx.target.Sprite Sprites}
     * @markdown
     * @abstract
     */
    export class Target extends Ext.Base {
        /**
         * Creates new Target.
         * @param {Ext.Component/Ext.Element/Ext.draw.Sprite} target The object to be animated
         */
        constructor(target: Ext.Component|Ext.dom.Element|Ext.draw.Sprite);
    }
}

declare module Ext.grid {
    /**
     * Internal utility class that provides a unique cell context.
     */
    export class CellContext extends Ext.Base {
        /**
         * @readonly
         * 'true' in this class to identify an object as an instantiated CellContext, or subclass thereof.
         */
        isCellContext: boolean;

        constructor(view: any);
    }

    interface CellEditorConfig extends Ext.EditorConfig {
        alignment?: any;

        cls?: any;

        hideEl?: any;

        shadow?: any;
    }

    /**
     * Internal utility class that provides default configuration for cell editing.
     */
    export class CellEditor extends Ext.Editor implements Ext.grid.CellEditorConfig {
        alignment: string;

        cls: string;

        hideEl: boolean;

        shadow: boolean|string;

        constructor(config: Ext.grid.CellEditorConfig);
    }

    interface ColumnComponentLayoutConfig extends Ext.layout.component.AutoConfig {
    }

    /**
     * Component layout for grid column headers which have a title element at the top followed by content.
     */
    export class ColumnComponentLayout extends Ext.layout.component.Auto implements Ext.grid.ColumnComponentLayoutConfig {
        protected setWidthInDom: boolean;

        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * This class is used only by the grid's HeaderContainer docked child.
     *
     * It adds the ability to shrink the vertical size of the inner container element back if a grouped
     * column header has all its child columns dragged out, and the whole HeaderContainer needs to shrink back down.
     *
     * Also, after every layout, after all headers have attained their 'stretchmax' height, it goes through and calls
     * 'setPadding' on the columns so that they lay out correctly.
     */
    export class ColumnLayout extends Ext.layout.container.HBox {
        constructor(config: Ext.layout.container.BoxConfig);

        protected initLayout();
    }

    /**
     * Manages and provides information about a TablePanel's *visible leaf* columns.
     */
    export class ColumnManager extends Ext.Base {
        constructor(headerCt: any, secondHeaderCt: any);

        /**
         * Get a leaf level header by index regardless of what the nesting
         * structure is.
         * @param {Number} index The column index for which to retrieve the column.
         * @return {Ext.grid.column.Column} The header. 'null' if it doesn't exist.
         */
        getHeaderAtIndex(index: number): Ext.grid.column.Column;

        /**
         * Get a leaf level header by index regardless of what the nesting
         * structure is.
         * @param {String} id The id
         * @return {Ext.grid.column.Column} The header. 'null' if it doesn't exist.
         */
        getHeaderById(id: string): Ext.grid.column.Column;

        /**
         * Returns the index of a leaf level header regardless of what the nesting
         * structure is.
         *
         * If a group header is passed, the index of the first leaf level heder within it is returned.
         *
         * @param {Ext.grid.column.Column} header The header to find the index of
         * @return {Number} The index of the specified column header
         */
        getHeaderIndex(header: Ext.grid.column.Column): number;

        /**
         * When passed a column index, returns the closet *visible* column to that. If the column at the passed index is visible,
         * that is returned. If it is hidden, either the next visible, or the previous visible column is returned.
         * @param {Number} index Position at which to find the closest visible column.
         */
        getVisibleHeaderClosestToIndex(index: number);
    }

    interface PanelConfig extends Ext.panel.TableConfig {
        /**
         * (required)
         */
        columns?: Ext.grid.column.Column|any;

        /**
         * False to remove row line styling
         */
        rowLines?: boolean;
    }

    /**
     * @author Aaron Conran
     * @docauthor Ed Spencer
     *
     * Grids are an excellent way of showing large amounts of tabular data on the client side. Essentially a supercharged
     * '<table>', GridPanel makes it easy to fetch, sort and filter large amounts of data.
     *
     * Grids are composed of two main pieces - a {@link Ext.data.Store Store} full of data and a set of columns to render.
     *
     * ## Basic GridPanel
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *         storeId:'simpsonsStore',
     *         fields:['name', 'email', 'phone'],
     *         data:{'items':[
     *             { 'name': 'Lisa',  "email":"lisa@simpsons.com",  "phone":"555-111-1224"  },
     *             { 'name': 'Bart',  "email":"bart@simpsons.com",  "phone":"555-222-1234" },
     *             { 'name': 'Homer', "email":"home@simpsons.com",  "phone":"555-222-1244"  },
     *             { 'name': 'Marge', "email":"marge@simpsons.com", "phone":"555-222-1254"  }
     *         ]},
     *         proxy: {
     *             type: 'memory',
     *             reader: {
     *                 type: 'json',
     *                 root: 'items'
     *             }
     *         }
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Simpsons',
     *         store: Ext.data.StoreManager.lookup('simpsonsStore'),
     *         columns: [
     *             { text: 'Name',  dataIndex: 'name' },
     *             { text: 'Email', dataIndex: 'email', flex: 1 },
     *             { text: 'Phone', dataIndex: 'phone' }
     *         ],
     *         height: 200,
     *         width: 400,
     *         renderTo: Ext.getBody()
     *     });
     *
     * The code above produces a simple grid with three columns. We specified a Store which will load JSON data inline.
     * In most apps we would be placing the grid inside another container and wouldn't need to use the
     * {@link #height}, {@link #width} and {@link #renderTo} configurations but they are included here to make it easy to get
     * up and running.
     *
     * The grid we created above will contain a header bar with a title ('Simpsons'), a row of column headers directly underneath
     * and finally the grid rows under the headers.
     *
     * ## Configuring columns
     *
     * By default, each column is sortable and will toggle between ASC and DESC sorting when you click on its header. Each
     * column header is also reorderable by default, and each gains a drop-down menu with options to hide and show columns.
     * It's easy to configure each column - here we use the same example as above and just modify the columns config:
     *
     *     columns: [
     *         {
     *             text: 'Name',
     *             dataIndex: 'name',
     *             sortable: false,
     *             hideable: false,
     *             flex: 1
     *         },
     *         {
     *             text: 'Email',
     *             dataIndex: 'email',
     *             hidden: true
     *         },
     *         {
     *             text: 'Phone',
     *             dataIndex: 'phone',
     *             width: 100
     *         }
     *     ]
     *
     * We turned off sorting and hiding on the 'Name' column so clicking its header now has no effect. We also made the Email
     * column hidden by default (it can be shown again by using the menu on any other column). We also set the Phone column to
     * a fixed with of 100px and flexed the Name column, which means it takes up all remaining width after the other columns
     * have been accounted for. See the {@link Ext.grid.column.Column column docs} for more details.
     *
     * ## Renderers
     *
     * As well as customizing columns, it's easy to alter the rendering of individual cells using renderers. A renderer is
     * tied to a particular column and is passed the value that would be rendered into each cell in that column. For example,
     * we could define a renderer function for the email column to turn each email address into a mailto link:
     *
     *     columns: [
     *         {
     *             text: 'Email',
     *             dataIndex: 'email',
     *             renderer: function(value) {
     *                 return Ext.String.format('<a href="mailto:{0}">{1}</a>', value, value);
     *             }
     *         }
     *     ]
     *
     * See the {@link Ext.grid.column.Column column docs} for more information on renderers.
     *
     * ## Selection Models
     *
     * Sometimes all you want is to render data onto the screen for viewing, but usually it's necessary to interact with or
     * update that data. Grids use a concept called a Selection Model, which is simply a mechanism for selecting some part of
     * the data in the grid. The two main types of Selection Model are RowSelectionModel, where entire rows are selected, and
     * CellSelectionModel, where individual cells are selected.
     *
     * Grids use a Row Selection Model by default, but this is easy to customise like so:
     *
     *     Ext.create('Ext.grid.Panel', {
     *         selType: 'cellmodel',
     *         store: ...
     *     });
     *
     * Specifying the 'cellmodel' changes a couple of things. Firstly, clicking on a cell now
     * selects just that cell (using a {@link Ext.selection.RowModel rowmodel} will select the entire row), and secondly the
     * keyboard navigation will walk from cell to cell instead of row to row. Cell-based selection models are usually used in
     * conjunction with editing.
     *
     * ## Sorting & Filtering
     *
     * Every grid is attached to a {@link Ext.data.Store Store}, which provides multi-sort and filtering capabilities. It's
     * easy to set up a grid to be sorted from the start:
     *
     *     var myGrid = Ext.create('Ext.grid.Panel', {
     *         store: {
     *             fields: ['name', 'email', 'phone'],
     *             sorters: ['name', 'phone']
     *         },
     *         columns: [
     *             { text: 'Name',  dataIndex: 'name' },
     *             { text: 'Email', dataIndex: 'email' }
     *         ]
     *     });
     *
     * Sorting at run time is easily accomplished by simply clicking each column header. If you need to perform sorting on
     * more than one field at run time it's easy to do so by adding new sorters to the store:
     *
     *     myGrid.store.sort([
     *         { property: 'name',  direction: 'ASC' },
     *         { property: 'email', direction: 'DESC' }
     *     ]);
     *
     * See {@link Ext.data.Store} for examples of filtering.
     *
     * ## State saving
     *
     * When configured {@link #stateful}, grids save their column state (order and width) encapsulated within the default
     * Panel state of changed width and height and collapsed/expanded state.
     *
     * Each {@link #columns column} of the grid may be configured with a {@link Ext.grid.column.Column#stateId stateId} which
     * identifies that column locally within the grid.
     *
     * ## Plugins and Features
     *
     * Grid supports addition of extra functionality through features and plugins:
     *
     * - {@link Ext.grid.plugin.CellEditing CellEditing} - editing grid contents one cell at a time.
     *
     * - {@link Ext.grid.plugin.RowEditing RowEditing} - editing grid contents an entire row at a time.
     *
     * - {@link Ext.grid.plugin.DragDrop DragDrop} - drag-drop reordering of grid rows.
     *
     * - {@link Ext.toolbar.Paging Paging toolbar} - paging through large sets of data.
     *
     * - {@link Ext.grid.plugin.BufferedRenderer Infinite scrolling} - another way to handle large sets of data.
     *
     * - {@link Ext.grid.RowNumberer RowNumberer} - automatically numbered rows.
     *
     * - {@link Ext.grid.feature.Grouping Grouping} - grouping together rows having the same value in a particular field.
     *
     * - {@link Ext.grid.feature.Summary Summary} - a summary row at the bottom of a grid.
     *
     * - {@link Ext.grid.feature.GroupingSummary GroupingSummary} - a summary row at the bottom of each group.
     */
    export class Panel extends Ext.panel.Table implements Ext.grid.PanelConfig {
        /**
         * (required)
         */
        columns: Ext.grid.column.Column|any;

        /**
         * False to remove row line styling
         */
        rowLines: boolean;

        protected viewType: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Reconfigures the grid with a new store/columns. Either the store or the columns can be omitted if you don't wish
         * to change them.
         * @param {Ext.data.Store} store (Optional) The new store.
         * @param {Object[]} columns (Optional) An array of column configs
         */
        reconfigure(store: Ext.data.Store, columns: any);

        /**
         * Fires before a reconfigure to enable modification of incoming Store and columns.
         * @param {Ext.data.Store} store The store that was passed to the {@link #method-reconfigure} method
         * @param {Object[]} columns The column configs that were passed to the {@link #method-reconfigure} method
         * @param {Ext.data.Store} oldStore The store that will be replaced
         * @param {Ext.grid.column.Column[]} The column headers that will be replaced.
         */
        beforereconfigure(that: Ext.grid.Panel, store: Ext.data.Store, columns: any, oldStore: Ext.data.Store, The: Ext.grid.column.Column);
    }

    interface RowEditorButtonsConfig extends Ext.container.ContainerConfig {
        frame?: any;

        shrinkWrap?: any;
    }

    /**
     * Private Container class used by the {@link Ext.grid.RowEditor} to hold its buttons.
     */
    export class RowEditorButtons extends Ext.container.Container implements Ext.grid.RowEditorButtonsConfig {
        frame: boolean;

        shrinkWrap: boolean|number;

        constructor(config: Ext.grid.RowEditorButtonsConfig);
    }

    interface RowEditorConfig extends Ext.form.PanelConfig {
        border?: any;

        hideMode?: any;
    }

    /**
     * Internal utility class used to provide row editing functionality. For developers, they should use
     * the RowEditing plugin to use this functionality with a grid.
     */
    export class RowEditor extends Ext.form.Panel implements Ext.grid.RowEditorConfig {
        border: number|string|boolean;

        hideMode: string;

        protected afterRender();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected getRefItems();

        isDirty();

        /**
         * Start editing the specified grid at the specified position.
         * @param {Ext.data.Model} record The Store data record which backs the row to be edited.
         * @param {Ext.data.Model} columnHeader The Column object defining the column to be edited.
         */
        startEdit(record: Ext.data.Model, columnHeader: Ext.data.Model);
    }

    interface ViewConfig extends Ext.view.TableConfig {
        autoScroll?: any;

        /**
         * True to stripe the rows.
         *
         * This causes the CSS class **'x-grid-row-alt'** to be added to alternate rows of the grid. A default CSS rule is
         * provided which sets a background color, but you can override this with a rule which either overrides the
         * **background-color** style using the '!important' modifier, or which uses a CSS selector of higher specificity.
         */
        stripeRows?: any;
    }

    /**
     * The grid View class provides extra {@link Ext.grid.Panel} specific functionality to the
     * {@link Ext.view.Table}. In general, this class is not instanced directly, instead a viewConfig
     * option is passed to the grid:
     *
     *     Ext.create('Ext.grid.Panel', {
     *         // other options
     *         viewConfig: {
     *             stripeRows: false
     *         }
     *     });
     *
     * ## Drag Drop
     *
     * Drag and drop functionality can be achieved in the grid by attaching a {@link Ext.grid.plugin.DragDrop} plugin
     * when creating the view.
     *
     *     Ext.create('Ext.grid.Panel', {
     *         // other options
     *         viewConfig: {
     *             plugins: {
     *                 ddGroup: 'people-group',
     *                 ptype: 'gridviewdragdrop',
     *                 enableDrop: false
     *             }
     *         }
     *     });
     */
    export class View extends Ext.view.Table implements Ext.grid.ViewConfig {
        autoScroll: boolean;

        /**
         * True to stripe the rows.
         *
         * This causes the CSS class **'x-grid-row-alt'** to be added to alternate rows of the grid. A default CSS rule is
         * provided which sets a background color, but you can override this with a rule which either overrides the
         * **background-color** style using the '!important' modifier, or which uses a CSS selector of higher specificity.
         */
        stripeRows: boolean;

        constructor(config: Ext.grid.ViewConfig);
    }

    export class ViewDropZone extends Ext.view.DropZone {
        constructor(config: Ext.tree.ViewDropZoneConfig);
    }
}

declare module Ext.grid.column {
    interface ActionConfig extends Ext.grid.column.ColumnConfig {
        /**
         * The alt text to use for the image element.
         */
        altText?: string;

        /**
         * If true, the action will not respond to click events, and will be displayed semi-opaque.
         *
         * This Column may also be disabled on a row by row basis by configuring a {@link #cfg-isDisabled} method.
         */
        disabled?: boolean;

        /**
         * A function which returns the CSS class to apply to the icon image.
         * The value of the column's configured field (if any).
         * An object in which you may set the following attributes:
         * A CSS class name to add to the cell's TD element.
         * An HTML attribute definition string to apply to the data container
         * element *within* the table cell (e.g. 'style="color:red;"').
         * The Record providing the data.
         * The row index.
         * The column index.
         * The Store which is providing the data Model.
         */
        getClass?: Function;

        /**
         * A function which returns the tooltip string for any row.
         * The value of the column's configured field (if any).
         * An object in which you may set the following attributes:
         * A CSS class name to add to the cell's TD element.
         * An HTML attribute definition string to apply to the data
         * container element _within_ the table cell (e.g. 'style="color:red;"').
         * The Record providing the data.
         * The row index.
         * The column index.
         * The Store which is providing the data Model.
         */
        getTip?: Function;

        /**
         * A function called when the icon is clicked.
         * The owning TableView.
         * The row index clicked on.
         * The column index clicked on.
         * The clicked item (or this Column if multiple {@link #cfg-items} were not configured).
         * The click event.
         * The Record underlying the clicked row.
         * The table row clicked upon.
         */
        handler?: Function;

        /**
         * The URL of an image to display as the clickable element in the column.
         *
         * Defaults to '{@link Ext#BLANK_IMAGE_URL}'.
         */
        icon?: string;

        /**
         * A CSS class to apply to the icon image. To determine the class dynamically, configure the Column with
         * a '{@link #getClass}' function.
         */
        iconCls?: string;

        /**
         * Text to display in this column's menu item if no {@link #text} was specified as a header.
         *
         * Optional, Defaults to: <i>Actions</i>
         */
        menuText?: string;

        /**
         * The scope ('this' reference) in which the '{@link #handler}', '{@link #getClass}', '{@link #cfg-isDisabled}' and '{@link #getTip}' fuctions are executed.
         * Defaults to this Column.
         */
        scope?: any;

        sortable?: any;

        /**
         * Prevent grid selection upon mousedown.
         *
         * Optional, Defaults to: true
         */
        stopSelection?: boolean;

        /**
         * A tooltip message to be displayed on hover. {@link Ext.tip.QuickTipManager#init Ext.tip.QuickTipManager} must
         * have been initialized.
         *
         * The tooltip may also be determined on a row by row basis by configuring a {@link #getTip} method.
         */
        tooltip?: string;
    }

    /**
     * A Grid header type which renders an icon, or a series of icons in a grid cell, and offers a scoped click
     * handler for each icon.
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *         storeId:'employeeStore',
     *         fields:['firstname', 'lastname', 'seniority', 'dep', 'hired'],
     *         data:[
     *             {firstname:"Michael", lastname:"Scott"},
     *             {firstname:"Dwight", lastname:"Schrute"},
     *             {firstname:"Jim", lastname:"Halpert"},
     *             {firstname:"Kevin", lastname:"Malone"},
     *             {firstname:"Angela", lastname:"Martin"}
     *         ]
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Action Column Demo',
     *         store: Ext.data.StoreManager.lookup('employeeStore'),
     *         columns: [
     *             {text: 'First Name',  dataIndex:'firstname'},
     *             {text: 'Last Name',  dataIndex:'lastname'},
     *             {
     *                 xtype:'actioncolumn',
     *                 width:50,
     *                 items: [{
     *                     icon: 'extjs/examples/shared/icons/fam/cog_edit.png',  // Use a URL in the icon config
     *                     tooltip: 'Edit',
     *                     handler: function(grid, rowIndex, colIndex) {
     *                         var rec = grid.getStore().getAt(rowIndex);
     *                         alert("Edit " + rec.get('firstname'));
     *                     }
     *                 },{
     *                     icon: 'extjs/examples/restful/images/delete.png',
     *                     tooltip: 'Delete',
     *                     handler: function(grid, rowIndex, colIndex) {
     *                         var rec = grid.getStore().getAt(rowIndex);
     *                         alert("Terminate " + rec.get('firstname'));
     *                     }
     *                 }]
     *             }
     *         ],
     *         width: 250,
     *         renderTo: Ext.getBody()
     *     });
     *
     * The action column can be at any index in the columns array, and a grid can have any number of
     * action columns.
     */
    export class Action extends Ext.grid.column.Column implements Ext.grid.column.ActionConfig {
        /**
         * The alt text to use for the image element.
         */
        altText: string;

        /**
         * If true, the action will not respond to click events, and will be displayed semi-opaque.
         *
         * This Column may also be disabled on a row by row basis by configuring a {@link #cfg-isDisabled} method.
         */
        disabled: boolean;

        /**
         * A function which returns the CSS class to apply to the icon image.
         * The value of the column's configured field (if any).
         * An object in which you may set the following attributes:
         * A CSS class name to add to the cell's TD element.
         * An HTML attribute definition string to apply to the data container
         * element *within* the table cell (e.g. 'style="color:red;"').
         * The Record providing the data.
         * The row index.
         * The column index.
         * The Store which is providing the data Model.
         */
        getClass: Function;

        /**
         * A function which returns the tooltip string for any row.
         * The value of the column's configured field (if any).
         * An object in which you may set the following attributes:
         * A CSS class name to add to the cell's TD element.
         * An HTML attribute definition string to apply to the data
         * container element _within_ the table cell (e.g. 'style="color:red;"').
         * The Record providing the data.
         * The row index.
         * The column index.
         * The Store which is providing the data Model.
         */
        getTip: Function;

        /**
         * A function called when the icon is clicked.
         * The owning TableView.
         * The row index clicked on.
         * The column index clicked on.
         * The clicked item (or this Column if multiple {@link #cfg-items} were not configured).
         * The click event.
         * The Record underlying the clicked row.
         * The table row clicked upon.
         */
        handler: Function;

        /**
         * The URL of an image to display as the clickable element in the column.
         *
         * Defaults to '{@link Ext#BLANK_IMAGE_URL}'.
         */
        icon: string;

        /**
         * A CSS class to apply to the icon image. To determine the class dynamically, configure the Column with
         * a '{@link #getClass}' function.
         */
        iconCls: string;

        /**
         * Text to display in this column's menu item if no {@link #text} was specified as a header.
         *
         * Optional, Defaults to: <i>Actions</i>
         */
        menuText: string;

        /**
         * The scope ('this' reference) in which the '{@link #handler}', '{@link #getClass}', '{@link #cfg-isDisabled}' and '{@link #getTip}' fuctions are executed.
         * Defaults to this Column.
         */
        scope: any;

        sortable: boolean;

        /**
         * Prevent grid selection upon mousedown.
         *
         * Optional, Defaults to: true
         */
        stopSelection: boolean;

        /**
         * A tooltip message to be displayed on hover. {@link Ext.tip.QuickTipManager#init Ext.tip.QuickTipManager} must
         * have been initialized.
         *
         * The tooltip may also be determined on a row by row basis by configuring a {@link #getTip} method.
         */
        tooltip: string;

        constructor(config: Ext.grid.column.ActionConfig);

        protected defaultRenderer();

        /**
         * Disables this ActionColumn's action at the specified index.
         * @param {Boolean} [silent=false]
         */
        disableAction(index: number|Ext.grid.column.Action, silent?: boolean);

        /**
         * Enables this ActionColumn's action at the specified index.
         * @param {Boolean} [silent=false]
         */
        enableAction(index: number|Ext.grid.column.Action, silent?: boolean);

        protected getRefItems();
    }

    interface BooleanConfig extends Ext.grid.column.ColumnConfig {
        /**
         * The string returned by the renderer when the column value is falsey (but not undefined).
         */
        falseText?: string;

        /**
         * The string returned by the renderer when the column value is not falsey.
         */
        trueText?: string;

        /**
         * The string returned by the renderer when the column value is undefined.
         */
        undefinedText?: string;
    }

    /**
     * A Column definition class which renders boolean data fields.  See the {@link Ext.grid.column.Column#xtype xtype}
     * config option of {@link Ext.grid.column.Column} for more details.
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *        storeId:'sampleStore',
     *        fields:[
     *            {name: 'framework', type: 'string'},
     *            {name: 'rocks', type: 'boolean'}
     *        ],
     *        data:{'items':[
     *            { 'framework': "Ext JS 4",     'rocks': true  },
     *            { 'framework': "Sencha Touch", 'rocks': true  },
     *            { 'framework': "Ext GWT",      'rocks': true  },
     *            { 'framework': "Other Guys",   'rocks': false }
     *        ]},
     *        proxy: {
     *            type: 'memory',
     *            reader: {
     *                type: 'json',
     *                root: 'items'
     *            }
     *        }
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Boolean Column Demo',
     *         store: Ext.data.StoreManager.lookup('sampleStore'),
     *         columns: [
     *             { text: 'Framework',  dataIndex: 'framework', flex: 1 },
     *             {
     *                 xtype: 'booleancolumn',
     *                 text: 'Rocks',
     *                 trueText: 'Yes',
     *                 falseText: 'No',
     *                 dataIndex: 'rocks'
     *             }
     *         ],
     *         height: 200,
     *         width: 400,
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Boolean extends Ext.grid.column.Column implements Ext.grid.column.BooleanConfig {
        /**
         * The string returned by the renderer when the column value is falsey (but not undefined).
         */
        falseText: string;

        /**
         * The string returned by the renderer when the column value is not falsey.
         */
        trueText: string;

        /**
         * The string returned by the renderer when the column value is undefined.
         */
        undefinedText: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface CheckColumnConfig extends Ext.grid.column.ColumnConfig {
        /**
         * Prevent grid selection upon mousedown.
         *
         * Optional, Defaults to: true
         */
        stopSelection?: boolean;

        tdCls?: any;
    }

    /**
     * A Column subclass which renders a checkbox in each column cell which toggles the truthiness of the associated data field on click.
     *
     * Example usage:
     *
     *     @example
     *     var store = Ext.create('Ext.data.Store', {
     *         fields : ['name', 'email', 'phone', 'active'],
     *         data   : {
     *             items : [
     *                 { name : 'Lisa',  email : 'lisa@simpsons.com',  phone : '555-111-1224', active : true  },
     *                 { name : 'Bart',  email : 'bart@simpsons.com',  phone : '555-222-1234', active : true  },
     *                 { name : 'Homer', email : 'home@simpsons.com',  phone : '555-222-1244', active : false },
     *                 { name : 'Marge', email : 'marge@simpsons.com', phone : '555-222-1254', active : true  }
     *             ]
     *         },
     *         proxy  : {
     *             type   : 'memory',
     *             reader : {
     *                 type : 'json',
     *                 root : 'items'
     *             }
     *         }
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title    : 'Simpsons',
     *         height   : 200,
     *         width    : 400,
     *         renderTo : Ext.getBody(),
     *         store    : store,
     *         columns  : [
     *             { text : 'Name', dataIndex : 'name' },
     *             { text : 'Email', dataIndex : 'email', flex : 1 },
     *             { text : 'Phone', dataIndex : 'phone' },
     *             { xtype : 'checkcolumn', text : 'Active', dataIndex : 'active' }
     *         ]
     *     });
     *
     * The check column can be at any index in the columns array.
     */
    export class CheckColumn extends Ext.grid.column.Column implements Ext.grid.column.CheckColumnConfig {
        /**
         * Prevent grid selection upon mousedown.
         *
         * Optional, Defaults to: true
         */
        stopSelection: boolean;

        tdCls: string;

        constructor();

        /**
         * Fires when before checked state of a row changes.
         * The change may be vetoed by returning 'false' from a listener.
         * @param {Ext.ux.CheckColumn} this CheckColumn
         * @param {Number} rowIndex The row index
         * @param {Boolean} checked True if the box is to be checked
         */
        beforecheckchange(that: Ext.grid.column.CheckColumn, rowIndex: number, checked: boolean);

        /**
         * Fires when the checked state of a row changes
         * @param {Ext.ux.CheckColumn} this CheckColumn
         * @param {Number} rowIndex The row index
         * @param {Boolean} checked True if the box is now checked
         */
        checkchange(that: Ext.grid.column.CheckColumn, rowIndex: number, checked: boolean);
    }

    interface ColumnConfig extends Ext.grid.header.ContainerConfig {
        /**
         * Sets the alignment of the header and rendered columns.
         * Possible values are: ''left'', ''center'', and ''right''.
         */
        align?: string;

        baseCls?: any;

        /**
         * An optional array of sub-column definitions. This column becomes a group, and houses the columns defined in the
         * 'columns' config.
         *
         * Group columns may not be sortable. But they may be hideable and moveable. And you may move headers into and out
         * of a group. Note that if all sub columns are dragged out of a group, the group is destroyed.
         */
        columns?: any;

        componentLayout?: any;

        /**
         * The name of the field in the grid's {@link Ext.data.Store}'s {@link Ext.data.Model} definition from
         * which to draw the column's value. **Required.**
         */
        dataIndex?: string;

        detachOnRemove?: any;

        /**
         * False to disable drag-drop reordering of this column.
         */
        draggable?: boolean;

        /**
         * A renderer to be used in conjunction with {@link Ext.grid.plugin.RowEditing RowEditing}. This renderer is used to
         * display a custom value for non-editable fields.
         */
        editRenderer?: Function;

        /**
         * An optional xtype or config object for a {@link Ext.form.field.Field Field} to use for editing.
         * Only applicable if the grid is using an {@link Ext.grid.plugin.Editing Editing} plugin.
         */
        editor?: any|string;

        /**
         * The text to diplay in empty cells (cells with a value of 'undefined', 'null', or '''').
         *
         * Defaults to '&#160;' aka '&nbsp;'.
         *
         * Optional, Defaults to: undefined
         */
        emptyCellText?: string;

        /**
         * Alias for {@link #editor}.
         * @deprecated 4.0.5 Use {@link #editor} instead.
         */
        field?: any|string;

        /**
         * True to prevent the column from being resizable.
         * @deprecated 4.0 Use {@link #resizable} instead.
         */
        fixed?: boolean;

        /**
         * If the grid uses a {@link Ext.grid.feature.Grouping}, this option may be used to disable the header menu
         * item to group by the column selected. By default, the header menu group option is enabled. Set to false to
         * disable (but still show) the group option in the header menu for the column.
         */
        groupable?: boolean;

        /**
         * The header text.
         * @deprecated 4.0 Use {@link #text} instead.
         */
        header?: string;

        /**
         * False to prevent the user from hiding this column.
         */
        hideable?: boolean;

        /**
         * If the grid is configured with {@link Ext.panel.Table#enableLocking enableLocking}, or has columns which are
         * configured with a {@link #locked} value, this option may be used to disable user-driven locking or unlocking
         * of this column. This column will remain in the side into which its own {@link #locked} configuration placed it.
         */
        lockable?: boolean;

        /**
         * True to lock this column in place.  Implicitly enables locking on the grid.
         * See also {@link Ext.grid.Panel#enableLocking}.
         *
         * Optional, Defaults to: false
         */
        locked?: boolean;

        /**
         * True to disable the column header menu containing sort/hide options.
         */
        menuDisabled?: boolean;

        /**
         * The text to render in the column visibility selection menu for this column.  If not
         * specified, will default to the text value.
         */
        menuText?: string;

        /**
         * A renderer is an 'interceptor' method which can be used to transform data (value, appearance, etc.)
         * before it is rendered. Example:
         *
         *     {
         *         renderer: function(value){
         *             if (value === 1) {
         *                 return '1 person';
         *             }
         *             return value + ' people';
         *         }
         *     }
         *
         * Additionally a string naming an {@link Ext.util.Format} method can be passed:
         *
         *     {
         *         renderer: 'uppercase'
         *     }
         *
         * The data value for the current cell
         * A collection of metadata about the current cell; can be used or modified
         * by the renderer. Recognized properties are: tdCls, tdAttr, and style.
         * The record for the current row
         * The index of the current row
         * The index of the current column
         * The data store
         * The current view
         * The HTML string to be rendered.
         */
        renderer?: Function|string;

        /**
         * The scope to use when calling the {@link #renderer} function.
         */
        scope?: any;

        /**
         * False to disable sorting of this column. Whether local/remote sorting is used is specified in
         * '{@link Ext.data.Store#remoteSort}'.
         */
        sortable?: boolean;

        /**
         * @override
         * An identifier which identifies this column uniquely within the owning grid's {@link #stateful state}.
         *
         * This does not have to be *globally* unique. A column's state is not saved standalone. It is encapsulated within
         * the owning grid's state.
         */
        stateId?: string;

        /**
         * A CSS class names to apply to the table cells for this column.
         */
        tdCls?: string;

        /**
         * The header text to be used as innerHTML (html tags are accepted) to display in the Grid.
         * **Note**: to have a clickable header with no text displayed you can use the default of '&#160;' aka '&nbsp;'.
         */
        text?: string;

        /**
         * A tooltip to display for this column header
         */
        tooltip?: string;

        /**
         * The type of {@link #tooltip} to use. Either 'qtip' for QuickTips or 'title' for title attribute.
         *
         * Optional, Defaults to: "qtip"
         */
        tooltipType?: string;
    }

    /**
     * This class specifies the definition for a column inside a {@link Ext.grid.Panel}. It encompasses
     * both the grid header configuration as well as displaying data within the grid itself. If the
     * {@link #columns} configuration is specified, this column will become a column group and can
     * contain other columns inside. In general, this class will not be created directly, rather
     * an array of column configurations will be passed to the grid:
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *         storeId:'employeeStore',
     *         fields:['firstname', 'lastname', 'seniority', 'dep', 'hired'],
     *         data:[
     *             {firstname:"Michael", lastname:"Scott", seniority:7, dep:"Management", hired:"01/10/2004"},
     *             {firstname:"Dwight", lastname:"Schrute", seniority:2, dep:"Sales", hired:"04/01/2004"},
     *             {firstname:"Jim", lastname:"Halpert", seniority:3, dep:"Sales", hired:"02/22/2006"},
     *             {firstname:"Kevin", lastname:"Malone", seniority:4, dep:"Accounting", hired:"06/10/2007"},
     *             {firstname:"Angela", lastname:"Martin", seniority:5, dep:"Accounting", hired:"10/21/2008"}
     *         ]
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Column Demo',
     *         store: Ext.data.StoreManager.lookup('employeeStore'),
     *         columns: [
     *             {text: 'First Name',  dataIndex:'firstname'},
     *             {text: 'Last Name',  dataIndex:'lastname'},
     *             {text: 'Hired Month',  dataIndex:'hired', xtype:'datecolumn', format:'M'},
     *             {text: 'Department (Yrs)', xtype:'templatecolumn', tpl:'{dep} ({seniority})'}
     *         ],
     *         width: 400,
     *         forceFit: true,
     *         renderTo: Ext.getBody()
     *     });
     *
     * # Convenience Subclasses
     *
     * There are several column subclasses that provide default rendering for various data types
     *
     *  - {@link Ext.grid.column.Action}: Renders icons that can respond to click events inline
     *  - {@link Ext.grid.column.Boolean}: Renders for boolean values
     *  - {@link Ext.grid.column.Date}: Renders for date values
     *  - {@link Ext.grid.column.Number}: Renders for numeric values
     *  - {@link Ext.grid.column.Template}: Renders a value using an {@link Ext.XTemplate} using the record data
     *
     * # Setting Sizes
     *
     * The columns are laid out by a {@link Ext.layout.container.HBox} layout, so a column can either
     * be given an explicit width value or a flex configuration. If no width is specified the grid will
     * automatically the size the column to 100px. For column groups, the size is calculated by measuring
     * the width of the child columns, so a width option should not be specified in that case.
     *
     * # Header Options
     *
     *  - {@link #text}: Sets the header text for the column
     *  - {@link #sortable}: Specifies whether the column can be sorted by clicking the header or using the column menu
     *  - {@link #hideable}: Specifies whether the column can be hidden using the column menu
     *  - {@link #menuDisabled}: Disables the column header menu
     *  - {@link #cfg-draggable}: Specifies whether the column header can be reordered by dragging
     *  - {@link #groupable}: Specifies whether the grid can be grouped by the column dataIndex. See also {@link Ext.grid.feature.Grouping}
     *
     * # Data Options
     *
     *  - {@link #dataIndex}: The dataIndex is the field in the underlying {@link Ext.data.Store} to use as the value for the column.
     *  - {@link #renderer}: Allows the underlying store value to be transformed before being displayed in the grid
     */
    export class Column extends Ext.grid.header.Container implements Ext.grid.column.ColumnConfig {
        /**
         * @readonly
         * Set in this class to identify, at runtime, instances which are not instances of the
         * HeaderContainer base class, but are in fact simple column headers.
         */
        isColumn: boolean;

        /**
         * @deprecated see isColumn
         * Set in this class to identify, at runtime, instances which are not instances of the
         * HeaderContainer base class, but are in fact, the subclass: Header.
         */
        isHeader: boolean;

        /**
         * Element that contains the text in column header.
         */
        textEl: Ext.dom.Element;

        /**
         * Element that acts as button for column header dropdown menu.
         */
        triggerEl: Ext.dom.Element;

        /**
         * Sets the alignment of the header and rendered columns.
         * Possible values are: ''left'', ''center'', and ''right''.
         */
        align: string;

        baseCls: string;

        /**
         * An optional array of sub-column definitions. This column becomes a group, and houses the columns defined in the
         * 'columns' config.
         *
         * Group columns may not be sortable. But they may be hideable and moveable. And you may move headers into and out
         * of a group. Note that if all sub columns are dragged out of a group, the group is destroyed.
         */
        columns: any;

        componentLayout: string|any;

        /**
         * The name of the field in the grid's {@link Ext.data.Store}'s {@link Ext.data.Model} definition from
         * which to draw the column's value. **Required.**
         */
        dataIndex: string;

        detachOnRemove: boolean;

        /**
         * False to disable drag-drop reordering of this column.
         */
        draggable: boolean;

        /**
         * An optional xtype or config object for a {@link Ext.form.field.Field Field} to use for editing.
         * Only applicable if the grid is using an {@link Ext.grid.plugin.Editing Editing} plugin.
         */
        editor: any|string;

        /**
         * A renderer to be used in conjunction with {@link Ext.grid.plugin.RowEditing RowEditing}. This renderer is used to
         * display a custom value for non-editable fields.
         */
        editRenderer: Function;

        /**
         * The text to diplay in empty cells (cells with a value of 'undefined', 'null', or '''').
         *
         * Defaults to '&#160;' aka '&nbsp;'.
         *
         * Optional, Defaults to: undefined
         */
        emptyCellText: string;

        /**
         * Alias for {@link #editor}.
         * @deprecated 4.0.5 Use {@link #editor} instead.
         */
        field: any|string;

        /**
         * True to prevent the column from being resizable.
         * @deprecated 4.0 Use {@link #resizable} instead.
         */
        fixed: boolean;

        /**
         * If the grid uses a {@link Ext.grid.feature.Grouping}, this option may be used to disable the header menu
         * item to group by the column selected. By default, the header menu group option is enabled. Set to false to
         * disable (but still show) the group option in the header menu for the column.
         */
        groupable: boolean;

        /**
         * The header text.
         * @deprecated 4.0 Use {@link #text} instead.
         */
        header: string;

        /**
         * False to prevent the user from hiding this column.
         */
        hideable: boolean;

        /**
         * If the grid is configured with {@link Ext.panel.Table#enableLocking enableLocking}, or has columns which are
         * configured with a {@link #locked} value, this option may be used to disable user-driven locking or unlocking
         * of this column. This column will remain in the side into which its own {@link #locked} configuration placed it.
         */
        lockable: boolean;

        /**
         * True to lock this column in place.  Implicitly enables locking on the grid.
         * See also {@link Ext.grid.Panel#enableLocking}.
         *
         * Optional, Defaults to: false
         */
        locked: boolean;

        /**
         * True to disable the column header menu containing sort/hide options.
         */
        menuDisabled: boolean;

        /**
         * The text to render in the column visibility selection menu for this column.  If not
         * specified, will default to the text value.
         */
        menuText: string;

        /**
         * A renderer is an 'interceptor' method which can be used to transform data (value, appearance, etc.)
         * before it is rendered. Example:
         *
         *     {
         *         renderer: function(value){
         *             if (value === 1) {
         *                 return '1 person';
         *             }
         *             return value + ' people';
         *         }
         *     }
         *
         * Additionally a string naming an {@link Ext.util.Format} method can be passed:
         *
         *     {
         *         renderer: 'uppercase'
         *     }
         *
         * The data value for the current cell
         * A collection of metadata about the current cell; can be used or modified
         * by the renderer. Recognized properties are: tdCls, tdAttr, and style.
         * The record for the current row
         * The index of the current row
         * The index of the current column
         * The data store
         * The current view
         * The HTML string to be rendered.
         */
        renderer: Function|string;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The scope to use when calling the {@link #renderer} function.
         */
        scope: any;

        /**
         * False to disable sorting of this column. Whether local/remote sorting is used is specified in
         * '{@link Ext.data.Store#remoteSort}'.
         */
        sortable: boolean;

        /**
         * @override
         * An identifier which identifies this column uniquely within the owning grid's {@link #stateful state}.
         *
         * This does not have to be *globally* unique. A column's state is not saved standalone. It is encapsulated within
         * the owning grid's state.
         */
        stateId: string;

        /**
         * A CSS class names to apply to the table cells for this column.
         */
        tdCls: string;

        /**
         * The header text to be used as innerHTML (html tags are accepted) to display in the Grid.
         * **Note**: to have a clickable header with no text displayed you can use the default of '&#160;' aka '&nbsp;'.
         */
        text: string;

        /**
         * A tooltip to display for this column header
         */
        tooltip: string;

        /**
         * The type of {@link #tooltip} to use. Either 'qtip' for QuickTips or 'title' for title attribute.
         *
         * Optional, Defaults to: "qtip"
         */
        tooltipType: string;

        protected afterRender();

        /**
         * Sizes this Column to fit the max content width.
         * *Note that group columns shrinkwrap around the size of leaf columns. Auto sizing a group column
         * autosizes descendant leaf columns.*
         * @param {Ext.grid.column.Column/Number} The header (or index of header) to auto size.
         */
        autoSize(The: Ext.grid.column.Column|number);

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * When defined this will take precedence over the {@link Ext.grid.column.Column#renderer renderer} config.
         * This is meant to be defined in subclasses that wish to supply their own renderer.
         */
        protected defaultRenderer();

        /**
         * Retrieves the editing field for editing associated with this header. Returns false if there is no field
         * associated with the Header the method will return false. If the field has not been instantiated it will be
         * created. Note: These methods only have an implementation if an Editing plugin has been enabled on the grid.
         * @param {Object} record The {@link Ext.data.Model Model} instance being edited.
         * @param {Object} defaultField An object representing a default field to be created
         * @return {Ext.form.field.Field} field
         */
        getEditor(record: any, defaultField: any): Ext.form.field.Field;

        /**
         * Returns the index of this column only if this column is a base level Column. If it
         * is a group column, it returns 'false'.
         * @return {Number}
         */
        getIndex(): number;

        /**
         * Returns the parameter to sort upon when sorting this header. By default this returns the dataIndex and will not
         * need to be overriden in most cases.
         * @return {String}
         */
        getSortParam(): string;

        /**
         * Returns the index of this column in the list of *visible* columns only if this column is a base level Column. If it
         * is a group column, it returns 'false'.
         * @return {Number}
         */
        getVisibleIndex(): number;

        protected initRenderData();

        /**
         * Determines whether the UI should be allowed to offer an option to hide this column.
         *
         * A column may *not* be hidden if to do so would leave the grid with no visible columns.
         *
         * This is used to determine the enabled/disabled state of header hide menu items.
         */
        isHideable();

        /**
         * Determines whether the UI should be allowed to offer an option to lock or unlock this column. Note
         * that this includes dragging a column into the opposite side of a {@link Ext.panel.Table#enableLocking lockable} grid.
         *
         * A column may *not* be moved from one side to the other of a {@link Ext.panel.Table#enableLocking lockable} grid
         * if to do so would leave one side with no visible columns.
         *
         * This is used to determine the enabled/disabled state of the lock/unlock
         * menu item used in {@link Ext.panel.Table#enableLocking lockable} grids, and to determine dropppabilty when dragging a header.
         */
        isLockable();

        protected onDestroy();

        /**
         * Sets the form field to be used for editing. Note: This method only has an implementation if an Editing plugin has
         * been enabled on the grid.
         * @param {Object} field An object representing a field to be created. If no xtype is specified a 'textfield' is
         * assumed.
         */
        setEditor(field: any);

        /**
         * Sets the header text for this Column.
         * @param {String} text The header to display on this Column.
         */
        setText(text: string);
    }

    interface DateConfig extends Ext.grid.column.ColumnConfig {
        /**
         * A formatting string as used by {@link Ext.Date#format} to format a Date for this Column.
         *
         * Defaults to the default date from {@link Ext.Date#defaultFormat} which itself my be overridden
         * in a locale file.
         */
        format?: string;
    }

    /**
     * A Column definition class which renders a passed date according to the default locale, or a configured
     * {@link #format}.
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *         storeId:'sampleStore',
     *         fields:[
     *             { name: 'symbol', type: 'string' },
     *             { name: 'date',   type: 'date' },
     *             { name: 'change', type: 'number' },
     *             { name: 'volume', type: 'number' },
     *             { name: 'topday', type: 'date' }
     *         ],
     *         data:[
     *             { symbol: "msft",   date: '2011/04/22', change: 2.43, volume: 61606325, topday: '04/01/2010' },
     *             { symbol: "goog",   date: '2011/04/22', change: 0.81, volume: 3053782,  topday: '04/11/2010' },
     *             { symbol: "apple",  date: '2011/04/22', change: 1.35, volume: 24484858, topday: '04/28/2010' },
     *             { symbol: "sencha", date: '2011/04/22', change: 8.85, volume: 5556351,  topday: '04/22/2010' }
     *         ]
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Date Column Demo',
     *         store: Ext.data.StoreManager.lookup('sampleStore'),
     *         columns: [
     *             { text: 'Symbol',   dataIndex: 'symbol', flex: 1 },
     *             { text: 'Date',     dataIndex: 'date',   xtype: 'datecolumn',   format:'Y-m-d' },
     *             { text: 'Change',   dataIndex: 'change', xtype: 'numbercolumn', format:'0.00' },
     *             { text: 'Volume',   dataIndex: 'volume', xtype: 'numbercolumn', format:'0,000' },
     *             { text: 'Top Day',  dataIndex: 'topday', xtype: 'datecolumn',   format:'l' }
     *         ],
     *         height: 200,
     *         width: 450,
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Date extends Ext.grid.column.Column implements Ext.grid.column.DateConfig {
        /**
         * A formatting string as used by {@link Ext.Date#format} to format a Date for this Column.
         *
         * Defaults to the default date from {@link Ext.Date#defaultFormat} which itself my be overridden
         * in a locale file.
         */
        format: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface NumberConfig extends Ext.grid.column.ColumnConfig {
        /**
         * A formatting string as used by {@link Ext.util.Format#number} to format a numeric value for this Column.
         */
        format?: string;
    }

    /**
     * A Column definition class which renders a numeric data field according to a {@link #format} string.
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *        storeId:'sampleStore',
     *        fields:[
     *            { name: 'symbol', type: 'string' },
     *            { name: 'price',  type: 'number' },
     *            { name: 'change', type: 'number' },
     *            { name: 'volume', type: 'number' }
     *        ],
     *        data:[
     *            { symbol: "msft",   price: 25.76,  change: 2.43, volume: 61606325 },
     *            { symbol: "goog",   price: 525.73, change: 0.81, volume: 3053782  },
     *            { symbol: "apple",  price: 342.41, change: 1.35, volume: 24484858 },
     *            { symbol: "sencha", price: 142.08, change: 8.85, volume: 5556351  }
     *        ]
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Number Column Demo',
     *         store: Ext.data.StoreManager.lookup('sampleStore'),
     *         columns: [
     *             { text: 'Symbol',         dataIndex: 'symbol', flex: 1 },
     *             { text: 'Current Price',  dataIndex: 'price',  renderer: Ext.util.Format.usMoney },
     *             { text: 'Change',         dataIndex: 'change', xtype: 'numbercolumn', format:'0.00' },
     *             { text: 'Volume',         dataIndex: 'volume', xtype: 'numbercolumn', format:'0,000' }
     *         ],
     *         height: 200,
     *         width: 400,
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Number extends Ext.grid.column.Column implements Ext.grid.column.NumberConfig {
        /**
         * A formatting string as used by {@link Ext.util.Format#number} to format a numeric value for this Column.
         */
        format: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface RowNumbererConfig extends Ext.grid.column.ColumnConfig {
        align?: any;

        cls?: any;

        dataIndex?: any;

        /**
         * False to disable drag-drop reordering of this column.
         *
         * Optional, Defaults to: false
         */
        draggable?: boolean;

        hideable?: any;

        lockable?: any;

        menuDisabled?: any;

        tdCls?: any;

        /**
         * Any valid text or HTML fragment to display in the header cell for the row number column.
         */
        text?: string;

        /**
         * The default width in pixels of the row number column.
         */
        width?: number;
    }

    /**
     * A special type of Grid {@link Ext.grid.column.Column} that provides automatic
     * row numbering.
     *
     * Usage:
     *
     *     columns: [
     *         {xtype: 'rownumberer'},
     *         {text: "Company", flex: 1, sortable: true, dataIndex: 'company'},
     *         {text: "Price", width: 120, sortable: true, renderer: Ext.util.Format.usMoney, dataIndex: 'price'},
     *         {text: "Change", width: 120, sortable: true, dataIndex: 'change'},
     *         {text: "% Change", width: 120, sortable: true, dataIndex: 'pctChange'},
     *         {text: "Last Updated", width: 120, sortable: true, renderer: Ext.util.Format.dateRenderer('m/d/Y'), dataIndex: 'lastChange'}
     *     ]
     */
    export class RowNumberer extends Ext.grid.column.Column implements Ext.grid.column.RowNumbererConfig {
        align: string;

        cls: string;

        dataIndex: string;

        /**
         * False to disable drag-drop reordering of this column.
         *
         * Optional, Defaults to: false
         */
        draggable: boolean;

        hideable: boolean;

        lockable: boolean;

        menuDisabled: boolean;

        tdCls: string;

        /**
         * Any valid text or HTML fragment to display in the header cell for the row number column.
         */
        text: string;

        /**
         * The default width in pixels of the row number column.
         */
        width: number;

        constructor(config: Ext.grid.column.RowNumbererConfig);
    }

    interface TemplateConfig extends Ext.grid.column.ColumnConfig {
    }

    /**
     * A Column definition class which renders a value by processing a {@link Ext.data.Model Model}'s
     * {@link Ext.data.Model#persistenceProperty data} using a {@link #tpl configured}
     * {@link Ext.XTemplate XTemplate}.
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *         storeId:'employeeStore',
     *         fields:['firstname', 'lastname', 'seniority', 'department'],
     *         groupField: 'department',
     *         data:[
     *             { firstname: "Michael", lastname: "Scott",   seniority: 7, department: "Management" },
     *             { firstname: "Dwight",  lastname: "Schrute", seniority: 2, department: "Sales" },
     *             { firstname: "Jim",     lastname: "Halpert", seniority: 3, department: "Sales" },
     *             { firstname: "Kevin",   lastname: "Malone",  seniority: 4, department: "Accounting" },
     *             { firstname: "Angela",  lastname: "Martin",  seniority: 5, department: "Accounting" }
     *         ]
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Column Template Demo',
     *         store: Ext.data.StoreManager.lookup('employeeStore'),
     *         columns: [
     *             { text: 'Full Name',       xtype: 'templatecolumn', tpl: '{firstname} {lastname}', flex:1 },
     *             { text: 'Department (Yrs)', xtype: 'templatecolumn', tpl: '{department} ({seniority})' }
     *         ],
     *         height: 200,
     *         width: 300,
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Template extends Ext.grid.column.Column implements Ext.grid.column.TemplateConfig {
        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }
}

declare module Ext.grid.feature {
    interface AbstractSummaryConfig extends Ext.util.ObservableConfig {
        /**
         * The name of the property which contains the Array of summary objects.
         * It allows to use server-side calculated summaries.
         *
         * Optional, Defaults to: undefined
         */
        remoteRoot?: string;

        /**
         * True to show the summary row.
         */
        showSummaryRow?: any;
    }

    /**
     * A small abstract class that contains the shared behaviour for any summary
     * calculations to be used in the grid.
     */
    export class AbstractSummary extends Ext.grid.feature.Feature implements Ext.grid.feature.AbstractSummaryConfig {
        /**
         * The name of the property which contains the Array of summary objects.
         * It allows to use server-side calculated summaries.
         *
         * Optional, Defaults to: undefined
         */
        remoteRoot: string;

        /**
         * True to show the summary row.
         */
        showSummaryRow: any;

        constructor(config: Ext.grid.feature.AbstractSummaryConfig);

        /**
         * Toggle whether or not to show the summary row.
         * @param {Boolean} visible True to show the summary row
         */
        toggleSummaryRow(visible: boolean);
    }

    /**
     * A feature is a type of plugin that is specific to the {@link Ext.grid.Panel}. It provides several
     * hooks that allows the developer to inject additional functionality at certain points throughout the
     * grid creation cycle. This class provides the base template methods that are available to the developer,
     * it should be extended.
     *
     * There are several built in features that extend this class, for example:
     *
     *  - {@link Ext.grid.feature.Grouping} - Shows grid rows in groups as specified by the {@link Ext.data.Store}
     *  - {@link Ext.grid.feature.RowBody} - Adds a body section for each grid row that can contain markup.
     *  - {@link Ext.grid.feature.Summary} - Adds a summary row at the bottom of the grid with aggregate totals for a column.
     *
     * ## Using Features
     * A feature is added to the grid by specifying it an array of features in the configuration:
     *
     *     var groupingFeature = Ext.create('Ext.grid.feature.Grouping');
     *     Ext.create('Ext.grid.Panel', {
     *         // other options
     *         features: [groupingFeature]
     *     });
     *
     * ## Writing Features
     *
     * A Feature may add new DOM structure within the structure of a grid.
     *
     * A grid is essentially a '<table>' element. A {@link Ext.view.Table TableView} instance uses three {@link Ext.XTemplate XTemplates}
     * to render the grid, 'tableTpl', 'rowTpl', 'cellTpl'.
     *
     * * A {@link Ext.view.Table TableView} uses its 'tableTpl' to emit the '<table>' and '<tbody>' HTML tags into its output stream. It also emits a '<thead>' which contains a
     * sizing row. To ender the rows, it invokes {@link Ext.view.Table#renderRows} passing the 'rows' member of its data object.
     *
     * The 'tableTpl''s data object Looks like this:
     *     {
     *         view: owningTableView,
     *         rows: recordsToRender,
     *         viewStartIndex: indexOfFirstRecordInStore,
     *         tableStyle: styleString
     *     }
     *
     * * A {@link Ext.view.Table TableView} uses its 'rowTpl' to emit a '<tr>' HTML tag to its output stream. To render cells,
     * it invokes {@link Ext.view.Table#renderCell} passing the 'rows' member of its data object.
     *
     * The 'rowTpl''s data object looks like this:
     *
     *     {
     *         view:        owningTableView,
     *         record:      recordToRender,
     *         recordIndex: indexOfRecordInStore,
     *         columns:     arrayOfColumnDefinitions,
     *         itemClasses: arrayOfClassNames, // For outermost row in case of wrapping
     *         rowClasses:  arrayOfClassNames,  // For internal data bearing row in case of wrapping
     *         rowStyle:    styleString
     *     }
     *
     * * A {@link Ext.view.Table TableView} uses its 'cellTpl' to emit a '<td>' HTML tag to its output stream.
     *
     * The 'cellTpl's' data object looks like this:
     *
     *     {
     *         record: recordToRender
     *         column: columnToRender;
     *         recordIndex: indexOfRecordInStore,
     *         columnIndex: columnIndex,
     *         align: columnAlign,
     *         tdCls: classForCell
     *     }
     *
     * A Feature may inject its own tableTpl or rowTpl or cellTpl into the {@link Ext.view.Table TableView}'s rendering by
     * calling {@link Ext.view.Table#addTableTpl} or {@link Ext.view.Table#addRowTpl} or {@link Ext.view.Table#addCellTpl}.
     *
     * The passed XTemplate is added *upstream* of the default template for the table element in a link list of XTemplates which contribute
     * to the element's HTML. It may emit appropriate HTML strings into the output stream *around* a call to
     *
     *     this.nextTpl.apply(values, out, parent);
     *
     * This passes the current value context, output stream and the parent value context to the next XTemplate in the list.
     *
     * @abstract
     */
    export class Feature extends Ext.util.Observable {
        /**
         * True when feature is disabled.
         */
        disabled: any;

        /**
         * Prefix to use when firing events on the view.
         * For example a prefix of group would expose "groupclick", "groupcontextmenu", "groupdblclick".
         */
        eventPrefix: any;

        /**
         * Selector used to determine when to fire the event with the eventPrefix.
         */
        eventSelector: any;

        /**
         * Reference to the grid panel
         */
        grid: any;

        /**
         * Most features will expose additional events, some may not and will
         * need to change this to false.
         */
        hasFeatureEvent: any;

        /**
         * Reference to the TableView.
         */
        view: any;

        constructor(config: Ext.grid.feature.AbstractSummaryConfig);

        /**
         * Disables the feature.
         */
        disable();

        /**
         * Enables the feature.
         */
        enable();

        /**
         * Abstract method to be overriden when a feature should add additional
         * arguments to its event signature. By default the event will fire:
         *
         * - view - The underlying Ext.view.Table
         * - featureTarget - The matched element by the defined {@link #eventSelector}
         *
         * The method must also return the eventName as the first index of the array
         * to be passed to fireEvent.
         */
        getFireEventArgs();
    }

    interface GroupingConfig extends Ext.util.ObservableConfig {
        /**
         * Set to 'false' to disable collapsing groups from the UI.
         *
         * This is set to 'false' when the associated {@link Ext.data.Store store} is
         * {@link Ext.data.Store#buffered buffered}.
         *
         * Optional, Defaults to: true
         */
        collapsible?: boolean;

        /**
         * Number of pixels to indent per grouping level
         *
         * Optional, Defaults to: 17
         */
        depthToIndent?: number;

        /**
         * True to enable the grouping control in the header menu.
         *
         * Optional, Defaults to: true
         */
        enableGroupingMenu?: boolean;

        /**
         * True to allow the user to turn off grouping.
         *
         * Optional, Defaults to: true
         */
        enableNoGroups?: boolean;

        /**
         * Text displayed in the grid header menu for grouping by header.
         *
         * Optional, Defaults to: "Group by this field"
         */
        groupByText?: string;

        /**
         * A string Template snippet, an array of strings (optionally followed by an object containing Template methods) to be used to construct a Template, or a Template instance.
         *
         * - Example 1 (Template snippet):
         *
         *       groupHeaderTpl: 'Group: {name}'
         *
         * - Example 2 (Array):
         *
         *       groupHeaderTpl: [
         *           'Group: ',
         *           '<div>{name:this.formatName}</div>',
         *           {
         *               formatName: function(name) {
         *                   return Ext.String.trim(name);
         *               }
         *           }
         *       ]
         *
         * - Example 3 (Template Instance):
         *
         *       groupHeaderTpl: Ext.create('Ext.XTemplate',
         *           'Group: ',
         *           '<div>{name:this.formatName}</div>',
         *           {
         *               formatName: function(name) {
         *                   return Ext.String.trim(name);
         *               }
         *           }
         *       )
         *
         * The field name being grouped by.
         * The column header associated with the field being grouped by *if there is a column for the field*, falls back to the groupField name.
         * The value of the {@link Ext.data.Store#groupField groupField} for the group header being rendered.
         * The rendered value of the {@link Ext.data.Store#groupField groupField} for the group header being rendered, as produced by the column renderer.
         * An alias for renderedGroupValue
         * Deprecated - use children instead. An array containing the child records for the group being rendered. *Not available if the store is {@link Ext.data.Store#buffered buffered}*
         * An array containing the child records for the group being rendered. *Not available if the store is {@link Ext.data.Store#buffered buffered}*
         */
        groupHeaderTpl?: string|any[]|Ext.Template;

        /**
         * True to hide the header that is currently grouped.
         *
         * Optional, Defaults to: false
         */
        hideGroupedHeader?: boolean;

        /**
         * Text displayed in the grid header for enabling/disabling grouping.
         *
         * Optional, Defaults to: "Show in groups"
         */
        showGroupsText?: string;

        showSummaryRow?: any;

        /**
         * True to start all groups collapsed.
         *
         * Optional, Defaults to: false
         */
        startCollapsed?: boolean;
    }

    /**
     * This feature allows to display the grid rows aggregated into groups as specified by the {@link Ext.data.Store#groupers}
     * specified on the Store. The group will show the title for the group name and then the appropriate records for the group
     * underneath. The groups can also be expanded and collapsed.
     *
     * ## Extra Events
     *
     * This feature adds several extra events that will be fired on the grid to interact with the groups:
     *
     *  - {@link #groupclick}
     *  - {@link #groupdblclick}
     *  - {@link #groupcontextmenu}
     *  - {@link #groupexpand}
     *  - {@link #groupcollapse}
     *
     * ## Menu Augmentation
     *
     * This feature adds extra options to the grid column menu to provide the user with functionality to modify the grouping.
     * This can be disabled by setting the {@link #enableGroupingMenu} option. The option to disallow grouping from being turned off
     * by the user is {@link #enableNoGroups}.
     *
     * ## Controlling Group Text
     *
     * The {@link #groupHeaderTpl} is used to control the rendered title for each group. It can modified to customized
     * the default display.
     *
     * ## Example Usage
     *
     *     @example
     *     var store = Ext.create('Ext.data.Store', {
     *         storeId:'employeeStore',
     *         fields:['name', 'seniority', 'department'],
     *         groupField: 'department',
     *         data: {'employees':[
     *             { "name": "Michael Scott",  "seniority": 7, "department": "Management" },
     *             { "name": "Dwight Schrute", "seniority": 2, "department": "Sales" },
     *             { "name": "Jim Halpert",    "seniority": 3, "department": "Sales" },
     *             { "name": "Kevin Malone",   "seniority": 4, "department": "Accounting" },
     *             { "name": "Angela Martin",  "seniority": 5, "department": "Accounting" }
     *         ]},
     *         proxy: {
     *             type: 'memory',
     *             reader: {
     *                 type: 'json',
     *                 root: 'employees'
     *             }
     *         }
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Employees',
     *         store: Ext.data.StoreManager.lookup('employeeStore'),
     *         columns: [
     *             { text: 'Name',     dataIndex: 'name' },
     *             { text: 'Seniority', dataIndex: 'seniority' }
     *         ],
     *         features: [{ftype:'grouping'}],
     *         width: 200,
     *         height: 275,
     *         renderTo: Ext.getBody()
     *     });
     *
     * **Note:** To use grouping with a grid that has {@link Ext.grid.column.Column#locked locked columns}, you need to supply
     * the grouping feature as a config object - so the grid can create two instances of the grouping feature.
     *
     * @author Nigel White
     */
    export class Grouping extends Ext.grid.feature.Feature implements Ext.grid.feature.GroupingConfig {
        eventPrefix: any;

        eventSelector: any;

        /**
         * Set to 'false' to disable collapsing groups from the UI.
         *
         * This is set to 'false' when the associated {@link Ext.data.Store store} is
         * {@link Ext.data.Store#buffered buffered}.
         *
         * Optional, Defaults to: true
         */
        collapsible: boolean;

        /**
         * Number of pixels to indent per grouping level
         *
         * Optional, Defaults to: 17
         */
        depthToIndent: number;

        /**
         * True to enable the grouping control in the header menu.
         *
         * Optional, Defaults to: true
         */
        enableGroupingMenu: boolean;

        /**
         * True to allow the user to turn off grouping.
         *
         * Optional, Defaults to: true
         */
        enableNoGroups: boolean;

        /**
         * Text displayed in the grid header menu for grouping by header.
         *
         * Optional, Defaults to: "Group by this field"
         */
        groupByText: string;

        /**
         * A string Template snippet, an array of strings (optionally followed by an object containing Template methods) to be used to construct a Template, or a Template instance.
         *
         * - Example 1 (Template snippet):
         *
         *       groupHeaderTpl: 'Group: {name}'
         *
         * - Example 2 (Array):
         *
         *       groupHeaderTpl: [
         *           'Group: ',
         *           '<div>{name:this.formatName}</div>',
         *           {
         *               formatName: function(name) {
         *                   return Ext.String.trim(name);
         *               }
         *           }
         *       ]
         *
         * - Example 3 (Template Instance):
         *
         *       groupHeaderTpl: Ext.create('Ext.XTemplate',
         *           'Group: ',
         *           '<div>{name:this.formatName}</div>',
         *           {
         *               formatName: function(name) {
         *                   return Ext.String.trim(name);
         *               }
         *           }
         *       )
         *
         * The field name being grouped by.
         * The column header associated with the field being grouped by *if there is a column for the field*, falls back to the groupField name.
         * The value of the {@link Ext.data.Store#groupField groupField} for the group header being rendered.
         * The rendered value of the {@link Ext.data.Store#groupField groupField} for the group header being rendered, as produced by the column renderer.
         * An alias for renderedGroupValue
         * Deprecated - use children instead. An array containing the child records for the group being rendered. *Not available if the store is {@link Ext.data.Store#buffered buffered}*
         * An array containing the child records for the group being rendered. *Not available if the store is {@link Ext.data.Store#buffered buffered}*
         */
        groupHeaderTpl: string|any[]|Ext.Template;

        /**
         * True to hide the header that is currently grouped.
         *
         * Optional, Defaults to: false
         */
        hideGroupedHeader: boolean;

        /**
         * Text displayed in the grid header for enabling/disabling grouping.
         *
         * Optional, Defaults to: "Show in groups"
         */
        showGroupsText: string;

        showSummaryRow: any;

        /**
         * True to start all groups collapsed.
         *
         * Optional, Defaults to: false
         */
        startCollapsed: boolean;

        /**
         * Collapse a group
         * @param {String} groupName The group name
         * @param {Boolean} focus Pass 'true' to focus the group after expand.
         */
        collapse(groupName: string, focus: boolean);

        /**
         * Collapse all groups
         */
        collapseAll();

        constructor();

        disable();

        enable();

        /**
         * Expand a group
         * @param {String} groupName The group name
         * @param {Boolean} focus Pass 'true' to focus the group after expand.
         */
        expand(groupName: string, focus: boolean);

        /**
         * Expand all groups
         */
        expandAll();

        /**
         * Returns the group data object for the group to which the passed record belongs **if the Store is grouped**.
         *
         * @param {Ext.data.Model} record The record for which to return group information.
         * @return {Object} A single group data block as returned from {@link Ext.data.Store#getGroups Store.getGroups}. Returns
         * 'undefined' if the Store is not grouped.
         */
        getRecordGroup(record: Ext.data.Model): any;

        /**
         * Returns 'true' if the named group is expanded.
         * @param {String} groupName The group name as returned from {@link Ext.data.Store#getGroupString getGroupString}. This is usually the value of
         * the {@link Ext.data.Store#groupField groupField}.
         * @return {Boolean} 'true' if the group defined by that value is expanded.
         */
        isExpanded(groupName: string): boolean;

        /**
         * @param {String} group The name of the group
         */
        groupclick(view: Ext.view.Table, node: HTMLElement, group: string, e: Ext.EventObject);

        /**
         * @param {String} group The name of the group
         */
        groupcollapse(view: Ext.view.Table, node: HTMLElement, group: string);

        /**
         * @param {String} group The name of the group
         */
        groupcontextmenu(view: Ext.view.Table, node: HTMLElement, group: string, e: Ext.EventObject);

        /**
         * @param {String} group The name of the group
         */
        groupdblclick(view: Ext.view.Table, node: HTMLElement, group: string, e: Ext.EventObject);

        /**
         * @param {String} group The name of the group
         */
        groupexpand(view: Ext.view.Table, node: HTMLElement, group: string);
    }

    interface GroupingSummaryConfig extends Ext.grid.feature.GroupingConfig {
        showSummaryRow?: any;
    }

    /**
     * This feature adds an aggregate summary row at the bottom of each group that is provided
     * by the {@link Ext.grid.feature.Grouping} feature. There are two aspects to the summary:
     *
     * ## Calculation
     *
     * The summary value needs to be calculated for each column in the grid. This is controlled
     * by the summaryType option specified on the column. There are several built in summary types,
     * which can be specified as a string on the column configuration. These call underlying methods
     * on the store:
     *
     *  - {@link Ext.data.Store#count count}
     *  - {@link Ext.data.Store#sum sum}
     *  - {@link Ext.data.Store#min min}
     *  - {@link Ext.data.Store#max max}
     *  - {@link Ext.data.Store#average average}
     *
     * Alternatively, the summaryType can be a function definition. If this is the case,
     * the function is called with an array of records to calculate the summary value.
     *
     * ## Rendering
     *
     * Similar to a column, the summary also supports a summaryRenderer function. This
     * summaryRenderer is called before displaying a value. The function is optional, if
     * not specified the default calculated value is shown. The summaryRenderer is called with:
     *
     *  - value {Object} - The calculated value.
     *  - summaryData {Object} - Contains all raw summary values for the row.
     *  - field {String} - The name of the field we are calculating
     *
     * ## Example Usage
     *
     *     @example
     *     Ext.define('TestResult', {
     *         extend: 'Ext.data.Model',
     *         fields: ['student', 'subject', {
     *             name: 'mark',
     *             type: 'int'
     *         }]
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         width: 200,
     *         height: 240,
     *         renderTo: document.body,
     *         features: [{
     *             groupHeaderTpl: 'Subject: {name}',
     *             ftype: 'groupingsummary'
     *         }],
     *         store: {
     *             model: 'TestResult',
     *             groupField: 'subject',
     *             data: [{
     *                 student: 'Student 1',
     *                 subject: 'Math',
     *                 mark: 84
     *             },{
     *                 student: 'Student 1',
     *                 subject: 'Science',
     *                 mark: 72
     *             },{
     *                 student: 'Student 2',
     *                 subject: 'Math',
     *                 mark: 96
     *             },{
     *                 student: 'Student 2',
     *                 subject: 'Science',
     *                 mark: 68
     *             }]
     *         },
     *         columns: [{
     *             dataIndex: 'student',
     *             text: 'Name',
     *             summaryType: 'count',
     *             summaryRenderer: function(value){
     *                 return Ext.String.format('{0} student{1}', value, value !== 1 ? 's' : '');
     *             }
     *         }, {
     *             dataIndex: 'mark',
     *             text: 'Mark',
     *             summaryType: 'average'
     *         }]
     *     });
     */
    export class GroupingSummary extends Ext.grid.feature.Grouping implements Ext.grid.feature.GroupingSummaryConfig {
        showSummaryRow: any;

        constructor();
    }

    /**
     * Private record store class which takes the place of the view's data store to provide a grouped
     * view of the data when the Grouping feature is used.
     *
     * Relays granular mutation events from the underlying store as refresh events to the view.
     *
     * On mutation events from the underlying store, updates the summary rows by firing update events on the corresponding
     * summary records.
     */
    export class GroupStore extends Ext.util.Observable {
        constructor(groupingFeature: any, store: any);

        /**
         * Get the index within the entire dataset. From 0 to the totalCount.
         *
         * Like #indexOf, this method is effected by filtering.
         *
         * @param {Ext.data.Model} record The Ext.data.Model object to find.
         * @return {Number} The index of the passed Record. Returns -1 if not found.
         */
        indexOfTotal(record: Ext.data.Model): number;
    }

    /**
     * The rowbody feature enhances the grid's markup to have an additional
     * tr -> td -> div which spans the entire width of the original row.
     *
     * This is useful to to associate additional information with a particular
     * record in a grid.
     *
     * Rowbodies are initially hidden unless you override setupRowData.
     *
     * Will expose additional events on the gridview with the prefix of 'rowbody'.
     * For example: 'rowbodyclick', 'rowbodydblclick', 'rowbodycontextmenu'.
     *
     * # Example
     *
     *     @example
     *     Ext.define('Animal', {
     *         extend: 'Ext.data.Model',
     *         fields: ['name', 'latin', 'desc']
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         width: 400,
     *         height: 300,
     *         renderTo: Ext.getBody(),
     *         store: {
     *             model: 'Animal',
     *             data: [
     *                 {name: 'Tiger', latin: 'Panthera tigris',
     *                  desc: 'The largest cat species, weighing up to 306 kg (670 lb).'},
     *                 {name: 'Roman snail', latin: 'Helix pomatia',
     *                  desc: 'A species of large, edible, air-breathing land snail.'},
     *                 {name: 'Yellow-winged darter', latin: 'Sympetrum flaveolum',
     *                  desc: 'A dragonfly found in Europe and mid and Northern China.'},
     *                 {name: 'Superb Fairy-wren', latin: 'Malurus cyaneus',
     *                  desc: 'Common and familiar across south-eastern Australia.'}
     *             ]
     *         },
     *         columns: [{
     *             dataIndex: 'name',
     *             text: 'Common name',
     *             width: 125
     *         }, {
     *             dataIndex: 'latin',
     *             text: 'Scientific name',
     *             flex: 1
     *         }],
     *         features: [{
     *             ftype: 'rowbody',
     *             setupRowData: function(record, rowIndex, rowValues) {
     *                 var headerCt = this.view.headerCt,
     *                     colspan = headerCt.getColumnCount();
     *                 // Usually you would style the my-body-class in CSS file
     *                 return {
     *                     rowBody: '<div style="padding: 1em">'+record.get("desc")+'</div>',
     *                     rowBodyCls: "my-body-class",
     *                     rowBodyColspan: colspan
     *                 };
     *             }
     *         }]
     *     });
     */
    export class RowBody extends Ext.grid.feature.Feature {
        eventPrefix: any;

        eventSelector: any;

        constructor(config: Ext.grid.feature.AbstractSummaryConfig);

        /**
         * Provides additional data to the prepareData call within the grid view.
         * The rowbody feature adds 3 additional variables into the grid view's template.
         * These are rowBodyCls, rowBodyColspan, and rowBody.
         * @param {Object} data The data for this particular record.
         * @param {Number} idx The row index for this record.
         * @param {Ext.data.Model} record The record instance
         * @param {Object} orig The original result from the prepareData call to massage.
         */
        getAdditionalData(data: any, idx: number, record: Ext.data.Model, orig: any);
    }

    export class RowWrap extends Ext.grid.feature.Feature {
        hasFeatureEvent: any;

        constructor(config: Ext.grid.feature.AbstractSummaryConfig);
    }

    interface SummaryConfig extends Ext.grid.feature.AbstractSummaryConfig {
        /**
         * Configure ''top'' or ''bottom'' top create a fixed summary row either above or below the scrollable table.
         */
        dock?: string;
    }

    /**
     * This feature is used to place a summary row at the bottom of the grid. If using a grouping,
     * see {@link Ext.grid.feature.GroupingSummary}. There are 2 aspects to calculating the summaries,
     * calculation and rendering.
     *
     * ## Calculation
     * The summary value needs to be calculated for each column in the grid. This is controlled
     * by the summaryType option specified on the column. There are several built in summary types,
     * which can be specified as a string on the column configuration. These call underlying methods
     * on the store:
     *
     *  - {@link Ext.data.Store#count count}
     *  - {@link Ext.data.Store#sum sum}
     *  - {@link Ext.data.Store#min min}
     *  - {@link Ext.data.Store#max max}
     *  - {@link Ext.data.Store#average average}
     *
     * Alternatively, the summaryType can be a function definition. If this is the case,
     * the function is called with an array of records to calculate the summary value.
     *
     * ## Rendering
     * Similar to a column, the summary also supports a summaryRenderer function. This
     * summaryRenderer is called before displaying a value. The function is optional, if
     * not specified the default calculated value is shown. The summaryRenderer is called with:
     *
     *  - value {Object} - The calculated value.
     *  - summaryData {Object} - Contains all raw summary values for the row.
     *  - field {String} - The name of the field we are calculating
     *
     * ## Example Usage
     *
     *     @example
     *     Ext.define('TestResult', {
     *         extend: 'Ext.data.Model',
     *         fields: ['student', {
     *             name: 'mark',
     *             type: 'int'
     *         }]
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         width: 400,
     *         height: 200,
     *         title: 'Summary Test',
     *         style: 'padding: 20px',
     *         renderTo: document.body,
     *         features: [{
     *             ftype: 'summary'
     *         }],
     *         store: {
     *             model: 'TestResult',
     *             data: [{
     *                 student: 'Student 1',
     *                 mark: 84
     *             },{
     *                 student: 'Student 2',
     *                 mark: 72
     *             },{
     *                 student: 'Student 3',
     *                 mark: 96
     *             },{
     *                 student: 'Student 4',
     *                 mark: 68
     *             }]
     *         },
     *         columns: [{
     *             dataIndex: 'student',
     *             text: 'Name',
     *             summaryType: 'count',
     *             summaryRenderer: function(value, summaryData, dataIndex) {
     *                 return Ext.String.format('{0} student{1}', value, value !== 1 ? 's' : '');
     *             }
     *         }, {
     *             dataIndex: 'mark',
     *             text: 'Mark',
     *             summaryType: 'average'
     *         }]
     *     });
     */
    export class Summary extends Ext.grid.feature.AbstractSummary implements Ext.grid.feature.SummaryConfig {
        /**
         * Configure ''top'' or ''bottom'' top create a fixed summary row either above or below the scrollable table.
         */
        dock: string;

        constructor(config: Ext.grid.feature.AbstractSummaryConfig);
    }
}

declare module Ext.grid.header {
    interface ContainerConfig extends Ext.container.ContainerConfig {
        baseCls?: any;

        border?: any;

        defaultType?: any;

        /**
         * Width of the header if no width or flex is specified.
         */
        defaultWidth?: number;

        detachOnRemove?: any;

        /**
         * False to disable column hiding within this grid.
         *
         * Optional, Defaults to: true
         */
        enableColumnHide?: boolean;

        /**
         * Specify as 'true' to constrain column dragging so that a column cannot be dragged into or out of this column.
         *
         * **Note that this config is only valid for column headers which contain child column headers, eg:**
         *     {
         *         sealed: true
         *         text: 'ExtJS',
         *         columns: [{
         *             text: '3.0.4',
         *             dataIndex: 'ext304'
         *         }, {
         *             text: '4.1.0',
         *             dataIndex: 'ext410'
         *         }
         *     }
         *
         * Optional, Defaults to: false
         */
        sealed?: boolean;

        /**
         * Provides the default sortable state for all Headers within this HeaderContainer.
         * Also turns on or off the menus in the HeaderContainer. Note that the menu is
         * shared across every header and therefore turning it off will remove the menu
         * items for every header.
         */
        sortable?: boolean;

        /**
         * HeaderContainer overrides the default weight of 0 for all docked items to 100.
         * This is so that it has more priority over things like toolbars.
         */
        weight?: number;
    }

    /**
     * Container which holds headers and is docked at the top or bottom of a TablePanel.
     * The HeaderContainer drives resizing/moving/hiding of columns within the TableView.
     * As headers are hidden, moved or resized the headercontainer is responsible for
     * triggering changes within the view.
     */
    export class Container extends Ext.container.Container implements Ext.grid.header.ContainerConfig {
        /**
         * True if this HeaderContainer is in fact a group header which contains sub headers.
         */
        isGroupHeader: boolean;

        baseCls: string;

        border: number|string|boolean;

        defaultType: string;

        /**
         * Width of the header if no width or flex is specified.
         */
        defaultWidth: number;

        detachOnRemove: boolean;

        /**
         * False to disable column hiding within this grid.
         *
         * Optional, Defaults to: true
         */
        enableColumnHide: boolean;

        /**
         * Specify as 'true' to constrain column dragging so that a column cannot be dragged into or out of this column.
         *
         * **Note that this config is only valid for column headers which contain child column headers, eg:**
         *     {
         *         sealed: true
         *         text: 'ExtJS',
         *         columns: [{
         *             text: '3.0.4',
         *             dataIndex: 'ext304'
         *         }, {
         *             text: '4.1.0',
         *             dataIndex: 'ext410'
         *         }
         *     }
         *
         * Optional, Defaults to: false
         */
        sealed: boolean;

        /**
         * Provides the default sortable state for all Headers within this HeaderContainer.
         * Also turns on or off the menus in the HeaderContainer. Note that the menu is
         * shared across every header and therefore turning it off will remove the menu
         * items for every header.
         */
        sortable: boolean;

        /**
         * HeaderContainer overrides the default weight of 0 for all docked items to 100.
         * This is so that it has more priority over things like toolbars.
         */
        weight: number;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Returns the number of <b>grid columns</b> descended from this HeaderContainer.
         * Group Columns are HeaderContainers. All grid columns are returned, including hidden ones.
         */
        getColumnCount();

        /**
         * Returns an array of menu CheckItems corresponding to all immediate children
         * of the passed Container which have been configured as hideable.
         */
        getColumnMenu();

        /**
         * Gets the full width of all columns that are visible.
         */
        getFullWidth();

        /**
         * Returns an array of all columns which appear in the grid's View. This goes down to the leaf column header
         * level, and does not return **grouped** headers which contain sub headers.
         *
         * It includes hidden headers even though they are not rendered. This is for collection of menu items for the column hide/show menu.
         *
         * Headers which have a hidden ancestor have a 'hiddenAncestor: true' property injected so that they can also be rendered at zero width without interrogating
         * that header's ownerCt axis for a hidden ancestor.
         * @returns {Array}
         */
        getGridColumns();

        /**
         * Get a leaf level header by index regardless of what the nesting
         * structure is.
         * @param {Number} index The column index for which to retrieve the column.
         */
        getHeaderAtIndex(index: number);

        /**
         * Returns the index of a leaf level header regardless of what the nesting
         * structure is.
         *
         * If a group header is passed, the index of the first leaf level header within it is returned.
         *
         * @param {Ext.grid.column.Column} header The header to find the index of
         * @return {Number} The index of the specified column header
         */
        getHeaderIndex(header: Ext.grid.column.Column): number;

        /**
         * Returns an array of menu items to be placed into the shared menu
         * across all headers in this header container.
         * @returns {Array} menuItems
         */
        getMenuItems();

        /**
         * Returns an array of the **visible** columns in the grid. This goes down to the lowest column header
         * level, and does not return **grouped** headers which contain sub headers.
         * @returns {Array}
         */
        getVisibleGridColumns();

        /**
         * When passed a column index, returns the closet *visible* column to that. If the column at the passed index is visible,
         * that is returned. If it is hidden, either the next visible, or the previous visible column is returned.
         * @param {Number} index Position at which to find the closest visible column.
         */
        getVisibleHeaderClosestToIndex(index: number);

        protected isLayoutRoot();

        protected onDestroy();

        /**
         * @param {Ext.grid.header.Container} ct The grid's header Container which encapsulates all column headers.
         * @param {Ext.grid.column.Column} column The Column header Component which provides the column definition
         */
        columnhide(ct: Ext.grid.header.Container, column: Ext.grid.column.Column);

        /**
         * @param {Ext.grid.header.Container} ct The grid's header Container which encapsulates all column headers.
         * @param {Ext.grid.column.Column} column The Column header Component which provides the column definition
         */
        columnmove(ct: Ext.grid.header.Container, column: Ext.grid.column.Column, fromIdx: number, toIdx: number);

        /**
         * @param {Ext.grid.header.Container} ct The grid's header Container which encapsulates all column headers.
         * @param {Ext.grid.column.Column} column The Column header Component which provides the column definition
         */
        columnresize(ct: Ext.grid.header.Container, column: Ext.grid.column.Column, width: number);

        /**
         * Fired after the columns change in any way, when a column has been hidden or shown, or when a column
         * is added to or removed from this header container.
         * @param {Ext.grid.header.Container} ct The grid's header Container which encapsulates all column headers.
         */
        columnschanged(ct: Ext.grid.header.Container);

        /**
         * @param {Ext.grid.header.Container} ct The grid's header Container which encapsulates all column headers.
         * @param {Ext.grid.column.Column} column The Column header Component which provides the column definition
         */
        columnshow(ct: Ext.grid.header.Container, column: Ext.grid.column.Column);

        /**
         * @param {Ext.grid.header.Container} ct The grid's header Container which encapsulates all column headers.
         * @param {Ext.grid.column.Column} column The Column header Component which provides the column definition
         */
        headerclick(ct: Ext.grid.header.Container, column: Ext.grid.column.Column, e: Ext.EventObject, t: HTMLElement);

        /**
         * @param {Ext.grid.header.Container} ct The grid's header Container which encapsulates all column headers.
         * @param {Ext.grid.column.Column} column The Column header Component which provides the column definition
         */
        headercontextmenu(ct: Ext.grid.header.Container, column: Ext.grid.column.Column, e: Ext.EventObject, t: HTMLElement);

        /**
         * @param {Ext.grid.header.Container} ct The grid's header Container which encapsulates all column headers.
         * @param {Ext.grid.column.Column} column The Column header Component which provides the column definition
         */
        headertriggerclick(ct: Ext.grid.header.Container, column: Ext.grid.column.Column, e: Ext.EventObject, t: HTMLElement);

        /**
         * Fired immediately after the column header menu is created.
         * @param {Ext.grid.header.Container} ct This instance
         * @param {Ext.menu.Menu} menu The Menu that was created
         */
        menucreate(ct: Ext.grid.header.Container, menu: Ext.menu.Menu);

        /**
         * @param {Ext.grid.header.Container} ct The grid's header Container which encapsulates all column headers.
         * @param {Ext.grid.column.Column} column The Column header Component which provides the column definition
         */
        sortchange(ct: Ext.grid.header.Container, column: Ext.grid.column.Column, direction: string);
    }

    export class DragZone extends Ext.dd.DragZone {
        constructor(headerCt: any);
    }

    export class DropZone extends Ext.dd.DropZone {
        constructor(headerCt: any);
    }
}

declare module Ext.grid.locking {
    /**
     * Private class which acts as a HeaderContainer for the Lockable which aggregates all columns
     * from both sides of the Loackable. It is never rendered, it's just used to interrogate the
     * column collection.
     */
    export class HeaderContainer extends Ext.grid.header.Container {
        constructor(lockable: any);

        getGridColumns();

        protected getRefItems();
    }

    interface LockableConfig {
        /**
         * Any special configuration options for the locked part of the grid
         */
        lockedGridConfig?: any;

        /**
         * A view configuration to be applied to the
         * locked side of the grid. Any conflicting configurations between lockedViewConfig
         * and viewConfig will be overwritten by the lockedViewConfig.
         */
        lockedViewConfig?: any;

        /**
         * Any special configuration options for the normal part of the grid
         */
        normalGridConfig?: any;

        /**
         * A view configuration to be applied to the
         * normal/unlocked side of the grid. Any conflicting configurations between normalViewConfig
         * and viewConfig will be overwritten by the normalViewConfig.
         */
        normalViewConfig?: any;

        /**
         * Number of pixels to scroll when scrolling the locked section with mousewheel.
         */
        scrollDelta?: number;

        /**
         * The xtype of the subgrid to specify. If this is
         * not specified lockable will determine the subgrid xtype to create by the
         * following rule. Use the superclasses xtype if the superclass is NOT
         * tablepanel, otherwise use the xtype itself.
         */
        subGridXType?: string;

        /**
         * Synchronize rowHeight between the normal and
         * locked grid view. This is turned on by default. If your grid is guaranteed
         * to have rows of all the same height, you should set this to false to
         * optimize performance.
         */
        syncRowHeight?: boolean;
    }

    /**
     * Lockable is a private mixin which injects lockable behavior into any
     * TablePanel subclass such as GridPanel or TreePanel. TablePanel will
     * automatically inject the Ext.grid.locking.Lockable mixin in when one of the
     * these conditions are met:
     *
     *  - The TablePanel has the lockable configuration set to true
     *  - One of the columns in the TablePanel has locked set to true/false
     *
     * Each TablePanel subclass must register an alias. It should have an array
     * of configurations to copy to the 2 separate tablepanel's that will be generated
     * to note what configurations should be copied. These are named normalCfgCopy and
     * lockedCfgCopy respectively.
     *
     * Columns which are locked must specify a fixed width. They do NOT support a
     * flex width.
     *
     * Configurations which are specified in this class will be available on any grid or
     * tree which is using the lockable functionality.
     */
    export class Lockable extends Ext.Base implements Ext.grid.locking.LockableConfig {
        /**
         * Any special configuration options for the locked part of the grid
         */
        lockedGridConfig: any;

        /**
         * A view configuration to be applied to the
         * locked side of the grid. Any conflicting configurations between lockedViewConfig
         * and viewConfig will be overwritten by the lockedViewConfig.
         */
        lockedViewConfig: any;

        /**
         * Any special configuration options for the normal part of the grid
         */
        normalGridConfig: any;

        /**
         * A view configuration to be applied to the
         * normal/unlocked side of the grid. Any conflicting configurations between normalViewConfig
         * and viewConfig will be overwritten by the normalViewConfig.
         */
        normalViewConfig: any;

        /**
         * Number of pixels to scroll when scrolling the locked section with mousewheel.
         */
        scrollDelta: number;

        /**
         * The xtype of the subgrid to specify. If this is
         * not specified lockable will determine the subgrid xtype to create by the
         * following rule. Use the superclasses xtype if the superclass is NOT
         * tablepanel, otherwise use the xtype itself.
         */
        subGridXType: string;

        /**
         * Synchronize rowHeight between the normal and
         * locked grid view. This is turned on by default. If your grid is guaranteed
         * to have rows of all the same height, you should set this to false to
         * optimize performance.
         */
        syncRowHeight: boolean;

        /**
         * Synchronizes the row heights between the locked and non locked portion of the grid for each
         * row. If one row is smaller than the other, the height will be increased to match the larger one.
         */
        syncRowHeights();

        filterchange();

        /**
         * Fires when a column is locked.
         * @param {Ext.grid.Panel} this The gridpanel.
         * @param {Ext.grid.column.Column} column The column being locked.
         */
        lockcolumn(that: Ext.grid.Panel, column: Ext.grid.column.Column);

        /**
         * Fires when the configured (or **reconfigured**) column set is split into two depending on the {@link Ext.grid.column.Column#locked locked} flag.
         * @param {Ext.grid.column.Column[]} lockedColumns The locked columns.
         * @param {Ext.grid.column.Column[]} normalColumns The normal columns.
         */
        processcolumns(lockedColumns: Ext.grid.column.Column, normalColumns: Ext.grid.column.Column);

        /**
         * Fires when a column is unlocked.
         * @param {Ext.grid.Panel} this The gridpanel.
         * @param {Ext.grid.column.Column} column The column being unlocked.
         */
        unlockcolumn(that: Ext.grid.Panel, column: Ext.grid.column.Column);
    }

    /**
     * This class is used internally to provide a single interface when using
     * a locking grid. Internally, the locking grid creates two separate grids,
     * so this class is used to map calls appropriately.
     */
    export class View extends Ext.Base {
        /**
         * 'true' in this class to identify an object as an instantiated LockingView, or subclass thereof.
         */
        isLockingView: boolean;

        constructor(config: any);
    }
}

declare module Ext.grid.plugin {
    interface BufferedRendererConfig extends Ext.AbstractPluginConfig {
        /**
         * The number of extra rows to render on the leading side of scrolling
         * **outside the {@link #numFromEdge}** buffer as scrolling proceeds.
         */
        leadingBufferZone?: any;

        /**
         * The zone which causes new rows to be appended to the view. As soon as the edge
         * of the rendered grid is this number of rows from the edge of the viewport, the view is moved.
         */
        numFromEdge?: any;

        /**
         * @deprecated This config is now ignored.
         */
        percentageFromEdge?: any;

        /**
         * This is the time in milliseconds to buffer load requests when scrolling the PagingScrollbar.
         */
        scrollToLoadBuffer?: any;

        /**
         * By default, on detection of a scroll event which brings the end of the rendered table within
         * '{@link #numFromEdge}' rows of the grid viewport, if the required rows are available in the Store,
         * the BufferedRenderer will render rows from the Store *immediately* before returning from the event handler.
         * This setting helps avoid the impression of whitespace appearing during scrolling.
         *
         * Set this to 'true' to defer the render until the scroll event handler exits. This allows for faster
         * scrolling, but also allows whitespace to be more easily scrolled into view.
         *
         * Optional, Defaults to: true
         */
        synchronousRender?: boolean;

        /**
         * The number of extra rows to render on the trailing side of scrolling
         * **outside the {@link #numFromEdge}** buffer as scrolling proceeds.
         */
        trailingBufferZone?: any;

        /**
         * Configure as 'true' if the row heights are not all the same height as the first row. Only configure this is needed - this will be if the
         * rows contain unpredictably sized data, or you have changed the cell's text overflow stype to ''wrap''.
         *
         * Optional, Defaults to: false
         */
        variableRowHeight?: boolean;
    }

    /**
     * Implements buffered rendering of a grid, allowing users can scroll
     * through thousands of records without the performance penalties of
     * renderering all the records on screen at once.
     *
     * The number of rows rendered outside the visible area, and the
     * buffering of pages of data from the remote server for immediate
     * rendering upon scroll can be controlled by configuring the plugin.
     *
     * You can tell it to create a larger table to provide more scrolling
     * before new rows need to be added to the leading edge of the table.
     *
     *     var myStore = Ext.create('Ext.data.Store', {
     *         // ...
     *         pageSize: 100,
     *         // ...
     *     });
     *
     *     var grid = Ext.create('Ext.grid.Panel', {
     *         // ...
     *         autoLoad: true,
     *         plugins: {
     *             ptype: 'bufferedrenderer',
     *             trailingBufferZone: 20,  // Keep 20 rows rendered in the table behind scroll
     *             leadingBufferZone: 50   // Keep 50 rows rendered in the table ahead of scroll
     *         },
     *         // ...
     *     });
     *
     * ## Implementation notes
     *
     * This class monitors scrolling of the {@link Ext.view.Table
     * TableView} within a {@link Ext.grid.Panel GridPanel} to render a small section of
     * the dataset.
     */
    export class BufferedRenderer extends Ext.AbstractPlugin implements Ext.grid.plugin.BufferedRendererConfig {
        /**
         * Current pixel scroll position of the associated {@link Ext.view.Table View}.
         */
        position: number;

        /**
         * The number of extra rows to render on the leading side of scrolling
         * **outside the {@link #numFromEdge}** buffer as scrolling proceeds.
         */
        leadingBufferZone: any;

        /**
         * The zone which causes new rows to be appended to the view. As soon as the edge
         * of the rendered grid is this number of rows from the edge of the viewport, the view is moved.
         */
        numFromEdge: any;

        /**
         * @deprecated This config is now ignored.
         */
        percentageFromEdge: any;

        /**
         * This is the time in milliseconds to buffer load requests when scrolling the PagingScrollbar.
         */
        scrollToLoadBuffer: any;

        /**
         * By default, on detection of a scroll event which brings the end of the rendered table within
         * '{@link #numFromEdge}' rows of the grid viewport, if the required rows are available in the Store,
         * the BufferedRenderer will render rows from the Store *immediately* before returning from the event handler.
         * This setting helps avoid the impression of whitespace appearing during scrolling.
         *
         * Set this to 'true' to defer the render until the scroll event handler exits. This allows for faster
         * scrolling, but also allows whitespace to be more easily scrolled into view.
         *
         * Optional, Defaults to: true
         */
        synchronousRender: boolean;

        /**
         * The number of extra rows to render on the trailing side of scrolling
         * **outside the {@link #numFromEdge}** buffer as scrolling proceeds.
         */
        trailingBufferZone: any;

        /**
         * Configure as 'true' if the row heights are not all the same height as the first row. Only configure this is needed - this will be if the
         * rows contain unpredictably sized data, or you have changed the cell's text overflow stype to ''wrap''.
         *
         * Optional, Defaults to: false
         */
        variableRowHeight: boolean;

        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.AbstractPluginConfig);

        destroy();

        /**
         * Scrolls to and optionlly selects the specified row index **in the total dataset**.
         *
         * @param {Number} recordIdx The zero-based position in the dataset to scroll to.
         * @param {Boolean} doSelect Pass as 'true' to select the specified row.
         * @param {Function} callback A function to call when the row has been scrolled to.
         * @param {Number} callback.recordIdx The resulting record index (may have changed if the passed index was outside the valid range).
         * @param {Ext.data.Model} callback.record The resulting record from the store.
         * @param {Object} scope The scope ('this' reference) in which to execute the callback. Defaults to this BufferedRenderer.
         */
        scrollTo(recordIdx: number, doSelect: boolean, callback: Function, callback_recordIdx: number, callback_record: Ext.data.Model, scope: any);
    }

    /**
     * The Ext.grid.plugin.CellEditing plugin injects editing at a cell level for a Grid. Only a single
     * cell will be editable at a time. The field that will be used for the editor is defined at the
     * {@link Ext.grid.column.Column#editor editor}. The editor can be a field instance or a field configuration.
     *
     * If an editor is not specified for a particular column then that cell will not be editable and it will
     * be skipped when activated via the mouse or the keyboard.
     *
     * The editor may be shared for each column in the grid, or a different one may be specified for each column.
     * An appropriate field type should be chosen to match the data structure that it will be editing. For example,
     * to edit a date, it would be useful to specify {@link Ext.form.field.Date} as the editor.
     *
     * ## Example
     *
     * A grid with editor for the name and the email columns:
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *         storeId:'simpsonsStore',
     *         fields:['name', 'email', 'phone'],
     *         data:{'items':[
     *             {"name":"Lisa", "email":"lisa@simpsons.com", "phone":"555-111-1224"},
     *             {"name":"Bart", "email":"bart@simpsons.com", "phone":"555-222-1234"},
     *             {"name":"Homer", "email":"home@simpsons.com", "phone":"555-222-1244"},
     *             {"name":"Marge", "email":"marge@simpsons.com", "phone":"555-222-1254"}
     *         ]},
     *         proxy: {
     *             type: 'memory',
     *             reader: {
     *                 type: 'json',
     *                 root: 'items'
     *             }
     *         }
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Simpsons',
     *         store: Ext.data.StoreManager.lookup('simpsonsStore'),
     *         columns: [
     *             {header: 'Name',  dataIndex: 'name', editor: 'textfield'},
     *             {header: 'Email', dataIndex: 'email', flex:1,
     *                 editor: {
     *                     xtype: 'textfield',
     *                     allowBlank: false
     *                 }
     *             },
     *             {header: 'Phone', dataIndex: 'phone'}
     *         ],
     *         selType: 'cellmodel',
     *         plugins: [
     *             Ext.create('Ext.grid.plugin.CellEditing', {
     *                 clicksToEdit: 1
     *             })
     *         ],
     *         height: 200,
     *         width: 400,
     *         renderTo: Ext.getBody()
     *     });
     *
     * This requires a little explanation. We're passing in 'store' and 'columns' as normal, but
     * we also specify a {@link Ext.grid.column.Column#field field} on two of our columns. For the
     * Name column we just want a default textfield to edit the value, so we specify 'textfield'.
     * For the Email column we customized the editor slightly by passing allowBlank: false, which
     * will provide inline validation.
     *
     * To support cell editing, we also specified that the grid should use the 'cellmodel'
     * {@link Ext.grid.Panel#selType selType}, and created an instance of the CellEditing plugin,
     * which we configured to activate each editor after a single click.
     */
    export class CellEditing extends Ext.grid.plugin.Editing {
        /**
         * Cancels any active editing.
         */
        cancelEdit();

        completeEdit();

        constructor(config: Ext.grid.plugin.EditingConfig);

        /**
         * Starts editing by position (row/column)
         * @param {Object} position A position with keys of row and column.
         */
        startEditByPosition(position: any);
    }

    interface DragDropConfig extends Ext.AbstractPluginConfig {
        /**
         * 'true' to register this container with the Scrollmanager for auto scrolling during drag operations.
         * A {@link Ext.dd.ScrollManager} configuration may also be passed.
         */
        containerScroll?: any|boolean;

        /**
         * A named drag drop group to which this object belongs. If a group is specified, then both the DragZones and
         * DropZone used by this plugin will only interact with other drag drop objects in the same group.
         */
        ddGroup?: string;

        /**
         * The {@link #ddGroup} to which the DragZone will belong.
         *
         * This defines which other DropZones the DragZone will interact with. Drag/DropZones only interact with other
         * Drag/DropZones which are members of the same {@link #ddGroup}.
         */
        dragGroup?: string;

        /**
         * The text to show while dragging.
         *
         * Two placeholders can be used in the text:
         *
         * - '{0}' The number of selected items.
         * - '{1}' 's' when more than 1 items (only useful for English).
         */
        dragText?: any;

        /**
         * The {@link #ddGroup} to which the DropZone will belong.
         *
         * This defines which other DragZones the DropZone will interact with. Drag/DropZones only interact with other
         * Drag/DropZones which are members of the same {@link #ddGroup}.
         */
        dropGroup?: string;

        /**
         * 'false' to disallow dragging items from the View.
         */
        enableDrag?: boolean;

        /**
         * 'false' to disallow the View from accepting drop gestures.
         */
        enableDrop?: boolean;
    }

    /**
     * This plugin provides drag and/or drop functionality for a {@link Ext.grid.View GridView}.
     *
     * It creates a specialized instance of {@link Ext.dd.DragZone DragZone} which knows how to drag out of a {@link
     * Ext.grid.View GridView} and loads the data object which is passed to a cooperating {@link Ext.dd.DragZone DragZone}'s
     * methods with the following properties:
     *
     * - 'copy' : {@link Boolean}
     *
     *   The value of the {@link Ext.grid.View GridView}'s 'copy' property, or 'true' if the GridView was configured with 'allowCopy: true' _and_
     *   the control key was pressed when the drag operation was begun.
     *
     * - 'view' : {@link Ext.grid.View GridView}
     *
     *   The source GridView from which the drag originated.
     *
     * - 'ddel' : HtmlElement
     *
     *   The drag proxy element which moves with the mouse
     *
     * - 'item' : HtmlElement
     *
     *   The GridView node upon which the mousedown event was registered.
     *
     * - 'records' : {@link Array}
     *
     *   An Array of {@link Ext.data.Model Model}s representing the selected data being dragged from the source {@link Ext.grid.View GridView}.
     *
     * It also creates a specialized instance of {@link Ext.dd.DropZone} which cooperates with other DropZones which are
     * members of the same ddGroup which processes such data objects.
     *
     * Adding this plugin to a view means that two new events may be fired from the client GridView, '{@link #beforedrop
     * beforedrop}' and '{@link #drop drop}'
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *         storeId:'simpsonsStore',
     *         fields:['name'],
     *         data: [["Lisa"], ["Bart"], ["Homer"], ["Marge"]],
     *         proxy: {
     *             type: 'memory',
     *             reader: 'array'
     *         }
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         store: 'simpsonsStore',
     *         columns: [
     *             {header: 'Name',  dataIndex: 'name', flex: true}
     *         ],
     *         viewConfig: {
     *             plugins: {
     *                 ptype: 'gridviewdragdrop',
     *                 dragText: 'Drag and drop to reorganize'
     *             }
     *         },
     *         height: 200,
     *         width: 400,
     *         renderTo: Ext.getBody()
     *     });
     */
    export class DragDrop extends Ext.AbstractPlugin implements Ext.grid.plugin.DragDropConfig {
        /**
         * 'true' to register this container with the Scrollmanager for auto scrolling during drag operations.
         * A {@link Ext.dd.ScrollManager} configuration may also be passed.
         */
        containerScroll: any|boolean;

        /**
         * A named drag drop group to which this object belongs. If a group is specified, then both the DragZones and
         * DropZone used by this plugin will only interact with other drag drop objects in the same group.
         */
        ddGroup: string;

        /**
         * The {@link #ddGroup} to which the DragZone will belong.
         *
         * This defines which other DropZones the DragZone will interact with. Drag/DropZones only interact with other
         * Drag/DropZones which are members of the same {@link #ddGroup}.
         */
        dragGroup: string;

        /**
         * The text to show while dragging.
         *
         * Two placeholders can be used in the text:
         *
         * - '{0}' The number of selected items.
         * - '{1}' 's' when more than 1 items (only useful for English).
         */
        dragText: any;

        /**
         * The {@link #ddGroup} to which the DropZone will belong.
         *
         * This defines which other DragZones the DropZone will interact with. Drag/DropZones only interact with other
         * Drag/DropZones which are members of the same {@link #ddGroup}.
         */
        dropGroup: string;

        /**
         * 'false' to disallow dragging items from the View.
         */
        enableDrag: boolean;

        /**
         * 'false' to disallow the View from accepting drop gestures.
         */
        enableDrop: boolean;

        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.AbstractPluginConfig);

        disable();

        enable();

        /**
         * **This event is fired through the GridView. Add listeners to the {@link Ext.grid.View GridView} object**
         *
         * Fired when a drop gesture has been triggered by a mouseup event in a valid drop position in the GridView.
         *
         * Returning 'false' to this event signals that the drop gesture was invalid, and if the drag proxy will animate
         * back to the point from which the drag began.
         *
         * The dropHandlers parameter can be used to defer the processing of this event. For example to wait for the result of
         * a message box confirmation or an asynchronous server call. See the details of this property for more information.
         *
         *     @example
         *     view.on('beforedrop', function(node, data, overModel, dropPosition, dropHandlers) {
         *         // Defer the handling
         *         dropHandlers.wait = true;
         *         Ext.MessageBox.confirm('Drop', 'Are you sure', function(btn){
         *             if (btn === 'yes') {
         *                 dropHandlers.processDrop();
         *             } else {
         *                 dropHandlers.cancelDrop();
         *             }
         *         });
         *     });
         *
         * Any other return value continues with the data transfer operation, unless the wait property is set.
         *
         * @param {HTMLElement} node The {@link Ext.grid.View GridView} node **if any** over which the mouse was positioned.
         *
         * Any other return value continues with the data transfer operation.
         *
         * @param {Object} data The data object gathered at mousedown time by the cooperating
         * {@link Ext.dd.DragZone DragZone}'s {@link Ext.dd.DragZone#getDragData getDragData} method it contains the following
         * properties:
         * @param {Boolean} data.copy The value of the GridView's 'copy' property, or 'true' if the GridView was configured with
         * 'allowCopy: true' and the control key was pressed when the drag operation was begun
         * @param {Ext.grid.View} data.view The source GridView from which the drag originated.
         * @param {HTMLElement} data.ddel The drag proxy element which moves with the mouse
         * @param {HTMLElement} data.item The GridView node upon which the mousedown event was registered.
         * @param {Ext.data.Model[]} data.records An Array of {@link Ext.data.Model Model}s representing the selected data being
         * dragged from the source GridView.
         *
         * @param {Ext.data.Model} overModel The Model over which the drop gesture took place.
         *
         * @param {String} dropPosition '"before"' or '"after"' depending on whether the mouse is above or below the midline
         * of the node.
         *
         * This parameter allows the developer to control when the drop action takes place. It is useful if any asynchronous
         * processing needs to be completed before performing the drop. This object has the following properties:
         *
         * @param {Boolean} dropHandlers.wait Indicates whether the drop should be deferred. Set this property to true to defer the drop.
         * @param {Function} dropHandlers.processDrop A function to be called to complete the drop operation.
         * @param {Function} dropHandlers.cancelDrop A function to be called to cancel the drop operation.
         */
        beforedrop(node: HTMLElement, data: any, data_copy: boolean, data_view: Ext.grid.View, data_ddel: HTMLElement, data_item: HTMLElement, data_records: Ext.data.Model, overModel: Ext.data.Model, dropPosition: string, dropHandlers: any, dropHandlers_wait: boolean, dropHandlers_processDrop: Function, dropHandlers_cancelDrop: Function);

        /**
         * **This event is fired through the GridView. Add listeners to the GridView object** Fired when a drop operation
         * has been completed and the data has been moved or copied.
         *
         * @param {HTMLElement} node The GridView node **if any** over which the mouse was positioned.
         *
         * @param {Object} data The data object gathered at mousedown time by the cooperating {@link Ext.dd.DragZone
         * DragZone}'s {@link Ext.dd.DragZone#getDragData getDragData} method it contains the following properties:
         *
         * - 'copy' : {@link Boolean}
         *
         *   The value of the GridView's 'copy' property, or 'true' if the GridView was configured with 'allowCopy: true' and
         *   the control key was pressed when the drag operation was begun
         *
         * - 'view' : {@link Ext.grid.View GridView}
         *
         *   The source GridView from which the drag originated.
         *
         * - 'ddel' : HtmlElement
         *
         *   The drag proxy element which moves with the mouse
         *
         * - 'item' : HtmlElement
         *
         *   The {@link Ext.grid.View GridView}{@link Ext.grid.View GridView} node upon which the mousedown event was registered.
         *
         * - 'records' : {@link Array}
         *
         *   An Array of {@link Ext.data.Model Model}s representing the selected data being dragged from the source GridView.
         *
         * @param {Ext.data.Model} overModel The Model over which the drop gesture took place.
         *
         * @param {String} dropPosition '"before"' or '"after"' depending on whether the mouse is above or below the midline
         * of the node.
         */
        drop(node: HTMLElement, data: any, overModel: Ext.data.Model, dropPosition: string);
    }

    interface EditingConfig extends Ext.AbstractPluginConfig {
        /**
         * The number of clicks on a grid required to display the editor.
         * The only accepted values are **1** and **2**.
         */
        clicksToEdit?: number;

        /**
         * The event which triggers editing. Supercedes the {@link #clicksToEdit} configuration. Maybe one of:
         *
         *  * cellclick
         *  * celldblclick
         *  * cellfocus
         *  * rowfocus
         */
        triggerEvent?: string;
    }

    /**
     * This class provides an abstract grid editing plugin on selected {@link Ext.grid.column.Column columns}.
     * The editable columns are specified by providing an {@link Ext.grid.column.Column#editor editor}
     * in the {@link Ext.grid.column.Column column configuration}.
     *
     * **Note:** This class should not be used directly. See {@link Ext.grid.plugin.CellEditing} and
     * {@link Ext.grid.plugin.RowEditing}.
     */
    export class Editing extends Ext.AbstractPlugin implements Ext.grid.plugin.EditingConfig {
        /**
         * Set to 'true' while the editing plugin is active and an Editor is visible.
         */
        editing: boolean;

        /**
         * The number of clicks on a grid required to display the editor.
         * The only accepted values are **1** and **2**.
         */
        clicksToEdit: number;

        /**
         * The event which triggers editing. Supercedes the {@link #clicksToEdit} configuration. Maybe one of:
         *
         *  * cellclick
         *  * celldblclick
         *  * cellfocus
         *  * rowfocus
         */
        triggerEvent: string;

        /**
         * Cancels any active edit that is in progress.
         */
        cancelEdit();

        /**
         * Completes the edit if there is an active edit in progress.
         */
        completeEdit();

        constructor(config: Ext.grid.plugin.EditingConfig);

        /**
         * Starts editing the specified record, using the specified Column definition to define which field is being edited.
         * @param {Ext.data.Model/Number} record The Store data record which backs the row to be edited, or index of the record in Store.
         * @param {Ext.grid.column.Column/Number} columnHeader The Column object defining the column to be edited, or index of the column.
         */
        startEdit(record: Ext.data.Model|number, columnHeader: Ext.grid.column.Column|number);

        /**
         * Fires before editing is triggered. Return false from event handler to stop the editing.
         *
         * @param {Object} context The editing context with the following properties:
         *  @param {Ext.grid.Panel}         context.grid The owning grid Panel.
         *  @param {Ext.data.Model}         context.record The record being edited.
         *  @param {String}                 context.field The name of the field being edited.
         *  @param {Mixed}                  context.value The field's current value.
         *  @param {HTMLElement}            context.row The grid row element.
         *  @param {Ext.grid.column.Column} context.column The Column being edited.
         *  @param {Number}                 context.rowIdx The index of the row being edited.
         *  @param {Number}                 context.colIdx The index of the column being edited.
         *  @param {Boolean}                context.cancel Set this to 'true' to cancel the edit or return false from your handler.
         *  @param {Mixed}                  context.originalValue Alias for value (only when using {@link Ext.grid.plugin.CellEditing CellEditing}).
         */
        beforeedit(editor: Ext.grid.plugin.Editing, context: any);

        /**
         * Fires when the user started editing but then cancelled the edit.
         * @param {Object} context The editing context with the following properties:
         *  @param {Ext.grid.Panel}         context.grid The owning grid Panel.
         *  @param {Ext.data.Model}         context.record The record being edited.
         *  @param {String}                 context.field The name of the field being edited.
         *  @param {Mixed}                  context.value The field's current value.
         *  @param {HTMLElement}            context.row The grid row element.
         *  @param {Ext.grid.column.Column} context.column The Column being edited.
         *  @param {Number}                 context.rowIdx The index of the row being edited.
         *  @param {Number}                 context.colIdx The index of the column being edited.
         */
        canceledit(editor: Ext.grid.plugin.Editing, context: any);

        /**
         * Fires after a editing. Usage example:
         *
         *     grid.on('edit', function(editor, e) {
         *         // commit the changes right after editing finished
         *         e.record.commit();
         *     });
         *
         * @param {Object} context The editing context with the following properties:
         *  @param {Ext.grid.Panel}         context.grid The owning grid Panel.
         *  @param {Ext.data.Model}         context.record The record being edited.
         *  @param {String}                 context.field The name of the field being edited.
         *  @param {Mixed}                  context.value The field's current value.
         *  @param {HTMLElement}            context.row The grid row element.
         *  @param {Ext.grid.column.Column} context.column The Column being edited.
         *  @param {Number}                 context.rowIdx The index of the row being edited.
         *  @param {Number}                 context.colIdx The index of the column being edited.
         */
        edit(editor: Ext.grid.plugin.Editing, context: any);

        /**
         * Fires after editing, but before the value is set in the record. Return false from event handler to
         * cancel the change.
         *
         * Usage example showing how to remove the red triangle (dirty record indicator) from some records (not all). By
         * observing the grid's validateedit event, it can be cancelled if the edit occurs on a targeted row (for example)
         * and then setting the field's new value in the Record directly:
         *
         *     grid.on('validateedit', function(editor, e) {
         *       var myTargetRow = 6;
         *
         *       if (e.rowIdx == myTargetRow) {
         *         e.cancel = true;
         *         e.record.data[e.field] = e.value;
         *       }
         *     });
         *
         * @param {Object} context The editing context with the following properties:
         *  @param {Ext.grid.Panel}         context.grid The owning grid Panel.
         *  @param {Ext.data.Model}         context.record The record being edited.
         *  @param {String}                 context.field The name of the field being edited.
         *  @param {Mixed}                  context.value The field's current value.
         *  @param {HTMLElement}            context.row The grid row element.
         *  @param {Ext.grid.column.Column} context.column The Column being edited.
         *  @param {Number}                 context.rowIdx The index of the row being edited.
         *  @param {Number}                 context.colIdx The index of the column being edited.
         */
        validateedit(editor: Ext.grid.plugin.Editing, context: any);
    }

    export class HeaderReorderer extends Ext.AbstractPlugin {
        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.AbstractPluginConfig);

        disable();

        enable();
    }

    interface HeaderResizerConfig extends Ext.AbstractPluginConfig {
        /**
         * True to resize on the fly rather than using a proxy marker.
         */
        dynamic?: boolean;
    }

    /**
     * Plugin to add header resizing functionality to a HeaderContainer.
     * Always resizing header to the left of the splitter you are resizing.
     */
    export class HeaderResizer extends Ext.AbstractPlugin implements Ext.grid.plugin.HeaderResizerConfig {
        /**
         * True to resize on the fly rather than using a proxy marker.
         */
        dynamic: boolean;

        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.AbstractPluginConfig);

        disable();

        enable();

        getDynamic();

        setDynamic();
    }

    interface RowEditingConfig extends Ext.grid.plugin.EditingConfig {
        /**
         * 'true' to automatically cancel any pending changes when the row editor begins editing a new row.
         * 'false' to force the user to explicitly cancel the pending changes.
         */
        autoCancel?: boolean;

        /**
         * The number of clicks to move the row editor to a new row while it is visible and actively editing another row.
         * This will default to the same value as {@link Ext.grid.plugin.Editing#clicksToEdit clicksToEdit}.
         */
        clicksToMoveEditor?: number;

        /**
         * True to show a {@link Ext.tip.ToolTip tooltip} that summarizes all validation errors present
         * in the row editor. Set to false to prevent the tooltip from showing.
         */
        errorSummary?: boolean;
    }

    /**
     * The Ext.grid.plugin.RowEditing plugin injects editing at a row level for a Grid. When editing begins,
     * a small floating dialog will be shown for the appropriate row. Each editable column will show a field
     * for editing. There is a button to save or cancel all changes for the edit.
     *
     * The field that will be used for the editor is defined at the
     * {@link Ext.grid.column.Column#editor editor}. The editor can be a field instance or a field configuration.
     * If an editor is not specified for a particular column then that column won't be editable and the value of
     * the column will be displayed. To provide a custom renderer for non-editable values, use the
     * {@link Ext.grid.column.Column#editRenderer editRenderer} configuration on the column.
     *
     * The editor may be shared for each column in the grid, or a different one may be specified for each column.
     * An appropriate field type should be chosen to match the data structure that it will be editing. For example,
     * to edit a date, it would be useful to specify {@link Ext.form.field.Date} as the editor.
     *
     *     @example
     *     Ext.create('Ext.data.Store', {
     *         storeId:'simpsonsStore',
     *         fields:['name', 'email', 'phone'],
     *         data: [
     *             {"name":"Lisa", "email":"lisa@simpsons.com", "phone":"555-111-1224"},
     *             {"name":"Bart", "email":"bart@simpsons.com", "phone":"555-222-1234"},
     *             {"name":"Homer", "email":"home@simpsons.com", "phone":"555-222-1244"},
     *             {"name":"Marge", "email":"marge@simpsons.com", "phone":"555-222-1254"}
     *         ]
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Simpsons',
     *         store: Ext.data.StoreManager.lookup('simpsonsStore'),
     *         columns: [
     *             {header: 'Name',  dataIndex: 'name', editor: 'textfield'},
     *             {header: 'Email', dataIndex: 'email', flex:1,
     *                 editor: {
     *                     xtype: 'textfield',
     *                     allowBlank: false
     *                 }
     *             },
     *             {header: 'Phone', dataIndex: 'phone'}
     *         ],
     *         selType: 'rowmodel',
     *         plugins: [
     *             Ext.create('Ext.grid.plugin.RowEditing', {
     *                 clicksToEdit: 1
     *             })
     *         ],
     *         height: 200,
     *         width: 400,
     *         renderTo: Ext.getBody()
     *     });
     */
    export class RowEditing extends Ext.grid.plugin.Editing implements Ext.grid.plugin.RowEditingConfig {
        /**
         * 'true' to automatically cancel any pending changes when the row editor begins editing a new row.
         * 'false' to force the user to explicitly cancel the pending changes.
         */
        autoCancel: boolean;

        /**
         * The number of clicks to move the row editor to a new row while it is visible and actively editing another row.
         * This will default to the same value as {@link Ext.grid.plugin.Editing#clicksToEdit clicksToEdit}.
         */
        clicksToMoveEditor: number;

        /**
         * True to show a {@link Ext.tip.ToolTip tooltip} that summarizes all validation errors present
         * in the row editor. Set to false to prevent the tooltip from showing.
         */
        errorSummary: boolean;

        constructor();
    }

    interface RowExpanderConfig extends Ext.AbstractPluginConfig {
        /**
         * <tt>true</tt> to toggle a row between expanded/collapsed when double clicked
         * (defaults to <tt>true</tt>).
         */
        expandOnDblClick?: boolean;

        /**
         * <tt>true</tt> to toggle selected row(s) between expanded/collapsed when the enter
         * key is pressed (defaults to <tt>true</tt>).
         */
        expandOnEnter?: boolean;

        /**
         * <tt>true</tt> to select a row when clicking on the expander icon
         * (defaults to <tt>false</tt>).
         */
        selectRowOnExpand?: boolean;
    }

    /**
     * Plugin (ptype = 'rowexpander') that adds the ability to have a Column in a grid which enables
     * a second row body which expands/contracts.  The expand/contract behavior is configurable to react
     * on clicking of the column, double click of the row, and/or hitting enter while a row is selected.
     */
    export class RowExpander extends Ext.AbstractPlugin implements Ext.grid.plugin.RowExpanderConfig {
        /**
         * <tt>true</tt> to toggle a row between expanded/collapsed when double clicked
         * (defaults to <tt>true</tt>).
         */
        expandOnDblClick: boolean;

        /**
         * <tt>true</tt> to toggle selected row(s) between expanded/collapsed when the enter
         * key is pressed (defaults to <tt>true</tt>).
         */
        expandOnEnter: boolean;

        /**
         * <tt>true</tt> to select a row when clicking on the expander icon
         * (defaults to <tt>false</tt>).
         */
        selectRowOnExpand: boolean;

        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.AbstractPluginConfig);

        /**
         * **Fired through the grid's View.**
         * @param {HTMLElement} rowNode The &lt;tr> element which owns the expanded row.
         * @param {Ext.data.Model} record The record providing the data.
         * @param {HTMLElement} expandRow The &lt;tr> element containing the expanded data.
         */
        collapsebody(rowNode: HTMLElement, record: Ext.data.Model, expandRow: HTMLElement);

        /**
         * **Fired through the grid's View**
         * @param {HTMLElement} rowNode The &lt;tr> element which owns the expanded row.
         * @param {Ext.data.Model} record The record providing the data.
         * @param {HTMLElement} expandRow The &lt;tr> element containing the expanded data.
         */
        expandbody(rowNode: HTMLElement, record: Ext.data.Model, expandRow: HTMLElement);
    }
}

declare module Ext.grid.property {
    interface GridConfig extends Ext.grid.PanelConfig {
        columnLines?: any;

        /**
         * An object containing name/value pairs of custom editor type definitions that allow
         * the grid to support additional types of editable fields.  By default, the grid supports strongly-typed editing
         * of strings, dates, numbers and booleans using built-in form editors, but any custom type can be supported and
         * associated with a custom input control by specifying a custom editor.  The name of the editor
         * type should correspond with the name of the property that will use the editor.  Example usage:
         *
         *     var grid = new Ext.grid.property.Grid({
         *
         *         // Custom editors for certain property names
         *         customEditors: {
         *             evtStart: Ext.create('Ext.form.TimeField', {selectOnFocus: true})
         *         },
         *
         *         // Displayed name for property names in the source
         *         propertyNames: {
         *             evtStart: 'Start Time'
         *         },
         *
         *         // Data object containing properties to edit
         *         source: {
         *             evtStart: '10:00 AM'
         *         }
         *     });
         * @deprecated See {@link #sourceConfig} editor
         */
        customEditors?: any;

        /**
         * An object containing name/value pairs of custom renderer type definitions that allow
         * the grid to support custom rendering of fields.  By default, the grid supports strongly-typed rendering
         * of strings, dates, numbers and booleans using built-in form editors, but any custom type can be supported and
         * associated with the type of the value.  The name of the renderer type should correspond with the name of the property
         * that it will render.  Example usage:
         *
         *     var grid = Ext.create('Ext.grid.property.Grid', {
         *         customRenderers: {
         *             Available: function(v){
         *                 if (v) {
         *                     return '<span style="color: green;">Yes</span>';
         *                 } else {
         *                     return '<span style="color: red;">No</span>';
         *                 }
         *             }
         *         },
         *         source: {
         *             Available: true
         *         }
         *     });
         * @deprecated See {@link #sourceConfig} renderer
         */
        customRenderers?: any;

        enableColumnMove?: any;

        /**
         * True to automatically infer the {@link #sourceConfig type} based on the initial value passed
         * for each field. This ensures the editor remains the correct type even if the value is blanked
         * and becomes empty.
         */
        inferTypes?: boolean;

        /**
         * Specify the width for the name column. The value column will take any remaining space.
         *
         * Optional, Defaults to: 115
         */
        nameColumnWidth?: number|string;

        /**
         * The name of the field from the property store to use as the property field name.
         * This may be useful if you do not configure the property Grid from an object, but use your own store configuration.
         */
        nameField?: string;

        /**
         * An object containing custom property name/display name pairs.
         * If specified, the display name will be shown in the name column instead of the property name.
         * @deprecated See {@link #sourceConfig} displayName
         */
        propertyNames?: any;

        /**
         * A data object to use as the data source of the grid (see {@link #setSource} for details).
         */
        source?: any;

        /**
         * This option allows various configurations to be set for each field in the property grid.
         * None of these configurations are required
         *
         * ####displayName
         * A custom name to appear as label for this field. If specified, the display name will be shown
         * in the name column instead of the property name. Example usage:
         *
         *     new Ext.grid.property.Grid({
         *         source: {
         *             clientIsAvailable: true
         *         },
         *         sourceConfig: {
         *             clientIsAvailable: {
         *                 // Custom name different to the field
         *                 displayName: 'Available'
         *             }
         *         }
         *     });
         *
         * ####renderer
         * A function used to transform the underlying value before it is displayed in the grid.
         * By default, the grid supports strongly-typed rendering of strings, dates, numbers and booleans using built-in form editors,
         * but any custom type can be supported and associated with the type of the value. Example usage:
         *
         *     new Ext.grid.property.Grid({
         *         source: {
         *             clientIsAvailable: true
         *         },
         *         sourceConfig: {
         *             clientIsAvailable: {
         *                 // Custom renderer to change the color based on the value
         *                 renderer: function(v){
         *                     var color = v ? 'green' : 'red';
         *                     return '<span style="color: ' + color + ';">' + v + '</span>';
         *                 }
         *             }
         *         }
         *     });
         *
         * ####type
         * Used to explicitly specify the editor type for a particular value. By default, the type is
         * automatically inferred from the value. See {@link #inferTypes}. Accepted values are:
         *
         * - 'date'
         * - 'boolean'
         * - 'number'
         * - 'string'
         *
         * For more advanced control an editor configuration can be passed (see the next section).
         * Example usage:
         *
         *     new Ext.grid.property.Grid({
         *         source: {
         *             attending: null
         *         },
         *         sourceConfig: {
         *             attending: {
         *                 // Force the type to be a numberfield, a null value would otherwise default to a textfield
         *                 type: 'number'
         *             }
         *         }
         *     });
         *
         * ####editor
         * Allows the grid to support additional types of editable fields.  By default, the grid supports strongly-typed editing
         * of strings, dates, numbers and booleans using built-in form editors, but any custom type can be supported and
         * associated with a custom input control by specifying a custom editor. Example usage
         *
         *     new Ext.grid.property.Grid({
         *         // Data object containing properties to edit
         *         source: {
         *             evtStart: '10:00 AM'
         *         },
         *
         *         sourceConfig: {
         *             evtStart: {
         *                 editor: Ext.create('Ext.form.field.Time', {selectOnFocus: true}),
         *                 displayName: 'Start Time'
         *             }
         *         }
         *     });
         */
        sourceConfig?: any;

        /**
         * The name of the field from the property store to use as the value field name.
         * This may be useful if you do not configure the property Grid from an object, but use your own store configuration.
         */
        valueField?: string;
    }

    /**
     * A specialized grid implementation intended to mimic the traditional property grid as typically seen in
     * development IDEs.  Each row in the grid represents a property of some object, and the data is stored
     * as a set of name/value pairs in {@link Ext.grid.property.Property Properties}. By default, the editors
     * shown are inferred from the data in the cell. More control over this can be specified by using the
     * {@link #sourceConfig} option. Example usage:
     *
     *     @example
     *     Ext.create('Ext.grid.property.Grid', {
     *         title: 'Properties Grid',
     *         width: 300,
     *         renderTo: Ext.getBody(),
     *         source: {
     *             "(name)": "My Object",
     *             "Created": Ext.Date.parse('10/15/2006', 'm/d/Y'),
     *             "Available": false,
     *             "Version": 0.01,
     *             "Description": "A test object"
     *         }
     *     });
     */
    export class Grid extends Ext.grid.Panel implements Ext.grid.property.GridConfig {
        columnLines: boolean;

        /**
         * An object containing name/value pairs of custom editor type definitions that allow
         * the grid to support additional types of editable fields.  By default, the grid supports strongly-typed editing
         * of strings, dates, numbers and booleans using built-in form editors, but any custom type can be supported and
         * associated with a custom input control by specifying a custom editor.  The name of the editor
         * type should correspond with the name of the property that will use the editor.  Example usage:
         *
         *     var grid = new Ext.grid.property.Grid({
         *
         *         // Custom editors for certain property names
         *         customEditors: {
         *             evtStart: Ext.create('Ext.form.TimeField', {selectOnFocus: true})
         *         },
         *
         *         // Displayed name for property names in the source
         *         propertyNames: {
         *             evtStart: 'Start Time'
         *         },
         *
         *         // Data object containing properties to edit
         *         source: {
         *             evtStart: '10:00 AM'
         *         }
         *     });
         * @deprecated See {@link #sourceConfig} editor
         */
        customEditors: any;

        /**
         * An object containing name/value pairs of custom renderer type definitions that allow
         * the grid to support custom rendering of fields.  By default, the grid supports strongly-typed rendering
         * of strings, dates, numbers and booleans using built-in form editors, but any custom type can be supported and
         * associated with the type of the value.  The name of the renderer type should correspond with the name of the property
         * that it will render.  Example usage:
         *
         *     var grid = Ext.create('Ext.grid.property.Grid', {
         *         customRenderers: {
         *             Available: function(v){
         *                 if (v) {
         *                     return '<span style="color: green;">Yes</span>';
         *                 } else {
         *                     return '<span style="color: red;">No</span>';
         *                 }
         *             }
         *         },
         *         source: {
         *             Available: true
         *         }
         *     });
         * @deprecated See {@link #sourceConfig} renderer
         */
        customRenderers: any;

        enableColumnMove: boolean;

        /**
         * True to automatically infer the {@link #sourceConfig type} based on the initial value passed
         * for each field. This ensures the editor remains the correct type even if the value is blanked
         * and becomes empty.
         */
        inferTypes: boolean;

        /**
         * Specify the width for the name column. The value column will take any remaining space.
         *
         * Optional, Defaults to: 115
         */
        nameColumnWidth: number|string;

        /**
         * The name of the field from the property store to use as the property field name.
         * This may be useful if you do not configure the property Grid from an object, but use your own store configuration.
         */
        nameField: string;

        /**
         * An object containing custom property name/display name pairs.
         * If specified, the display name will be shown in the name column instead of the property name.
         * @deprecated See {@link #sourceConfig} displayName
         */
        propertyNames: any;

        /**
         * A data object to use as the data source of the grid (see {@link #setSource} for details).
         */
        source: any;

        /**
         * This option allows various configurations to be set for each field in the property grid.
         * None of these configurations are required
         *
         * ####displayName
         * A custom name to appear as label for this field. If specified, the display name will be shown
         * in the name column instead of the property name. Example usage:
         *
         *     new Ext.grid.property.Grid({
         *         source: {
         *             clientIsAvailable: true
         *         },
         *         sourceConfig: {
         *             clientIsAvailable: {
         *                 // Custom name different to the field
         *                 displayName: 'Available'
         *             }
         *         }
         *     });
         *
         * ####renderer
         * A function used to transform the underlying value before it is displayed in the grid.
         * By default, the grid supports strongly-typed rendering of strings, dates, numbers and booleans using built-in form editors,
         * but any custom type can be supported and associated with the type of the value. Example usage:
         *
         *     new Ext.grid.property.Grid({
         *         source: {
         *             clientIsAvailable: true
         *         },
         *         sourceConfig: {
         *             clientIsAvailable: {
         *                 // Custom renderer to change the color based on the value
         *                 renderer: function(v){
         *                     var color = v ? 'green' : 'red';
         *                     return '<span style="color: ' + color + ';">' + v + '</span>';
         *                 }
         *             }
         *         }
         *     });
         *
         * ####type
         * Used to explicitly specify the editor type for a particular value. By default, the type is
         * automatically inferred from the value. See {@link #inferTypes}. Accepted values are:
         *
         * - 'date'
         * - 'boolean'
         * - 'number'
         * - 'string'
         *
         * For more advanced control an editor configuration can be passed (see the next section).
         * Example usage:
         *
         *     new Ext.grid.property.Grid({
         *         source: {
         *             attending: null
         *         },
         *         sourceConfig: {
         *             attending: {
         *                 // Force the type to be a numberfield, a null value would otherwise default to a textfield
         *                 type: 'number'
         *             }
         *         }
         *     });
         *
         * ####editor
         * Allows the grid to support additional types of editable fields.  By default, the grid supports strongly-typed editing
         * of strings, dates, numbers and booleans using built-in form editors, but any custom type can be supported and
         * associated with a custom input control by specifying a custom editor. Example usage
         *
         *     new Ext.grid.property.Grid({
         *         // Data object containing properties to edit
         *         source: {
         *             evtStart: '10:00 AM'
         *         },
         *
         *         sourceConfig: {
         *             evtStart: {
         *                 editor: Ext.create('Ext.form.field.Time', {selectOnFocus: true}),
         *                 displayName: 'Start Time'
         *             }
         *         }
         *     });
         */
        sourceConfig: any;

        /**
         * The name of the field from the property store to use as the value field name.
         * This may be useful if you do not configure the property Grid from an object, but use your own store configuration.
         */
        valueField: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Gets the source data object containing the property data.  See {@link #setSource} for details regarding the
         * format of the data object.
         * @return {Object} The data object.
         */
        getSource(): any;

        /**
         * Removes a property from the grid.
         * @param {String} prop The name of the property to remove.
         */
        removeProperty(prop: string);

        /**
         * Sets the value of a property.
         * @param {String} prop The name of the property to set.
         * @param {Object} value The value to test.
         * @param {Boolean} [create=false] 'true' to create the property if it doesn't already exist.
         */
        setProperty(prop: string, value: any, create?: boolean);

        /**
         * Sets the source data object containing the property data.  The data object can contain one or more name/value
         * pairs representing all of the properties of an object to display in the grid, and this data will automatically
         * be loaded into the grid's {@link #store}.  The values should be supplied in the proper data type if needed,
         * otherwise string type will be assumed.  If the grid already contains data, this method will replace any
         * existing data.  See also the {@link #source} config value.  Example usage:
         *
         *     grid.setSource({
         *         "(name)": "My Object",
         *         "Created": Ext.Date.parse('10/15/2006', 'm/d/Y'),  // date type
         *         "Available": false,  // boolean type
         *         "Version": .01,      // decimal type
         *         "Description": "A test object"
         *     });
         *
         * @param {Object} source The data object.
         * @param {Object} [sourceConfig] A new {@link #sourceConfig object}. If this argument is not passed
         * the current configuration will be re-used. To reset the config, pass 'null' or an empty object literal.
         */
        setSource(source: any, sourceConfig?: any);

        /**
         * Fires before a property value changes.  Handlers can return false to cancel the property change
         * (this will internally call {@link Ext.data.Model#reject} on the property's record).
         * @param {Object} source The source data object for the grid (corresponds to the same object passed in
         * as the {@link #source} config property).
         * @param {String} recordId The record's id in the data store
         * @param {Object} value The current edited property value
         * @param {Object} oldValue The original property value prior to editing
         */
        beforepropertychange(source: any, recordId: string, value: any, oldValue: any);

        /**
         * Fires after a property value has changed.
         * @param {Object} source The source data object for the grid (corresponds to the same object passed in
         * as the {@link #source} config property).
         * @param {String} recordId The record's id in the data store
         * @param {Object} value The current edited property value
         * @param {Object} oldValue The original property value prior to editing
         */
        propertychange(source: any, recordId: string, value: any, oldValue: any);
    }

    /**
     * A custom HeaderContainer for the {@link Ext.grid.property.Grid}.
     * Generally it should not need to be used directly.
     */
    export class HeaderContainer extends Ext.grid.header.Container {
        /**
         * Creates new HeaderContainer.
         * @param {Ext.grid.property.Grid} grid The grid this store will be bound to
         * @param {Object} source The source data config object
         */
        constructor(grid: Ext.grid.property.Grid, source: any);
    }

    interface PropertyConfig extends Ext.data.ModelConfig {
        idProperty?: any;
    }

    export class Property extends Ext.data.Model implements Ext.grid.property.PropertyConfig {
        fields: Ext.util.MixedCollection;

        idProperty: string|any|Ext.data.Field;

        /**
         * A specific {@link Ext.data.Model} type that represents a name/value pair and is made to work with the
         * {@link Ext.grid.property.Grid}. Typically, Properties do not need to be created directly as they can be
         * created implicitly by simply using the appropriate data configs either via the
         * {@link Ext.grid.property.Grid#source} config property or by calling {@link Ext.grid.property.Grid#setSource}.
         * However, if the need arises, these records can also be created explicitly as shown below. Example usage:
         *
         *     var rec = new Ext.grid.property.Property({
         *         name: 'birthday',
         *         value: Ext.Date.parse('17/06/1962', 'd/m/Y')
         *     });
         *     // Add record to an already populated grid
         *     grid.store.addSorted(rec);
         *
         * @constructor
         * Creates new property.
         * @param {Object} config A data object in the format:
         * @param {String/String[]} config.name A name or names for the property.
         * @param {Mixed/Mixed[]} config.value A value or values for the property.
         * The specified value's type will be read automatically by the grid to determine the type of editor to use when
         * displaying it.
         * @return {Object}
         */
        constructor(config: Ext.grid.property.PropertyConfig, config_name: string, config_value: any);
    }

    interface StoreConfig extends Ext.data.StoreConfig {
        sortOnLoad?: any;
    }

    /**
     * A custom {@link Ext.data.Store} for the {@link Ext.grid.property.Grid}. This class handles the mapping
     * between the custom data source objects supported by the grid and the {@link Ext.grid.property.Property} format
     * used by the {@link Ext.data.Store} base class.
     */
    export class Store extends Ext.data.Store implements Ext.grid.property.StoreConfig {
        sortOnLoad: boolean;

        /**
         * Creates new property store.
         * @param {Ext.grid.Panel} grid The grid this store will be bound to
         * @param {Object} source The source data config object
         */
        constructor(grid: Ext.grid.Panel, source: any);
    }
}

declare module Ext.layout {
    /**
     * This class provides a DOM ClassList API to buffer access to an element's class.
     * Instances of this class are created by {@link Ext.layout.ContextItem#getClassList}.
     */
    export class ClassList extends Ext.Base {
        /**
         * Adds a single class to the class list.
         */
        add();

        /**
         * Adds one or more classes in an array or space-delimited string to the class list.
         */
        addMany();

        /**
         * Removes a single class from the class list.
         */
        remove();

        /**
         * Removes one or more classes in an array or space-delimited string from the class
         * list.
         */
        removeMany();
    }

    /**
     * Manages context information during a layout.
     *
     * # Algorithm
     *
     * This class performs the following jobs:
     *
     *  - Cache DOM reads to avoid reading the same values repeatedly.
     *  - Buffer DOM writes and flush them as a block to avoid read/write interleaving.
     *  - Track layout dependencies so each layout does not have to figure out the source of
     *    its dependent values.
     *  - Intelligently run layouts when the values on which they depend change (a trigger).
     *  - Allow layouts to avoid processing when required values are unavailable (a block).
     *
     * Work done during layout falls into either a "read phase" or a "write phase" and it is
     * essential to always be aware of the current phase. Most methods in
     * {@link Ext.layout.Layout Layout} are called during a read phase:
     * {@link Ext.layout.Layout#calculate calculate},
     * {@link Ext.layout.Layout#completeLayout completeLayout} and
     * {@link Ext.layout.Layout#finalizeLayout finalizeLayout}. The exceptions to this are
     * {@link Ext.layout.Layout#beginLayout beginLayout},
     * {@link Ext.layout.Layout#beginLayoutCycle beginLayoutCycle} and
     * {@link Ext.layout.Layout#finishedLayout finishedLayout} which are called during
     * a write phase. While {@link Ext.layout.Layout#finishedLayout finishedLayout} is called
     * a write phase, it is really intended to be a catch-all for post-processing after a
     * layout run.
     *
     * In a read phase, it is OK to read the DOM but this should be done using the appropriate
     * {@link Ext.layout.ContextItem ContextItem} where possible since that provides a cache
     * to avoid redundant reads. No writes should be made to the DOM in a read phase! Instead,
     * the values should be written to the proper ContextItem for later write-back.
     *
     * The rules flip-flop in a write phase. The only difference is that ContextItem methods
     * like {@link Ext.layout.ContextItem#getStyle getStyle} will still read the DOM unless the
     * value was previously read. This detail is unknowable from the outside of ContextItem, so
     * read calls to ContextItem should also be avoided in a write phase.
     *
     * Calculating interdependent layouts requires a certain amount of iteration. In a given
     * cycle, some layouts will contribute results that allow other layouts to proceed. The
     * general flow then is to gather all of the layouts (both component and container) in a
     * component tree and queue them all for processing. The initial queue order is bottom-up
     * and component layout first, then container layout (if applicable) for each component.
     *
     * This initial step also calls the beginLayout method on all layouts to clear any values
     * from the DOM that might interfere with calculations and measurements. In other words,
     * this is a "write phase" and reads from the DOM should be strictly avoided.
     *
     * Next the layout enters into its iterations or "cycles". Each cycle consists of calling
     * the {@link Ext.layout.Layout#calculate calculate} method on all layouts in the
     * {@link #layoutQueue}. These calls are part of a "read phase" and writes to the DOM should
     * be strictly avoided.
     *
     * # Considerations
     *
     * **RULE 1**: Respect the read/write cycles. Always use the {@link Ext.layout.ContextItem#getProp getProp}
     * or {@link Ext.layout.ContextItem#getDomProp getDomProp} methods to get calculated values;
     * only use the {@link Ext.layout.ContextItem#getStyle getStyle} method to read styles; use
     * {@link Ext.layout.ContextItem#setProp setProp} to set DOM values. Some reads will, of
     * course, still go directly to the DOM, but if there is a method in
     * {@link Ext.layout.ContextItem ContextItem} to do a certain job, it should be used instead
     * of a lower-level equivalent.
     *
     * The basic logic flow in {@link Ext.layout.Layout#calculate calculate} consists of gathering
     * values by calling {@link Ext.layout.ContextItem#getProp getProp} or
     * {@link Ext.layout.ContextItem#getDomProp getDomProp}, calculating results and publishing
     * them by calling {@link Ext.layout.ContextItem#setProp setProp}. It is important to realize
     * that {@link Ext.layout.ContextItem#getProp getProp} will return 'undefined' if the value
     * is not yet known. But the act of calling the method is enough to track the fact that the
     * calling layout depends (in some way) on this value. In other words, the calling layout is
     * "triggered" by the properties it requests.
     *
     * **RULE 2**: Avoid calling {@link Ext.layout.ContextItem#getProp getProp} unless the value
     * is needed. Gratuitous calls cause inefficiency because the layout will appear to depend on
     * values that it never actually uses. This applies equally to
     * {@link Ext.layout.ContextItem#getDomProp getDomProp} and the test-only methods
     * {@link Ext.layout.ContextItem#hasProp hasProp} and {@link Ext.layout.ContextItem#hasDomProp hasDomProp}.
     *
     * Because {@link Ext.layout.ContextItem#getProp getProp} can return 'undefined', it is often
     * the case that subsequent math will produce NaN's. This is usually not a problem as the
     * NaN's simply propagate along and result in final results that are NaN. Both 'undefined'
     * and NaN are ignored by {@link Ext.layout.ContextItem#setProp}, so it is often not necessary
     * to even know that this is happening. It does become important for determining if a layout
     * is not done or if it might lead to publishing an incorrect (but not NaN or 'undefined')
     * value.
     *
     * **RULE 3**: If a layout has not calculated all the values it is required to calculate, it
     * must set {@link Ext.layout.Layout#done done} to 'false' before returning from
     * {@link Ext.layout.Layout#calculate calculate}. This value is always 'true' on entry because
     * it is simpler to detect the incomplete state rather than the complete state (especially up
     * and down a class hierarchy).
     *
     * **RULE 4**: A layout must never publish an incomplete (wrong) result. Doing so would cause
     * dependent layouts to run their calculations on those wrong values, producing more wrong
     * values and some layouts may even incorrectly flag themselves as {@link Ext.layout.Layout#done done}
     * before the correct values are determined and republished. Doing this will poison the
     * calculations.
     *
     * **RULE 5**: Each value should only be published by one layout. If multiple layouts attempt
     * to publish the same values, it would be nearly impossible to avoid breaking **RULE 4**. To
     * help detect this problem, the layout diagnostics will trap on an attempt to set a value
     * from different layouts.
     *
     * Complex layouts can produce many results as part of their calculations. These values are
     * important for other layouts to proceed and need to be published by the earliest possible
     * call to {@link Ext.layout.Layout#calculate} to avoid unnecessary cycles and poor performance. It is
     * also possible, however, for some results to be related in a way such that publishing them
     * may be an all-or-none proposition (typically to avoid breaking *RULE 4*).
     *
     * **RULE 6**: Publish results as soon as they are known to be correct rather than wait for
     * all values to be calculated. Waiting for everything to be complete can lead to deadlock.
     * The key here is not to forget **RULE 4** in the process.
     *
     * Some layouts depend on certain critical values as part of their calculations. For example,
     * HBox depends on width and cannot do anything until the width is known. In these cases, it
     * is best to use {@link Ext.layout.ContextItem#block block} or
     * {@link Ext.layout.ContextItem#domBlock domBlock} and thereby avoid processing the layout
     * until the needed value is available.
     *
     * **RULE 7**: Use {@link Ext.layout.ContextItem#block block} or
     * {@link Ext.layout.ContextItem#domBlock domBlock} when values are required to make progress.
     * This will mimize wasted recalculations.
     *
     * **RULE 8**: Blocks should only be used when no forward progress can be made. If even one
     * value could still be calculated, a block could result in a deadlock.
     *
     * Historically, layouts have been invoked directly by component code, sometimes in places
     * like an 'afterLayout' method for a child component. With the flexibility now available
     * to solve complex, iterative issues, such things should be done in a responsible layout
     * (be it component or container).
     *
     * **RULE 9**: Use layouts to solve layout issues and don't wait for the layout to finish to
     * perform further layouts. This is especially important now that layouts process entire
     * component trees and not each layout in isolation.
     *
     * # Sequence Diagram
     *
     * The simplest sequence diagram for a layout run looks roughly like this:
     *
     *       Context         Layout 1     Item 1     Layout 2     Item 2
     *          |               |           |           |           |
     *     ---->X-------------->X           |           |           |
     *     run  X---------------|-----------|---------->X           |
     *          X beginLayout   |           |           |           |
     *          X               |           |           |           |
     *        A X-------------->X           |           |           |
     *          X  calculate    X---------->X           |           |
     *          X             C X  getProp  |           |           |
     *        B X               X---------->X           |           |
     *          X               |  setProp  |           |           |
     *          X               |           |           |           |
     *        D X---------------|-----------|---------->X           |
     *          X  calculate    |           |           X---------->X
     *          X               |           |           |  setProp  |
     *        E X               |           |           |           |
     *          X---------------|-----------|---------->X           |
     *          X completeLayout|           |         F |           |
     *          X               |           |           |           |
     *        G X               |           |           |           |
     *        H X-------------->X           |           |           |
     *          X  calculate    X---------->X           |           |
     *          X             I X  getProp  |           |           |
     *          X               X---------->X           |           |
     *          X               |  setProp  |           |           |
     *        J X-------------->X           |           |           |
     *          X completeLayout|           |           |           |
     *          X               |           |           |           |
     *        K X-------------->X           |           |           |
     *          X---------------|-----------|---------->X           |
     *          X finalizeLayout|           |           |           |
     *          X               |           |           |           |
     *        L X-------------->X           |           |           |
     *          X---------------|-----------|---------->X           |
     *          X finishedLayout|           |           |           |
     *          X               |           |           |           |
     *        M X-------------->X           |           |           |
     *          X---------------|-----------|---------->X           |
     *          X notifyOwner   |           |           |           |
     *        N |               |           |           |           |
     *          -               -           -           -           -
     *
     *
     * Notes:
     *
     * **A.** This is a call from the {@link #run} method to the {@link #runCycle} method.
     * Each layout in the queue will have its {@link Ext.layout.Layout#calculate calculate}
     * method called.
     *
     * **B.** After each {@link Ext.layout.Layout#calculate calculate} method is called the
     * {@link Ext.layout.Layout#done done} flag is checked to see if the Layout has completed.
     * If it has completed and that layout object implements a
     * {@link Ext.layout.Layout#completeLayout completeLayout} method, this layout is queued to
     * receive its call. Otherwise, the layout will be queued again unless there are blocks or
     * triggers that govern its requeueing.
     *
     * **C.** The call to {@link Ext.layout.ContextItem#getProp getProp} is made to the Item
     * and that will be tracked as a trigger (keyed by the name of the property being requested).
     * Changes to this property will cause this layout to be requeued. The call to
     * {@link Ext.layout.ContextItem#setProp setProp} will place a value in the item and not
     * directly into the DOM.
     *
     * **D.** Call the other layouts now in the first cycle (repeat **B** and **C** for each
     * layout).
     *
     * **E.** After completing a cycle, if progress was made (new properties were written to
     * the context) and if the {@link #layoutQueue} is not empty, the next cycle is run. If no
     * progress was made or no layouts are ready to run, all buffered values are written to
     * the DOM (a flush).
     *
     * **F.** After flushing, any layouts that were marked as {@link Ext.layout.Layout#done done}
     * that also have a {@link Ext.layout.Layout#completeLayout completeLayout} method are called.
     * This can cause them to become no longer done (see {@link #invalidate}). As with
     * {@link Ext.layout.Layout#calculate calculate}, this is considered a "read phase" and
     * direct DOM writes should be avoided.
     *
     * **G.** Flushing and calling any pending {@link Ext.layout.Layout#completeLayout completeLayout}
     * methods will likely trigger layouts that called {@link Ext.layout.ContextItem#getDomProp getDomProp}
     * and unblock layouts that have called {@link Ext.layout.ContextItem#domBlock domBlock}.
     * These variants are used when a layout needs the value to be correct in the DOM and not
     * simply known. If this does not cause at least one layout to enter the queue, we have a
     * layout FAILURE. Otherwise, we continue with the next cycle.
     *
     * **H.** Call {@link Ext.layout.Layout#calculate calculate} on any layouts in the queue
     * at the start of this cycle. Just a repeat of **B** through **G**.
     *
     * **I.** Once the layout has calculated all that it is resposible for, it can leave itself
     * in the {@link Ext.layout.Layout#done done} state. This is the value on entry to
     * {@link Ext.layout.Layout#calculate calculate} and must be cleared in that call if the
     * layout has more work to do.
     *
     * **J.** Now that all layouts are done, flush any DOM values and
     * {@link Ext.layout.Layout#completeLayout completeLayout} calls. This can again cause
     * layouts to become not done, and so we will be back on another cycle if that happens.
     *
     * **K.** After all layouts are done, call the {@link Ext.layout.Layout#finalizeLayout finalizeLayout}
     * method on any layouts that have one. As with {@link Ext.layout.Layout#completeLayout completeLayout},
     * this can cause layouts to become no longer done. This is less desirable than using
     * {@link Ext.layout.Layout#completeLayout completeLayout} because it will cause all
     * {@link Ext.layout.Layout#finalizeLayout finalizeLayout} methods to be called again
     * when we think things are all wrapped up.
     *
     * **L.** After finishing the last iteration, layouts that have a
     * {@link Ext.layout.Layout#finishedLayout finishedLayout} method will be called. This
     * call will only happen once per run and cannot cause layouts to be run further.
     *
     * **M.** After calling finahedLayout, layouts that have a
     * {@link Ext.layout.Layout#notifyOwner notifyOwner} method will be called. This
     * call will only happen once per run and cannot cause layouts to be run further.
     *
     * **N.** One last flush to make sure everything has been written to the DOM.
     *
     * # Inter-Layout Collaboration
     *
     * Many layout problems require collaboration between multiple layouts. In some cases, this
     * is as simple as a component's container layout providing results used by its component
     * layout or vise-versa. A slightly more distant collaboration occurs in a box layout when
     * stretchmax is used: the child item's component layout provides results that are consumed
     * by the ownerCt's box layout to determine the size of the children.
     *
     * The various forms of interdependence between a container and its children are described by
     * each components' {@link Ext.AbstractComponent#getSizeModel size model}.
     *
     * To facilitate this collaboration, the following pairs of properties are published to the
     * component's {@link Ext.layout.ContextItem ContextItem}:
     *
     *  - width/height: These hold the final size of the component. The layout indicated by the
     *    {@link Ext.AbstractComponent#getSizeModel size model} is responsible for setting these.
     *  - contentWidth/contentHeight: These hold size information published by the container
     *    layout or from DOM measurement. These describe the content only. These values are
     *    used by the component layout to determine the outer width/height when that component
     *    is {@link Ext.AbstractComponent#shrinkWrap shrink-wrapped}. They are also used to
     *    determine overflow. All container layouts must publish these values for dimensions
     *    that are shrink-wrapped. If a component has raw content (not container items), the
     *    componentLayout must publish these values instead.
     */
    export class Context extends Ext.Base {
        /**
         * List of layouts to perform.
         */
        layoutQueue: Ext.util.Queue;

        /**
         * One of these values:
         *
         *  - 0 - Before run
         *  - 1 - Running
         *  - 2 - Run complete
         */
        state: number;

        constructor(config: any);

        /**
         * Flushes any pending writes to the DOM by calling each ContextItem in the flushQueue.
         */
        flush();

        /**
         * Returns the ContextItem for a component.
         */
        getCmp(cmp: Ext.Component);

        /**
         * Returns the ContextItem for an element.
         */
        getEl(parent: Ext.layout.ContextItem, el: Ext.dom.Element);

        /**
         * Invalidates one or more components' layouts (component and container). This can be
         * called before run to identify the components that need layout or during the run to
         * restart the layout of a component. This is called internally to flush any queued
         * invalidations at the start of a cycle. If called during a run, it is not expected
         * that new components will be introduced to the layout.
         *
         * @param {Ext.Component/Array} components An array of Components or a single Component.
         * @param {Boolean} full True if all properties should be invalidated, otherwise only
         *  those calculated by the component should be invalidated.
         */
        invalidate(components: Ext.Component|any[], full: boolean);

        /**
         * Removes the ContextItem for an element from the cache and from the parent's
         * "children" array.
         */
        removeEl(parent: Ext.layout.ContextItem, el: Ext.dom.Element);

        /**
         * Resets the given layout object. This is called at the start of the run and can also
         * be called during the run by calling {@link #invalidate}.
         */
        resetLayout();

        /**
         * Runs the layout calculations. This can be called only once on this object.
         * @return {Boolean} True if all layouts were completed, false if not.
         */
        run(): boolean;

        /**
         * Performs one layout cycle by calling each layout in the layout queue.
         * @return {Boolean} True if some progress was made, false if not.
         */
        protected runCycle(): boolean;

        /**
         * Set the size of a component, element or composite or an array of components or elements.
         * The item(s) to size.
         * @param {Number} width The new width to set (ignored if undefined or NaN).
         * @param {Number} height The new height to set (ignored if undefined or NaN).
         */
        setItemSize(items: Ext.Component|Ext.dom.Element|Ext.dom.CompositeElement, width: number, height: number);
    }

    /**
     * This class manages state information for a component or element during a layout.
     *
     * # Blocks
     *
     * A "block" is a required value that is preventing further calculation. When a layout has
     * encountered a situation where it cannot possibly calculate results, it can associate
     * itself with the context item and missing property so that it will not be rescheduled
     * until that property is set.
     *
     * Blocks are a one-shot registration. Once the property changes, the block is removed.
     *
     * Be careful with blocks. If *any* further calculations can be made, a block is not the
     * right choice.
     *
     * # Triggers
     *
     * Whenever any call to {@link #getProp}, {@link #getDomProp}, {@link #hasProp} or
     * {@link #hasDomProp} is made, the current layout is automatically registered as being
     * dependent on that property in the appropriate state. Any changes to the property will
     * trigger the layout and it will be queued in the {@link Ext.layout.Context}.
     *
     * Triggers, once added, remain for the entire layout. Any changes to the property will
     * reschedule all unfinished layouts in their trigger set.
     */
    export class ContextItem extends Ext.Base {
        /**
         * State variables that are cleared when invalidated. Only applies to component items.
         */
        state: any;

        /**
         * True if this item wraps a Component (rather than an Element).
         * @readonly
         */
        wrapsComponent: boolean;

        /**
         * Queue the addition of a class name (or array of class names) to this ContextItem's target when next flushed.
         */
        addCls();

        /**
         * Registers a layout in the block list for the given property. Once the property is
         * set in the {@link Ext.layout.Context}, the layout is unblocked.
         *
         * @param {String} propName The property name that blocked the layout (e.g., 'width').
         */
        block(layout: Ext.layout.Layout, propName: string);

        /**
         * clears the margin cache so that marginInfo get re-read from the dom on the next call to getMarginInfo()
         * This is needed in some special cases where the margins have changed since the last layout, making the cached
         * values invalid.  For example collapsed window headers have different margin than expanded ones.
         */
        clearMarginCache();

        constructor(config: any);

        /**
         * Registers a layout in the DOM block list for the given property. Once the property
         * flushed to the DOM by the {@link Ext.layout.Context}, the layout is unblocked.
         *
         * @param {String} propName The property name that blocked the layout (e.g., 'width').
         */
        domBlock(layout: Ext.layout.Layout, propName: string);

        /**
         * Flushes any updates in the dirty collection to the DOM. This is only called if there
         * are dirty entries because this object is only added to the flushQueue of the
         * {@link Ext.layout.Context} when entries become dirty.
         */
        flush();

        /**
         * Gets the border information for the element as an object with left, top, right and
         * bottom properties holding border size in pixels. This object is only read from the
         * DOM on first request and is cached.
         * @return {Object}
         */
        getBorderInfo(): any;

        /**
         * Returns a ClassList-like object to buffer access to this item's element's classes.
         */
        getClassList();

        /**
         * Gets a property of this object if it is correct in the DOM. Also tracks the current
         * layout as dependent on this property so that DOM writes of it will trigger the
         * layout to be recalculated.
         * @param {String} propName The property name (e.g., 'width').
         * @return {Object} The property value or undefined if not yet set or is dirty.
         */
        getDomProp(propName: string): any;

        /**
         * Returns the context item for an owned element. This should only be called on a
         * component's item. The list of child items is used to manage invalidating calculated
         * results.
         * @param {String/Ext.dom.Element} nameOrEl The element or the name of an owned element
         * @param {Ext.layout.container.Container/Ext.Component} [owner] The owner of the
         * named element if the passed "nameOrEl" parameter is a String. Defaults to this
         * ContextItem's "target" property.  For more details on owned elements see
         * {@link Ext.Component#cfg-childEls childEls} and
         * {@link Ext.Component#renderSelectors renderSelectors}
         * @return {Ext.layout.ContextItem}
         */
        getEl(nameOrEl: string|Ext.dom.Element, owner?: Ext.layout.container.Container|Ext.Component): Ext.layout.ContextItem;

        /**
         * Gets the "frame" information for the element as an object with left, top, right and
         * bottom properties holding border+framing size in pixels. This object is calculated
         * on first request and is cached.
         * @return {Object}
         */
        getFrameInfo(): any;

        /**
         * Gets the margin information for the element as an object with left, top, right and
         * bottom properties holding margin size in pixels. This object is only read from the
         * DOM on first request and is cached.
         * @return {Object}
         */
        getMarginInfo(): any;

        /**
         * Gets the padding information for the element as an object with left, top, right and
         * bottom properties holding padding size in pixels. This object is only read from the
         * DOM on first request and is cached.
         * @return {Object}
         */
        getPaddingInfo(): any;

        /**
         * Gets a property of this object. Also tracks the current layout as dependent on this
         * property so that changes to it will trigger the layout to be recalculated.
         * @param {String} propName The property name that blocked the layout (e.g., 'width').
         * @return {Object} The property value or undefined if not yet set.
         */
        getProp(propName: string): any;

        /**
         * Returns a style for this item. Each style is read from the DOM only once on first
         * request and is then cached. If the value is an integer, it is parsed automatically
         * (so '5px' is not returned, but rather 5).
         *
         * @param {String} styleName The CSS style name.
         * @return {Object} The value of the DOM style (parsed as necessary).
         */
        getStyle(styleName: string): any;

        /**
         * Returns styles for this item. Each style is read from the DOM only once on first
         * request and is then cached. If the value is an integer, it is parsed automatically
         * (so '5px' is not returned, but rather 5).
         *
         * @param {String[]} styleNames The CSS style names.
         * @param {String[]} [altNames] The alternate names for the returned styles. If given,
         * these names must correspond one-for-one to the 'styleNames'.
         * @return {Object} The values of the DOM styles (parsed as necessary).
         */
        getStyles(styleNames: string, altNames?: string): any;

        /**
         * Returns true if the given property is correct in the DOM. This is equivalent to
         * calling {@link #getDomProp} and not getting an undefined result. In particular,
         * this call registers the current layout to be triggered by flushes of this property.
         *
         * @param {String} propName The property name (e.g., 'width').
         * @return {Boolean}
         */
        hasDomProp(propName: string): boolean;

        /**
         * Returns true if the given property has been set. This is equivalent to calling
         * {@link #getProp} and not getting an undefined result. In particular, this call
         * registers the current layout to be triggered by changes to this property.
         *
         * @param {String} propName The property name (e.g., 'width').
         * @return {Boolean}
         */
        hasProp(propName: string): boolean;

        /**
         * Invalidates the component associated with this item. The layouts for this component
         * and all of its contained items will be re-run after first clearing any computed
         * values.
         *
         * If state needs to be carried forward beyond the invalidation, the 'options' parameter
         * can be used.
         *
         * @param {Object} options An object describing how to handle the invalidation.
         * @param {Object} options.state An object to {@link Ext#apply} to the {@link #state}
         *  of this item after invalidation clears all other properties.
         * @param {Function} options.before A function to call after the context data is cleared
         * and before the {@link Ext.layout.Layout#beginLayoutCycle} methods are called.
         * @param {Ext.layout.ContextItem} options.before.item This ContextItem.
         * @param {Object} options.before.options The options object passed to {@link #invalidate}.
         * @param {Function} options.after A function to call after the context data is cleared
         * and after the {@link Ext.layout.Layout#beginLayoutCycle} methods are called.
         * @param {Ext.layout.ContextItem} options.after.item This ContextItem.
         * @param {Object} options.after.options The options object passed to {@link #invalidate}.
         * @param {Object} options.scope The scope to use when calling the callback functions.
         */
        invalidate(options: any, options_state: any, options_before: Function, options_before_item: Ext.layout.ContextItem, options_before_options: any, options_after: Function, options_after_item: Ext.layout.ContextItem, options_after_options: any, options_scope: any);

        /**
         * Recovers a property value from the last computation and restores its value and
         * dirty state.
         *
         * @param {String} propName The name of the property to recover.
         * @param {Object} oldProps The old "props" object from which to recover values.
         * @param {Object} oldDirty The old "dirty" object from which to recover state.
         */
        recoverProp(propName: string, oldProps: any, oldDirty: any);

        /**
         * Queue the removal of a class name (or array of class names) from this ContextItem's target when next flushed.
         */
        removeCls();

        /**
         * Removes a cached ContextItem that was created using {@link #getEl}.  It may be
         * necessary to call this method if the dom reference for owned element changes so
         * that {@link #getEl} can be called again to reinitialize the ContextItem with the
         * new element.
         * @param {String/Ext.dom.Element} nameOrEl The element or the name of an owned element
         * @param {Ext.layout.container.Container/Ext.Component} [owner] The owner of the
         * named element if the passed "nameOrEl" parameter is a String. Defaults to this
         * ContextItem's "target" property.
         */
        removeEl(nameOrEl: string|Ext.dom.Element, owner?: Ext.layout.container.Container|Ext.Component);

        /**
         * Queue the setting of a DOM attribute on this ContextItem's target when next flushed.
         */
        setAttribute();

        /**
         * Sets the contentHeight property. If the component uses raw content, then only the
         * measured height is acceptable.
         *
         * Calculated values can sometimes be NaN or undefined, which generally mean the
         * calculation is not done. To indicate that such as value was passed, 0 is returned.
         * Otherwise, 1 is returned.
         *
         * If the caller is not measuring (i.e., they are calculating) and the component has raw
         * content, 1 is returned indicating that the caller is done.
         */
        setContentHeight();

        /**
         * Sets the contentWidth and contentHeight properties. If the component uses raw content,
         * then only the measured values are acceptable.
         *
         * Calculated values can sometimes be NaN or undefined, which generally means that the
         * calculation is not done. To indicate that either passed value was such a value, false
         * returned. Otherwise, true is returned.
         *
         * If the caller is not measuring (i.e., they are calculating) and the component has raw
         * content, true is returned indicating that the caller is done.
         */
        setContentSize();

        /**
         * Sets the contentWidth property. If the component uses raw content, then only the
         * measured width is acceptable.
         *
         * Calculated values can sometimes be NaN or undefined, which generally means that the
         * calculation is not done. To indicate that such as value was passed, 0 is returned.
         * Otherwise, 1 is returned.
         *
         * If the caller is not measuring (i.e., they are calculating) and the component has raw
         * content, 1 is returned indicating that the caller is done.
         */
        setContentWidth();

        /**
         * Sets the height and constrains the height to min/maxHeight range.
         *
         * @param {Number} height The height.
         * @param {Boolean} [dirty=true] Specifies if the value is currently in the DOM. A
         * value of 'false' indicates that the value is already in the DOM.
         * @return {Number} The actual height after constraining.
         */
        setHeight(height: number, dirty?: boolean): number;

        /**
         * Sets a property value. This will unblock and/or trigger dependent layouts if the
         * property value is being changed. Values of NaN and undefined are not accepted by
         * this method.
         *
         * @param {String} propName The property name (e.g., 'width').
         * @param {Object} value The new value of the property.
         * @param {Boolean} dirty Optionally specifies if the value is currently in the DOM
         *  (default is 'true' which indicates the value is not in the DOM and must be flushed
         *  at some point).
         * @return {Number} 1 if this call specified the property value, 0 if not.
         */
        setProp(propName: string, value: any, dirty: boolean): number;

        /**
         * Sets the height and constrains the width to min/maxWidth range.
         *
         * @param {Number} width The width.
         * @param {Boolean} [dirty=true] Specifies if the value is currently in the DOM. A
         * value of 'false' indicates that the value is already in the DOM.
         * @return {Number} The actual width after constraining.
         */
        setWidth(width: number, dirty?: boolean): number;
    }

    /**
     * This class is the base for all layout types: component and container.
     */
    export class Layout extends Ext.Base {
        /**
         * Used only during a layout run, this value indicates that a
         * layout has finished its calculations. This flag is set to true prior to the call to
         * {@link #calculate} and should be set to false if this layout has more work to do.
         */
        done: boolean;

        /**
         * 'true' in this class to identify an object as an instantiated Layout, or subclass thereof.
         * @readonly
         */
        isLayout: boolean;

        /**
         * Removes layout's itemCls and owning Container's itemCls.
         * Clears the managed dimensions flags
         */
        protected afterRemove();

        /**
         * Called before any calculation cycles to prepare for layout.
         *
         * This is a write phase and DOM reads should be strictly avoided when overridding
         * this method.
         *
         * @param {Ext.layout.ContextItem} ownerContext The context item for the layout's owner
         * component.
         */
        beginLayout(ownerContext: Ext.layout.ContextItem);

        /**
         * Called before any calculation cycles to reset DOM values and prepare for calculation.
         *
         * This is a write phase and DOM reads should be strictly avoided when overridding
         * this method.
         *
         * @param {Ext.layout.ContextItem} ownerContext The context item for the layout's owner
         * component.
         */
        beginLayoutCycle(ownerContext: Ext.layout.ContextItem);

        /**
         * Called to perform the calculations for this layout. This method will be called at
         * least once and may be called repeatedly if the {@link #done} property is cleared
         * before return to indicate that this layout is not yet done. The {@link #done} property
         * is always set to 'true' before entering this method.
         *
         * This is a read phase and DOM writes should be strictly avoided in derived classes.
         * Instead, DOM writes need to be written to {@link Ext.layout.ContextItem} objects to
         *  be flushed at the next opportunity.
         *
         * @param {Ext.layout.ContextItem} ownerContext The context item for the layout's owner
         * component.
         * @abstract
         */
        calculate(ownerContext: Ext.layout.ContextItem);

        /**
         * This method (if implemented) is called at the end of the cycle in which this layout
         * completes (by not setting {@link #done} to 'false' in {@link #calculate}). It is
         * possible for the layout to complete and yet become invalid before the end of the cycle,
         * in which case, this method will not be called. It is also possible for this method to
         * be called and then later the layout becomes invalidated. This will result in
         * {@link #calculate} being called again, followed by another call to this method.
         *
         * This is a read phase and DOM writes should be strictly avoided in derived classes.
         * Instead, DOM writes need to be written to {@link Ext.layout.ContextItem} objects to
         * be flushed at the next opportunity.
         *
         * This method need not be implemented by derived classes and, in fact, should only be
         * implemented when needed.
         *
         * @param {Ext.layout.ContextItem} ownerContext The context item for the layout's owner
         * component.
         */
        completeLayout(ownerContext: Ext.layout.ContextItem);

        /**
         * Called before an item is rendered to allow the layout to configure the item.
         * @param {Ext.Component} item The item to be configured
         */
        protected configureItem(item: Ext.Component);

        constructor(config: Ext.grid.ColumnComponentLayoutConfig);

        /**
         * Destroys this layout. This method removes a 'targetCls' from the 'target'
         * element and calls 'onDestroy'.
         *
         * A derived class can override either this method or 'onDestroy' but in all
         * cases must call the base class versions of these methods to allow the base class to
         * perform its cleanup.
         *
         * This method (or 'onDestroy') are overridden by subclasses most often to purge
         * event handlers or remove unmanged DOM nodes.
         */
        protected destroy();

        /**
         * This method (if implemented) is called after all layouts have completed. In most
         * ways this is similar to {@link #completeLayout}. This call can cause this (or any
         * layout) to be become invalid (see {@link Ext.layout.Context#invalidate}), but this
         * is best avoided. This method is intended to be where final reads are made and so it
         * is best to avoid invalidating layouts at this point whenever possible. Even so, this
         * method can be used to perform final checks that may require all other layouts to be
         * complete and then invalidate some results.
         *
         * This is a read phase and DOM writes should be strictly avoided in derived classes.
         * Instead, DOM writes need to be written to {@link Ext.layout.ContextItem} objects to
         * be flushed at the next opportunity.
         *
         * This method need not be implemented by derived classes and, in fact, should only be
         * implemented when needed.
         *
         * @param {Ext.layout.ContextItem} ownerContext The context item for the layout's owner
         * component.
         */
        finalizeLayout(ownerContext: Ext.layout.ContextItem);

        /**
         * This method is called after all layouts are complete and their calculations flushed
         * to the DOM. No further layouts will be run and this method is only called once per
         * layout run. The base component layout caches 'lastComponentSize'.
         *
         * This is a write phase and DOM reads should be avoided if possible when overridding
         * this method.
         *
         * This method need not be implemented by derived classes and, in fact, should only be
         * implemented when needed.
         *
         * @param {Ext.layout.ContextItem} ownerContext The context item for the layout's owner
         * component.
         */
        finishedLayout(ownerContext: Ext.layout.ContextItem);

        /**
         * Returns an object describing how this layout manages the size of the given component.
         * This method must be implemented by any layout that manages components.
         *
         * @return {Ext.layout.SizePolicy} An object describing the sizing done by the layout
         * for this item.
         */
        protected getItemSizePolicy(item: Ext.Component): Ext.layout.SizePolicy;

        /**
         * Returns the set of items to layout (empty by default).
         */
        protected getLayoutItems();

        /**
         * A one-time initialization method called just before rendering.
         */
        protected initLayout();

        /**
         * Validates item is in the proper place in the dom.
         */
        protected isValidParent();

        /**
         * This method (if implemented) is called after all layouts are finished, and all have
         * a 'lastComponentSize' cached. No further layouts will be run and this method is only
         * called once per layout run. It is the bookend to {@link #beginLayout}.
         *
         * This is a write phase and DOM reads should be avoided if possible when overridding
         * this method. This is the catch-all tail method to a layout and so the rules are more
         * relaxed. Even so, for performance reasons, it is best to avoid reading the DOM. If
         * a read is necessary, consider implementing a {@link #finalizeLayout} method to do the
         * required reads.
         *
         * This method need not be implemented by derived classes and, in fact, should only be
         * implemented when needed.
         *
         * @param {Ext.layout.ContextItem} ownerContext The context item for the layout's owner
         * component.
         */
        notifyOwner(ownerContext: Ext.layout.ContextItem);

        /**
         * This method is called when a child item changes in some way. By default this calls
         * {@link Ext.AbstractComponent#updateLayout} on this layout's owner.
         *
         * @param {Ext.Component} child The child item that has changed.
         * @return {Boolean} True if this layout has handled the content change.
         */
        onContentChange(child: Ext.Component): boolean;

        /**
         * Iterates over all passed items, ensuring they are rendered.  If the items are already rendered,
         * also determines if the items are in the proper place in the dom.
         */
        protected renderItems();
    }

    /**
     * This class describes a size determination strategy or algorithm used by the layout
     * system. There are special instances of this class stored as static properties to
     * avoid needless object instantiation. These instances should be treated as readonly.
     *
     *  * 'calculated'
     *  * 'configured'
     *  * 'constrainedMax'
     *  * 'constrainedMin'
     *  * 'natural'
     *  * 'shrinkWrap'
     *  * 'calculatedFromConfigured'
     *  * 'calculatedFromNatural'
     *  * 'calculatedFromShrinkWrap'
     *
     * Using one of these instances is simply:
     *
     *       var calculated = Ext.layout.SizeModel.calculated;
     */
    export class SizeModel extends Ext.Base {
        /**
         * True if the size is either 'natural' or 'shrinkWrap', otherwise false.
         * @readonly
         */
        auto: boolean;

        /**
         * True if the size is calculated by the 'ownerLayout'.
         * @readonly
         */
        calculated: boolean;

        /**
         * True if the size is calculated by the 'ownerLayout' based on a configured size.
         * @readonly
         */
        calculatedFromConfigured: boolean;

        /**
         * True if the size is calculated by the 'ownerLayout' based on 'natural' size model
         * results.
         * @readonly
         */
        calculatedFromNatural: boolean;

        /**
         * True if the size is calculated by the 'ownerLayout' based on 'shrinkWrap' size model
         * results.
         * @readonly
         */
        calculatedFromShrinkWrap: boolean;

        /**
         * True if the size is configured (e.g., by a 'width' or 'minWidth'). The names of
         * configuration properties can be found in the {@link #names} property.
         * @readonly
         */
        configured: boolean;

        /**
         * True if the size is constrained by a 'maxWidth' or 'maxHeight' configuration. This
         * is a flavor of 'configured' (since 'maxWidth' and 'maxHeight' are config options).
         * If true, the {@link #names} property will be defined as well.
         * @readonly
         */
        constrainedMax: boolean;

        /**
         * True if the size is constrained by a 'minWidth' or 'minHeight' configuration. This
         * is a flavor of 'configured' (since 'minWidth' and 'minHeight' are config options).
         * If true, the {@link #names} property will be defined as well.
         * @readonly
         */
        constrainedMin: boolean;

        /**
         * True if the size is either 'calculated' or 'configured', otherwise false.
         * @readonly
         */
        fixed: boolean;

        /**
         * The name of this size model (e.g., "calculated").
         * @readonly
         */
        name: string;

        /**
         * An object with the config property names that determine the
         * size.
         * The width property name (e.g., 'width').
         * The height property name (e.g., 'minHeight').
         * @readonly
         */
        names: any;

        /**
         * True if the size is determined by CSS and not by content. Such sizes are assumed to
         * be dependent on the container box and measurement occurs on the outer-most element.
         * @readonly
         */
        natural: boolean;

        /**
         * The 0-based ordinal for this 'SizeModel' instance.
         * @readonly
         */
        ordinal: number;

        /**
         * An array of objects indexed by the {@link #ordinal} of a height 'SizeModel' on
         * a width 'SizeModel' to yield an object describing both height and width size
         * models.
         *
         * Used like this:
         *
         *      widthModel.pairsByHeightOrdinal[heightModel.ordinal]
         *
         * This provides a reusable object equivalent to the following:
         *
         *      {
         *          width: widthModel,
         *          height: heightModel
         *      }
         *
         * The 'SizeModel' for
         * the width.
         * The 'SizeModel' for
         * the height.
         */
        pairsByHeightOrdinal: any;

        /**
         * True if the size is determined by content irrespective of the container box.
         * @readonly
         */
        shrinkWrap: boolean;

        constructor(config: any);
    }

    /**
     * This class describes how a layout will interact with a component it manages.
     *
     * There are special instances of this class stored as static properties to avoid object
     * instantiation. All instances of this class should be treated as readonly objects.
     */
    export class SizePolicy {
        /**
         * Indicates that the 'height' of the component is consumed.
         * @readonly
         */
        readsHeight: boolean;

        /**
         * Indicates that the 'width' of the component is consumed.
         * @readonly
         */
        readsWidth: boolean;

        /**
         * Indicates that the 'height' of the component will be set (i.e., calculated).
         * @readonly
         */
        setsHeight: boolean;

        /**
         * Indicates that the 'width' of the component will be set (i.e., calculated).
         * @readonly
         */
        setsWidth: boolean;
    }
}

declare module Ext.layout.component {
    interface AutoConfig {
    }

    /**
     * The class is the default component layout for {@link Ext.Component} when no explicit
     * '{@link Ext.Component#componentLayout componentLayout}' is configured.
     *
     * This class uses template methods to perform the individual aspects of measurement,
     * calculation and publication of results. The methods called depend on the component's
     * {@link Ext.AbstractComponent#getSizeModel size model}.
     *
     * ## configured / calculated
     *
     * In either of these size models, the dimension of the outer element is of a known size.
     * The size is found in the 'ownerContext' (the {@link Ext.layout.ContextItem} for the owner
     * component) as either "width" or "height". This value, if available, is passed to the
     * 'publishInnerWidth' or 'publishInnerHeight' method, respectively.
     *
     * ## shrinkWrap
     *
     * When a dimension uses the 'shrinkWrap' size model, that means the content is measured,
     * then the outer (owner) size is calculated and published.
     *
     * For example, for a shrinkWrap width, the following sequence of calls are made:
     *
     * - 'Ext.layout.component.Component#measureContentWidth'
     * - 'publishOwnerWidth'
     *    - 'calculateOwnerWidthFromContentWidth'
     *    - 'publishInnerWidth' (in the event of hitting a min/maxWidth constraint)
     *
     * ## natural
     *
     * When a dimension uses the 'natural' size model, the measurement is made on the outer
     * (owner) element. This size is then used to determine the content area in much the same
     * way as if the outer element had a 'configured' or 'calculated' size model.
     *
     * - 'Ext.layout.component.Component#measureOwnerWidth'
     * - 'publishInnerWidth'
     */
    export class Auto extends Ext.layout.component.Component implements Ext.layout.component.AutoConfig {
        /**
         * When publishing height of an auto Component, it is usually not written to the DOM.
         * Setting this to 'true' overrides this behaviour.
         *
         * Optional, Defaults to: false
         */
        protected setHeightInDom: boolean;

        /**
         * When publishing width of an auto Component, it is usually not written to the DOM.
         * Setting this to 'true' overrides this behaviour.
         *
         * Optional, Defaults to: false
         */
        protected setWidthInDom: boolean;

        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * Component layout for components which maintain an inner body element which must be resized to synchronize with the
     * Component size.
     */
    export class Body extends Ext.layout.component.Auto {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * Component layout for {@link Ext.view.BoundList}.
     */
    export class BoundList extends Ext.layout.component.Auto {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);

        protected getLayoutItems();

        protected isValidParent();
    }

    /**
     * Component layout for buttons
     */
    export class Button extends Ext.layout.component.Auto {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * This class is intended to be extended or created via the {@link Ext.Component#componentLayout layout}
     * configuration property.  See {@link Ext.Component#componentLayout} for additional details.
     */
    export class Component extends Ext.layout.Layout {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);

        /**
         * Returns the element into which rendering must take place. Defaults to the owner Component's encapsulating element.
         *
         * May be overridden in Component layout managers which implement an inner element.
         * @return {Ext.Element}
         */
        getRenderTarget(): Ext.dom.Element;

        /**
         * Returns the owner component's resize element.
         * @return {Ext.Element}
         */
        getTarget(): Ext.dom.Element;
    }

    /**
     * This ComponentLayout handles docking for Panels. It takes care of panels that are
     * part of a ContainerLayout that sets this Panel's size and Panels that are part of
     * an AutoContainerLayout in which this panel get his height based of the CSS or
     * or its content.
     */
    export class Dock extends Ext.layout.component.Component {
        /**
         * We are overriding the Ext.layout.Layout configureItem method to also add a class that
         * indicates the position of the docked item. We use the itemCls (x-docked) as a prefix.
         * An example of a class added to a dock: right item is x-docked-right
         * @param {Ext.Component} item The item we are configuring
         */
        protected configureItem(item: Ext.Component);

        constructor(config: Ext.grid.ColumnComponentLayoutConfig);

        /**
         * Retrieve an ordered and/or filtered array of all docked Components.
         * @param {String} [order='render'] The desired ordering of the items ('render' or 'visual').
         * @param {Boolean} [beforeBody] An optional flag to limit the set of items to only those
         *  before the body (true) or after the body (false). All components are returned by
         *  default.
         * @return {Ext.Component[]} An array of components.
         */
        protected getDockedItems(order?: string, beforeBody?: boolean): Ext.Component;

        /**
         * The default weighting of docked items produces this arrangement:
         *
         *      +--------------------------------------------+
         *      |                    Top 1                   |
         *      +--------------------------------------------+
         *      |                    Top 2                   |
         *      +-----+-----+--------------------+-----+-----+
         *      |     |     |                    |     |     |
         *      |     |     |                    |     |     |
         *      |     |     |                    |  R  |  R  |
         *      |  L  |  L  |                    |  I  |  I  |
         *      |  E  |  E  |                    |  G  |  G  |
         *      |  F  |  F  |                    |  H  |  H  |
         *      |  T  |  T  |                    |  T  |  T  |
         *      |     |     |                    |     |     |
         *      |  2  |  1  |                    |  1  |  2  |
         *      |     |     |                    |     |     |
         *      |     |     |                    |     |     |
         *      +-----+-----+--------------------+-----+-----+
         *      |                  Bottom 1                  |
         *      +--------------------------------------------+
         *      |                  Bottom 2                  |
         *      +--------------------------------------------+
         *
         * So when we are shrinkWrapDock on the horizontal, the stretch size for top/bottom
         * docked items is the final axis size. For the vertical axis, however, the stretch
         */
        invalidateAxes();

        /**
         * Render the top and left docked items before any existing DOM nodes in our render target,
         * and then render the right and bottom docked items after. This is important, for such things
         * as tab stops and ARIA readers, that the DOM nodes are in a meaningful order.
         * Our collection of docked items will already be ordered via Panel.getDockedItems().
         */
        protected renderItems();
    }

    interface DrawConfig extends Ext.layout.component.AutoConfig {
    }

    export class Draw extends Ext.layout.component.Auto implements Ext.layout.component.DrawConfig {
        protected setHeightInDom: boolean;

        protected setWidthInDom: boolean;

        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * Component layout for Ext.form.FieldSet components
     */
    export class FieldSet extends Ext.layout.component.Body {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);

        protected getLayoutItems();
    }

    export class ProgressBar extends Ext.layout.component.Auto {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }
}

declare module Ext.layout.component.field {
    /**
     * Layout class for {@link Ext.form.field.ComboBox} fields. Handles sizing the input field.
     */
    export class ComboBox extends Ext.layout.component.field.Trigger {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * Layout class for components with {@link Ext.form.Labelable field labeling}, handling the sizing and alignment of
     * the form control, label, and error message treatment.
     */
    export class Field extends Ext.layout.component.Auto {
        /**
         * Error message displayed as content of an element with a given id elsewhere in the app
         */
        elementId: any;

        /**
         * Collection of named strategies for laying out and adjusting insets to accommodate error messages.
         * An appropriate one will be chosen based on the owner field's {@link Ext.form.Labelable#msgTarget} config.
         */
        errorStrategies: any;

        /**
         * Collection of named strategies for laying out and adjusting labels to accommodate error messages.
         * An appropriate one will be chosen based on the owner field's {@link Ext.form.Labelable#labelAlign} config.
         */
        labelStrategies: any;

        /**
         * Label displayed to the left of the bodyEl
         */
        left: any;

        /**
         * Error displayed as QuickTip on hover of the field container
         */
        qtip: any;

        /**
         * Same as left, only difference is text-align in CSS
         */
        right: any;

        /**
         * Error displayed as icon (with QuickTip on hover) to right of the bodyEl
         */
        side: any;

        /**
         * Error displayed as title tip on hover of the field container
         */
        title: any;

        /**
         * Label displayed above the bodyEl
         */
        top: any;

        /**
         * Error message displayed underneath the bodyEl
         */
        under: any;

        constructor(config: Ext.grid.ColumnComponentLayoutConfig);

        /**
         * Return the set of strategy functions from the {@link #errorStrategies errorStrategies collection}
         * that is appropriate for the field's {@link Ext.form.Labelable#msgTarget msgTarget} config.
         */
        getErrorStrategy();

        /**
         * Return the set of strategy functions from the {@link #labelStrategies labelStrategies collection}
         * that is appropriate for the field's {@link Ext.form.Labelable#labelAlign labelAlign} config.
         */
        getLabelStrategy();

        /**
         * Destroy the error tip instance.
         */
        static destroyTip();

        /**
         * Use a custom QuickTip instance separate from the main QuickTips singleton, so that we
         * can give it a custom frame style. Responds to errorqtip rather than the qtip property.
         */
        static initTip();
    }

    export class FieldContainer extends Ext.layout.component.field.Field {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * Layout class for {@link Ext.form.field.HtmlEditor} fields. Sizes textarea and iframe elements.
     */
    export class HtmlEditor extends Ext.layout.component.field.FieldContainer {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    export class Slider extends Ext.layout.component.field.Field {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * Layout class for {@link Ext.form.field.Text} fields. Handles sizing the input field.
     */
    export class Text extends Ext.layout.component.field.Field {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * Layout class for {@link Ext.form.field.TextArea} fields. Handles sizing the textarea field.
     */
    export class TextArea extends Ext.layout.component.field.Text {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    /**
     * Layout class for {@link Ext.form.field.Trigger} fields. Adjusts the input field size to accommodate
     * the trigger button(s).
     */
    export class Trigger extends Ext.layout.component.field.Field {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }
}

declare module Ext.layout.container {
    interface AbsoluteConfig extends Ext.layout.container.AnchorConfig {
        /**
         * True indicates that changes to one item in this layout do not effect the layout in
         * general. This may need to be set to false if {@link Ext.Component#autoScroll}
         * is enabled for the container.
         */
        ignoreOnContentChange?: boolean;

        itemCls?: any;
    }

    /**
     * This is a layout that inherits the anchoring of {@link Ext.layout.container.Anchor} and adds the
     * ability for x/y positioning using the standard x and y component config options.
     *
     * This class is intended to be extended or created via the {@link Ext.container.Container#layout layout}
     * configuration property.  See {@link Ext.container.Container#layout} for additional details.
     *
     *     @example
     *     Ext.create('Ext.form.Panel', {
     *         title: 'Absolute Layout',
     *         width: 300,
     *         height: 275,
     *         layout: {
     *             type: 'absolute'
     *             // layout-specific configs go here
     *             //itemCls: 'x-abs-layout-item',
     *         },
     *         url:'save-form.php',
     *         defaultType: 'textfield',
     *         items: [{
     *             x: 10,
     *             y: 10,
     *             xtype:'label',
     *             text: 'Send To:'
     *         },{
     *             x: 80,
     *             y: 10,
     *             name: 'to',
     *             anchor:'90%'  // anchor width by percentage
     *         },{
     *             x: 10,
     *             y: 40,
     *             xtype:'label',
     *             text: 'Subject:'
     *         },{
     *             x: 80,
     *             y: 40,
     *             name: 'subject',
     *             anchor: '90%'  // anchor width by percentage
     *         },{
     *             x:0,
     *             y: 80,
     *             xtype: 'textareafield',
     *             name: 'msg',
     *             anchor: '100% 100%'  // anchor width and height
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Absolute extends Ext.layout.container.Anchor implements Ext.layout.container.AbsoluteConfig {
        /**
         * True indicates that changes to one item in this layout do not effect the layout in
         * general. This may need to be set to false if {@link Ext.Component#autoScroll}
         * is enabled for the container.
         */
        ignoreOnContentChange: boolean;

        itemCls: string;

        constructor();
    }

    interface AccordionConfig extends Ext.layout.container.VBoxConfig {
        /**
         * Only valid when {@link #multi} is 'false' and {@link #animate} is 'false'.
         *
         * True to swap the position of each panel as it is expanded so that it becomes the first item in the container,
         * false to keep the panels in the rendered order.
         */
        activeOnTop?: boolean;

        align?: any;

        /**
         * True to slide the contained panels open and closed during expand/collapse using animation, false to open and
         * close directly with no animation. Note: The layout performs animated collapsing
         * and expanding, *not* the child Panels.
         */
        animate?: boolean;

        /**
         * Child Panels have their width actively managed to fit within the accordion's width.
         * @removed This config is ignored in ExtJS 4
         */
        autoWidth?: boolean;

        /**
         * True to make sure the collapse/expand toggle button always renders first (to the left of) any other tools
         * in the contained Panels' title bars, false to render it last. By default, this will use the
         * {@link Ext.panel.Panel#collapseFirst} setting on the panel. If the config option is specified on the layout,
         * it will override the panel value.
         */
        collapseFirst?: boolean;

        /**
         * True to adjust the active item's height to fill the available space in the container, false to use the
         * item's current height, or auto height if not explicitly set.
         */
        fill?: boolean;

        /**
         * True to hide the contained Panels' collapse/expand toggle buttons, false to display them.
         * When set to true, {@link #titleCollapse} is automatically set to true.
         */
        hideCollapseTool?: boolean;

        itemCls?: any;

        /**
         * Set to true to enable multiple accordion items to be open at once.
         */
        multi?: boolean;

        /**
         * True to allow expand/collapse of each contained panel by clicking anywhere on the title bar, false to allow
         * expand/collapse only when the toggle tool button is clicked.  When set to false,
         * {@link #hideCollapseTool} should be false also. An explicit {@link Ext.panel.Panel#titleCollapse} declared
         * on the panel will override this setting.
         */
        titleCollapse?: boolean;
    }

    /**
     * This is a layout that manages multiple Panels in an expandable accordion style such that by default only
     * one Panel can be expanded at any given time (set {@link #multi} config to have more open). Each Panel has
     * built-in support for expanding and collapsing.
     *
     * Note: Only Ext Panels and all subclasses of Ext.panel.Panel may be used in an accordion layout Container.
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Accordion Layout',
     *         width: 300,
     *         height: 300,
     *         defaults: {
     *             // applied to each contained panel
     *             bodyStyle: 'padding:15px'
     *         },
     *         layout: {
     *             // layout-specific configs go here
     *             type: 'accordion',
     *             titleCollapse: false,
     *             animate: true,
     *             activeOnTop: true
     *         },
     *         items: [{
     *             title: 'Panel 1',
     *             html: 'Panel content!'
     *         },{
     *             title: 'Panel 2',
     *             html: 'Panel content!'
     *         },{
     *             title: 'Panel 3',
     *             html: 'Panel content!'
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Accordion extends Ext.layout.container.VBox implements Ext.layout.container.AccordionConfig {
        /**
         * Only valid when {@link #multi} is 'false' and {@link #animate} is 'false'.
         *
         * True to swap the position of each panel as it is expanded so that it becomes the first item in the container,
         * false to keep the panels in the rendered order.
         */
        activeOnTop: boolean;

        align: string;

        /**
         * True to slide the contained panels open and closed during expand/collapse using animation, false to open and
         * close directly with no animation. Note: The layout performs animated collapsing
         * and expanding, *not* the child Panels.
         */
        animate: boolean;

        /**
         * Child Panels have their width actively managed to fit within the accordion's width.
         * @removed This config is ignored in ExtJS 4
         */
        autoWidth: boolean;

        /**
         * True to make sure the collapse/expand toggle button always renders first (to the left of) any other tools
         * in the contained Panels' title bars, false to render it last. By default, this will use the
         * {@link Ext.panel.Panel#collapseFirst} setting on the panel. If the config option is specified on the layout,
         * it will override the panel value.
         */
        collapseFirst: boolean;

        /**
         * True to adjust the active item's height to fill the available space in the container, false to use the
         * item's current height, or auto height if not explicitly set.
         */
        fill: boolean;

        /**
         * True to hide the contained Panels' collapse/expand toggle buttons, false to display them.
         * When set to true, {@link #titleCollapse} is automatically set to true.
         */
        hideCollapseTool: boolean;

        itemCls: string;

        /**
         * Set to true to enable multiple accordion items to be open at once.
         */
        multi: boolean;

        /**
         * True to allow expand/collapse of each contained panel by clicking anywhere on the title bar, false to allow
         * expand/collapse only when the toggle tool button is clicked.  When set to false,
         * {@link #hideCollapseTool} should be false also. An explicit {@link Ext.panel.Panel#titleCollapse} declared
         * on the panel will override this setting.
         */
        titleCollapse: boolean;

        constructor();
    }

    interface AnchorConfig extends Ext.layout.container.AutoConfig {
        /**
         * This configuation option is to be applied to **child 'items'** of a container managed by
         * this layout (ie. configured with 'layout:'anchor'').
         *
         * This value is what tells the layout how an item should be anchored to the container. 'items'
         * added to an AnchorLayout accept an anchoring-specific config property of **anchor** which is a string
         * containing two values: the horizontal anchor value and the vertical anchor value (for example, '100% 50%').
         * The following types of anchor values are supported:
         *
         * - **Percentage** : Any value between 1 and 100, expressed as a percentage.
         *
         *   The first anchor is the percentage width that the item should take up within the container, and the
         *   second is the percentage height.  For example:
         *
         *       // two values specified
         *       anchor: '100% 50%' // render item complete width of the container and
         *                          // 1/2 height of the container
         *       // one value specified
         *       anchor: '100%'     // the width value; the height will default to auto
         *
         * - **Offsets** : Any positive or negative integer value.
         *
         *   This is a raw adjustment where the first anchor is the offset from the right edge of the container,
         *   and the second is the offset from the bottom edge. For example:
         *
         *       // two values specified
         *       anchor: '-50 -100' // render item the complete width of the container
         *                          // minus 50 pixels and
         *                          // the complete height minus 100 pixels.
         *       // one value specified
         *       anchor: '-50'      // anchor value is assumed to be the right offset value
         *                          // bottom offset will default to 0
         *
         * - **Sides** : Valid values are 'right' (or 'r') and 'bottom' (or 'b').
         *
         *   Either the container must have a fixed size or an anchorSize config value defined at render time in
         *   order for these to have any effect.
         *
         * - **Mixed** :
         *
         *   Anchor values can also be mixed as needed.  For example, to render the width offset from the container
         *   right edge by 50 pixels and 75% of the container's height use:
         *
         *       anchor:   '-50 75%'
         */
        anchor?: string;

        /**
         * Default anchor for all child **container** items applied if no anchor or specific width is set on the child item.
         */
        defaultAnchor?: string;
    }

    /**
     * This is a layout that enables anchoring of contained elements relative to the container's dimensions.
     * If the container is resized, all anchored items are automatically rerendered according to their
     * '{@link #anchor}' rules.
     *
     * This class is intended to be extended or created via the {@link Ext.container.AbstractContainer#layout layout}: 'anchor'
     * config, and should generally not need to be created directly via the new keyword.
     *
     * AnchorLayout does not have any direct config options (other than inherited ones). By default,
     * AnchorLayout will calculate anchor measurements based on the size of the container itself. However, the
     * container using the AnchorLayout can supply an anchoring-specific config property of 'anchorSize'.
     *
     * If anchorSize is specifed, the layout will use it as a virtual container for the purposes of calculating
     * anchor measurements based on it instead, allowing the container to be sized independently of the anchoring
     * logic if necessary.
     *
     *     @example
     *     Ext.create('Ext.Panel', {
     *         width: 500,
     *         height: 400,
     *         title: "AnchorLayout Panel",
     *         layout: 'anchor',
     *         renderTo: Ext.getBody(),
     *         items: [
     *             {
     *                 xtype: 'panel',
     *                 title: '75% Width and 20% Height',
     *                 anchor: '75% 20%'
     *             },
     *             {
     *                 xtype: 'panel',
     *                 title: 'Offset -300 Width & -200 Height',
     *                 anchor: '-300 -200'
     *             },
     *             {
     *                 xtype: 'panel',
     *                 title: 'Mixed Offset and Percent',
     *                 anchor: '-250 20%'
     *             }
     *         ]
     *     });
     */
    export class Anchor extends Ext.layout.container.Auto implements Ext.layout.container.AnchorConfig {
        manageOverflow: boolean;

        /**
         * This configuation option is to be applied to **child 'items'** of a container managed by
         * this layout (ie. configured with 'layout:'anchor'').
         *
         * This value is what tells the layout how an item should be anchored to the container. 'items'
         * added to an AnchorLayout accept an anchoring-specific config property of **anchor** which is a string
         * containing two values: the horizontal anchor value and the vertical anchor value (for example, '100% 50%').
         * The following types of anchor values are supported:
         *
         * - **Percentage** : Any value between 1 and 100, expressed as a percentage.
         *
         *   The first anchor is the percentage width that the item should take up within the container, and the
         *   second is the percentage height.  For example:
         *
         *       // two values specified
         *       anchor: '100% 50%' // render item complete width of the container and
         *                          // 1/2 height of the container
         *       // one value specified
         *       anchor: '100%'     // the width value; the height will default to auto
         *
         * - **Offsets** : Any positive or negative integer value.
         *
         *   This is a raw adjustment where the first anchor is the offset from the right edge of the container,
         *   and the second is the offset from the bottom edge. For example:
         *
         *       // two values specified
         *       anchor: '-50 -100' // render item the complete width of the container
         *                          // minus 50 pixels and
         *                          // the complete height minus 100 pixels.
         *       // one value specified
         *       anchor: '-50'      // anchor value is assumed to be the right offset value
         *                          // bottom offset will default to 0
         *
         * - **Sides** : Valid values are 'right' (or 'r') and 'bottom' (or 'b').
         *
         *   Either the container must have a fixed size or an anchorSize config value defined at render time in
         *   order for these to have any effect.
         *
         * - **Mixed** :
         *
         *   Anchor values can also be mixed as needed.  For example, to render the width offset from the container
         *   right edge by 50 pixels and 75% of the container's height use:
         *
         *       anchor:   '-50 75%'
         */
        anchor: string;

        /**
         * Default anchor for all child **container** items applied if no anchor or specific width is set on the child item.
         */
        defaultAnchor: string;

        constructor();
    }

    interface AutoConfig extends Ext.layout.container.ContainerConfig {
        /**
         * Set to 'true' to leave space for a vertical scrollbar (if the OS shows space-consuming scrollbars) regardless
         * of whether a scrollbar is needed.
         *
         * This is useful if content height changes during application usage, but you do not want the calculated width
         * of child items to change when a scrollbar appears or disappears. The scrollbar will appear in the reserved space,
         * and the calculated width of child Components will not change.
         *
         *     @example
         *     Ext.define('Employee', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *            {name: 'rating', type: 'int'},
         *            {name: 'salary', type: 'float'},
         *            {name: 'name'}
         *         ]
         *     });
         *
         *     function createFakeData(count) {
         *         var firstNames   = ['Ed', 'Tommy', 'Aaron', 'Abe', 'Jamie', 'Adam', 'Dave', 'David', 'Jay', 'Nicolas', 'Nige'],
         *             lastNames    = ['Spencer', 'Maintz', 'Conran', 'Elias', 'Avins', 'Mishcon', 'Kaneda', 'Davis', 'Robinson', 'Ferrero', 'White'],
         *             ratings      = [1, 2, 3, 4, 5],
         *             salaries     = [100, 400, 900, 1500, 1000000];
         *
         *         var data = [];
         *         for (var i = 0; i < (count || 25); i++) {
         *             var ratingId    = Math.floor(Math.random() * ratings.length),
         *                 salaryId    = Math.floor(Math.random() * salaries.length),
         *                 firstNameId = Math.floor(Math.random() * firstNames.length),
         *                 lastNameId  = Math.floor(Math.random() * lastNames.length),
         *
         *                 rating      = ratings[ratingId],
         *                 salary      = salaries[salaryId],
         *                 name        = Ext.String.format("{0} {1}", firstNames[firstNameId], lastNames[lastNameId]);
         *
         *             data.push({
         *                 rating: rating,
         *                 salary: salary,
         *                 name: name
         *             });
         *         }
         *         store.loadData(data);
         *     }
         *
         *     // create the Data Store
         *     var store = Ext.create('Ext.data.Store', {
         *         id: 'store',
         *         model: 'Employee',
         *         proxy: {
         *             type: 'memory'
         *         }
         *     });
         *     createFakeData(10);
         *
         *     var grid = Ext.create('Ext.grid.Panel', {
         *         title: 'Grid loaded with varying number of records',
         *         anchor: '100%',
         *         store: store,
         *         columns: [{
         *             xtype: 'rownumberer',
         *             width: 40,
         *             sortable: false
         *         },{
         *             text: 'Name',
         *             flex: 1,
         *             sortable: true,
         *             dataIndex: 'name'
         *         },{
         *             text: 'Rating',
         *             width: 125,
         *             sortable: true,
         *             dataIndex: 'rating'
         *         },{
         *             text: 'Salary',
         *             width: 125,
         *             sortable: true,
         *             dataIndex: 'salary',
         *             align: 'right',
         *             renderer: Ext.util.Format.usMoney
         *         }]
         *     });
         *
         *     Ext.create('Ext.panel.Panel', {
         *         renderTo: document.body,
         *         width: 800,
         *         height: 600,
         *         layout: {
         *             type: 'anchor',
         *             reserveScrollbar: true // There will be a gap even when there's no scrollbar
         *         },
         *         autoScroll: true,
         *         items: grid,
         *         tbar: {
         *             defaults: {
         *                 handler: function(b) {
         *                     createFakeData(b.count);
         *                 }
         *             },
         *             items: [{
         *                  text: '10 Items',
         *                  count: 10
         *             },{
         *                  text: '100 Items',
         *                  count: 100
         *             },{
         *                  text: '300 Items',
         *                  count: 300
         *             },{
         *                  text: '1000 Items',
         *                  count: 1000
         *             },{
         *                  text: '5000 Items',
         *                  count: 5000
         *             }]
         *         }
         *     });
         *
         * Optional, Defaults to: false
         */
        reserveScrollbar?: boolean;
    }

    /**
     * The AutoLayout is the default layout manager delegated by {@link Ext.container.Container} to
     * render any child Components when no '{@link Ext.container.Container#layout layout}' is configured into
     * a '{@link Ext.container.Container Container}.' AutoLayout provides only a passthrough of any layout calls
     * to any child containers.
     *
     *     @example
     *     Ext.create('Ext.Panel', {
     *         width: 500,
     *         height: 280,
     *         title: "AutoLayout Panel",
     *         layout: 'auto',
     *         renderTo: document.body,
     *         items: [{
     *             xtype: 'panel',
     *             title: 'Top Inner Panel',
     *             width: '75%',
     *             height: 90
     *         },
     *         {
     *             xtype: 'panel',
     *             title: 'Bottom Inner Panel',
     *             width: '75%',
     *             height: 90
     *         }]
     *     });
     */
    export class Auto extends Ext.layout.container.Container implements Ext.layout.container.AutoConfig {
        /**
         * true to rerun the layout if scrollbars are needed.
         *
         * Optional, Defaults to: false
         */
        manageOverflow: boolean;

        /**
         * indicates that this layout will correct cross browser padding differences when the
         * container has overflow.
         *
         * In some browsers the right and/or bottom padding of a container is lost when
         * the container has overflow.  If managePadding is true the layout will apply the
         * padding to an inner wrapping element instead of the container element that has the
         * overflow so that paddding will be included in the scrollable area.
         * Note: padding will not be managed if it is configured on the container using
         * a style config or css class.  In order to be managed, padding must be added to the
         * container using the appropriate {@link Ext.AbstractComponent#contentPaddingProperty
         * contentPaddingProperty}.  For {@link Ext.panel.Panel Panels} use
         * {@link Ext.panel.AbstractPanel#bodyPadding}, and for
         * {@link Ext.container.Container Containers}, use
         * {@link Ext.AbstractComponent#padding padding}
         *
         * Optional, Defaults to: true
         */
        managePadding: boolean;

        /**
         * Set to 'true' to leave space for a vertical scrollbar (if the OS shows space-consuming scrollbars) regardless
         * of whether a scrollbar is needed.
         *
         * This is useful if content height changes during application usage, but you do not want the calculated width
         * of child items to change when a scrollbar appears or disappears. The scrollbar will appear in the reserved space,
         * and the calculated width of child Components will not change.
         *
         *     @example
         *     Ext.define('Employee', {
         *         extend: 'Ext.data.Model',
         *         fields: [
         *            {name: 'rating', type: 'int'},
         *            {name: 'salary', type: 'float'},
         *            {name: 'name'}
         *         ]
         *     });
         *
         *     function createFakeData(count) {
         *         var firstNames   = ['Ed', 'Tommy', 'Aaron', 'Abe', 'Jamie', 'Adam', 'Dave', 'David', 'Jay', 'Nicolas', 'Nige'],
         *             lastNames    = ['Spencer', 'Maintz', 'Conran', 'Elias', 'Avins', 'Mishcon', 'Kaneda', 'Davis', 'Robinson', 'Ferrero', 'White'],
         *             ratings      = [1, 2, 3, 4, 5],
         *             salaries     = [100, 400, 900, 1500, 1000000];
         *
         *         var data = [];
         *         for (var i = 0; i < (count || 25); i++) {
         *             var ratingId    = Math.floor(Math.random() * ratings.length),
         *                 salaryId    = Math.floor(Math.random() * salaries.length),
         *                 firstNameId = Math.floor(Math.random() * firstNames.length),
         *                 lastNameId  = Math.floor(Math.random() * lastNames.length),
         *
         *                 rating      = ratings[ratingId],
         *                 salary      = salaries[salaryId],
         *                 name        = Ext.String.format("{0} {1}", firstNames[firstNameId], lastNames[lastNameId]);
         *
         *             data.push({
         *                 rating: rating,
         *                 salary: salary,
         *                 name: name
         *             });
         *         }
         *         store.loadData(data);
         *     }
         *
         *     // create the Data Store
         *     var store = Ext.create('Ext.data.Store', {
         *         id: 'store',
         *         model: 'Employee',
         *         proxy: {
         *             type: 'memory'
         *         }
         *     });
         *     createFakeData(10);
         *
         *     var grid = Ext.create('Ext.grid.Panel', {
         *         title: 'Grid loaded with varying number of records',
         *         anchor: '100%',
         *         store: store,
         *         columns: [{
         *             xtype: 'rownumberer',
         *             width: 40,
         *             sortable: false
         *         },{
         *             text: 'Name',
         *             flex: 1,
         *             sortable: true,
         *             dataIndex: 'name'
         *         },{
         *             text: 'Rating',
         *             width: 125,
         *             sortable: true,
         *             dataIndex: 'rating'
         *         },{
         *             text: 'Salary',
         *             width: 125,
         *             sortable: true,
         *             dataIndex: 'salary',
         *             align: 'right',
         *             renderer: Ext.util.Format.usMoney
         *         }]
         *     });
         *
         *     Ext.create('Ext.panel.Panel', {
         *         renderTo: document.body,
         *         width: 800,
         *         height: 600,
         *         layout: {
         *             type: 'anchor',
         *             reserveScrollbar: true // There will be a gap even when there's no scrollbar
         *         },
         *         autoScroll: true,
         *         items: grid,
         *         tbar: {
         *             defaults: {
         *                 handler: function(b) {
         *                     createFakeData(b.count);
         *                 }
         *             },
         *             items: [{
         *                  text: '10 Items',
         *                  count: 10
         *             },{
         *                  text: '100 Items',
         *                  count: 100
         *             },{
         *                  text: '300 Items',
         *                  count: 300
         *             },{
         *                  text: '1000 Items',
         *                  count: 1000
         *             },{
         *                  text: '5000 Items',
         *                  count: 5000
         *             }]
         *         }
         *     });
         *
         * Optional, Defaults to: false
         */
        reserveScrollbar: boolean;

        /**
         * Handles overflow processing for a container.  In addition to the ownerContext
         * passed to the {@link #calculate} method, this method also needs the containerSize
         * (the object returned by {@link #getContainerSize}).
         */
        protected calculateOverflow(ownerContext: Ext.layout.ContextItem);

        constructor();

        /**
         * Returns the container size (that of the target). Only the fixed-sized dimensions can
         * be returned because the shrinkWrap dimensions are based on the contentWidth/Height
         * as determined by the container layout.
         *
         * If the {@link #calculateOverflow} method is used and if {@link #manageOverflow} is
         * true, this will adjust the width/height by the size of scrollbars.
         *
         * @param {Ext.layout.ContextItem} ownerContext The owner's context item.
         * @param {Boolean} [inDom=false] True if the container size must be in the DOM.
         * @return {Object} The size
         * @return {Number} return.width The width
         * @return {Number} return.height The height
         */
        protected getContainerSize(ownerContext: Ext.layout.ContextItem, inDom?: boolean): any;

        /**
         * Returns the overflow-x style of the render target.
         * Note: If overflow is configured on a container using style or css class this method
         * will read the dom the first time it is called. It is therefore preferable for
         * performance reasons to use the autoScroll or overflowX config when horizontal
         * overflow is desired.
         * @return {String}
         */
        protected getOverflowXStyle(ownerContext: Ext.layout.ContextItem): string;

        /**
         * Returns the overflow-y style of the render target.
         * Note: If overflow is configured on a container using style or css class this method
         * will read the dom the first time it is called. It is therefore preferable for
         * performance reasons to use the autoScroll or overflowY config when vertical
         * overflow is desired.
         * @return {String}
         */
        protected getOverflowYStyle(ownerContext: Ext.layout.ContextItem): string;

        protected initLayout();

        /**
         * This method sets the height and/or width of the outerCt/innerCt to adjust for the
         * following browser-specific issues:
         *
         * 1. In IE6 and 7 strict if we are using the shrink wrap template, and the outerCt
         * has a 100% width (because the container is not shrink wrapping width currently),
         * and the target element has a vertical scrollbar, the browser disregards the
         * scrollbar when sizing the width of the outerCt.  This can result in the target
         * element gaining a horizontal scrollbar.  We fix this issue by setting a pixel
         * width on the outerCt
         *
         * 2. In IE quirks when using the "non shrink wrap" template, a long non-breaking word
         * can cause the outerCt's width to expand beyond the width of its container. This
         * behavior is desired if the container has the potential for horizontal overflow,
         * but can cause text to be hidden if the container's overflow is hidden. To prevent
         * this from happening we give the outerCt a fixed width in IE quirks when the
         * container does not have horizontal overflow.
         *
         * 3. In some browsers a percentage-height element ignores the horizontal scrollbar
         * of its parent (see Ext.supports.PercentageHeightOverflowBug).  If the browser is
         * affected by this bug the outerCt needs a pixel height in order to support
         * percentage-height children when not shrink-wrapping height. If the browser is not
         * affected by this bug, a height of 100% is assigned to the outerCt (see
         * beginLayoutCycle).
         *
         * 4. In IE6/7 strict when using the "shrink wrap" template, percentage heights on
         * children do not work unless the innerCt td has a height set.  We can't use height
         * 100% on the innerCt because conent-box sizing will cause any top/bottom padding to
         * be added to the height.  The solution is to set a pixel height on the innerCt.
         
         * 5. IE8 strict mode has a bug with percentage height children.  if the innerCt has
         * a height of 100%, has padding, and has a child item with a percentage height, that
         * child item will be sized as a percentage of the parent's height plus padding height.
         * In other words, a child with height:50% would have its height caclulated thusly:
         * (parentHeight + parentPaddingHeight) * 0.5
         * To fix this, we have to give the innerCt a pixel height.
         *
         * 6. In IE7 strict if we're using the "non shrink wrap" template, and the target
         * element has overflow-y:auto, the outerCt reserves space for the target element's
         * vertical scrollbar even when there is no vertical scrollbar.  This is fixed by
         * setting the targetEl's overflow property to "hidden" and then back to "auto".
         */
        protected setCtSizeIfNeeded(ownerContext: Ext.layout.ContextItem, containerSize: any);
    }

    interface BorderConfig extends Ext.layout.container.ContainerConfig {
        itemCls?: any;

        /**
         * Sets the padding to be applied to all child items managed by this layout.
         *
         * This property can be specified as a string containing space-separated, numeric
         * padding values. The order of the sides associated with each value matches the way
         * CSS processes padding values:
         *
         *  - If there is only one value, it applies to all sides.
         *  - If there are two values, the top and bottom borders are set to the first value
         *    and the right and left are set to the second.
         *  - If there are three values, the top is set to the first value, the left and right
         *    are set to the second, and the bottom is set to the third.
         *  - If there are four values, they apply to the top, right, bottom, and left,
         *    respectively.
         */
        padding?: number|string|any;

        /**
         * The default weights to assign to regions in the border layout. These values are
         * used when a region does not contain a 'weight' property. This object must have
         * properties for all regions ("north", "south", "east" and "west").
         *
         * **IMPORTANT:** Since this is an object, changing its properties will impact ALL
         * instances of Border layout. If this is not desired, provide a replacement object as
         * a config option instead:
         *
         *      layout: {
         *          type: 'border',
         *          regionWeights: {
         *              west: 20,
         *              north: 10,
         *              south: -10,
         *              east: -20
         *          }
         *      }
         *
         * The region with the highest weight is assigned space from the border before other
         * regions. Regions of equal weight are assigned space based on their position in the
         * owner's items list (first come, first served).
         */
        regionWeights?: any;

        /**
         * This configuration option is to be applied to the **child 'items'** managed by this layout.
         * Each region with 'split:true' will get a {@link Ext.resizer.BorderSplitter Splitter} that
         * allows for manual resizing of the container. Except for the 'center' region.
         */
        split?: boolean;

        /**
         * This configuration option is to be applied to the **child 'items'** managed by this layout and
         * is used in conjunction with {@link #split}. By default, when specifying {@link #split}, the region
         * can be dragged to be resized. Set this option to false to show the split bar but prevent resizing.
         *
         * Optional, Defaults to: true
         */
        splitterResize?: boolean;
    }

    /**
     * This is a multi-pane, application-oriented UI layout style that supports multiple nested panels, automatic bars
     * between regions and built-in {@link Ext.panel.Panel#collapsible expanding and collapsing} of regions.
     *
     * This class is intended to be extended or created via the 'layout:'border'' {@link Ext.container.Container#layout}
     * config, and should generally not need to be created directly via the new keyword.
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         width: 500,
     *         height: 300,
     *         title: 'Border Layout',
     *         layout: 'border',
     *         items: [{
     *             title: 'South Region is resizable',
     *             region: 'south',     // position for region
     *             xtype: 'panel',
     *             height: 100,
     *             split: true,         // enable resizing
     *             margins: '0 5 5 5'
     *         },{
     *             // xtype: 'panel' implied by default
     *             title: 'West Region is collapsible',
     *             region:'west',
     *             xtype: 'panel',
     *             margins: '5 0 0 5',
     *             width: 200,
     *             collapsible: true,   // make collapsible
     *             id: 'west-region-container',
     *             layout: 'fit'
     *         },{
     *             title: 'Center Region',
     *             region: 'center',     // center region is required, no width/height specified
     *             xtype: 'panel',
     *             layout: 'fit',
     *             margins: '5 5 0 0'
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     *
     * # Notes
     *
     *   - When using the split option, the layout will automatically insert a {@link Ext.resizer.Splitter}
     *     into the appropriate place. This will modify the underlying
     *     {@link Ext.container.Container#property-items items} collection in the container.
     *
     *   - Any Container using the Border layout **must** have a child item with 'region:'center''.
     *     The child item in the center region will always be resized to fill the remaining space
     *     not used by the other regions in the layout.
     *
     *   - Any child items with a region of 'west' or 'east' may be configured with either an initial
     *     'width', or a {@link Ext.layout.container.Box#flex} value, or an initial percentage width
     *     **string** (Which is simply divided by 100 and used as a flex value).
     *     The 'center' region has a flex value of '1'.
     *
     *   - Any child items with a region of 'north' or 'south' may be configured with either an initial
     *     'height', or a {@link Ext.layout.container.Box#flex} value, or an initial percentage height
     *     **string** (Which is simply divided by 100 and used as a flex value).
     *     The 'center' region has a flex value of '1'.
     *
     *   - **There is no BorderLayout.Region class in ExtJS 4.0+**
     */
    export class Border extends Ext.layout.container.Container implements Ext.layout.container.BorderConfig {
        itemCls: string;

        /**
         * Sets the padding to be applied to all child items managed by this layout.
         *
         * This property can be specified as a string containing space-separated, numeric
         * padding values. The order of the sides associated with each value matches the way
         * CSS processes padding values:
         *
         *  - If there is only one value, it applies to all sides.
         *  - If there are two values, the top and bottom borders are set to the first value
         *    and the right and left are set to the second.
         *  - If there are three values, the top is set to the first value, the left and right
         *    are set to the second, and the bottom is set to the third.
         *  - If there are four values, they apply to the top, right, bottom, and left,
         *    respectively.
         */
        padding: number|string|any;

        /**
         * The default weights to assign to regions in the border layout. These values are
         * used when a region does not contain a 'weight' property. This object must have
         * properties for all regions ("north", "south", "east" and "west").
         *
         * **IMPORTANT:** Since this is an object, changing its properties will impact ALL
         * instances of Border layout. If this is not desired, provide a replacement object as
         * a config option instead:
         *
         *      layout: {
         *          type: 'border',
         *          regionWeights: {
         *              west: 20,
         *              north: 10,
         *              south: -10,
         *              east: -20
         *          }
         *      }
         *
         * The region with the highest weight is assigned space from the border before other
         * regions. Regions of equal weight are assigned space based on their position in the
         * owner's items list (first come, first served).
         */
        regionWeights: any;

        /**
         * This configuration option is to be applied to the **child 'items'** managed by this layout.
         * Each region with 'split:true' will get a {@link Ext.resizer.BorderSplitter Splitter} that
         * allows for manual resizing of the container. Except for the 'center' region.
         */
        split: boolean;

        /**
         * This configuration option is to be applied to the **child 'items'** managed by this layout and
         * is used in conjunction with {@link #split}. By default, when specifying {@link #split}, the region
         * can be dragged to be resized. Set this option to false to show the split bar but prevent resizing.
         *
         * Optional, Defaults to: true
         */
        splitterResize: boolean;

        constructor();
    }

    interface BoxConfig extends Ext.layout.container.ContainerConfig {
        /**
         * If the individual contained items do not have a margins property specified or margin specified via CSS, the
         * default margins from this property will be applied to each item.
         *
         * This property may be specified as an object containing margins to apply in the format:
         *
         *     {
         *         top: (top margin),
         *         right: (right margin),
         *         bottom: (bottom margin),
         *         left: (left margin)
         *     }
         *
         * This property may also be specified as a string containing space-separated, numeric margin values. The order of
         * the sides associated with each value matches the way CSS processes margin values:
         *
         *   - If there is only one value, it applies to all sides.
         *   - If there are two values, the top and bottom borders are set to the first value and the right and left are
         *     set to the second.
         *   - If there are three values, the top is set to the first value, the left and right are set to the second,
         *     and the bottom is set to the third.
         *   - If there are four values, they apply to the top, right, bottom, and left, respectively.
         */
        defaultMargins?: any;

        /**
         * This configuration option is to be applied to **child items** of the container managed by this layout. Each child
         * item with a flex property will be flexed (horizontally in 'hbox', vertically in 'vbox') according to each item's
         * **relative** flex value compared to the sum of all items with a flex value specified. Any child items that have
         * either a 'flex = 0' or 'flex = undefined' will not be 'flexed' (the initial size will not be changed).
         */
        flex?: number;

        itemCls?: any;

        /**
         * Controls how the child items of the container are packed together. Acceptable configuration values for this
         * property are:
         *
         *   - **start** - child items are packed together at **left** (HBox) or **top** (VBox) side of container (*default**)
         *   - **center** - child items are packed together at **mid-width** (HBox) or **mid-height** (VBox) of container
         *   - **end** - child items are packed together at **right** (HBox) or **bottom** (VBox) side of container
         */
        pack?: string;

        /**
         * Sets the padding to be applied to all child items managed by this layout.
         *
         * This property must be specified as a string containing space-separated, numeric padding values. The order of the
         * sides associated with each value matches the way CSS processes padding values:
         *
         *   - If there is only one value, it applies to all sides.
         *   - If there are two values, the top and bottom borders are set to the first value and the right and left are
         *     set to the second.
         *   - If there are three values, the top is set to the first value, the left and right are set to the second,
         *     and the bottom is set to the third.
         *   - If there are four values, they apply to the top, right, bottom, and left, respectively.
         */
        padding?: string;

        /**
         * Allows stretchMax calculation to take into account the max perpendicular size (height for HBox layout and width
         * for VBox layout) of another Box layout when calculating its maximum perpendicular child size.
         *
         * If specified as a string, this may be either a known Container ID, or a ComponentQuery selector which is rooted
         * at this layout's Container (ie, to find a sibling, use '"^>#siblingItemId').
         */
        stretchMaxPartner?: string|Ext.Component;
    }

    /**
     * Base Class for HBoxLayout and VBoxLayout Classes. Generally it should not need to be used directly.
     */
    export class Box extends Ext.layout.container.Container implements Ext.layout.container.BoxConfig {
        /**
         * If the individual contained items do not have a margins property specified or margin specified via CSS, the
         * default margins from this property will be applied to each item.
         *
         * This property may be specified as an object containing margins to apply in the format:
         *
         *     {
         *         top: (top margin),
         *         right: (right margin),
         *         bottom: (bottom margin),
         *         left: (left margin)
         *     }
         *
         * This property may also be specified as a string containing space-separated, numeric margin values. The order of
         * the sides associated with each value matches the way CSS processes margin values:
         *
         *   - If there is only one value, it applies to all sides.
         *   - If there are two values, the top and bottom borders are set to the first value and the right and left are
         *     set to the second.
         *   - If there are three values, the top is set to the first value, the left and right are set to the second,
         *     and the bottom is set to the third.
         *   - If there are four values, they apply to the top, right, bottom, and left, respectively.
         */
        defaultMargins: any;

        /**
         * This configuration option is to be applied to **child items** of the container managed by this layout. Each child
         * item with a flex property will be flexed (horizontally in 'hbox', vertically in 'vbox') according to each item's
         * **relative** flex value compared to the sum of all items with a flex value specified. Any child items that have
         * either a 'flex = 0' or 'flex = undefined' will not be 'flexed' (the initial size will not be changed).
         */
        flex: number;

        itemCls: string;

        /**
         * Controls how the child items of the container are packed together. Acceptable configuration values for this
         * property are:
         *
         *   - **start** - child items are packed together at **left** (HBox) or **top** (VBox) side of container (*default**)
         *   - **center** - child items are packed together at **mid-width** (HBox) or **mid-height** (VBox) of container
         *   - **end** - child items are packed together at **right** (HBox) or **bottom** (VBox) side of container
         */
        pack: string;

        /**
         * Sets the padding to be applied to all child items managed by this layout.
         *
         * This property must be specified as a string containing space-separated, numeric padding values. The order of the
         * sides associated with each value matches the way CSS processes padding values:
         *
         *   - If there is only one value, it applies to all sides.
         *   - If there are two values, the top and bottom borders are set to the first value and the right and left are
         *     set to the second.
         *   - If there are three values, the top is set to the first value, the left and right are set to the second,
         *     and the bottom is set to the third.
         *   - If there are four values, they apply to the top, right, bottom, and left, respectively.
         */
        padding: string;

        /**
         * Allows stretchMax calculation to take into account the max perpendicular size (height for HBox layout and width
         * for VBox layout) of another Box layout when calculating its maximum perpendicular child size.
         *
         * If specified as a string, this may be either a known Container ID, or a ComponentQuery selector which is rooted
         * at this layout's Container (ie, to find a sibling, use '"^>#siblingItemId').
         */
        stretchMaxPartner: string|Ext.Component;

        /**
         * This method is called to (re)cache our understanding of flexes. This happens during beginLayout and may need to
         * be called again if the flexes are changed during the layout (e.g., like ColumnLayout).
         */
        protected cacheFlexes(ownerContext: any);

        constructor(config: Ext.layout.container.BoxConfig);
    }

    interface CardConfig extends Ext.layout.container.FitConfig {
        /**
         * True to render each contained item at the time it becomes active, false to render all contained items
         * as soon as the layout is rendered (defaults to false).  If there is a significant amount of content or
         * a lot of heavy controls being rendered into panels that are not displayed by default, setting this to
         * true might improve performance.
         */
        deferredRender?: boolean;
    }

    /**
     * This layout manages multiple child Components, each fitted to the Container, where only a single child Component can be
     * visible at any given time.  This layout style is most commonly used for wizards, tab implementations, etc.
     * This class is intended to be extended or created via the layout:'card' {@link Ext.container.Container#layout} config,
     * and should generally not need to be created directly via the new keyword.
     *
     * The CardLayout's focal method is {@link #setActiveItem}.  Since only one panel is displayed at a time,
     * the only way to move from one Component to the next is by calling setActiveItem, passing the next panel to display
     * (or its id or index).  The layout itself does not provide a user interface for handling this navigation,
     * so that functionality must be provided by the developer.
     *
     * To change the active card of a container, call the setActiveItem method of its layout:
     *
     *     @example
     *     var p = Ext.create('Ext.panel.Panel', {
     *         layout: 'card',
     *         items: [
     *             { html: 'Card 1' },
     *             { html: 'Card 2' }
     *         ],
     *         renderTo: Ext.getBody()
     *     });
     *
     *     p.getLayout().setActiveItem(1);
     *
     * The {@link Ext.Component#beforedeactivate beforedeactivate} and {@link Ext.Component#beforeactivate beforeactivate}
     * events can be used to prevent a card from activating or deactivating by returning 'false'.
     *
     *     @example
     *     var active = 0;
     *     var main = Ext.create('Ext.panel.Panel', {
     *         renderTo: Ext.getBody(),
     *         width: 200,
     *         height: 200,
     *         layout: 'card',
     *         tbar: [{
     *             text: 'Next',
     *             handler: function(){
     *                 var layout = main.getLayout();
     *                 ++active;
     *                 layout.setActiveItem(active);
     *                 active = main.items.indexOf(layout.getActiveItem());
     *             }
     *         }],
     *         items: [{
     *             title: 'P1'
     *         }, {
     *             title: 'P2'
     *         }, {
     *             title: 'P3',
     *             listeners: {
     *                 beforeactivate: function(){
     *                     return false;
     *                 }
     *             }
     *         }]
     *     });
     *
     * In the following example, a simplistic wizard setup is demonstrated.  A button bar is added
     * to the footer of the containing panel to provide navigation buttons.  The buttons will be handled by a
     * common navigation routine.  Note that other uses of a CardLayout (like a tab control) would require a
     * completely different implementation.  For serious implementations, a better approach would be to extend
     * CardLayout to provide the custom functionality needed.
     *
     *     @example
     *     var navigate = function(panel, direction){
     *         // This routine could contain business logic required to manage the navigation steps.
     *         // It would call setActiveItem as needed, manage navigation button state, handle any
     *         // branching logic that might be required, handle alternate actions like cancellation
     *         // or finalization, etc.  A complete wizard implementation could get pretty
     *         // sophisticated depending on the complexity required, and should probably be
     *         // done as a subclass of CardLayout in a real-world implementation.
     *         var layout = panel.getLayout();
     *         layout[direction]();
     *         Ext.getCmp('move-prev').setDisabled(!layout.getPrev());
     *         Ext.getCmp('move-next').setDisabled(!layout.getNext());
     *     };
     *
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Example Wizard',
     *         width: 300,
     *         height: 200,
     *         layout: 'card',
     *         bodyStyle: 'padding:15px',
     *         defaults: {
     *             // applied to each contained panel
     *             border: false
     *         },
     *         // just an example of one possible navigation scheme, using buttons
     *         bbar: [
     *             {
     *                 id: 'move-prev',
     *                 text: 'Back',
     *                 handler: function(btn) {
     *                     navigate(btn.up("panel"), "prev");
     *                 },
     *                 disabled: true
     *             },
     *             '->', // greedy spacer so that the buttons are aligned to each side
     *             {
     *                 id: 'move-next',
     *                 text: 'Next',
     *                 handler: function(btn) {
     *                     navigate(btn.up("panel"), "next");
     *                 }
     *             }
     *         ],
     *         // the panels (or "cards") within the layout
     *         items: [{
     *             id: 'card-0',
     *             html: '<h1>Welcome to the Wizard!</h1><p>Step 1 of 3</p>'
     *         },{
     *             id: 'card-1',
     *             html: '<p>Step 2 of 3</p>'
     *         },{
     *             id: 'card-2',
     *             html: '<h1>Congratulations!</h1><p>Step 3 of 3 - Complete</p>'
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Card extends Ext.layout.container.Fit implements Ext.layout.container.CardConfig {
        /**
         * True to render each contained item at the time it becomes active, false to render all contained items
         * as soon as the layout is rendered (defaults to false).  If there is a significant amount of content or
         * a lot of heavy controls being rendered into panels that are not displayed by default, setting this to
         * true might improve performance.
         */
        deferredRender: boolean;

        constructor();

        /**
         * Return the active (visible) component in the layout.
         * @returns {Ext.Component}
         */
        getActiveItem();

        /**
         * Return the active (visible) component in the layout to the next card
         * @returns {Ext.Component} The next component or false.
         */
        getNext();

        /**
         * Return the active (visible) component in the layout to the previous card
         * @returns {Ext.Component} The previous component or false.
         */
        getPrev();

        /**
         * Sets the active (visible) component in the layout to the next card
         * @return {Ext.Component} the activated component or false when nothing activated.
         */
        next(): Ext.Component;

        /**
         * Sets the active (visible) component in the layout to the previous card
         * @return {Ext.Component} the activated component or false when nothing activated.
         */
        prev(): Ext.Component;

        /**
         * Makes the given card active.
         *
         *     var card1 = Ext.create('Ext.panel.Panel', {itemId: 'card-1'});
         *     var card2 = Ext.create('Ext.panel.Panel', {itemId: 'card-2'});
         *     var panel = Ext.create('Ext.panel.Panel', {
         *         layout: 'card',
         *         activeItem: 0,
         *         items: [card1, card2]
         *     });
         *     // These are all equivalent
         *     panel.getLayout().setActiveItem(card2);
         *     panel.getLayout().setActiveItem('card-2');
         *     panel.getLayout().setActiveItem(1);
         *
         * @param {Ext.Component/Number/String} newCard  The component, component {@link Ext.Component#id id},
         * {@link Ext.Component#itemId itemId}, or index of component.
         * @return {Ext.Component} the activated component or false when nothing activated.
         * False is returned also when trying to activate an already active card.
         */
        setActiveItem(newCard: Ext.Component|number|string): Ext.Component;
    }

    interface CheckboxGroupConfig extends Ext.layout.container.ContainerConfig {
        /**
         * By default,  CheckboxGroup allocates all available space to the configured columns meaning that
         * column are evenly spaced across the container.
         *
         * To have each column only be wide enough to fit the container Checkboxes (or Radios), set 'autoFlex' to 'false'
         *
         * Optional, Defaults to: true
         */
        autoFlex?: boolean;
    }

    /**
     * This layout implements the column arrangement for {@link Ext.form.CheckboxGroup} and {@link Ext.form.RadioGroup}.
     * It groups the component's sub-items into columns based on the component's
     * {@link Ext.form.CheckboxGroup#columns columns} and {@link Ext.form.CheckboxGroup#vertical} config properties.
     */
    export class CheckboxGroup extends Ext.layout.container.Container implements Ext.layout.container.CheckboxGroupConfig {
        /**
         * By default,  CheckboxGroup allocates all available space to the configured columns meaning that
         * column are evenly spaced across the container.
         *
         * To have each column only be wide enough to fit the container Checkboxes (or Radios), set 'autoFlex' to 'false'
         *
         * Optional, Defaults to: true
         */
        autoFlex: boolean;

        constructor();

        protected initLayout();

        protected isValidParent();

        /**
         * Iterates over all passed items, ensuring they are rendered.  If the items are already rendered,
         * also determines if the items are in the proper place in the dom.
         */
        protected renderItems();
    }

    interface ColumnConfig extends Ext.layout.container.AutoConfig {
        itemCls?: any;
    }

    /**
     * This is the layout style of choice for creating structural layouts in a multi-column format where the width of each
     * column can be specified as a percentage or fixed width, but the height is allowed to vary based on the content. This
     * class is intended to be extended or created via the layout:'column' {@link Ext.container.Container#layout} config,
     * and should generally not need to be created directly via the new keyword.
     *
     * ColumnLayout does not have any direct config options (other than inherited ones), but it does support a specific
     * config property of 'columnWidth' that can be included in the config of any panel added to it. The layout will use
     * the columnWidth (if present) or width of each panel during layout to determine how to size each panel. If width or
     * columnWidth is not specified for a given panel, its width will default to the panel's width (or auto).
     *
     * The width property is always evaluated as pixels, and must be a number greater than or equal to 1. The columnWidth
     * property is always evaluated as a percentage, and must be a decimal value greater than 0 and less than 1 (e.g., .25).
     *
     * The basic rules for specifying column widths are pretty simple. The logic makes two passes through the set of
     * contained panels. During the first layout pass, all panels that either have a fixed width or none specified (auto)
     * are skipped, but their widths are subtracted from the overall container width.
     *
     * During the second pass, all panels with columnWidths are assigned pixel widths in proportion to their percentages
     * based on the total **remaining** container width. In other words, percentage width panels are designed to fill
     * the space left over by all the fixed-width and/or auto-width panels. Because of this, while you can specify any
     * number of columns with different percentages, the columnWidths must always add up to 1 (or 100%) when added
     * together, otherwise your layout may not render as expected.
     *
     *     @example
     *     // All columns are percentages -- they must add up to 1
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Column Layout - Percentage Only',
     *         width: 350,
     *         height: 250,
     *         layout:'column',
     *         items: [{
     *             title: 'Column 1',
     *             columnWidth: 0.25
     *         },{
     *             title: 'Column 2',
     *             columnWidth: 0.55
     *         },{
     *             title: 'Column 3',
     *             columnWidth: 0.20
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     *
     *     // Mix of width and columnWidth -- all columnWidth values must add up
     *     // to 1. The first column will take up exactly 120px, and the last two
     *     // columns will fill the remaining container width.
     *
     *     Ext.create('Ext.Panel', {
     *         title: 'Column Layout - Mixed',
     *         width: 350,
     *         height: 250,
     *         layout:'column',
     *         items: [{
     *             title: 'Column 1',
     *             width: 120
     *         },{
     *             title: 'Column 2',
     *             columnWidth: 0.7
     *         },{
     *             title: 'Column 3',
     *             columnWidth: 0.3
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Column extends Ext.layout.container.Auto implements Ext.layout.container.ColumnConfig {
        manageOverflow: boolean;

        itemCls: string;

        constructor();
    }

    interface ContainerConfig {
        /**
         * An optional extra CSS class that will be added to the container. This can be useful for
         * adding customized styles to the container or any of its children using standard CSS
         * rules. See {@link Ext.Component}.{@link Ext.Component#componentCls componentCls} also.
         */
        itemCls?: string;
    }

    /**
     * This class is intended to be extended or created via the {@link Ext.container.Container#layout layout}
     * configuration property.  See {@link Ext.container.Container#layout} for additional details.
     */
    export class Container extends Ext.layout.Layout implements Ext.layout.container.ContainerConfig {
        /**
         * The element used to correct body padding during overflow.
         */
        overflowPadderEl: Ext.dom.Element;

        /**
         * An optional extra CSS class that will be added to the container. This can be useful for
         * adding customized styles to the container or any of its children using standard CSS
         * rules. See {@link Ext.Component}.{@link Ext.Component#componentCls componentCls} also.
         */
        itemCls: string;

        constructor();

        /**
         * Returns the container size (that of the target). Only the fixed-sized dimensions can
         * be returned because the shrinkWrap dimensions are based on the contentWidth/Height
         * as determined by the container layout.
         *
         * @param {Ext.layout.ContextItem} ownerContext The owner's context item.
         * @param {Boolean} [inDom=false] True if the container size must be in the DOM.
         * @return {Object} The size
         * @return {Number} return.width The width
         * @return {Number} return.height The height
         */
        protected getContainerSize(ownerContext: Ext.layout.ContextItem, inDom?: boolean): any;

        /**
         * Returns the element into which extra functional DOM elements can be inserted. Defaults to the owner Component's encapsulating element.
         *
         * May be overridden in Component layout managers which implement a {@link #getRenderTarget component render target} which must only
         * contain child components.
         * @return {Ext.Element}
         */
        getElementTarget(): Ext.dom.Element;

        /**
         * Returns all items that are rendered
         * @return {Array} All matching items
         */
        protected getRenderedItems(): any[];

        /**
         * Returns the element into which rendering must take place. Defaults to the owner Container's
         * target element.
         *
         * May be overridden in layout managers which implement an inner element.
         *
         * @return {Ext.Element}
         */
        getRenderTarget(): Ext.dom.Element;

        /**
         * Returns the owner component's resize element.
         * @return {Ext.Element}
         */
        getTarget(): Ext.dom.Element;

        /**
         * Returns all items that are both rendered and visible
         * @return {Array} All matching items
         */
        protected getVisibleItems(): any[];
    }

    /**
     * Component layout for editors
     */
    export class Editor extends Ext.layout.container.Container {
        constructor();
    }

    interface FitConfig extends Ext.layout.container.ContainerConfig {
        /**
         * If the individual contained items do not have a margins property specified or margin specified via CSS, the
         * default margins from this property will be applied to each item.
         *
         * This property may be specified as an object containing margins to apply in the format:
         *
         *     {
         *         top: (top margin),
         *         right: (right margin),
         *         bottom: (bottom margin),
         *         left: (left margin)
         *     }
         *
         * This property may also be specified as a string containing space-separated, numeric margin values. The order of
         * the sides associated with each value matches the way CSS processes margin values:
         *
         *   - If there is only one value, it applies to all sides.
         *   - If there are two values, the top and bottom borders are set to the first value and the right and left are
         *     set to the second.
         *   - If there are three values, the top is set to the first value, the left and right are set to the second,
         *     and the bottom is set to the third.
         *   - If there are four values, they apply to the top, right, bottom, and left, respectively.
         */
        defaultMargins?: any;

        itemCls?: any;
    }

    /**
     * This is a base class for layouts that contain a single item that automatically expands to fill the layout's
     * container. This class is intended to be extended or created via the layout:'fit'
     * {@link Ext.container.Container#layout} config, and should generally not need to be created directly via the new keyword.
     *
     * Fit layout does not have any direct config options (other than inherited ones). To fit a panel to a container using
     * Fit layout, simply set 'layout: 'fit'' on the container and add a single panel to it.
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Fit Layout',
     *         width: 300,
     *         height: 150,
     *         layout:'fit',
     *         items: {
     *             title: 'Inner Panel',
     *             html: 'This is the inner panel content',
     *             bodyPadding: 20,
     *             border: false
     *         },
     *         renderTo: Ext.getBody()
     *     });
     *
     * If the container has multiple items, all of the items will all be equally sized. This is usually not
     * desired, so to avoid this, place only a **single** item in the container. This sizing of all items
     * can be used to provide a background {@link Ext.Img image} that is "behind" another item
     * such as a {@link Ext.view.View dataview} if you also absolutely position the items.
     */
    export class Fit extends Ext.layout.container.Container implements Ext.layout.container.FitConfig {
        /**
         * If the individual contained items do not have a margins property specified or margin specified via CSS, the
         * default margins from this property will be applied to each item.
         *
         * This property may be specified as an object containing margins to apply in the format:
         *
         *     {
         *         top: (top margin),
         *         right: (right margin),
         *         bottom: (bottom margin),
         *         left: (left margin)
         *     }
         *
         * This property may also be specified as a string containing space-separated, numeric margin values. The order of
         * the sides associated with each value matches the way CSS processes margin values:
         *
         *   - If there is only one value, it applies to all sides.
         *   - If there are two values, the top and bottom borders are set to the first value and the right and left are
         *     set to the second.
         *   - If there are three values, the top is set to the first value, the left and right are set to the second,
         *     and the bottom is set to the third.
         *   - If there are four values, they apply to the top, right, bottom, and left, respectively.
         */
        defaultMargins: any;

        itemCls: string;

        constructor();
    }

    /**
     * This is a layout that will render form Fields, one under the other all stretched to the Container width.
     *
     *     @example
     *     Ext.create('Ext.Panel', {
     *         width: 500,
     *         height: 300,
     *         title: "FormLayout Panel",
     *         layout: 'form',
     *         renderTo: Ext.getBody(),
     *         bodyPadding: 5,
     *         defaultType: 'textfield',
     *         items: [{
     *            fieldLabel: 'First Name',
     *             name: 'first',
     *             allowBlank:false
     *         },{
     *             fieldLabel: 'Last Name',
     *             name: 'last'
     *         },{
     *             fieldLabel: 'Company',
     *             name: 'company'
     *         }, {
     *             fieldLabel: 'Email',
     *             name: 'email',
     *             vtype:'email'
     *         }, {
     *             fieldLabel: 'DOB',
     *             name: 'dob',
     *             xtype: 'datefield'
     *         }, {
     *             fieldLabel: 'Age',
     *             name: 'age',
     *             xtype: 'numberfield',
     *             minValue: 0,
     *             maxValue: 100
     *         }, {
     *             xtype: 'timefield',
     *             fieldLabel: 'Time',
     *             name: 'time',
     *             minValue: '8:00am',
     *             maxValue: '6:00pm'
     *         }]
     *     });
     *
     * Note that any configured {@link Ext.Component#padding padding} will be ignored on items within a Form layout.
     */
    export class Form extends Ext.layout.container.Container {
        /**
         * Returns flags indicating cross-browser handling of scrollHeight/Width. In particular,
         * IE has issues with padding-bottom in a scrolling element (it does not include that
         * padding in the scrollHeight). Also, margin-bottom on a child in a scrolling element
         * can be lost.
         *
         * All browsers seem to ignore margin-right on children and padding-right on the parent
         * element (the one with the overflow)
         *
         * This method returns a number with the follow bit positions set based on things not
         * accounted for in scrollHeight and scrollWidth:
         *
         *  - 1: Scrolling element's padding-bottom is not included in scrollHeight.
         *  - 2: Last child's margin-bottom is not included in scrollHeight.
         *  - 4: Scrolling element's padding-right is not included in scrollWidth.
         *  - 8: Child's margin-right is not included in scrollWidth.
         *
         * To work around the margin-bottom issue, it is sufficient to create a 0px tall last
         * child that will "hide" the margin. This can also be handled by wrapping the children
         * in an element, again "hiding" the margin. Wrapping the elements is about the only
         * way to preserve their right margins. This is the strategy used by Column layout.
         *
         * To work around the padding-bottom problem, since it is comes from a style on the
         * parent element, about the only simple fix is to create a last child with height
         * equal to padding-bottom. To preserve the right padding, the sizing element needs to
         * have a width that includes the right padding.
         */
        getScrollRangeFlags: any;

        /**
         * Handles overflow processing for a container. This should be called once the layout
         * has determined contentWidth/Height. In addition to the ownerContext passed to the
         * {@link #calculate} method, this method also needs the containerSize (the object
         * returned by {@link #getContainerSize}).
         *
         * @param {Number} dimensions A bit mask for the overflow managed dimensions. The 0-bit
         * is for 'width' and the 1-bit is for 'height'. In other words, a value of 1 would be
         * only 'width', 2 would be only 'height' and 3 would be both.
         */
        calculateOverflow(ownerContext: Ext.layout.ContextItem, containerSize: any, dimensions: number);

        constructor();

        /**
         * Creates an element that makes bottom/right body padding consistent across browsers.
         * This element is sized based on the need for scrollbars in {@link #calculateOverflow}.
         * If the {@link #manageOverflow} option is false, this element is not created.
         *
         * See {@link #getScrollRangeFlags} for more details.
         */
        doRenderPadder();

        /**
         * returns the overflow-x style of the render target
         * @return {String}
         */
        protected getOverflowXStyle(ownerContext: Ext.layout.ContextItem): string;

        /**
         * returns the overflow-y style of the render target
         * @return {String}
         */
        protected getOverflowYStyle(ownerContext: Ext.layout.ContextItem): string;

        protected initLayout();
    }

    interface HBoxConfig extends Ext.layout.container.BoxConfig {
        /**
         * Controls how the child items of the container are aligned. Acceptable configuration values for this property are:
         *
         * - **top** : **Default** child items are aligned vertically at the **top** of the container.
         * - **middle** : child items are aligned vertically in the **middle** of the container.
         * - **bottom** : child items are aligned vertically at the **bottom** of the container.
         * - **stretch** : child items are stretched vertically to fill the height of the container.
         * - **stretchmax** : child items are stretched vertically to the height of the largest item.
         */
        align?: string;

        /**
         * The Math method to use
         * for rounding fractional pixels when '{@link #align}:middle' is used.
         *
         * Optional, Defaults to: 'round'
         */
        alignRoundingMethod?: any;

        /**
         * Limits the size of {@link #align aligned} components to the size of the container under certain circumstances.
         * Firstly, the container height must not be determined by the height of the child components. Secondly, the child
         * components must have their height {@link Ext.AbstractComponent#shrinkWrap shrinkwrapped}.
         */
        constrainAlign?: boolean;
    }

    /**
     * A layout that arranges items horizontally across a Container. This layout optionally divides available horizontal
     * space between child items containing a numeric 'flex' configuration.
     *
     * This layout may also be used to set the heights of child items by configuring it with the {@link #align} option.
     *
     *     @example
     *     Ext.create('Ext.Panel', {
     *         width: 500,
     *         height: 300,
     *         title: "HBoxLayout Panel",
     *         layout: {
     *             type: 'hbox',
     *             align: 'stretch'
     *         },
     *         renderTo: document.body,
     *         items: [{
     *             xtype: 'panel',
     *             title: 'Inner Panel One',
     *             flex: 2
     *         },{
     *             xtype: 'panel',
     *             title: 'Inner Panel Two',
     *             flex: 1
     *         },{
     *             xtype: 'panel',
     *             title: 'Inner Panel Three',
     *             flex: 1
     *         }]
     *     });
     */
    export class HBox extends Ext.layout.container.Box implements Ext.layout.container.HBoxConfig {
        /**
         * Controls how the child items of the container are aligned. Acceptable configuration values for this property are:
         *
         * - **top** : **Default** child items are aligned vertically at the **top** of the container.
         * - **middle** : child items are aligned vertically in the **middle** of the container.
         * - **bottom** : child items are aligned vertically at the **bottom** of the container.
         * - **stretch** : child items are stretched vertically to fill the height of the container.
         * - **stretchmax** : child items are stretched vertically to the height of the largest item.
         */
        align: string;

        /**
         * The Math method to use
         * for rounding fractional pixels when '{@link #align}:middle' is used.
         *
         * Optional, Defaults to: 'round'
         */
        alignRoundingMethod: any;

        /**
         * Limits the size of {@link #align aligned} components to the size of the container under certain circumstances.
         * Firstly, the container height must not be determined by the height of the child components. Secondly, the child
         * components must have their height {@link Ext.AbstractComponent#shrinkWrap shrinkwrapped}.
         */
        constrainAlign: boolean;

        constructor(config: Ext.layout.container.BoxConfig);
    }

    interface TableConfig extends Ext.layout.container.ContainerConfig {
        /**
         * The total number of columns to create in the table for this layout. If not specified, all Components added to
         * this layout will be rendered into a single row using one column per Component.
         */
        columns?: number;

        /**
         * An object containing properties which are added to the {@link Ext.DomHelper DomHelper} specification used to
         * create the layout's '<table>' element. Example:
         *
         *     {
         *         xtype: 'panel',
         *         layout: {
         *             type: 'table',
         *             columns: 3,
         *             tableAttrs: {
         *                 style: {
         *                     width: '100%'
         *                 }
         *             }
         *         }
         *     }
         */
        tableAttrs?: any;

        /**
         * An object containing properties which are added to the {@link Ext.DomHelper DomHelper} specification used to
         * create the layout's '<td>' elements.
         */
        tdAttrs?: any;

        /**
         * An object containing properties which are added to the {@link Ext.DomHelper DomHelper} specification used to
         * create the layout's '<tr>' elements.
         */
        trAttrs?: any;
    }

    /**
     * This layout allows you to easily render content into an HTML table. The total number of columns can be specified, and
     * rowspan and colspan can be used to create complex layouts within the table. This class is intended to be extended or
     * created via the 'layout: {type: 'table'}' {@link Ext.container.Container#layout} config, and should generally not
     * need to be created directly via the new keyword.
     *
     * Note that when creating a layout via config, the layout-specific config properties must be passed in via the {@link
     * Ext.container.Container#layout} object which will then be applied internally to the layout. In the case of
     * TableLayout, the only valid layout config properties are {@link #columns} and {@link #tableAttrs}. However, the items
     * added to a TableLayout can supply the following table-specific config properties:
     *
     *   - **rowspan** Applied to the table cell containing the item.
     *   - **colspan** Applied to the table cell containing the item.
     *   - **cellId** An id applied to the table cell containing the item.
     *   - **cellCls** A CSS class name added to the table cell containing the item.
     *
     * The basic concept of building up a TableLayout is conceptually very similar to building up a standard HTML table. You
     * simply add each panel (or "cell") that you want to include along with any span attributes specified as the special
     * config properties of rowspan and colspan which work exactly like their HTML counterparts. Rather than explicitly
     * creating and nesting rows and columns as you would in HTML, you simply specify the total column count in the
     * layout config and start adding panels in their natural order from left to right, top to bottom. The layout will
     * automatically figure out, based on the column count, rowspans and colspans, how to position each panel within the
     * table. Just like with HTML tables, your rowspans and colspans must add up correctly in your overall layout or you'll
     * end up with missing and/or extra cells! Example usage:
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Table Layout',
     *         width: 300,
     *         height: 150,
     *         layout: {
     *             type: 'table',
     *             // The total column count must be specified here
     *             columns: 3
     *         },
     *         defaults: {
     *             // applied to each contained panel
     *             bodyStyle: 'padding:20px'
     *         },
     *         items: [{
     *             html: 'Cell A content',
     *             rowspan: 2
     *         },{
     *             html: 'Cell B content',
     *             colspan: 2
     *         },{
     *             html: 'Cell C content',
     *             cellCls: 'highlight'
     *         },{
     *             html: 'Cell D content'
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Table extends Ext.layout.container.Container implements Ext.layout.container.TableConfig {
        /**
         * The total number of columns to create in the table for this layout. If not specified, all Components added to
         * this layout will be rendered into a single row using one column per Component.
         */
        columns: number;

        /**
         * An object containing properties which are added to the {@link Ext.DomHelper DomHelper} specification used to
         * create the layout's '<table>' element. Example:
         *
         *     {
         *         xtype: 'panel',
         *         layout: {
         *             type: 'table',
         *             columns: 3,
         *             tableAttrs: {
         *                 style: {
         *                     width: '100%'
         *                 }
         *             }
         *         }
         *     }
         */
        tableAttrs: any;

        /**
         * An object containing properties which are added to the {@link Ext.DomHelper DomHelper} specification used to
         * create the layout's '<td>' elements.
         */
        tdAttrs: any;

        /**
         * An object containing properties which are added to the {@link Ext.DomHelper DomHelper} specification used to
         * create the layout's '<tr>' elements.
         */
        trAttrs: any;

        constructor();
    }

    interface VBoxConfig extends Ext.layout.container.BoxConfig {
        /**
         * Controls how the child items of the container are aligned. Acceptable configuration values for this property are:
         *
         * - **left** : **Default** child items are aligned horizontally at the **left** side of the container.
         * - **center** : child items are aligned horizontally at the **mid-width** of the container.
         * - **right** : child items are aligned horizontally at the **right** of the container.
         * - **stretch** : child items are stretched horizontally to fill the width of the container.
         * - **stretchmax** : child items are stretched horizontally to the size of the largest item.
         */
        align?: string;

        /**
         * The Math method to use
         * for rounding fractional pixels when '{@link #align}:center' is used.
         *
         * Optional, Defaults to: 'round'
         */
        alignRoundingMethod?: any;

        /**
         * Limits the size of {@link #align aligned} components to the size of the container under certain circumstances.
         * Firstly, the container width must not be determined by the width of the child components. Secondly, the child
         * components must have their width {@link Ext.AbstractComponent#shrinkWrap shrinkwrapped}.
         */
        constrainAlign?: boolean;
    }

    /**
     * A layout that arranges items vertically down a Container. This layout optionally divides available vertical space
     * between child items containing a numeric 'flex' configuration.
     *
     * This layout may also be used to set the widths of child items by configuring it with the {@link #align} option.
     *
     *     @example
     *     Ext.create('Ext.Panel', {
     *         width: 500,
     *         height: 400,
     *         title: "VBoxLayout Panel",
     *         layout: {
     *             type: 'vbox',
     *             align: 'center'
     *         },
     *         renderTo: document.body,
     *         items: [{
     *             xtype: 'panel',
     *             title: 'Inner Panel One',
     *             width: 250,
     *             flex: 2
     *         },
     *         {
     *             xtype: 'panel',
     *             title: 'Inner Panel Two',
     *             width: 250,
     *             flex: 4
     *         },
     *         {
     *             xtype: 'panel',
     *             title: 'Inner Panel Three',
     *             width: '50%',
     *             flex: 4
     *         }]
     *     });
     */
    export class VBox extends Ext.layout.container.Box implements Ext.layout.container.VBoxConfig {
        /**
         * Controls how the child items of the container are aligned. Acceptable configuration values for this property are:
         *
         * - **left** : **Default** child items are aligned horizontally at the **left** side of the container.
         * - **center** : child items are aligned horizontally at the **mid-width** of the container.
         * - **right** : child items are aligned horizontally at the **right** of the container.
         * - **stretch** : child items are stretched horizontally to fill the width of the container.
         * - **stretchmax** : child items are stretched horizontally to the size of the largest item.
         */
        align: string;

        /**
         * The Math method to use
         * for rounding fractional pixels when '{@link #align}:center' is used.
         *
         * Optional, Defaults to: 'round'
         */
        alignRoundingMethod: any;

        /**
         * Limits the size of {@link #align aligned} components to the size of the container under certain circumstances.
         * Firstly, the container width must not be determined by the width of the child components. Secondly, the child
         * components must have their width {@link Ext.AbstractComponent#shrinkWrap shrinkwrapped}.
         */
        constrainAlign: boolean;

        constructor(config: Ext.layout.container.BoxConfig);
    }
}

declare module Ext.layout.container.boxOverflow {
    interface MenuConfig {
        /**
         * CSS class added to the Button which shows the overflow menu.
         */
        triggerButtonCls?: string;
    }

    export class Menu extends Ext.layout.container.boxOverflow.None implements Ext.layout.container.boxOverflow.MenuConfig {
        /**
         * Array of all items that are currently hidden and should go into the dropdown menu
         */
        menuItems: any[];

        /**
         * HTML fragment to render into the toolbar overflow menu if there are no items to display
         */
        noItemsMenuText: string;

        /**
         * CSS class added to the Button which shows the overflow menu.
         */
        triggerButtonCls: string;

        constructor(layout: any);
    }

    /**
     * Base class for Box Layout overflow handlers. These specialized classes are invoked when a Box Layout
     * (either an HBox or a VBox) has child items that are either too wide (for HBox) or too tall (for VBox)
     * for its container.
     */
    export class None extends Ext.Base {
        constructor(layout: any, config: Ext.layout.container.boxOverflow.ScrollerConfig);
    }

    interface ScrollerConfig {
        /**
         * CSS class added to the afterCt element. This is the element that holds any special items such as scrollers,
         * which must always be present at the rightmost edge of the Container
         */
        afterCtCls?: string;

        /**
         * CSS class added to the right scroller element if enableScroll is used
         */
        afterScrollerCls?: string;

        /**
         * True to animate the scrolling of items within the layout (ignored if enableScroll is false)
         */
        animateScroll?: boolean;

        /**
         * CSS class added to the beforeCt element. This is the element that holds any special items such as scrollers,
         * which must always be present at the leftmost edge of the Container
         */
        beforeCtCls?: string;

        /**
         * CSS class added to the left scroller element if enableScroll is used
         */
        beforeScrollerCls?: string;

        /**
         * Number of milliseconds that each scroll animation lasts
         */
        scrollDuration?: number;

        /**
         * The number of pixels to scroll by on scroller click
         */
        scrollIncrement?: number;

        /**
         * Number of milliseconds between each scroll while a scroller button is held down
         */
        scrollRepeatInterval?: number;

        /**
         * CSS class added to both scroller elements if enableScroll is used
         *
         * Optional, Defaults to: 'x-box-scroller'
         */
        scrollerCls?: string;

        /**
         * The number of pixels to increment on mouse wheel scrolling.
         */
        wheelIncrement?: number;
    }

    export class Scroller extends Ext.layout.container.boxOverflow.None implements Ext.layout.container.boxOverflow.ScrollerConfig {
        /**
         * CSS class added to the afterCt element. This is the element that holds any special items such as scrollers,
         * which must always be present at the rightmost edge of the Container
         */
        afterCtCls: string;

        /**
         * CSS class added to the right scroller element if enableScroll is used
         */
        afterScrollerCls: string;

        /**
         * True to animate the scrolling of items within the layout (ignored if enableScroll is false)
         */
        animateScroll: boolean;

        /**
         * CSS class added to the beforeCt element. This is the element that holds any special items such as scrollers,
         * which must always be present at the leftmost edge of the Container
         */
        beforeCtCls: string;

        /**
         * CSS class added to the left scroller element if enableScroll is used
         */
        beforeScrollerCls: string;

        /**
         * Number of milliseconds that each scroll animation lasts
         */
        scrollDuration: number;

        /**
         * CSS class added to both scroller elements if enableScroll is used
         *
         * Optional, Defaults to: 'x-box-scroller'
         */
        scrollerCls: string;

        /**
         * The number of pixels to scroll by on scroller click
         */
        scrollIncrement: number;

        /**
         * Number of milliseconds between each scroll while a scroller button is held down
         */
        scrollRepeatInterval: number;

        /**
         * The number of pixels to increment on mouse wheel scrolling.
         */
        wheelIncrement: number;

        constructor(layout: any, config: Ext.layout.container.boxOverflow.ScrollerConfig);

        /**
         * Returns the current scroll position of the innerCt element
         * @return {Number} The current scroll position
         */
        getScrollPosition(): number;

        /**
         * Scrolls to the given component.
         * @param {String/Number/Ext.Component} item The item to scroll to. Can be a numerical index, component id
         * or a reference to the component itself.
         * @param {Boolean} animate True to animate the scrolling
         */
        scrollToItem(item: string|number|Ext.Component, animate: boolean);

        /**
         * @param {Ext.layout.container.boxOverflow.Scroller} scroller The layout scroller
         * @param {Number} newPosition The new position of the scroller
         * @param {Boolean/Object} animate If animating or not. If true, it will be a animation configuration, else it will be false
         */
        scroll(scroller: Ext.layout.container.boxOverflow.Scroller, newPosition: number, animate: boolean|any);
    }
}

declare module Ext.menu {
    interface CheckItemConfig extends Ext.menu.ItemConfig {
        /**
         * True to prevent the checked item from being toggled. Any submenu will still be accessible.
         *
         * Optional, Defaults to: false
         */
        checkChangeDisabled?: boolean;

        /**
         * Alternative for the {@link #checkchange} event.  Gets called with the same parameters.
         */
        checkHandler?: Function;

        /**
         * True to render the menuitem initially checked.
         *
         * Optional, Defaults to: false
         */
        checked?: boolean;

        /**
         * The CSS class used by {@link #cls} to show the checked state.
         * Defaults to 'Ext.baseCSSPrefix + 'menu-item-checked''.
         */
        checkedCls?: string;

        /**
         * Name of a radio group that the item belongs.
         *
         * Specifying this option will turn check item into a radio item.
         *
         * Note that the group name must be globally unique.
         */
        group?: string;

        /**
         * The CSS class applied to this item's icon image to denote being a part of a radio group.
         * Defaults to 'Ext.baseCSSClass + 'menu-group-icon''.
         * Any specified {@link #iconCls} overrides this.
         */
        groupCls?: string;

        /**
         * Whether to not to hide the owning menu when this item is clicked.
         * Defaults to 'false' for checkbox items, and to 'true' for radio group items.
         *
         * Optional, Defaults to: false
         */
        hideOnClick?: boolean;

        /**
         * Scope for the {@link #checkHandler} callback.
         */
        scope?: any;

        /**
         * The CSS class used by {@link #cls} to show the unchecked state.
         * Defaults to 'Ext.baseCSSPrefix + 'menu-item-unchecked''.
         */
        uncheckedCls?: string;
    }

    /**
     * A menu item that contains a togglable checkbox by default, but that can also be a part of a radio group.
     *
     *     @example
     *     Ext.create('Ext.menu.Menu', {
     *         width: 100,
     *         height: 110,
     *         floating: false,  // usually you want this set to True (default)
     *         renderTo: Ext.getBody(),  // usually rendered by it's containing component
     *         items: [{
     *             xtype: 'menucheckitem',
     *             text: 'select all'
     *         },{
     *             xtype: 'menucheckitem',
     *             text: 'select specific'
     *         },{
     *             iconCls: 'add16',
     *             text: 'icon item'
     *         },{
     *             text: 'regular item'
     *         }]
     *     });
     */
    export class CheckItem extends Ext.menu.Item implements Ext.menu.CheckItemConfig {
        /**
         * True to prevent the checked item from being toggled. Any submenu will still be accessible.
         *
         * Optional, Defaults to: false
         */
        checkChangeDisabled: boolean;

        /**
         * True to render the menuitem initially checked.
         *
         * Optional, Defaults to: false
         */
        checked: boolean;

        /**
         * The CSS class used by {@link #cls} to show the checked state.
         * Defaults to 'Ext.baseCSSPrefix + 'menu-item-checked''.
         */
        checkedCls: string;

        /**
         * Alternative for the {@link #checkchange} event.  Gets called with the same parameters.
         */
        checkHandler: Function;

        /**
         * Name of a radio group that the item belongs.
         *
         * Specifying this option will turn check item into a radio item.
         *
         * Note that the group name must be globally unique.
         */
        group: string;

        /**
         * The CSS class applied to this item's icon image to denote being a part of a radio group.
         * Defaults to 'Ext.baseCSSClass + 'menu-group-icon''.
         * Any specified {@link #iconCls} overrides this.
         */
        groupCls: string;

        /**
         * Whether to not to hide the owning menu when this item is clicked.
         * Defaults to 'false' for checkbox items, and to 'true' for radio group items.
         *
         * Optional, Defaults to: false
         */
        hideOnClick: boolean;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * Scope for the {@link #checkHandler} callback.
         */
        scope: any;

        /**
         * The CSS class used by {@link #cls} to show the unchecked state.
         * Defaults to 'Ext.baseCSSPrefix + 'menu-item-unchecked''.
         */
        uncheckedCls: string;

        protected afterRender();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Disables just the checkbox functionality of this menu Item. If this menu item has a submenu, that submenu
         * will still be accessible
         */
        disableCheckChange();

        /**
         * Reenables the checkbox functionality of this menu item after having been disabled by {@link #disableCheckChange}
         */
        enableCheckChange();

        protected initComponent();

        protected onDestroy();

        /**
         * Sets the checked state of the item
         * @param {Boolean} checked True to check, false to uncheck
         * @param {Boolean} [suppressEvents=false] True to prevent firing the checkchange events.
         */
        setChecked(checked: boolean, suppressEvents?: boolean);

        /**
         * Fires before a change event. Return false to cancel.
         */
        beforecheckchange(that: Ext.menu.CheckItem, checked: boolean);

        /**
         * Fires after a change event.
         */
        checkchange(that: Ext.menu.CheckItem, checked: boolean);
    }

    interface ColorPickerConfig extends Ext.menu.MenuConfig {
        /**
         * False to continue showing the menu after a color is selected.
         */
        hideOnClick?: boolean;

        /**
         * An id to assign to the underlying color picker.
         */
        pickerId?: string;
    }

    /**
     * A menu containing a Ext.picker.Color Component.
     *
     * Notes:
     *
     *   - Although not listed here, the **constructor** for this class accepts all of the
     *     configuration options of {@link Ext.picker.Color}.
     *   - If subclassing ColorMenu, any configuration options for the ColorPicker must be
     *     applied to the **initialConfig** property of the ColorMenu. Applying
     *     {@link Ext.picker.Color ColorPicker} configuration settings to 'this' will **not**
     *     affect the ColorPicker's configuration.
     *
     * Example:
     *
     *     @example
     *     var colorPicker = Ext.create('Ext.menu.ColorPicker', {
     *         value: '000000'
     *     });
     *
     *     Ext.create('Ext.menu.Menu', {
     *         width: 100,
     *         height: 90,
     *         floating: false,  // usually you want this set to True (default)
     *         renderTo: Ext.getBody(),  // usually rendered by it's containing component
     *         items: [{
     *             text: 'choose a color',
     *             menu: colorPicker
     *         },{
     *             iconCls: 'add16',
     *             text: 'icon item'
     *         },{
     *             text: 'regular item'
     *         }]
     *     });
     */
    export class ColorPicker extends Ext.menu.Menu implements Ext.menu.ColorPickerConfig {
        /**
         * The {@link Ext.picker.Color} instance for this ColorMenu
         */
        picker: Ext.picker.Color;

        /**
         * False to continue showing the menu after a color is selected.
         */
        hideOnClick: boolean;

        /**
         * An id to assign to the underlying color picker.
         */
        pickerId: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        select();
    }

    interface DatePickerConfig extends Ext.menu.MenuConfig {
        /**
         * False to continue showing the menu after a date is selected.
         */
        hideOnClick?: boolean;

        /**
         * An id to assign to the underlying date picker.
         */
        pickerId?: string;
    }

    /**
     * A menu containing an Ext.picker.Date Component.
     *
     * Notes:
     *
     * - Although not listed here, the **constructor** for this class accepts all of the
     *   configuration options of **{@link Ext.picker.Date}**.
     * - If subclassing DateMenu, any configuration options for the DatePicker must be applied
     *   to the **initialConfig** property of the DateMenu. Applying {@link Ext.picker.Date Date Picker}
     *   configuration settings to **this** will **not** affect the Date Picker's configuration.
     *
     * Example:
     *
     *     @example
     *     var dateMenu = Ext.create('Ext.menu.DatePicker', {
     *         handler: function(dp, date){
     *             Ext.Msg.alert('Date Selected', 'You selected ' + Ext.Date.format(date, 'M j, Y'));
     *         }
     *     });
     *
     *     Ext.create('Ext.menu.Menu', {
     *         width: 100,
     *         height: 90,
     *         floating: false,  // usually you want this set to True (default)
     *         renderTo: Ext.getBody(),  // usually rendered by it's containing component
     *         items: [{
     *             text: 'choose a date',
     *             menu: dateMenu
     *         },{
     *             iconCls: 'add16',
     *             text: 'icon item'
     *         },{
     *             text: 'regular item'
     *         }]
     *     });
     */
    export class DatePicker extends Ext.menu.Menu implements Ext.menu.DatePickerConfig {
        /**
         * The {@link Ext.picker.Date} instance for this DateMenu
         */
        picker: Ext.picker.Date;

        /**
         * False to continue showing the menu after a date is selected.
         */
        hideOnClick: boolean;

        /**
         * An id to assign to the underlying date picker.
         */
        pickerId: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        select();
    }

    interface ItemConfig extends Ext.ComponentConfig {
        /**
         * The CSS class added to the menu item when the item is activated (focused/mouseover).
         */
        activeCls?: string;

        /**
         * Whether or not this menu item can be activated when focused/mouseovered.
         */
        canActivate?: boolean;

        /**
         * The delay in milliseconds to wait before hiding the menu after clicking the menu item.
         * This only has an effect when 'hideOnClick: true'.
         */
        clickHideDelay?: number;

        /**
         * Whether or not to destroy any associated sub-menu when this item is destroyed.
         */
        destroyMenu?: boolean;

        /**
         * The CSS class added to the menu item when the item is disabled.
         */
        disabledCls?: string;

        /**
         * A numeric unicode character code to use as the icon for this item. The default
         * font-family for glyphs can be set globally using
         * {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()}. Alternatively, this
         * config option accepts a string with the charCode and font-family separated by the
         * '@' symbol. For example '65@My Font Family'.
         */
        glyph?: number|string;

        /**
         * A function called when the menu item is clicked (can be used instead of {@link #click} event).
         * The item that was clicked
         * The underyling {@link Ext.EventObject}.
         */
        handler?: Function;

        /**
         * Whether to not to hide the owning menu when this item is clicked.
         */
        hideOnClick?: boolean;

        /**
         * The href attribute to use for the underlying anchor link.
         *
         * Optional, Defaults to: '#'
         */
        href?: string;

        /**
         * The target attribute to use for the underlying anchor link.
         */
        hrefTarget?: string;

        /**
         * The path to an icon to display in this item.
         *
         * Defaults to 'Ext.BLANK_IMAGE_URL'.
         */
        icon?: string;

        /**
         * A CSS class that specifies a 'background-image' to use as the icon for this item.
         */
        iconCls?: string;

        /**
         * The default {@link Ext.util.Positionable#getAlignToXY Ext.util.Positionable.getAlignToXY} anchor position value for this
         * item's sub-menu relative to this item's position.
         */
        menuAlign?: string;

        /**
         * The delay in milliseconds before this item's sub-menu expands after this item is moused over.
         */
        menuExpandDelay?: number;

        /**
         * The delay in milliseconds before this item's sub-menu hides after this item is moused out.
         */
        menuHideDelay?: number;

        /**
         * Whether or not this item is plain text/html with no icon or visual activation.
         */
        plain?: boolean;

        /**
         * The text/html to display in this item.
         */
        text?: string;

        /**
         * The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or
         * QuickTips config object.
         */
        tooltip?: string|any;

        /**
         * The type of tooltip to use. Either 'qtip' for QuickTips or 'title' for title attribute.
         */
        tooltipType?: string;
    }

    /**
     * A base class for all menu items that require menu-related functionality such as click handling,
     * sub-menus, icons, etc.
     *
     *     @example
     *     Ext.create('Ext.menu.Menu', {
     *         width: 100,
     *         height: 100,
     *         floating: false,  // usually you want this set to True (default)
     *         renderTo: Ext.getBody(),  // usually rendered by it's containing component
     *         items: [{
     *             text: 'icon item',
     *             iconCls: 'add16'
     *         },{
     *             text: 'text item'
     *         },{
     *             text: 'plain item',
     *             plain: true
     *         }]
     *     });
     */
    export class Item extends Ext.Component implements Ext.menu.ItemConfig {
        /**
         * Whether or not this item is currently activated
         */
        activated: boolean;

        maskOnDisable: boolean;

        /**
         * The sub-menu associated with this item, if one was configured.
         */
        menu: Ext.menu.Menu;

        /**
         * The parent Menu of this item.
         */
        parentMenu: Ext.menu.Menu;

        /**
         * The CSS class added to the menu item when the item is activated (focused/mouseover).
         */
        activeCls: string;

        /**
         * Whether or not this menu item can be activated when focused/mouseovered.
         */
        canActivate: boolean;

        /**
         * The delay in milliseconds to wait before hiding the menu after clicking the menu item.
         * This only has an effect when 'hideOnClick: true'.
         */
        clickHideDelay: number;

        /**
         * Whether or not to destroy any associated sub-menu when this item is destroyed.
         */
        destroyMenu: boolean;

        /**
         * The CSS class added to the menu item when the item is disabled.
         */
        disabledCls: string;

        /**
         * A numeric unicode character code to use as the icon for this item. The default
         * font-family for glyphs can be set globally using
         * {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()}. Alternatively, this
         * config option accepts a string with the charCode and font-family separated by the
         * '@' symbol. For example '65@My Font Family'.
         */
        glyph: number|string;

        /**
         * A function called when the menu item is clicked (can be used instead of {@link #click} event).
         * The item that was clicked
         * The underyling {@link Ext.EventObject}.
         */
        handler: Function;

        /**
         * Whether to not to hide the owning menu when this item is clicked.
         */
        hideOnClick: boolean;

        /**
         * The href attribute to use for the underlying anchor link.
         *
         * Optional, Defaults to: '#'
         */
        href: string;

        /**
         * The target attribute to use for the underlying anchor link.
         */
        hrefTarget: string;

        /**
         * The path to an icon to display in this item.
         *
         * Defaults to 'Ext.BLANK_IMAGE_URL'.
         */
        icon: string;

        /**
         * A CSS class that specifies a 'background-image' to use as the icon for this item.
         */
        iconCls: string;

        /**
         * The default {@link Ext.util.Positionable#getAlignToXY Ext.util.Positionable.getAlignToXY} anchor position value for this
         * item's sub-menu relative to this item's position.
         */
        menuAlign: string;

        /**
         * The delay in milliseconds before this item's sub-menu expands after this item is moused over.
         */
        menuExpandDelay: number;

        /**
         * The delay in milliseconds before this item's sub-menu hides after this item is moused out.
         */
        menuHideDelay: number;

        /**
         * Whether or not this item is plain text/html with no icon or visual activation.
         */
        plain: boolean;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The text/html to display in this item.
         */
        text: string;

        /**
         * The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or
         * QuickTips config object.
         */
        tooltip: string|any;

        /**
         * The type of tooltip to use. Either 'qtip' for QuickTips or 'title' for title attribute.
         */
        tooltipType: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected initComponent();

        protected onDestroy();

        protected onRender();

        /**
         * Sets the {@link #click} handler of this item
         * @param {Function} fn The handler function
         * @param {Object} [scope] The scope of the handler function
         */
        setHandler(fn: Function, scope?: any);

        /**
         * Sets the {@link #icon} on this item.
         * @param {String} icon The new icon
         */
        setIcon(icon: string);

        /**
         * Sets the {@link #iconCls} of this item
         * @param {String} iconCls The CSS class to set to {@link #iconCls}
         */
        setIconCls(iconCls: string);

        /**
         * Set a child menu for this item. See the {@link #cfg-menu} configuration.
         * @param {Ext.menu.Menu/Object} menu A menu, or menu configuration. null may be
         * passed to remove the menu.
         * @param {Boolean} [destroyMenu] True to destroy any existing menu. False to
         * prevent destruction. If not specified, the {@link #destroyMenu} configuration
         * will be used.
         */
        setMenu(menu: Ext.menu.Menu|any, destroyMenu?: boolean);

        /**
         * Sets the {@link #text} of this item
         * @param {String} text The {@link #text}
         */
        setText(text: string);

        /**
         * Sets the tooltip for this menu item.
         *
         * @param {String/Object} tooltip This may be:
         *
         *   - **String** : A string to be used as innerHTML (html tags are accepted) to show in a tooltip
         *   - **Object** : A configuration object for {@link Ext.tip.QuickTipManager#register}.
         *
         * @return {Ext.menu.Item} this
         */
        setTooltip(tooltip: string|any): Ext.menu.Item;

        /**
         * Fires when this item is clicked
         * @param {Ext.menu.Item} item The item that was clicked
         * @param {Ext.EventObject} e The underyling {@link Ext.EventObject}.
         */
        click(item: Ext.menu.Item, e: Ext.EventObject);

        /**
         * Fired when the item's icon is changed by the {@link #setIcon} or {@link #setIconCls} methods.
         */
        iconchange(that: Ext.menu.Item, oldIcon: string, newIcon: string);

        /**
         * Fired when the item's text is changed by the {@link #setText} method.
         */
        textchange(that: Ext.menu.Item, oldText: string, newText: string);
    }

    export class KeyNav extends Ext.util.KeyNav {
        constructor(config: any);
    }

    /**
     * Provides a common registry of all menus on a page.
     */
    export class Manager {
        /**
         * Returns a {@link Ext.menu.Menu} object
         * @param {String/Object} menu The string menu id, an existing menu object reference, or a Menu config that will
         * be used to generate and return a new Menu this.
         * @return {Ext.menu.Menu} The specified menu, or null if none are found
         */
        static get(menu: string|any): Ext.menu.Menu;

        /**
         * Hides all menus that are currently visible
         * @return {Boolean} success True if any active menus were hidden.
         */
        static hideAll(): boolean;
    }

    interface MenuConfig extends Ext.panel.PanelConfig {
        /**
         * True to allow multiple menus to be displayed at the same time.
         *
         * Optional, Defaults to: false
         */
        allowOtherMenus?: boolean;

        /**
         * True to enable keyboard navigation for controlling the menu.
         * This option should generally be disabled when form fields are
         * being used inside the menu.
         *
         * Optional, Defaults to: true
         */
        enableKeyNav?: boolean;

        /**
         * A Menu configured as 'floating: true' (the default) will be rendered as an absolutely positioned,
         * {@link Ext.Component#floating floating} {@link Ext.Component Component}. If configured as 'floating: false', the Menu may be
         * used as a child item of another {@link Ext.container.Container Container}.
         *
         * Optional, Defaults to: true
         */
        floating?: boolean;

        /**
         * True to initially render the Menu as hidden, requiring to be shown manually.
         *
         * Defaults to 'true' when 'floating: true', and defaults to 'false' when 'floating: false'.
         *
         * Optional, Defaults to: undefined
         */
        hidden?: boolean;

        hideMode?: any;

        /**
         * True to ignore clicks on any item in this menu that is a parent item (displays a submenu)
         * so that the submenu is not dismissed when clicking the parent item.
         *
         * Optional, Defaults to: false
         */
        ignoreParentClicks?: boolean;

        /**
         * The minimum width of the Menu. The default minWidth only applies when the {@link #floating} config is true.
         *
         * Optional, Defaults to: 120
         */
        minWidth?: number;

        /**
         * True to remove the incised line down the left side of the menu and to not indent general Component items.
         *
         * {@link Ext.menu.Item MenuItem}s will *always* have space at their start for an icon. With the 'plain' setting,
         * non {@link Ext.menu.Item MenuItem} child components will not be indented to line up.
         *
         * Basically, 'plain:true' makes a Menu behave more like a regular {@link Ext.layout.container.HBox HBox layout}
         * {@link Ext.panel.Panel Panel} which just has the same background as a Menu.
         *
         * See also the {@link #showSeparator} config.
         *
         * Optional, Defaults to: false
         */
        plain?: boolean;

        /**
         * True to show the icon separator.
         *
         * Optional, Defaults to: true
         */
        showSeparator?: boolean;
    }

    /**
     * A menu object. This is the container to which you may add {@link Ext.menu.Item menu items}.
     *
     * Menus may contain either {@link Ext.menu.Item menu items}, or general {@link Ext.Component Components}.
     * Menus may also contain {@link Ext.panel.AbstractPanel#dockedItems docked items} because it extends {@link Ext.panel.Panel}.
     *
     * By default, non {@link Ext.menu.Item menu items} are indented so that they line up with the text of menu items. clearing
     * the icon column. To make a contained general {@link Ext.Component Component} left aligned configure the child
     * Component with 'indent: false.
     *
     * By default, Menus are absolutely positioned, floating Components. By configuring a Menu with '{@link #floating}: false',
     * a Menu may be used as a child of a {@link Ext.container.Container Container}.
     *
     *     @example
     *     Ext.create('Ext.menu.Menu', {
     *         width: 100,
     *         margin: '0 0 10 0',
     *         floating: false,  // usually you want this set to True (default)
     *         renderTo: Ext.getBody(),  // usually rendered by it's containing component
     *         items: [{
     *             text: 'regular item 1'
     *         },{
     *             text: 'regular item 2'
     *         },{
     *             text: 'regular item 3'
     *         }]
     *     });
     *
     *     Ext.create('Ext.menu.Menu', {
     *         width: 100,
     *         plain: true,
     *         floating: false,  // usually you want this set to True (default)
     *         renderTo: Ext.getBody(),  // usually rendered by it's containing component
     *         items: [{
     *             text: 'plain item 1'
     *         },{
     *             text: 'plain item 2'
     *         },{
     *             text: 'plain item 3'
     *         }]
     *     });
     */
    export class Menu extends Ext.panel.Panel implements Ext.menu.MenuConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Menu, or subclass thereof.
         */
        isMenu: boolean;

        /**
         * The parent Menu of this Menu.
         */
        parentMenu: Ext.menu.Menu;

        /**
         * True to allow multiple menus to be displayed at the same time.
         *
         * Optional, Defaults to: false
         */
        allowOtherMenus: boolean;

        /**
         * True to enable keyboard navigation for controlling the menu.
         * This option should generally be disabled when form fields are
         * being used inside the menu.
         *
         * Optional, Defaults to: true
         */
        enableKeyNav: boolean;

        /**
         * A Menu configured as 'floating: true' (the default) will be rendered as an absolutely positioned,
         * {@link Ext.Component#floating floating} {@link Ext.Component Component}. If configured as 'floating: false', the Menu may be
         * used as a child item of another {@link Ext.container.Container Container}.
         *
         * Optional, Defaults to: true
         */
        floating: boolean;

        /**
         * True to initially render the Menu as hidden, requiring to be shown manually.
         *
         * Defaults to 'true' when 'floating: true', and defaults to 'false' when 'floating: false'.
         *
         * Optional, Defaults to: undefined
         */
        hidden: boolean;

        hideMode: string;

        /**
         * True to ignore clicks on any item in this menu that is a parent item (displays a submenu)
         * so that the submenu is not dismissed when clicking the parent item.
         *
         * Optional, Defaults to: false
         */
        ignoreParentClicks: boolean;

        /**
         * The minimum width of the Menu. The default minWidth only applies when the {@link #floating} config is true.
         *
         * Optional, Defaults to: 120
         */
        minWidth: number;

        /**
         * True to remove the incised line down the left side of the menu and to not indent general Component items.
         *
         * {@link Ext.menu.Item MenuItem}s will *always* have space at their start for an icon. With the 'plain' setting,
         * non {@link Ext.menu.Item MenuItem} child components will not be indented to line up.
         *
         * Basically, 'plain:true' makes a Menu behave more like a regular {@link Ext.layout.container.HBox HBox layout}
         * {@link Ext.panel.Panel Panel} which just has the same background as a Menu.
         *
         * See also the {@link #showSeparator} config.
         *
         * Optional, Defaults to: false
         */
        plain: boolean;

        /**
         * True to show the icon separator.
         *
         * Optional, Defaults to: true
         */
        showSeparator: boolean;

        protected beforeShow();

        /**
         * Returns whether a menu item can be activated or not.
         * @return {Boolean}
         */
        canActivateItem(): boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Deactivates the current active item on the menu, if one exists.
         */
        deactivateActiveItem();

        protected onDestroy();

        /**
         * Fires when this menu is clicked
         * @param {Ext.menu.Menu} menu The menu which has been clicked
         * @param {Ext.Component} item The menu item that was clicked. 'undefined' if not applicable.
         * @param {Ext.EventObject} e The underlying {@link Ext.EventObject}.
         */
        click(menu: Ext.menu.Menu, item: Ext.Component, e: Ext.EventObject);

        /**
         * Fires when the mouse enters this menu
         * @param {Ext.menu.Menu} menu The menu
         * @param {Ext.EventObject} e The underlying {@link Ext.EventObject}
         */
        mouseenter(menu: Ext.menu.Menu, e: Ext.EventObject);

        /**
         * Fires when the mouse leaves this menu
         * @param {Ext.menu.Menu} menu The menu
         * @param {Ext.EventObject} e The underlying {@link Ext.EventObject}
         */
        mouseleave(menu: Ext.menu.Menu, e: Ext.EventObject);

        /**
         * Fires when the mouse is hovering over this menu
         * @param {Ext.menu.Menu} menu The menu
         * @param {Ext.Component} item The menu item that the mouse is over. 'undefined' if not applicable.
         * @param {Ext.EventObject} e The underlying {@link Ext.EventObject}
         */
        mouseover(menu: Ext.menu.Menu, item: Ext.Component, e: Ext.EventObject);
    }

    interface SeparatorConfig extends Ext.menu.ItemConfig {
        /**
         * The CSS class used by the separator item to show the incised line.
         */
        separatorCls?: string;
    }

    /**
     * Adds a separator bar to a menu, used to divide logical groups of menu items. Generally you will
     * add one of these by using "-" in your call to add() or in your items config rather than creating one directly.
     *
     *     @example
     *     Ext.create('Ext.menu.Menu', {
     *         width: 100,
     *         height: 100,
     *         floating: false,  // usually you want this set to True (default)
     *         renderTo: Ext.getBody(),  // usually rendered by it's containing component
     *         items: [{
     *             text: 'icon item',
     *             iconCls: 'add16'
     *         },{
     *             xtype: 'menuseparator'
     *         },{
     *            text: 'separator above'
     *         },{
     *            text: 'regular item'
     *         }]
     *     });
     */
    export class Separator extends Ext.menu.Item implements Ext.menu.SeparatorConfig {
        /**
         * The CSS class used by the separator item to show the incised line.
         */
        separatorCls: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }
}

declare module Ext.panel {
    interface AbstractPanelConfig extends Ext.container.ContainerConfig {
        /**
         * The base CSS class to apply to this panel's element.
         * @since 2.3.0
         *
         * Optional, Defaults to: x-panel
         */
        baseCls?: string;

        /**
         * A shortcut to add or remove the border on the body of a panel. In the classic theme
         * this only applies to a panel which has the {@link #frame} configuration set to 'true'.
         * @since 2.3.0
         */
        bodyBorder?: boolean;

        /**
         * A CSS class, space-delimited string of classes, or array of classes to be applied to the panel's body element.
         * The following examples are all valid:<pre><code>
         bodyCls: 'foo'
         bodyCls: 'foo bar'
         bodyCls: ['foo', 'bar']
         * </code></pre>
         */
        bodyCls?: string;

        /**
         * A shortcut for setting a padding style on the body element. The value can either be
         * a number to be applied to all sides, or a normal css string describing padding.
         * Defaults to <code>undefined</code>.
         */
        bodyPadding?: number|string;

        /**
         * Custom CSS styles to be applied to the panel's body element, which can be supplied as a valid CSS style string,
         * an object containing style property name/value pairs or a function that returns such a string or object.
         * For example, these two formats are interpreted to be equivalent:<pre><code>
         bodyStyle: 'background:#ffc; padding:10px;'
         bodyStyle: {
         background: '#ffc',
         padding: '10px'
         }
         * </code></pre>
         *
         * @since 2.3.0
         */
        bodyStyle?: string|any|Function;

        border?: any;

        componentLayout?: any;

        /**
         * A component or series of components to be added as docked items to this panel.
         * The docked items can be docked to either the top, right, left or bottom of a panel.
         * This is typically used for things like toolbars or tab bars:
         * <pre><code>
         var panel = new Ext.panel.Panel({
         fullscreen: true,
         dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
         text: 'Docked to the top'
         }]
         }]
         });</code></pre>
         */
        dockedItems?: any;

        /**
         * Allows for this panel to include the {@link #dockedItems} when trying to determine the overall
         * size of the panel. This option is only applicable when this panel is also shrink wrapping in the
         * same dimensions. See {@link Ext.AbstractComponent#shrinkWrap} for an explanation of the configuration options.
         */
        shrinkWrapDock?: boolean|number;
    }

    /**
     * A base class which provides methods common to Panel classes across the Sencha product range.
     *
     * Please refer to sub class's documentation
     */
    export class AbstractPanel extends Ext.container.Container implements Ext.panel.AbstractPanelConfig {
        /**
         * The Panel's body {@link Ext.dom.Element Element} which may be used to contain HTML content.
         * The content may be specified in the {@link #html} config, or it may be loaded using the
         * {@link #loader} config. Read-only.
         *
         * If this is used to load visible HTML elements in either way, then
         * the Panel may not be used as a Layout for hosting nested Panels.
         *
         * If this Panel is intended to be used as the host of a Layout (See {@link #layout}
         * then the body Element must not be loaded or changed - it is under the control
         * of the Panel's Layout.
         *
         * @readonly
         */
        body: Ext.dom.Element;

        /**
         * The name of the padding property that is used by the layout to manage
         * padding.  See {@link Ext.layout.container.Auto#managePadding managePadding}
         *
         * Optional, Defaults to: 'padding'
         *
         * Optional, Defaults to: 'bodyPadding'
         */
        contentPaddingProperty: string;

        /**
         * 'true' in this class to identify an object as an instantiated Panel, or subclass thereof.
         */
        isPanel: boolean;

        /**
         * The base CSS class to apply to this panel's element.
         * @since 2.3.0
         *
         * Optional, Defaults to: x-panel
         */
        baseCls: string;

        /**
         * A shortcut to add or remove the border on the body of a panel. In the classic theme
         * this only applies to a panel which has the {@link #frame} configuration set to 'true'.
         * @since 2.3.0
         */
        bodyBorder: boolean;

        /**
         * A CSS class, space-delimited string of classes, or array of classes to be applied to the panel's body element.
         * The following examples are all valid:<pre><code>
         bodyCls: 'foo'
         bodyCls: 'foo bar'
         bodyCls: ['foo', 'bar']
         * </code></pre>
         */
        bodyCls: string;

        /**
         * A shortcut for setting a padding style on the body element. The value can either be
         * a number to be applied to all sides, or a normal css string describing padding.
         * Defaults to <code>undefined</code>.
         */
        bodyPadding: number|string;

        /**
         * Custom CSS styles to be applied to the panel's body element, which can be supplied as a valid CSS style string,
         * an object containing style property name/value pairs or a function that returns such a string or object.
         * For example, these two formats are interpreted to be equivalent:<pre><code>
         bodyStyle: 'background:#ffc; padding:10px;'
         bodyStyle: {
         background: '#ffc',
         padding: '10px'
         }
         * </code></pre>
         *
         * @since 2.3.0
         */
        bodyStyle: string|any|Function;

        border: number|string|boolean;

        componentLayout: string|any;

        /**
         * A component or series of components to be added as docked items to this panel.
         * The docked items can be docked to either the top, right, left or bottom of a panel.
         * This is typically used for things like toolbars or tab bars:
         * <pre><code>
         var panel = new Ext.panel.Panel({
         fullscreen: true,
         dockedItems: [{
         xtype: 'toolbar',
         dock: 'top',
         items: [{
         text: 'Docked to the top'
         }]
         }]
         });</code></pre>
         */
        dockedItems: any;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * Allows for this panel to include the {@link #dockedItems} when trying to determine the overall
         * size of the panel. This option is only applicable when this panel is also shrink wrapping in the
         * same dimensions. See {@link Ext.AbstractComponent#shrinkWrap} for an explanation of the configuration options.
         */
        shrinkWrapDock: boolean|number;

        /**
         * Adds a CSS class to the body element. If not rendered, the class will
         * be added when the panel is rendered.
         * @param {String} cls The class to add
         * @return {Ext.panel.Panel} this
         */
        addBodyCls(cls: string): Ext.panel.Panel;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Attempts a default component lookup (see {@link Ext.container.Container#getComponent}). If the component is not found in the normal
         * items, the dockedItems are searched and the matched component (if any) returned (see {@link #getDockedComponent}). Note that docked
         * items will only be matched by component id or itemId -- if you pass a numeric index only non-docked child components will be searched.
         * @param {String/Number} comp The component id, itemId or position to find
         * @return {Ext.Component} The component (if found)
         * @since 2.3.0
         */
        getComponent(comp: string|number): Ext.Component;

        /**
         * Removes a CSS class from the body element.
         * @param {String} cls The class to remove
         * @return {Ext.panel.Panel} this
         */
        removeBodyCls(cls: string): Ext.panel.Panel;

        /**
         * Sets the body style according to the passed parameters.
         * @param {Mixed} style A full style specification string, or object, or the name of a style property to set.
         * @param {String} value If the first param was a style property name, the style property value.
         * @return {Ext.panel.Panel} this
         */
        setBodyStyle(style: any, value: string): Ext.panel.Panel;
    }

    /**
     * DD implementation for Panels.
     */
    export class DD extends Ext.dd.DragSource {
        /**
         * An empty function by default, but provided so that you can perform a custom action
         * after an invalid drop has occurred by providing an implementation.
         * @param {Event} e The event object
         * @param {String} id The id of the dropped element
         */
        afterInvalidDrop(e: Event, id: string);

        constructor(panel: any, cfg: any);

        createFrame();
    }

    interface HeaderConfig extends Ext.container.ContainerConfig {
        componentLayout?: any;

        defaultType?: any;

        /**
         * A numeric unicode character code to use as the icon for the panel header. The
         * default font-family for glyphs can be set globally using
         * {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()}. Alternatively, this
         * config option accepts a string with the charCode and font-family separated by the
         * '@' symbol. For example '65@My Font Family'.
         */
        glyph?: number|string;

        /**
         * Path to image for an icon in the header. Used for displaying an icon to the left of a title.
         */
        icon?: string;

        /**
         * CSS class for an icon in the header. Used for displaying an icon to the left of a title.
         */
        iconCls?: string;

        shrinkWrap?: any;

        /**
         * The title text to display.
         */
        title?: string;

        /**
         * The alignment of the title text within the available space between the
         * icon and the tools.
         *
         * May be '"left"', '"right"' or '"center"'. Defaults to the browser's natural
         * behavior depending on the css direction property - '"left"' when direction
         * is ltr  and '"right"' when direction is rtl
         * (see {@link Ext.AbstractComponent#rtl}).
         *
         * Optional
         */
        titleAlign?: string;

        /**
         * The ordinal position among the header items (tools and other components specified using the {@link #cfg-items} config)
         * at which the title component is inserted. See {@link Ext.panel.Panel#cfg-header Panel's header config}.
         *
         * If not specified, the title is inserted after any {@link #cfg-items}, but *before* any {@link Ext.panel.Panel#tools}.
         *
         * Note that if an {@link #icon} or {@link #iconCls} has been configured, then the icon component will be the
         * first item before all specified tools or {@link #cfg-items}. This configuration does not include the icon.
         *
         * Optional
         */
        titlePosition?: number;
    }

    /**
     * Simple header class which is used for on {@link Ext.panel.Panel} and {@link Ext.window.Window}.
     */
    export class Header extends Ext.container.Container implements Ext.panel.HeaderConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Header, or subclass thereof.
         */
        isHeader: boolean;

        componentLayout: string|any;

        defaultType: string;

        /**
         * A numeric unicode character code to use as the icon for the panel header. The
         * default font-family for glyphs can be set globally using
         * {@link Ext#setGlyphFontFamily Ext.setGlyphFontFamily()}. Alternatively, this
         * config option accepts a string with the charCode and font-family separated by the
         * '@' symbol. For example '65@My Font Family'.
         */
        glyph: number|string;

        /**
         * Path to image for an icon in the header. Used for displaying an icon to the left of a title.
         */
        icon: string;

        /**
         * CSS class for an icon in the header. Used for displaying an icon to the left of a title.
         */
        iconCls: string;

        protected renderTpl: Ext.XTemplate|string;

        shrinkWrap: boolean|number;

        /**
         * The title text to display.
         */
        title: string;

        /**
         * The alignment of the title text within the available space between the
         * icon and the tools.
         *
         * May be '"left"', '"right"' or '"center"'. Defaults to the browser's natural
         * behavior depending on the css direction property - '"left"' when direction
         * is ltr  and '"right"' when direction is rtl
         * (see {@link Ext.AbstractComponent#rtl}).
         *
         * Optional
         */
        titleAlign: string;

        /**
         * The ordinal position among the header items (tools and other components specified using the {@link #cfg-items} config)
         * at which the title component is inserted. See {@link Ext.panel.Panel#cfg-header Panel's header config}.
         *
         * If not specified, the title is inserted after any {@link #cfg-items}, but *before* any {@link Ext.panel.Panel#tools}.
         *
         * Note that if an {@link #icon} or {@link #iconCls} has been configured, then the icon component will be the
         * first item before all specified tools or {@link #cfg-items}. This configuration does not include the icon.
         *
         * Optional
         */
        titlePosition: number;

        /**
         * Add a tool to the header
         */
        addTool(tool: any);

        protected beforeLayout();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Gets the tools for this header.
         * @return {Ext.panel.Tool[]} The tools
         */
        getTools(): Ext.panel.Tool;

        /**
         * Sets glyph that provides the icon image for this header.  This method will replace any existing
         * glyph if one has already been set.
         * @param {Number/String} glyph the numeric charCode or string charCode/font-family.
         * This parameter expects a format consistent with that of {@link #glyph}
         */
        setGlyph(glyph: number|string);

        /**
         * Sets the image path that provides the icon image for this header.  This method will replace any existing
         * icon if one has already been set.
         * @param {String} icon The new icon path
         */
        setIcon(icon: string);

        /**
         * Sets the CSS class that provides the icon image for this header.  This method will replace any existing
         * icon class if one has already been set.
         * @param {String} cls The new CSS class name
         */
        setIconCls(cls: string);

        /**
         * Sets the title of the header.
         * @param {String} title The title to be set
         */
        setTitle(title: string);

        /**
         * Fires when the header is clicked. This event will not be fired
         * if the click was on a {@link Ext.panel.Tool}
         */
        click(that: Ext.panel.Header, e: Ext.EventObject);

        /**
         * Fires when the header is double clicked. This event will not
         * be fired if the click was on a {@link Ext.panel.Tool}
         */
        dblclick(that: Ext.panel.Header, e: Ext.EventObject);
    }

    interface PanelConfig extends Ext.panel.AbstractPanelConfig {
        /**
         * 'true' to animate the transition when the panel is collapsed, 'false' to skip the animation (defaults to 'true'
         * if the {@link Ext.fx.Anim} class is available, otherwise 'false'). May also be specified as the animation
         * duration in milliseconds.
         */
        animCollapse?: boolean;

        /**
         * Convenience config. Short for 'Bottom Bar'.
         *
         *     bbar: [
         *       { xtype: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'bottom',
         *         items: [
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         */
        bbar?: any;

        /**
         * The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to
         * 'right' for buttons/fbar, 'left' for other toolbar types).
         *
         * **NOTE:** The prefered way to specify toolbars is to use the dockedItems config. Instead of buttonAlign you
         * would add the layout: { pack: 'start' | 'center' | 'end' } option to the dockedItem config.
         */
        buttonAlign?: string;

        /**
         * Convenience config used for adding buttons docked to the bottom of the panel. This is a
         * synonym for the {@link #fbar} config.
         *
         *     buttons: [
         *       { text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'bottom',
         *         ui: 'footer',
         *         defaults: {minWidth: {@link #minButtonWidth}},
         *         items: [
         *             { xtype: 'component', flex: 1 },
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         *
         * The {@link #minButtonWidth} is used as the default {@link Ext.button.Button#minWidth minWidth} for
         * each of the buttons in the buttons toolbar.
         */
        buttons?: any;

        /**
         * True to display the 'close' tool button and allow the user to close the window, false to hide the button and
         * disallow closing the window.
         *
         * By default, when close is requested by clicking the close button in the header, the {@link #method-close} method will be
         * called. This will _{@link Ext.Component#method-destroy destroy}_ the Panel and its content meaning that it may not be
         * reused.
         *
         * To make closing a Panel _hide_ the Panel so that it may be reused, set {@link #closeAction} to 'hide'.
         */
        closable?: boolean;

        /**
         * The action to take when the close header tool is clicked:
         *
         * - **''{@link #method-destroy}''** :
         *
         *   {@link #method-remove remove} the window from the DOM and {@link Ext.Component#method-destroy destroy} it and all descendant
         *   Components. The window will **not** be available to be redisplayed via the {@link #method-show} method.
         *
         * - **''{@link #method-hide}''** :
         *
         *   {@link #method-hide} the window by setting visibility to hidden and applying negative offsets. The window will be
         *   available to be redisplayed via the {@link #method-show} method.
         *
         * **Note:** This behavior has changed! setting *does* affect the {@link #method-close} method which will invoke the
         * approriate closeAction.
         */
        closeAction?: string;

        /**
         * The direction to collapse the Panel when the toggle button is clicked.
         *
         * Defaults to the {@link #headerPosition}
         *
         * **Important: This config is _ignored_ for {@link #collapsible} Panels which are direct child items of a {@link
         * Ext.layout.container.Border border layout}.**
         *
         * Specify as ''top'', ''bottom'', ''left'' or ''right''.
         */
        collapseDirection?: string;

        /**
         * 'true' to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in
         * the panel's title bar, 'false' to render it last.
         */
        collapseFirst?: boolean;

        /**
         * **Important: this config is only effective for {@link #collapsible} Panels which are direct child items of a
         * {@link Ext.layout.container.Border border layout}.**
         *
         * When _not_ a direct child item of a {@link Ext.layout.container.Border border layout}, then the Panel's header
         * remains visible, and the body is collapsed to zero dimensions. If the Panel has no header, then a new header
         * (orientated correctly depending on the {@link #collapseDirection}) will be inserted to show a the title and a re-
         * expand tool.
         *
         * When a child item of a {@link Ext.layout.container.Border border layout}, this config has three possible values:
         *
         * - 'undefined' - When collapsed, a placeholder {@link Ext.panel.Header Header} is injected into the layout to
         *   represent the Panel and to provide a UI with a Tool to allow the user to re-expand the Panel.
         *
         * - '"header"' - The Panel collapses to leave its header visible as when not inside a
         *   {@link Ext.layout.container.Border border layout}.
         *
         * - '"mini"' - The Panel collapses without a visible header.
         */
        collapseMode?: string;

        /**
         * 'true' to render the panel collapsed, 'false' to render it expanded.
         */
        collapsed?: boolean;

        /**
         * A CSS class to add to the panel's element after it has been collapsed.
         */
        collapsedCls?: string;

        /**
         * True to make the panel collapsible and have an expand/collapse toggle Tool added into the header tool button
         * area. False to keep the panel sized either statically, or by an owning layout manager, with no toggle Tool.
         * When a panel is used in a {@link Ext.layout.container.Border border layout}, the {@link #floatable} option
         * can influence the behavior of collapsing.
         * See {@link #collapseMode} and {@link #collapseDirection}
         */
        collapsible?: boolean;

        /**
         * @override
         * True to constrain the panel within its containing element, false to allow it to fall outside of its containing
         * element. By default floating components such as Windows will be rendered to 'document.body'. To render and constrain the window within
         * another element specify {@link #renderTo}. Optionally the header only can be constrained
         * using {@link #constrainHeader}.
         */
        constrain?: boolean;

        /**
         * True to constrain the panel header within its containing element (allowing the panel body to fall outside of
         * its containing element) or false to allow the header to fall outside its containing element.
         * Optionally the entire panel can be constrained using {@link #constrain}.
         */
        constrainHeader?: boolean;

        /**
         * A component or series of components to be added as docked items to this panel. The docked items can be docked to
         * either the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars:
         *
         *     var panel = new Ext.panel.Panel({
         *         dockedItems: [{
         *             xtype: 'toolbar',
         *             dock: 'top',
         *             items: [{
         *                 text: 'Docked to the top'
         *             }]
         *         }]
         *     });
         */
        dockedItems?: any;

        /**
         * Convenience config used for adding items to the bottom of the panel. Short for Footer Bar.
         *
         *     fbar: [
         *       { type: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'bottom',
         *         ui: 'footer',
         *         defaults: {minWidth: {@link #minButtonWidth}},
         *         items: [
         *             { xtype: 'component', flex: 1 },
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         *
         * The {@link #minButtonWidth} is used as the default {@link Ext.button.Button#minWidth minWidth} for
         * each of the buttons in the fbar.
         */
        fbar?: any;

        /**
         * **Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a
         * {@link Ext.layout.container.Border border layout}.**
         *
         * true to allow clicking a collapsed Panel's {@link #placeholder} to display the Panel floated above the layout,
         * false to force the user to fully expand a collapsed region by clicking the expand button to see it again.
         */
        floatable?: boolean;

        /**
         * True to apply a frame to the panel.
         */
        frame?: boolean;

        /**
         * True to apply a frame to the panel panels header (if 'frame' is true).
         */
        frameHeader?: boolean;

        glyph?: number|string;

        /**
         * Pass as 'false' to prevent a Header from being created and shown.
         *
         * Pass as a config object (optionally containing an 'xtype') to custom-configure this Panel's header.
         *
         * See {@link Ext.panel.Header} for all the options that may be specified here.
         *
         * A {@link Ext.panel.Header panel header} is a {@link Ext.container.Container} which contains the Panel's {@link #title} and {@link #tools}.
         * You may also configure the Panel's 'header' option with its own child items which go *before* the {@link #tools}
         *
         * By default the panel {@link #title} is inserted after items configured in this config, but before any tools.
         * To insert the title at any point in the full array, specify the {@link Ext.panel.Header #titlePosition} config:
         *
         *    new Ext.panel.Panel({
         *        title: 'Test',
         *        tools: [{
         *            type: 'refresh
         *        }, {
         *            type: 'help'
         *        }],
         *        titlePosition: 2 // Title will come AFTER the two tools
         *        ...
         *    });
         *
         * Optional
         */
        header?: boolean|any;

        /**
         * Optional CSS class to apply to the header element on mouseover
         */
        headerOverCls?: string;

        /**
         * Specify as ''top'', ''bottom'', ''left'' or ''right''.
         */
        headerPosition?: string;

        /**
         * 'true' to hide the expand/collapse toggle button when '{@link #collapsible} == true', 'false' to display it.
         */
        hideCollapseTool?: boolean;

        /**
         * Path to image for an icon in the header. Used for displaying an icon to the left of a title.
         */
        icon?: string;

        /**
         * CSS class for an icon in the header. Used for displaying an icon to the left of a title.
         */
        iconCls?: string;

        /**
         * Convenience config. Short for 'Left Bar' (left-docked, vertical toolbar).
         *
         *     lbar: [
         *       { xtype: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'left',
         *         items: [
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         */
        lbar?: any;

        /**
         * When true, the dock component layout writes
         * height information to the panel's DOM elements based on its shrink wrap height
         * calculation. This ensures that the browser respects the calculated height.
         * When false, the dock component layout will not write heights on the panel or its
         * body element. In some simple layout cases, not writing the heights to the DOM may
         * be desired because this allows the browser to respond to direct DOM manipulations
         * (like animations).
         *
         * Optional, Defaults to: true
         */
        manageHeight?: boolean;

        /**
         * Minimum width of all footer toolbar buttons in pixels. If set, this will be used as the default
         * value for the {@link Ext.button.Button#minWidth} config of each Button added to the **footer toolbar** via the
         * {@link #fbar} or {@link #buttons} configurations. It will be ignored for buttons that have a minWidth configured
         * some other way, e.g. in their own config object or via the {@link Ext.container.Container#defaults defaults} of
         * their parent container.
         */
        minButtonWidth?: number;

        /**
         * True to overlap the header in a panel over the framing of the panel itself. This is needed when frame:true (and
         * is done automatically for you). Otherwise it is undefined. If you manually add rounded corners to a panel header
         * which does not have frame:true, this will need to be set to true.
         */
        overlapHeader?: boolean;

        /**
         * **Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a
         * {@link Ext.layout.container.Border border layout} when not using the ''header'' {@link #collapseMode}.**
         *
         * **Optional.** A Component (or config object for a Component) to show in place of this Panel when this Panel is
         * collapsed by a {@link Ext.layout.container.Border border layout}. Defaults to a generated {@link Ext.panel.Header
         * Header} containing a {@link Ext.panel.Tool Tool} to re-expand the Panel.
         */
        placeholder?: Ext.Component|any;

        /**
         * The {@link Ext.dom.Element#setVisibilityMode mode} for hiding collapsed panels when
         * using {@link #collapseMode} "placeholder".
         */
        placeholderCollapseHideMode?: number;

        /**
         * @deprecated 4.1.0 Use {@link #header} instead.
         * Prevent a Header from being created and shown.
         */
        preventHeader?: boolean;

        /**
         * Convenience config. Short for 'Right Bar' (right-docked, vertical toolbar).
         *
         *     rbar: [
         *       { xtype: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'right',
         *         items: [
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         */
        rbar?: any;

        /**
         * When {@link #cfg-draggable} is 'true', Specify this as 'true' to  cause the 'draggable' config
         * to work the same as it does in {@link Ext.window.Window Window}. This Panel
         * just becomes movable. No DragDrop instances receive any notifications.
         * For example:
         *
         *     @example
         *     var win = Ext.create('widget.window', {
         *         height: 300,
         *         width: 300,
         *         title: 'Constraining Window',
         *         closable: false,
         *         items: {
         *             title: "Floating Panel",
         *             width: 100,
         *             height: 100,
         *             floating: true,
         *             draggable: true,
         *             constrain: true,
         *             simpleDrag: true
         *         }
         *     });
         *     win.show();
         *     // Floating components begin life hidden
         *     win.child('[title=Floating Panel]').show();
         *
         * Optional, Defaults to: false
         */
        simpleDrag?: boolean;

        /**
         * Convenience config. Short for 'Top Bar'.
         *
         *     tbar: [
         *       { xtype: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'top',
         *         items: [
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         */
        tbar?: any;

        /**
         * The title text to be used to display in the {@link Ext.panel.Header panel header}. When a
         * 'title' is specified the {@link Ext.panel.Header} will automatically be created and displayed unless
         * {@link #header} is set to 'false'.
         *
         * Optional, Defaults to: ''
         */
        title?: string;

        /**
         * The alignment of the title text within the available space between the
         * icon and the tools.
         *
         * May be '"left"', '"right"' or '"center"'. Defaults to the browser's natural
         * behavior depending on the css direction property - '"left"' when direction
         * is ltr and '"right"' when direction is rtl
         * (see {@link Ext.AbstractComponent#rtl}).
         *
         * Optional
         */
        titleAlign?: string;

        /**
         * 'true' to allow expanding and collapsing the panel (when '{@link #collapsible} = true') by clicking anywhere in
         * the header bar, 'false') to allow it only by clicking to tool button). When a panel is used in a
         * {@link Ext.layout.container.Border border layout}, the {@link #floatable} option can influence the behavior of collapsing.
         */
        titleCollapse?: boolean;

        /**
         * An array of {@link Ext.panel.Tool} configs/instances to be added to the header tool area. The tools are stored as
         * child components of the header container. They can be accessed using {@link #down} and {#query}, as well as the
         * other component methods. The toggle tool is automatically created if {@link #collapsible} is set to true.
         *
         * Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the
         * visual button. Any required functionality must be provided by adding handlers that implement the necessary
         * behavior.
         *
         * Example usage:
         *
         *     tools:[{
         *         type:'refresh',
         *         tooltip: 'Refresh form Data',
         *         // hidden:true,
         *         handler: function(event, toolEl, panelHeader) {
         *             // refresh logic
         *         }
         *     },
         *     {
         *         type:'help',
         *         tooltip: 'Get Help',
         *         callback: function(panel, tool, event) {
         *             // show help here
         *         }
         *     }]
         *
         * The difference between 'handler' and 'callback' is the signature. For details on
         * the distinction, see {@link Ext.panel.Tool}.
         */
        tools?: any|Ext.panel.Tool;
    }

    /**
     * Panel is a container that has specific functionality and structural components that make it the perfect building
     * block for application-oriented user interfaces.
     *
     * Panels are, by virtue of their inheritance from {@link Ext.container.Container}, capable of being configured with a
     * {@link Ext.container.Container#layout layout}, and containing child Components.
     *
     * When either specifying child {@link #cfg-items} of a Panel, or dynamically {@link Ext.container.Container#method-add adding}
     * Components to a Panel, remember to consider how you wish the Panel to arrange those child elements, and whether those
     * child elements need to be sized using one of Ext's built-in '{@link Ext.container.Container#layout layout}'
     * schemes. By default, Panels use the {@link Ext.layout.container.Auto Auto} scheme. This simply renders child
     * components, appending them one after the other inside the Container, and **does not apply any sizing** at all.
     *
     * {@img Ext.panel.Panel/panel.png Panel components}
     *
     * A Panel may also contain {@link #bbar bottom} and {@link #tbar top} toolbars, along with separate {@link
     * Ext.panel.Header header}, {@link #fbar footer} and body sections.
     *
     * Panel also provides built-in {@link #collapsible collapsible, expandable} and {@link #closable} behavior. Panels can
     * be easily dropped into any {@link Ext.container.Container Container} or layout, and the layout and rendering pipeline
     * is {@link Ext.container.Container#method-add completely managed by the framework}.
     *
     * **Note:** By default, the '{@link #closable close}' header tool _destroys_ the Panel resulting in removal of the
     * Panel and the destruction of any descendant Components. This makes the Panel object, and all its descendants
     * **unusable**. To enable the close tool to simply _hide_ a Panel for later re-use, configure the Panel with
     * '{@link #closeAction closeAction}: 'hide''.
     *
     * Usually, Panels are used as constituents within an application, in which case, they would be used as child items of
     * Containers, and would themselves use Ext.Components as child {@link #cfg-items}. However to illustrate simply rendering a
     * Panel into the document, here's how to do it:
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Hello',
     *         width: 200,
     *         html: '<p>World!</p>',
     *         renderTo: Ext.getBody()
     *     });
     *
     * A more realistic scenario is a Panel created to house input fields which will not be rendered, but used as a
     * constituent part of a Container:
     *
     *     @example
     *     var filterPanel = Ext.create('Ext.panel.Panel', {
     *         bodyPadding: 5,  // Don't want content to crunch against the borders
     *         width: 300,
     *         title: 'Filters',
     *         items: [{
     *             xtype: 'datefield',
     *             fieldLabel: 'Start date'
     *         }, {
     *             xtype: 'datefield',
     *             fieldLabel: 'End date'
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     *
     * Note that the Panel above is configured to render into the document and assigned a size. In a real world scenario,
     * the Panel will often be added inside a Container which will use a {@link #layout} to render, size and position its
     * child Components.
     *
     * Panels will often use specific {@link #layout}s to provide an application with shape and structure by containing and
     * arranging child Components:
     *
     *     @example
     *     var resultsPanel = Ext.create('Ext.panel.Panel', {
     *         title: 'Results',
     *         width: 600,
     *         height: 400,
     *         renderTo: Ext.getBody(),
     *         layout: {
     *             type: 'vbox',       // Arrange child items vertically
     *             align: 'stretch',    // Each takes up full width
     *             padding: 5
     *         },
     *         items: [{               // Results grid specified as a config object with an xtype of 'grid'
     *             xtype: 'grid',
     *             columns: [{header: 'Column One'}],            // One header just for show. There's no data,
     *             store: Ext.create('Ext.data.ArrayStore', {}), // A dummy empty data store
     *             flex: 1                                       // Use 1/3 of Container's height (hint to Box layout)
     *         }, {
     *             xtype: 'splitter'   // A splitter between the two child items
     *         }, {                    // Details Panel specified as a config object (no xtype defaults to 'panel').
     *             title: 'Details',
     *             bodyPadding: 5,
     *             items: [{
     *                 fieldLabel: 'Data item',
     *                 xtype: 'textfield'
     *             }], // An array of form fields
     *             flex: 2             // Use 2/3 of Container's height (hint to Box layout)
     *         }]
     *     });
     *
     * The example illustrates one possible method of displaying search results. The Panel contains a grid with the
     * resulting data arranged in rows. Each selected row may be displayed in detail in the Panel below. The {@link
     * Ext.layout.container.VBox vbox} layout is used to arrange the two vertically. It is configured to stretch child items
     * horizontally to full width. Child items may either be configured with a numeric height, or with a 'flex' value to
     * distribute available space proportionately.
     *
     * This Panel itself may be a child item of, for exaple, a {@link Ext.tab.Panel} which will size its child items to fit
     * within its content area.
     *
     * Using these techniques, as long as the **layout** is chosen and configured correctly, an application may have any
     * level of nested containment, all dynamically sized according to configuration, the user's preference and available
     * browser size.
     */
    export class Panel extends Ext.panel.AbstractPanel implements Ext.panel.PanelConfig {
        /**
         * Only present if this Panel has been configured with {@link #cfg-draggable} 'true'.
         *
         * ##Simple dragging##
         *
         * If this Panel is configured {@link #cfg-simpleDrag} 'true' (the default is 'false'), this property
         * will reference an instance of {@link Ext.util.ComponentDragger} (A subclass of
         * {@link Ext.dd.DragTracker DragTracker}) which handles moving the Panel's DOM Element,
         * and constraining according to the {@link #constrain} and {@link #constrainHeader} .
         *
         * This object fires various events during its lifecycle and during a drag operation.
         *
         * ##Complex dragging interacting with other DragDrop instances##
         *
         * By default, this property in a {@link #cfg-draggable} Panel will contain an instance of {@link
         * Ext.dd.DragSource} which handles dragging the Panel.
         *
         * The developer must provide implementations of the abstract methods of {@link Ext.dd.DragSource} in order to
         * supply behaviour for each stage of the drag/drop process. See {@link #cfg-draggable}.
         */
        dd: Ext.dd.DragSource|Ext.util.ComponentDragger;

        /**
         * 'true' to animate the transition when the panel is collapsed, 'false' to skip the animation (defaults to 'true'
         * if the {@link Ext.fx.Anim} class is available, otherwise 'false'). May also be specified as the animation
         * duration in milliseconds.
         */
        animCollapse: boolean;

        /**
         * Convenience config. Short for 'Bottom Bar'.
         *
         *     bbar: [
         *       { xtype: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'bottom',
         *         items: [
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         */
        bbar: any;

        /**
         * The alignment of any buttons added to this panel. Valid values are 'right', 'left' and 'center' (defaults to
         * 'right' for buttons/fbar, 'left' for other toolbar types).
         *
         * **NOTE:** The prefered way to specify toolbars is to use the dockedItems config. Instead of buttonAlign you
         * would add the layout: { pack: 'start' | 'center' | 'end' } option to the dockedItem config.
         */
        buttonAlign: string;

        /**
         * Convenience config used for adding buttons docked to the bottom of the panel. This is a
         * synonym for the {@link #fbar} config.
         *
         *     buttons: [
         *       { text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'bottom',
         *         ui: 'footer',
         *         defaults: {minWidth: {@link #minButtonWidth}},
         *         items: [
         *             { xtype: 'component', flex: 1 },
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         *
         * The {@link #minButtonWidth} is used as the default {@link Ext.button.Button#minWidth minWidth} for
         * each of the buttons in the buttons toolbar.
         */
        buttons: any;

        /**
         * True to display the 'close' tool button and allow the user to close the window, false to hide the button and
         * disallow closing the window.
         *
         * By default, when close is requested by clicking the close button in the header, the {@link #method-close} method will be
         * called. This will _{@link Ext.Component#method-destroy destroy}_ the Panel and its content meaning that it may not be
         * reused.
         *
         * To make closing a Panel _hide_ the Panel so that it may be reused, set {@link #closeAction} to 'hide'.
         */
        closable: boolean;

        /**
         * The action to take when the close header tool is clicked:
         *
         * - **''{@link #method-destroy}''** :
         *
         *   {@link #method-remove remove} the window from the DOM and {@link Ext.Component#method-destroy destroy} it and all descendant
         *   Components. The window will **not** be available to be redisplayed via the {@link #method-show} method.
         *
         * - **''{@link #method-hide}''** :
         *
         *   {@link #method-hide} the window by setting visibility to hidden and applying negative offsets. The window will be
         *   available to be redisplayed via the {@link #method-show} method.
         *
         * **Note:** This behavior has changed! setting *does* affect the {@link #method-close} method which will invoke the
         * approriate closeAction.
         */
        closeAction: string;

        /**
         * 'true' to render the panel collapsed, 'false' to render it expanded.
         */
        collapsed: boolean;

        /**
         * A CSS class to add to the panel's element after it has been collapsed.
         */
        collapsedCls: string;

        /**
         * The direction to collapse the Panel when the toggle button is clicked.
         *
         * Defaults to the {@link #headerPosition}
         *
         * **Important: This config is _ignored_ for {@link #collapsible} Panels which are direct child items of a {@link
         * Ext.layout.container.Border border layout}.**
         *
         * Specify as ''top'', ''bottom'', ''left'' or ''right''.
         */
        collapseDirection: string;

        /**
         * 'true' to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in
         * the panel's title bar, 'false' to render it last.
         */
        collapseFirst: boolean;

        /**
         * **Important: this config is only effective for {@link #collapsible} Panels which are direct child items of a
         * {@link Ext.layout.container.Border border layout}.**
         *
         * When _not_ a direct child item of a {@link Ext.layout.container.Border border layout}, then the Panel's header
         * remains visible, and the body is collapsed to zero dimensions. If the Panel has no header, then a new header
         * (orientated correctly depending on the {@link #collapseDirection}) will be inserted to show a the title and a re-
         * expand tool.
         *
         * When a child item of a {@link Ext.layout.container.Border border layout}, this config has three possible values:
         *
         * - 'undefined' - When collapsed, a placeholder {@link Ext.panel.Header Header} is injected into the layout to
         *   represent the Panel and to provide a UI with a Tool to allow the user to re-expand the Panel.
         *
         * - '"header"' - The Panel collapses to leave its header visible as when not inside a
         *   {@link Ext.layout.container.Border border layout}.
         *
         * - '"mini"' - The Panel collapses without a visible header.
         */
        collapseMode: string;

        /**
         * True to make the panel collapsible and have an expand/collapse toggle Tool added into the header tool button
         * area. False to keep the panel sized either statically, or by an owning layout manager, with no toggle Tool.
         * When a panel is used in a {@link Ext.layout.container.Border border layout}, the {@link #floatable} option
         * can influence the behavior of collapsing.
         * See {@link #collapseMode} and {@link #collapseDirection}
         */
        collapsible: boolean;

        /**
         * @override
         * True to constrain the panel within its containing element, false to allow it to fall outside of its containing
         * element. By default floating components such as Windows will be rendered to 'document.body'. To render and constrain the window within
         * another element specify {@link #renderTo}. Optionally the header only can be constrained
         * using {@link #constrainHeader}.
         */
        constrain: boolean;

        /**
         * True to constrain the panel header within its containing element (allowing the panel body to fall outside of
         * its containing element) or false to allow the header to fall outside its containing element.
         * Optionally the entire panel can be constrained using {@link #constrain}.
         */
        constrainHeader: boolean;

        /**
         * A component or series of components to be added as docked items to this panel. The docked items can be docked to
         * either the top, right, left or bottom of a panel. This is typically used for things like toolbars or tab bars:
         *
         *     var panel = new Ext.panel.Panel({
         *         dockedItems: [{
         *             xtype: 'toolbar',
         *             dock: 'top',
         *             items: [{
         *                 text: 'Docked to the top'
         *             }]
         *         }]
         *     });
         */
        dockedItems: any;

        /**
         * Convenience config used for adding items to the bottom of the panel. Short for Footer Bar.
         *
         *     fbar: [
         *       { type: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'bottom',
         *         ui: 'footer',
         *         defaults: {minWidth: {@link #minButtonWidth}},
         *         items: [
         *             { xtype: 'component', flex: 1 },
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         *
         * The {@link #minButtonWidth} is used as the default {@link Ext.button.Button#minWidth minWidth} for
         * each of the buttons in the fbar.
         */
        fbar: any;

        /**
         * **Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a
         * {@link Ext.layout.container.Border border layout}.**
         *
         * true to allow clicking a collapsed Panel's {@link #placeholder} to display the Panel floated above the layout,
         * false to force the user to fully expand a collapsed region by clicking the expand button to see it again.
         */
        floatable: boolean;

        /**
         * True to apply a frame to the panel.
         */
        frame: boolean;

        /**
         * True to apply a frame to the panel panels header (if 'frame' is true).
         */
        frameHeader: boolean;

        glyph: number|string;

        /**
         * Pass as 'false' to prevent a Header from being created and shown.
         *
         * Pass as a config object (optionally containing an 'xtype') to custom-configure this Panel's header.
         *
         * See {@link Ext.panel.Header} for all the options that may be specified here.
         *
         * A {@link Ext.panel.Header panel header} is a {@link Ext.container.Container} which contains the Panel's {@link #title} and {@link #tools}.
         * You may also configure the Panel's 'header' option with its own child items which go *before* the {@link #tools}
         *
         * By default the panel {@link #title} is inserted after items configured in this config, but before any tools.
         * To insert the title at any point in the full array, specify the {@link Ext.panel.Header #titlePosition} config:
         *
         *    new Ext.panel.Panel({
         *        title: 'Test',
         *        tools: [{
         *            type: 'refresh
         *        }, {
         *            type: 'help'
         *        }],
         *        titlePosition: 2 // Title will come AFTER the two tools
         *        ...
         *    });
         *
         * Optional
         */
        header: boolean|any;

        /**
         * Optional CSS class to apply to the header element on mouseover
         */
        headerOverCls: string;

        /**
         * Specify as ''top'', ''bottom'', ''left'' or ''right''.
         */
        headerPosition: string;

        /**
         * 'true' to hide the expand/collapse toggle button when '{@link #collapsible} == true', 'false' to display it.
         */
        hideCollapseTool: boolean;

        /**
         * Path to image for an icon in the header. Used for displaying an icon to the left of a title.
         */
        icon: string;

        /**
         * CSS class for an icon in the header. Used for displaying an icon to the left of a title.
         */
        iconCls: string;

        /**
         * Convenience config. Short for 'Left Bar' (left-docked, vertical toolbar).
         *
         *     lbar: [
         *       { xtype: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'left',
         *         items: [
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         */
        lbar: any;

        /**
         * When true, the dock component layout writes
         * height information to the panel's DOM elements based on its shrink wrap height
         * calculation. This ensures that the browser respects the calculated height.
         * When false, the dock component layout will not write heights on the panel or its
         * body element. In some simple layout cases, not writing the heights to the DOM may
         * be desired because this allows the browser to respond to direct DOM manipulations
         * (like animations).
         *
         * Optional, Defaults to: true
         */
        manageHeight: boolean;

        /**
         * Minimum width of all footer toolbar buttons in pixels. If set, this will be used as the default
         * value for the {@link Ext.button.Button#minWidth} config of each Button added to the **footer toolbar** via the
         * {@link #fbar} or {@link #buttons} configurations. It will be ignored for buttons that have a minWidth configured
         * some other way, e.g. in their own config object or via the {@link Ext.container.Container#defaults defaults} of
         * their parent container.
         */
        minButtonWidth: number;

        /**
         * True to overlap the header in a panel over the framing of the panel itself. This is needed when frame:true (and
         * is done automatically for you). Otherwise it is undefined. If you manually add rounded corners to a panel header
         * which does not have frame:true, this will need to be set to true.
         */
        overlapHeader: boolean;

        /**
         * **Important: This config is only effective for {@link #collapsible} Panels which are direct child items of a
         * {@link Ext.layout.container.Border border layout} when not using the ''header'' {@link #collapseMode}.**
         *
         * **Optional.** A Component (or config object for a Component) to show in place of this Panel when this Panel is
         * collapsed by a {@link Ext.layout.container.Border border layout}. Defaults to a generated {@link Ext.panel.Header
         * Header} containing a {@link Ext.panel.Tool Tool} to re-expand the Panel.
         */
        placeholder: Ext.Component|any;

        /**
         * The {@link Ext.dom.Element#setVisibilityMode mode} for hiding collapsed panels when
         * using {@link #collapseMode} "placeholder".
         */
        placeholderCollapseHideMode: number;

        /**
         * @deprecated 4.1.0 Use {@link #header} instead.
         * Prevent a Header from being created and shown.
         */
        preventHeader: boolean;

        /**
         * Convenience config. Short for 'Right Bar' (right-docked, vertical toolbar).
         *
         *     rbar: [
         *       { xtype: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'right',
         *         items: [
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         */
        rbar: any;

        /**
         * When {@link #cfg-draggable} is 'true', Specify this as 'true' to  cause the 'draggable' config
         * to work the same as it does in {@link Ext.window.Window Window}. This Panel
         * just becomes movable. No DragDrop instances receive any notifications.
         * For example:
         *
         *     @example
         *     var win = Ext.create('widget.window', {
         *         height: 300,
         *         width: 300,
         *         title: 'Constraining Window',
         *         closable: false,
         *         items: {
         *             title: "Floating Panel",
         *             width: 100,
         *             height: 100,
         *             floating: true,
         *             draggable: true,
         *             constrain: true,
         *             simpleDrag: true
         *         }
         *     });
         *     win.show();
         *     // Floating components begin life hidden
         *     win.child('[title=Floating Panel]').show();
         *
         * Optional, Defaults to: false
         */
        simpleDrag: boolean;

        /**
         * Convenience config. Short for 'Top Bar'.
         *
         *     tbar: [
         *       { xtype: 'button', text: 'Button 1' }
         *     ]
         *
         * is equivalent to
         *
         *     dockedItems: [{
         *         xtype: 'toolbar',
         *         dock: 'top',
         *         items: [
         *             { xtype: 'button', text: 'Button 1' }
         *         ]
         *     }]
         */
        tbar: any;

        /**
         * The title text to be used to display in the {@link Ext.panel.Header panel header}. When a
         * 'title' is specified the {@link Ext.panel.Header} will automatically be created and displayed unless
         * {@link #header} is set to 'false'.
         *
         * Optional, Defaults to: ''
         */
        title: string;

        /**
         * The alignment of the title text within the available space between the
         * icon and the tools.
         *
         * May be '"left"', '"right"' or '"center"'. Defaults to the browser's natural
         * behavior depending on the css direction property - '"left"' when direction
         * is ltr and '"right"' when direction is rtl
         * (see {@link Ext.AbstractComponent#rtl}).
         *
         * Optional
         */
        titleAlign: string;

        /**
         * 'true' to allow expanding and collapsing the panel (when '{@link #collapsible} = true') by clicking anywhere in
         * the header bar, 'false') to allow it only by clicking to tool button). When a panel is used in a
         * {@link Ext.layout.container.Border border layout}, the {@link #floatable} option can influence the behavior of collapsing.
         */
        titleCollapse: boolean;

        /**
         * An array of {@link Ext.panel.Tool} configs/instances to be added to the header tool area. The tools are stored as
         * child components of the header container. They can be accessed using {@link #down} and {#query}, as well as the
         * other component methods. The toggle tool is automatically created if {@link #collapsible} is set to true.
         *
         * Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the
         * visual button. Any required functionality must be provided by adding handlers that implement the necessary
         * behavior.
         *
         * Example usage:
         *
         *     tools:[{
         *         type:'refresh',
         *         tooltip: 'Refresh form Data',
         *         // hidden:true,
         *         handler: function(event, toolEl, panelHeader) {
         *             // refresh logic
         *         }
         *     },
         *     {
         *         type:'help',
         *         tooltip: 'Get Help',
         *         callback: function(panel, tool, event) {
         *             // show help here
         *         }
         *     }]
         *
         * The difference between 'handler' and 'callback' is the signature. For details on
         * the distinction, see {@link Ext.panel.Tool}.
         */
        tools: any|Ext.panel.Tool;

        /**
         * Add tools to this panel
         * @param {Object[]/Ext.panel.Tool[]} tools The tools to add
         */
        addTool(tools: any|Ext.panel.Tool);

        /**
         * Invoked after the Panel is Collapsed.
         */
        protected afterCollapse(animated: boolean);

        /**
         * Invoked after the Panel is Expanded.
         */
        protected afterExpand(animated: boolean);

        /**
         * Closes the Panel. By default, this method, removes it from the DOM, {@link Ext.Component#method-destroy destroy}s the
         * Panel object and all its descendant Components. The {@link #beforeclose beforeclose} event is fired before the
         * close happens and will cancel the close action if it returns false.
         *
         * **Note:** This method is also affected by the {@link #closeAction} setting. For more explicit control use
         * {@link #method-destroy} and {@link #method-hide} methods.
         */
        close();

        /**
         * Collapses the panel body so that the body becomes hidden. Docked Components parallel to the border towards which
         * the collapse takes place will remain visible. Fires the {@link #beforecollapse} event which will cancel the
         * collapse action if it returns false.
         *
         * @param {String} [direction] The direction to collapse towards. Must be one of
         *
         *   - Ext.Component.DIRECTION_TOP
         *   - Ext.Component.DIRECTION_RIGHT
         *   - Ext.Component.DIRECTION_BOTTOM
         *   - Ext.Component.DIRECTION_LEFT
         *
         * Defaults to {@link #collapseDirection}.
         *
         * @param {Boolean} [animate] True to animate the transition, else false
         * (defaults to the value of the {@link #animCollapse} panel config). May
         * also be specified as the animation duration in milliseconds.
         * @return {Ext.panel.Panel} this
         */
        collapse(direction?: string, animate?: boolean): Ext.panel.Panel;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * converts a collapsdDir into an anchor argument for Element.slideIn
         * overridden in rtl mode to switch "l" and "r"
         */
        convertCollapseDir();

        /**
         * Expands the panel body so that it becomes visible.  Fires the {@link #beforeexpand} event which will
         * cancel the expand action if it returns false.
         * @param {Boolean} [animate] True to animate the transition, else false
         * (defaults to the value of the {@link #animCollapse} panel config).  May
         * also be specified as the animation duration in milliseconds.
         * @return {Ext.panel.Panel} this
         */
        expand(animate?: boolean): Ext.panel.Panel;

        /**
         * Returns the current collapsed state of the panel.
         * @return {Boolean/String} False when not collapsed, otherwise the value of {@link #collapseDirection}.
         */
        getCollapsed(): boolean|string;

        /**
         * Gets the {@link Ext.panel.Header Header} for this panel.
         */
        getHeader();

        protected isLayoutRoot();

        /**
         * Set the glyph for the panel's header. See {@link Ext.panel.Header#glyph}. It will
         * fire the {@link #glyphchange} event after completion.
         * @param {Number/String} newGlyph The new glyph
         * This parameter expects a format consistent with that of {@link #glyph}
         */
        setGlyph(newGlyph: number|string);

        /**
         * Set the icon for the panel's header. See {@link Ext.panel.Header#icon}. It will fire the
         * {@link #iconchange} event after completion.
         * @param {String} newIcon The new icon path
         */
        setIcon(newIcon: string);

        /**
         * Set the iconCls for the panel's header. See {@link Ext.panel.Header#iconCls}. It will fire the
         * {@link #iconclschange} event after completion.
         * @param {String} newIconCls The new CSS class name
         */
        setIconCls(newIconCls: string);

        /**
         * Set a title for the panel's header. See {@link Ext.panel.Header#title}.
         */
        setTitle(newTitle: string);

        /**
         * Shortcut for performing an {@link #method-expand} or {@link #method-collapse} based on the current state of the panel.
         * @return {Ext.panel.Panel} this
         */
        toggleCollapse(): Ext.panel.Panel;

        /**
         * Fires before the user closes the panel. Return false from any listener to stop the close event being
         * fired
         * @param {Ext.panel.Panel} panel The Panel object
         */
        beforeclose(panel: Ext.panel.Panel);

        /**
         * Fires before this panel is collapsed. Return false to prevent the collapse.
         * @param {Ext.panel.Panel} p The Panel being collapsed.
         * @param {String} direction . The direction of the collapse. One of
         *
         *   - Ext.Component.DIRECTION_TOP
         *   - Ext.Component.DIRECTION_RIGHT
         *   - Ext.Component.DIRECTION_BOTTOM
         *   - Ext.Component.DIRECTION_LEFT
         *
         * @param {Boolean} animate True if the collapse is animated, else false.
         */
        beforecollapse(p: Ext.panel.Panel, direction: string, animate: boolean);

        /**
         * Fires before this panel is expanded. Return false to prevent the expand.
         * @param {Ext.panel.Panel} p The Panel being expanded.
         * @param {Boolean} animate True if the expand is animated, else false.
         */
        beforeexpand(p: Ext.panel.Panel, animate: boolean);

        /**
         * Fires after a collapsed Panel has been "floated" by clicking on
         * it's header. Only applicable when the Panel is an item in a
         * {@link Ext.layout.container.Border Border Layout}.
         */
        float();

        /**
         * Fired when the Panel glyph has been changed by the {@link #setGlyph} method.
         */
        glyphchange(that: Ext.panel.Panel, newGlyph: number|string, oldGlyph: number|string);

        /**
         * Fires after the Panel icon has been set or changed.
         * @param {Ext.panel.Panel} p The Panel which has the icon changed.
         * @param {String} newIcon The path to the new icon image.
         * @param {String} oldIcon The path to the previous panel icon image.
         */
        iconchange(p: Ext.panel.Panel, newIcon: string, oldIcon: string);

        /**
         * Fires after the Panel iconCls has been set or changed.
         * @param {Ext.panel.Panel} p The Panel which has the iconCls changed.
         * @param {String} newIconCls The new iconCls.
         * @param {String} oldIconCls The previous panel iconCls.
         */
        iconclschange(p: Ext.panel.Panel, newIconCls: string, oldIconCls: string);

        /**
         * Fires after the Panel title has been set or changed.
         * @param {Ext.panel.Panel} p the Panel which has been resized.
         * @param {String} newTitle The new title.
         * @param {String} oldTitle The previous panel title.
         */
        titlechange(p: Ext.panel.Panel, newTitle: string, oldTitle: string);

        /**
         * Fires after a "floated" Panel has returned to it's collapsed state
         * as a result of the mouse leaving the Panel. Only applicable when
         * the Panel is an item in a
         * {@link Ext.layout.container.Border Border Layout}.
         */
        unfloat();
    }

    interface ProxyConfig {
        /**
         * True to insert a placeholder proxy element while dragging the panel, false to drag with no proxy.
         * Most Panels are not absolute positioned and therefore we need to reserve this space.
         */
        insertProxy?: boolean;

        /**
         * True to move the panel to the dragged position when dropped
         *
         * Optional, Defaults to: true
         */
        moveOnDrag?: boolean;
    }

    /**
     * A custom drag proxy implementation specific to {@link Ext.panel.Panel}s. This class
     * is primarily used internally for the Panel's drag drop implementation, and
     * should never need to be created directly.
     */
    export class Proxy extends Ext.Base implements Ext.panel.ProxyConfig {
        panel: Ext.panel.Panel;

        /**
         * True to insert a placeholder proxy element while dragging the panel, false to drag with no proxy.
         * Most Panels are not absolute positioned and therefore we need to reserve this space.
         */
        insertProxy: boolean;

        /**
         * True to move the panel to the dragged position when dropped
         *
         * Optional, Defaults to: true
         */
        moveOnDrag: boolean;

        /**
         * Creates new panel proxy.
         * @param {Ext.panel.Panel} panel The {@link Ext.panel.Panel} to proxy for
         * @param {Object} [config] Config object
         */
        constructor(panel: Ext.panel.Panel, config?: Ext.panel.ProxyConfig);

        /**
         * Gets the proxy's element
         * @return {Ext.Element} The proxy's element
         */
        getEl(): Ext.dom.Element;

        /**
         * Gets the proxy's ghost Panel
         * @return {Ext.panel.Panel} The proxy's ghost Panel
         */
        getGhost(): Ext.panel.Panel;

        /**
         * Gets the proxy element. This is the element that represents where the
         * Panel was before we started the drag operation.
         * @return {Ext.Element} The proxy's element
         */
        getProxy(): Ext.dom.Element;

        /**
         * Hides the proxy
         */
        hide();

        /**
         * Moves the proxy to a different position in the DOM.  This is typically
         * called while dragging the Panel to keep the proxy sync'd to the Panel's
         * location.
         * @param {HTMLElement} parentNode The proxy's parent DOM node
         * @param {HTMLElement} [before] The sibling node before which the
         * proxy should be inserted. Defaults to the parent's last child if not
         * specified.
         */
        moveProxy(parentNode: HTMLElement, before?: HTMLElement);

        /**
         * Shows the proxy
         */
        show();
    }

    interface TableConfig extends Ext.panel.PanelConfig {
        /**
         * True to allow deselecting a record. This config is forwarded to {@link Ext.selection.Model#allowDeselect}.
         *
         * Optional, Defaults to: false
         */
        allowDeselect?: boolean;

        /**
         * Adds column line styling
         */
        columnLines?: boolean;

        /**
         * An array of {@link Ext.grid.column.Column column} definition objects which define all columns that appear in this
         * grid. Each column definition provides the header text for the column, and a definition of where the data for that
         * column comes from.
         *
         * This can also be a configuration object for a {Ext.grid.header.Container HeaderContainer} which may override
         * certain default configurations if necessary. For example, the special layout may be overridden to use a simpler
         * layout, or one can set default values shared by all columns:
         *
         *     columns: {
         *         items: [
         *             {
         *                 text: "Column A"
         *                 dataIndex: "field_A"
         *             },{
         *                 text: "Column B",
         *                 dataIndex: "field_B"
         *             },
         *             ...
         *         ],
         *         defaults: {
         *             flex: 1
         *         }
         *     }
         */
        columns?: Ext.grid.column.Column|any;

        /**
         * Defaults to true to enable deferred row rendering.
         *
         * This allows the View to execute a refresh quickly, with the expensive update of the row structure deferred so
         * that layouts with GridPanels appear, and lay out more quickly.
         */
        deferRowRender?: boolean;

        /**
         * True to disable selection model.
         *
         * Optional, Defaults to: false
         */
        disableSelection?: boolean;

        /**
         * Default text (html tags are accepted) to display in the Panel body when the Store
         * is empty. When specified, and the Store is empty, the text will be rendered inside a DIV with the CSS class "x-grid-empty".
         */
        emptyText?: string;

        /**
         * False to disable column hiding within this grid.
         *
         * Optional, Defaults to: true
         */
        enableColumnHide?: boolean;

        /**
         * False to disable column dragging within this grid.
         *
         * Optional, Defaults to: true
         */
        enableColumnMove?: boolean;

        /**
         * False to disable column resizing within this grid.
         *
         * Optional, Defaults to: true
         */
        enableColumnResize?: boolean;

        /**
         * Configure as 'true' to enable locking support for this grid. Alternatively, locking will also be automatically
         * enabled if any of the columns in the {@link #columns columns} configuration contain a {@link Ext.grid.column.Column#locked locked} config option.
         *
         * A locking grid is processed in a special way. The configuration options are cloned and *two* grids are created to be the locked (left) side
         * and the normal (right) side. This Panel becomes merely a {@link Ext.container.Container container} which arranges both in an {@link Ext.layout.container.HBox HBox} layout.
         *
         * {@link #plugins Plugins} may be targeted at either locked, or unlocked grid, or, both, in which case the plugin is cloned and used on both sides.
         *
         * Plugins may also be targeted at the containing locking Panel.
         *
         * This is configured by specifying a 'lockableScope' property in your plugin which may have the following values:
         *
         *  * '"both"' (the default) - The plugin is added to both grids
         *  * '"top"' - The plugin is added to the containing Panel
         *  * '"locked"' - The plugin is added to the locked (left) grid
         *  * '"normal"' - The plugin is added to the normal (right) grid
         *
         * If 'both' is specified, then each copy of the plugin gains a property 'lockingPartner' which references its sibling on the other side so that they
         * can synchronize operations is necessary.
         *
         * {@link #features Features} may also be configured with 'lockableScope' and may target the locked grid, the normal grid or both grids. Features
         * also get a 'lockingPartner' reference injected.
         *
         * Optional, Defaults to: false
         */
        enableLocking?: boolean;

        /**
         * An array of grid Features to be added to this grid. Can also be just a single feature instead of array.
         *
         * Features config behaves much like {@link #plugins}.
         * A feature can be added by either directly referencing the instance:
         *
         *     features: [Ext.create('Ext.grid.feature.GroupingSummary', {groupHeaderTpl: 'Subject: {name}'})],
         *
         * By using config object with ftype:
         *
         *     features: [{ftype: 'groupingsummary', groupHeaderTpl: 'Subject: {name}'}],
         *
         * Or with just a ftype:
         *
         *     features: ['grouping', 'groupingsummary'],
         *
         * See {@link Ext.enums.Feature} for list of all ftypes.
         */
        features?: Ext.grid.feature.Feature|any|Ext.enums.Feature;

        /**
         * True to force the columns to fit into the available width. Headers are first sized according to configuration,
         * whether that be a specific width, or flex. Then they are all proportionally changed in width so that the entire
         * content width is used. For more accurate control, it is more optimal to specify a flex setting on the columns
         * that are to be stretched & explicit widths on columns that are not.
         */
        forceFit?: boolean;

        /**
         * True to hide column headers.
         *
         * Optional, Defaults to: false
         */
        hideHeaders?: boolean;

        layout?: any;

        /**
         * True to enable 'MULTI' selection mode on selection model.
         * @deprecated 4.1.1 Use {@link Ext.selection.Model#mode} 'MULTI' instead.
         *
         * Optional, Defaults to: false
         */
        multiSelect?: boolean;

        /**
         * Adds row line styling
         *
         * Optional, Defaults to: true
         */
        rowLines?: boolean;

        /**
         * Scrollers configuration. Valid values are 'both', 'horizontal' or 'vertical'.
         * True implies 'both'. False implies 'none'.
         */
        scroll?: string|boolean;

        /**
         * True to constrain column dragging so that a column cannot be dragged in or out of it's
         * current group. Only relevant while {@link #enableColumnMove} is enabled.
         *
         * Optional, Defaults to: false
         */
        sealedColumns?: boolean;

        /**
         * A {@link Ext.selection.Model selection model} instance or config object.  In latter case the {@link #selType}
         * config option determines to which type of selection model this config is applied.
         */
        selModel?: Ext.selection.Model|any;

        /**
         * An xtype of selection model to use. Defaults to 'rowmodel'. This is used to create selection model if just
         * a config object or nothing at all given in {@link #selModel} config.
         */
        selType?: string;

        /**
         * True to enable 'SIMPLE' selection mode on selection model.
         * @deprecated 4.1.1 Use {@link Ext.selection.Model#mode} 'SIMPLE' instead.
         *
         * Optional, Defaults to: false
         */
        simpleSelect?: boolean;

        /**
         * False to disable column sorting via clicking the header and via the Sorting menu items.
         */
        sortableColumns?: boolean;

        /**
         * (required)
         * The {@link Ext.data.Store Store} the grid should use as its data source.
         */
        store?: Ext.data.Store;

        /**
         * A config object to be used when configuring the {@link Ext.grid.plugin.BufferedRenderer scroll monitor} to control
         * refreshing of data in an "infinite grid".
         *
         * Configurations of this object allow fine tuning of data caching which can improve performance and usability
         * of the infinite grid.
         */
        verticalScroller?: any;

        /**
         * The {@link Ext.view.Table} used by the grid. Use {@link #viewConfig} to just supply some config options to
         * view (instead of creating an entire View instance).
         */
        view?: Ext.view.Table;

        /**
         * A config object that will be applied to the grid's UI view. Any of the config options available for
         * {@link Ext.view.Table} can be specified here. This option is ignored if {@link #view} is specified.
         */
        viewConfig?: any;
    }

    /**
     * @author Nicolas Ferrero
     *
     * TablePanel is the basis of both {@link Ext.tree.Panel TreePanel} and {@link Ext.grid.Panel GridPanel}.
     *
     * TablePanel aggregates:
     *
     *  - a Selection Model
     *  - a View
     *  - a Store
     *  - Scrollers
     *  - Ext.grid.header.Container
     *
     * @mixins Ext.grid.locking.Lockable
     */
    export class Table extends Ext.panel.Panel implements Ext.panel.TableConfig {
        /**
         * True to indicate that a view has been injected into the panel.
         */
        hasView: boolean;

        /**
         * If you are writing a grid plugin or a {Ext.grid.feature.Feature Feature} which creates a column-based structure which
         * needs a view refresh when columns are moved, then set this property in the grid.
         *
         * An example is the built in {@link Ext.grid.feature.AbstractSummary Summary} Feature. This creates summary rows, and the
         * summary columns must be in the same order as the data columns. This plugin sets the 'optimizedColumnMove' to 'false.
         */
        optimizedColumnMove: boolean;

        /**
         * True to allow deselecting a record. This config is forwarded to {@link Ext.selection.Model#allowDeselect}.
         *
         * Optional, Defaults to: false
         */
        allowDeselect: boolean;

        /**
         * Adds column line styling
         */
        columnLines: boolean;

        /**
         * An array of {@link Ext.grid.column.Column column} definition objects which define all columns that appear in this
         * grid. Each column definition provides the header text for the column, and a definition of where the data for that
         * column comes from.
         *
         * This can also be a configuration object for a {Ext.grid.header.Container HeaderContainer} which may override
         * certain default configurations if necessary. For example, the special layout may be overridden to use a simpler
         * layout, or one can set default values shared by all columns:
         *
         *     columns: {
         *         items: [
         *             {
         *                 text: "Column A"
         *                 dataIndex: "field_A"
         *             },{
         *                 text: "Column B",
         *                 dataIndex: "field_B"
         *             },
         *             ...
         *         ],
         *         defaults: {
         *             flex: 1
         *         }
         *     }
         */
        columns: Ext.grid.column.Column|any;

        /**
         * Defaults to true to enable deferred row rendering.
         *
         * This allows the View to execute a refresh quickly, with the expensive update of the row structure deferred so
         * that layouts with GridPanels appear, and lay out more quickly.
         */
        deferRowRender: boolean;

        /**
         * True to disable selection model.
         *
         * Optional, Defaults to: false
         */
        disableSelection: boolean;

        /**
         * Default text (html tags are accepted) to display in the Panel body when the Store
         * is empty. When specified, and the Store is empty, the text will be rendered inside a DIV with the CSS class "x-grid-empty".
         */
        emptyText: string;

        /**
         * False to disable column hiding within this grid.
         *
         * Optional, Defaults to: true
         */
        enableColumnHide: boolean;

        /**
         * False to disable column dragging within this grid.
         *
         * Optional, Defaults to: true
         */
        enableColumnMove: boolean;

        /**
         * False to disable column resizing within this grid.
         *
         * Optional, Defaults to: true
         */
        enableColumnResize: boolean;

        /**
         * Configure as 'true' to enable locking support for this grid. Alternatively, locking will also be automatically
         * enabled if any of the columns in the {@link #columns columns} configuration contain a {@link Ext.grid.column.Column#locked locked} config option.
         *
         * A locking grid is processed in a special way. The configuration options are cloned and *two* grids are created to be the locked (left) side
         * and the normal (right) side. This Panel becomes merely a {@link Ext.container.Container container} which arranges both in an {@link Ext.layout.container.HBox HBox} layout.
         *
         * {@link #plugins Plugins} may be targeted at either locked, or unlocked grid, or, both, in which case the plugin is cloned and used on both sides.
         *
         * Plugins may also be targeted at the containing locking Panel.
         *
         * This is configured by specifying a 'lockableScope' property in your plugin which may have the following values:
         *
         *  * '"both"' (the default) - The plugin is added to both grids
         *  * '"top"' - The plugin is added to the containing Panel
         *  * '"locked"' - The plugin is added to the locked (left) grid
         *  * '"normal"' - The plugin is added to the normal (right) grid
         *
         * If 'both' is specified, then each copy of the plugin gains a property 'lockingPartner' which references its sibling on the other side so that they
         * can synchronize operations is necessary.
         *
         * {@link #features Features} may also be configured with 'lockableScope' and may target the locked grid, the normal grid or both grids. Features
         * also get a 'lockingPartner' reference injected.
         *
         * Optional, Defaults to: false
         */
        enableLocking: boolean;

        /**
         * An array of grid Features to be added to this grid. Can also be just a single feature instead of array.
         *
         * Features config behaves much like {@link #plugins}.
         * A feature can be added by either directly referencing the instance:
         *
         *     features: [Ext.create('Ext.grid.feature.GroupingSummary', {groupHeaderTpl: 'Subject: {name}'})],
         *
         * By using config object with ftype:
         *
         *     features: [{ftype: 'groupingsummary', groupHeaderTpl: 'Subject: {name}'}],
         *
         * Or with just a ftype:
         *
         *     features: ['grouping', 'groupingsummary'],
         *
         * See {@link Ext.enums.Feature} for list of all ftypes.
         */
        features: Ext.grid.feature.Feature|any|Ext.enums.Feature;

        /**
         * True to force the columns to fit into the available width. Headers are first sized according to configuration,
         * whether that be a specific width, or flex. Then they are all proportionally changed in width so that the entire
         * content width is used. For more accurate control, it is more optimal to specify a flex setting on the columns
         * that are to be stretched & explicit widths on columns that are not.
         */
        forceFit: boolean;

        /**
         * True to hide column headers.
         *
         * Optional, Defaults to: false
         */
        hideHeaders: boolean;

        layout: Ext.enums.Layout|any;

        /**
         * True to enable 'MULTI' selection mode on selection model.
         * @deprecated 4.1.1 Use {@link Ext.selection.Model#mode} 'MULTI' instead.
         *
         * Optional, Defaults to: false
         */
        multiSelect: boolean;

        /**
         * Adds row line styling
         *
         * Optional, Defaults to: true
         */
        rowLines: boolean;

        /**
         * Scrollers configuration. Valid values are 'both', 'horizontal' or 'vertical'.
         * True implies 'both'. False implies 'none'.
         */
        scroll: string|boolean;

        /**
         * True to constrain column dragging so that a column cannot be dragged in or out of it's
         * current group. Only relevant while {@link #enableColumnMove} is enabled.
         *
         * Optional, Defaults to: false
         */
        sealedColumns: boolean;

        /**
         * A {@link Ext.selection.Model selection model} instance or config object.  In latter case the {@link #selType}
         * config option determines to which type of selection model this config is applied.
         */
        selModel: Ext.selection.Model|any;

        /**
         * An xtype of selection model to use. Defaults to 'rowmodel'. This is used to create selection model if just
         * a config object or nothing at all given in {@link #selModel} config.
         */
        selType: string;

        /**
         * True to enable 'SIMPLE' selection mode on selection model.
         * @deprecated 4.1.1 Use {@link Ext.selection.Model#mode} 'SIMPLE' instead.
         *
         * Optional, Defaults to: false
         */
        simpleSelect: boolean;

        /**
         * False to disable column sorting via clicking the header and via the Sorting menu items.
         */
        sortableColumns: boolean;

        /**
         * (required)
         * The {@link Ext.data.Store Store} the grid should use as its data source.
         */
        store: Ext.data.Store;

        /**
         * A config object to be used when configuring the {@link Ext.grid.plugin.BufferedRenderer scroll monitor} to control
         * refreshing of data in an "infinite grid".
         *
         * Configurations of this object allow fine tuning of data caching which can improve performance and usability
         * of the infinite grid.
         */
        verticalScroller: any;

        /**
         * The {@link Ext.view.Table} used by the grid. Use {@link #viewConfig} to just supply some config options to
         * view (instead of creating an entire View instance).
         */
        view: Ext.view.Table;

        /**
         * A config object that will be applied to the grid's UI view. Any of the config options available for
         * {@link Ext.view.Table} can be specified here. This option is ignored if {@link #view} is specified.
         */
        viewConfig: any;

        /**
         * An xtype of view to use. This is automatically set to 'gridview' by {@link Ext.grid.Panel Grid}
         * and to 'treeview' by {@link Ext.tree.Panel Tree}.
         */
        protected viewType: string;

        applyState(state: any);

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * This method is obsolete in 4.1. The closest equivalent in
         * 4.1 is {@link #doLayout}, but it is also possible that no
         * layout is needed.
         * @deprecated 4.1
         */
        determineScrollbars();

        /**
         * Returns the selection model being used and creates it via the configuration if it has not been created already.
         * @return {Ext.selection.Model} selModel
         */
        getSelectionModel(): Ext.selection.Model;

        /**
         * Returns the store associated with this Panel.
         * @return {Ext.data.Store} The store
         */
        getStore(): Ext.data.Store;

        /**
         * Gets the view for this panel.
         * @return {Ext.view.Table}
         */
        getView(): Ext.view.Table;

        /**
         * This method is obsolete in 4.1. The closest equivalent in 4.1 is
         * {@link Ext.AbstractComponent#updateLayout}, but it is also possible that no layout
         * is needed.
         * @deprecated 4.1
         */
        invalidateScroller();

        protected onDestroy();

        beforecellclick();

        beforecellcontextmenu();

        beforecelldblclick();

        beforecellkeydown();

        beforecellmousedown();

        beforecellmouseup();

        beforecontainerclick();

        beforecontainercontextmenu();

        beforecontainerdblclick();

        beforecontainermousedown();

        beforecontainermouseout();

        beforecontainermouseover();

        beforecontainermouseup();

        beforedeselect();

        beforeitemclick();

        beforeitemcontextmenu();

        beforeitemdblclick();

        beforeitemmousedown();

        beforeitemmouseenter();

        beforeitemmouseleave();

        beforeitemmouseup();

        beforeselect();

        cellclick();

        cellcontextmenu();

        celldblclick();

        cellkeydown();

        cellmousedown();

        cellmouseup();

        columnhide();

        columnmove();

        columnresize();

        columnschanged();

        columnshow();

        containerclick();

        containercontextmenu();

        containerdblclick();

        containermouseout();

        containermouseover();

        containermouseup();

        deselect();

        filterchange();

        headerclick();

        headercontextmenu();

        headertriggerclick();

        itemclick();

        itemcontextmenu();

        itemdblclick();

        itemmousedown();

        itemmouseenter();

        itemmouseleave();

        itemmouseup();

        select();

        selectionchange();

        sortchange();

        /**
         * Fires when the grid view is available (use this for selecting a default row).
         */
        viewready(that: Ext.panel.Table);
    }

    interface ToolConfig extends Ext.ComponentConfig {
        baseCls?: any;

        /**
         * A function to execute when the tool is clicked.
         * The logical owner of the tool. In a typical
         * 'Ext.panel.Panel', this is set to the owning panel. This value comes from the
         * 'toolOwner' config.
         * The tool that is calling.
         * The click event.
         * @since 4.2
         */
        callback?: Function;

        disabledCls?: any;

        /**
         * A function to execute when the tool is clicked. Arguments passed are:
         *
         * - **event** : Ext.EventObject - The click event.
         * - **toolEl** : Ext.Element - The tool Element.
         * - **owner** : Ext.panel.Header - The host panel header.
         * - **tool** : Ext.panel.Tool - The tool object
         */
        handler?: Function;

        height?: any;

        /**
         * The scope to execute the {@link #callback} or {@link #handler} function. Defaults
         * to the tool.
         */
        scope?: any;

        /**
         * Specify as false to allow click event to propagate.
         */
        stopEvent?: boolean;

        /**
         * The owner to report to the 'callback' method. Default is 'null' for the 'ownerCt'.
         * @since 4.2
         */
        toolOwner?: Ext.Component;

        /**
         * The tooltip for the tool - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config
         * object
         */
        tooltip?: string|any;

        /**
         * The type of tooltip to use. Either 'qtip' (default) for QuickTips or 'title' for title attribute.
         */
        tooltipType?: string;

        /**
         * The type of tool to render. The following types are available:
         *
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-close"></span> close
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-minimize"></span> minimize
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-maximize"></span> maximize
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-restore"></span> restore
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-toggle"></span> toggle
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-gear"></span> gear
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-prev"></span> prev
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-next"></span> next
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-pin"></span> pin
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-unpin"></span> unpin
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-right"></span> right
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-left"></span> left
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-down"></span> down
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-up"></span> up
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-refresh"></span> refresh
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-plus"></span> plus
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-minus"></span> minus
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-search"></span> search
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-save"></span> save
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-help"></span> help
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-print"></span> print
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-expand"></span> expand
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-collapse"></span> collapse
         */
        type?: string;

        width?: any;
    }

    /**
     * This class is used to display small visual icons in the header of a panel. There are a set of
     * 25 icons that can be specified by using the {@link #type} config. The {@link #callback} config
     * can be used to provide a function that will respond to any click events. In general, this class
     * will not be instantiated directly, rather it will be created by specifying the {@link Ext.panel.Panel#tools}
     * configuration on the Panel itself.
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         width: 200,
     *         height: 200,
     *         renderTo: document.body,
     *         title: 'A Panel',
     *         tools: [{
     *             type: 'help',
     *             callback: function() {
     *                 // show help here
     *             }
     *         }, {
     *             itemId: 'refresh',
     *             type: 'refresh',
     *             hidden: true,
     *             callback: function() {
     *                 // do refresh
     *             }
     *         }, {
     *             type: 'search',
     *             callback: function (panel) {
     *                 // do search
     *                 panel.down('#refresh').show();
     *             }
     *         }]
     *     });
     *
     * The 'callback' config was added in Ext JS 4.2.1 as an alternative to {@link #handler}
     * to provide a more convenient list of arguments. In Ext JS 4.2.1 it is also possible to
     * pass a method name instead of a direct function:
     *
     *      tools: [{
     *          type: 'help',
     *          callback: 'onHelp',
     *          scope: this
     *      },
     *      ...
     *
     * The 'callback' (or 'handler') name is looked up on the 'scope' which will also be the
     * 'this' reference when the method is called.
     */
    export class Tool extends Ext.Component implements Ext.panel.ToolConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Tool, or subclass thereof.
         */
        isTool: boolean;

        baseCls: string;

        /**
         * A function to execute when the tool is clicked.
         * The logical owner of the tool. In a typical
         * 'Ext.panel.Panel', this is set to the owning panel. This value comes from the
         * 'toolOwner' config.
         * The tool that is calling.
         * The click event.
         * @since 4.2
         */
        callback: Function;

        disabledCls: string;

        /**
         * A function to execute when the tool is clicked. Arguments passed are:
         *
         * - **event** : Ext.EventObject - The click event.
         * - **toolEl** : Ext.Element - The tool Element.
         * - **owner** : Ext.panel.Header - The host panel header.
         * - **tool** : Ext.panel.Tool - The tool object
         */
        handler: Function;

        height: number;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The scope to execute the {@link #callback} or {@link #handler} function. Defaults
         * to the tool.
         */
        scope: any;

        /**
         * Specify as false to allow click event to propagate.
         */
        stopEvent: boolean;

        /**
         * The owner to report to the 'callback' method. Default is 'null' for the 'ownerCt'.
         * @since 4.2
         */
        toolOwner: Ext.Component;

        /**
         * The tooltip for the tool - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config
         * object
         */
        tooltip: string|any;

        /**
         * The type of tooltip to use. Either 'qtip' (default) for QuickTips or 'title' for title attribute.
         */
        tooltipType: string;

        /**
         * The type of tool to render. The following types are available:
         *
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-close"></span> close
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-minimize"></span> minimize
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-maximize"></span> maximize
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-restore"></span> restore
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-toggle"></span> toggle
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-gear"></span> gear
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-prev"></span> prev
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-next"></span> next
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-pin"></span> pin
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-unpin"></span> unpin
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-right"></span> right
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-left"></span> left
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-down"></span> down
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-up"></span> up
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-refresh"></span> refresh
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-plus"></span> plus
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-minus"></span> minus
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-search"></span> search
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-save"></span> save
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-help"></span> help
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-print"></span> print
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-expand"></span> expand
         * - <span class="x-tool"><img src="data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==" class="x-tool-collapse"></span> collapse
         */
        type: string;

        width: number;

        protected afterRender();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected initComponent();

        protected onDestroy();

        /**
         * Sets the type of the tool. Allows the icon to be changed.
         * @param {String} type The new type. See the {@link #type} config.
         * @return {Ext.panel.Tool} this
         */
        setType(type: string): Ext.panel.Tool;

        /**
         * Fires when the tool is clicked
         * @param {Ext.EventObject} e The event object
         */
        click(that: Ext.panel.Tool, e: Ext.EventObject);
    }
}

declare module Ext.perf {
    export class Accumulator extends Ext.Base {
    }

    export class Monitor {
    }
}

declare module Ext.picker {
    interface ColorConfig extends Ext.ComponentConfig {
        /**
         * If set to true then reselecting a color that is already selected fires the {@link #event-select} event
         */
        allowReselect?: boolean;

        /**
         * The DOM event that will cause a color to be selected. This can be any valid event name (dblclick, contextmenu).
         */
        clickEvent?: string;

        /**
         * The CSS class to apply to the containing element.
         *
         * Optional, Defaults to: 'x-color-picker'
         */
        componentCls?: string;

        /**
         * A function that will handle the select event of this picker. The handler is passed the following parameters:
         *
         * - 'picker' : ColorPicker
         *
         *   The {@link Ext.picker.Color picker}.
         *
         * - 'color' : String
         *
         *   The 6-digit color hex code (without the # symbol).
         */
        handler?: Function;

        /**
         * The CSS class to apply to the color picker's items
         */
        itemCls?: string;

        /**
         * The scope ('this' reference) in which the '{@link #handler}' function will be called.
         *
         * Defaults to this Color picker instance.
         */
        scope?: any;

        /**
         * The CSS class to apply to the selected element
         *
         * Optional, Defaults to: 'x-color-picker-selected'
         */
        selectedCls?: string;

        /**
         * The initial color to highlight (should be a valid 6-digit color hex code without the # symbol). Note that the hex
         * codes are case-sensitive.
         */
        value?: string;
    }

    /**
     * Color picker provides a simple color palette for choosing colors. The picker can be rendered to any container. The
     * available default to a standard 40-color palette; this can be customized with the {@link #colors} config.
     *
     * Typically you will need to implement a handler function to be notified when the user chooses a color from the picker;
     * you can register the handler using the {@link #event-select} event, or by implementing the {@link #handler} method.
     *
     *     @example
     *     Ext.create('Ext.picker.Color', {
     *         value: '993300',  // initial selected color
     *         renderTo: Ext.getBody(),
     *         listeners: {
     *             select: function(picker, selColor) {
     *                 alert(selColor);
     *             }
     *         }
     *     });
     */
    export class Color extends Ext.Component implements Ext.picker.ColorConfig {
        /**
         * An array of 6-digit color hex code strings (without the # symbol). This array can contain any number of colors,
         * and each hex code should be unique. The width of the picker is controlled via CSS by adjusting the width property
         * of the 'x-color-picker' class (or assigning a custom class), so you can balance the number of colors with the
         * width setting until the box is symmetrical.
         *
         * You can override individual colors if needed:
         *
         *     var cp = new Ext.picker.Color();
         *     cp.colors[0] = 'FF0000';  // change the first box to red
         *
         * Or you can provide a custom array of your own for complete control:
         *
         *     var cp = new Ext.picker.Color();
         *     cp.colors = ['000000', '993300', '333300'];
         */
        colors: string;

        /**
         * If set to true then reselecting a color that is already selected fires the {@link #event-select} event
         */
        allowReselect: boolean;

        /**
         * The DOM event that will cause a color to be selected. This can be any valid event name (dblclick, contextmenu).
         */
        clickEvent: string;

        /**
         * The CSS class to apply to the containing element.
         *
         * Optional, Defaults to: 'x-color-picker'
         */
        componentCls: string;

        /**
         * A function that will handle the select event of this picker. The handler is passed the following parameters:
         *
         * - 'picker' : ColorPicker
         *
         *   The {@link Ext.picker.Color picker}.
         *
         * - 'color' : String
         *
         *   The 6-digit color hex code (without the # symbol).
         */
        handler: Function;

        /**
         * The CSS class to apply to the color picker's items
         */
        itemCls: string;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The scope ('this' reference) in which the '{@link #handler}' function will be called.
         *
         * Defaults to this Color picker instance.
         */
        scope: any;

        /**
         * The CSS class to apply to the selected element
         *
         * Optional, Defaults to: 'x-color-picker-selected'
         */
        selectedCls: string;

        /**
         * The initial color to highlight (should be a valid 6-digit color hex code without the # symbol). Note that the hex
         * codes are case-sensitive.
         */
        value: string;

        /**
         * Clears any selection and sets the value to 'null'.
         */
        clear();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Get the currently selected color value.
         * @return {String} value The selected value. Null if nothing is selected.
         */
        getValue(): string;

        protected onRender();

        /**
         * Selects the specified color in the picker (fires the {@link #event-select} event)
         * @param {String} color A valid 6-digit color hex code (# will be stripped if included)
         * @param {Boolean} [suppressEvent=false] True to stop the select event from firing.
         */
        select(color: string, suppressEvent?: boolean);
    }

    interface DateConfig extends Ext.ComponentConfig {
        /**
         * The text to display for the aria title
         */
        ariaTitle?: string;

        /**
         * The date format to display for the current value in the {@link #ariaTitle}
         */
        ariaTitleDateFormat?: string;

        /**
         * The base CSS class to apply to this components element.
         *
         * Optional, Defaults to: 'x-datepicker'
         */
        baseCls?: string;

        border?: any;

        /**
         * An array of textual day names which can be overriden for localization support (defaults to Ext.Date.dayNames)
         * @deprecated This config is deprecated. In future the day names will be retrieved from {@link Ext.Date}
         */
        dayNames?: string;

        /**
         * True to disable animations when showing the month picker.
         */
        disableAnim?: boolean;

        /**
         * The class to apply to disabled cells.
         *
         * Optional, Defaults to: 'x-datepicker-disabled'
         */
        disabledCellCls?: string;

        /**
         * An array of 'dates' to disable, as strings. These strings will be used to build a dynamic regular expression so
         * they are very powerful. Some examples:
         *
         *   - ['03/08/2003', '09/16/2003'] would disable those exact dates
         *   - ['03/08', '09/16'] would disable those days for every year
         *   - ['^03/08'] would only match the beginning (useful if you are using short years)
         *   - ['03/../2006'] would disable every day in March 2006
         *   - ['^03'] would disable every day in every March
         *
         * Note that the format of the dates included in the array should exactly match the {@link #format} config. In order
         * to support regular expressions, if you are using a date format that has '.' in it, you will have to escape the
         * dot when restricting dates. For example: ['03\\.08\\.03'].
         */
        disabledDates?: string;

        /**
         * JavaScript regular expression used to disable a pattern of dates. The {@link #disabledDates}
         * config will generate this regex internally, but if you specify disabledDatesRE it will take precedence over the
         * disabledDates value.
         *
         * Optional, Defaults to: null
         */
        disabledDatesRE?: RegExp;

        /**
         * The tooltip text to display when the date falls on a disabled date.
         */
        disabledDatesText?: string;

        /**
         * An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday.
         *
         * Optional, Defaults to: null
         */
        disabledDays?: number;

        /**
         * The tooltip to display when the date falls on a disabled day.
         */
        disabledDaysText?: string;

        /**
         * True to automatically focus the picker on show.
         */
        focusOnShow?: boolean;

        /**
         * The default date format string which can be overriden for localization support. The format must be valid
         * according to {@link Ext.Date#parse} (defaults to {@link Ext.Date#defaultFormat}).
         */
        format?: string;

        /**
         * Optional. A function that will handle the select event of this picker. The handler is passed the following
         * parameters:
         *
         *   - 'picker' : Ext.picker.Date
         *
         * This Date picker.
         *
         *   - 'date' : Date
         *
         * The selected date.
         */
        handler?: Function;

        /**
         * Specifies optional custom key event handlers for the {@link Ext.util.KeyNav} attached to this date picker. Must
         * conform to the config format recognized by the {@link Ext.util.KeyNav} constructor. Handlers specified in this
         * object will replace default handlers of the same name.
         */
        keyNavConfig?: any;

        /**
         * The format for displaying a date in a longer format.
         */
        longDayFormat?: string;

        /**
         * Maximum allowable date (JavaScript date object)
         *
         * Optional, Defaults to: null
         */
        maxDate?: Date;

        /**
         * The error text to display if the maxDate validation fails.
         */
        maxText?: string;

        /**
         * Minimum allowable date (JavaScript date object)
         *
         * Optional, Defaults to: null
         */
        minDate?: Date;

        /**
         * The error text to display if the minDate validation fails.
         */
        minText?: string;

        /**
         * An array of textual month names which can be overriden for localization support (defaults to Ext.Date.monthNames)
         * @deprecated This config is deprecated. In future the month names will be retrieved from {@link Ext.Date}
         */
        monthNames?: string;

        /**
         * The date format for the header month
         */
        monthYearFormat?: string;

        /**
         * The header month selector tooltip
         */
        monthYearText?: string;

        /**
         * The next month navigation button tooltip
         */
        nextText?: string;

        /**
         * The previous month navigation button tooltip
         */
        prevText?: string;

        /**
         * The scope ('this' reference) in which the '{@link #handler}' function will be called.
         *
         * Defaults to this DatePicker instance.
         */
        scope?: any;

        /**
         * The class to apply to the selected cell.
         *
         * Optional, Defaults to: 'x-datepicker-selected'
         */
        selectedCls?: string;

        /**
         * False to hide the footer area containing the Today button and disable the keyboard handler for spacebar that
         * selects the current date.
         */
        showToday?: boolean;

        /**
         * Day index at which the week should begin, 0-based.
         *
         * Defaults to '0' (Sunday).
         *
         * Optional, Defaults to: undefined
         */
        startDay?: number;

        /**
         * The text to display on the button that selects the current date
         */
        todayText?: string;

        /**
         * A string used to format the message for displaying in a tooltip over the button that selects the current date.
         * The '{0}' token in string is replaced by today's date.
         */
        todayTip?: string;
    }

    /**
     * A date picker. This class is used by the Ext.form.field.Date field to allow browsing and selection of valid
     * dates in a popup next to the field, but may also be used with other components.
     *
     * Typically you will need to implement a handler function to be notified when the user chooses a date from the picker;
     * you can register the handler using the {@link #select} event, or by implementing the {@link #handler} method.
     *
     * By default the user will be allowed to pick any date; this can be changed by using the {@link #minDate},
     * {@link #maxDate}, {@link #disabledDays}, {@link #disabledDatesRE}, and/or {@link #disabledDates} configs.
     *
     * All the string values documented below may be overridden by including an Ext locale file in your page.
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Choose a future date:',
     *         width: 200,
     *         bodyPadding: 10,
     *         renderTo: Ext.getBody(),
     *         items: [{
     *             xtype: 'datepicker',
     *             minDate: new Date(),
     *             handler: function(picker, date) {
     *                 // do something with the selected date
     *             }
     *         }]
     *     });
     */
    export class Date extends Ext.Component implements Ext.picker.DateConfig {
        /**
         * The text to display for the aria title
         */
        ariaTitle: string;

        /**
         * The date format to display for the current value in the {@link #ariaTitle}
         */
        ariaTitleDateFormat: string;

        /**
         * The base CSS class to apply to this components element.
         *
         * Optional, Defaults to: 'x-datepicker'
         */
        baseCls: string;

        border: number|string|boolean;

        /**
         * An array of textual day names which can be overriden for localization support (defaults to Ext.Date.dayNames)
         * @deprecated This config is deprecated. In future the day names will be retrieved from {@link Ext.Date}
         */
        dayNames: string;

        /**
         * True to disable animations when showing the month picker.
         */
        disableAnim: boolean;

        /**
         * The class to apply to disabled cells.
         *
         * Optional, Defaults to: 'x-datepicker-disabled'
         */
        disabledCellCls: string;

        /**
         * An array of 'dates' to disable, as strings. These strings will be used to build a dynamic regular expression so
         * they are very powerful. Some examples:
         *
         *   - ['03/08/2003', '09/16/2003'] would disable those exact dates
         *   - ['03/08', '09/16'] would disable those days for every year
         *   - ['^03/08'] would only match the beginning (useful if you are using short years)
         *   - ['03/../2006'] would disable every day in March 2006
         *   - ['^03'] would disable every day in every March
         *
         * Note that the format of the dates included in the array should exactly match the {@link #format} config. In order
         * to support regular expressions, if you are using a date format that has '.' in it, you will have to escape the
         * dot when restricting dates. For example: ['03\\.08\\.03'].
         */
        disabledDates: string;

        /**
         * JavaScript regular expression used to disable a pattern of dates. The {@link #disabledDates}
         * config will generate this regex internally, but if you specify disabledDatesRE it will take precedence over the
         * disabledDates value.
         *
         * Optional, Defaults to: null
         */
        disabledDatesRE: RegExp;

        /**
         * The tooltip text to display when the date falls on a disabled date.
         */
        disabledDatesText: string;

        /**
         * An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday.
         *
         * Optional, Defaults to: null
         */
        disabledDays: number;

        /**
         * The tooltip to display when the date falls on a disabled day.
         */
        disabledDaysText: string;

        /**
         * True to automatically focus the picker on show.
         */
        focusOnShow: boolean;

        /**
         * The default date format string which can be overriden for localization support. The format must be valid
         * according to {@link Ext.Date#parse} (defaults to {@link Ext.Date#defaultFormat}).
         */
        format: string;

        /**
         * Optional. A function that will handle the select event of this picker. The handler is passed the following
         * parameters:
         *
         *   - 'picker' : Ext.picker.Date
         *
         * This Date picker.
         *
         *   - 'date' : Date
         *
         * The selected date.
         */
        handler: Function;

        /**
         * Specifies optional custom key event handlers for the {@link Ext.util.KeyNav} attached to this date picker. Must
         * conform to the config format recognized by the {@link Ext.util.KeyNav} constructor. Handlers specified in this
         * object will replace default handlers of the same name.
         */
        keyNavConfig: any;

        /**
         * The format for displaying a date in a longer format.
         */
        longDayFormat: string;

        /**
         * Maximum allowable date (JavaScript date object)
         *
         * Optional, Defaults to: null
         */
        maxDate: Date;

        /**
         * The error text to display if the maxDate validation fails.
         */
        maxText: string;

        /**
         * Minimum allowable date (JavaScript date object)
         *
         * Optional, Defaults to: null
         */
        minDate: Date;

        /**
         * The error text to display if the minDate validation fails.
         */
        minText: string;

        /**
         * An array of textual month names which can be overriden for localization support (defaults to Ext.Date.monthNames)
         * @deprecated This config is deprecated. In future the month names will be retrieved from {@link Ext.Date}
         */
        monthNames: string;

        /**
         * The date format for the header month
         */
        monthYearFormat: string;

        /**
         * The header month selector tooltip
         */
        monthYearText: string;

        /**
         * The next month navigation button tooltip
         */
        nextText: string;

        /**
         * The previous month navigation button tooltip
         */
        prevText: string;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The scope ('this' reference) in which the '{@link #handler}' function will be called.
         *
         * Defaults to this DatePicker instance.
         */
        scope: any;

        /**
         * The class to apply to the selected cell.
         *
         * Optional, Defaults to: 'x-datepicker-selected'
         */
        selectedCls: string;

        /**
         * False to hide the footer area containing the Today button and disable the keyboard handler for spacebar that
         * selects the current date.
         */
        showToday: boolean;

        /**
         * Day index at which the week should begin, 0-based.
         *
         * Defaults to '0' (Sunday).
         *
         * Optional, Defaults to: undefined
         */
        startDay: number;

        /**
         * The text to display on the button that selects the current date
         */
        todayText: string;

        /**
         * A string used to format the message for displaying in a tooltip over the button that selects the current date.
         * The '{0}' token in string is replaced by today's date.
         */
        todayTip: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Gets a single character to represent the day of the week
         * @return {String} The character
         */
        getDayInitial(): string;

        /**
         * Gets the current selected value of the date field
         * @return {Date} The selected date
         */
        getValue(): Date;

        /**
         * Hides the month picker, if it's visible.
         * @param {Boolean} [animate] Indicates whether to animate this action. If the animate
         * parameter is not specified, the behavior will use {@link #disableAnim} to determine
         * whether to animate or not.
         * @return {Ext.picker.Date} this
         */
        hideMonthPicker(animate?: boolean): Ext.picker.Date;

        protected initComponent();

        /**
         * Sets the current value to today.
         * @return {Ext.picker.Date} this
         */
        selectToday(): Ext.picker.Date;

        /**
         * Replaces any existing disabled dates with new values and refreshes the DatePicker.
         * @param {String[]/RegExp} disabledDates An array of date strings (see the {@link #disabledDates} config for
         * details on supported values), or a JavaScript regular expression used to disable a pattern of dates.
         * @return {Ext.picker.Date} this
         */
        setDisabledDates(disabledDates: string|RegExp): Ext.picker.Date;

        /**
         * Replaces any existing disabled days (by index, 0-6) with new values and refreshes the DatePicker.
         * @param {Number[]} disabledDays An array of disabled day indexes. See the {@link #disabledDays} config for details
         * on supported values.
         * @return {Ext.picker.Date} this
         */
        setDisabledDays(disabledDays: number): Ext.picker.Date;

        /**
         * Replaces any existing {@link #maxDate} with the new value and refreshes the DatePicker.
         * @param {Date} value The maximum date that can be selected
         * @return {Ext.picker.Date} this
         */
        setMaxDate(value: Date): Ext.picker.Date;

        /**
         * Replaces any existing {@link #minDate} with the new value and refreshes the DatePicker.
         * @param {Date} value The minimum date that can be selected
         * @return {Ext.picker.Date} this
         */
        setMinDate(value: Date): Ext.picker.Date;

        /**
         * Sets the value of the date field
         * @param {Date} value The date to set
         * @return {Ext.picker.Date} this
         */
        setValue(value: Date): Ext.picker.Date;

        /**
         * Show the month picker
         * @param {Boolean} [animate] Indicates whether to animate this action. If the animate
         * parameter is not specified, the behavior will use {@link #disableAnim} to determine
         * whether to animate or not.
         * @return {Ext.picker.Date} this
         */
        showMonthPicker(animate?: boolean): Ext.picker.Date;

        /**
         * Show the next month.
         * @return {Ext.picker.Date} this
         */
        showNextMonth(e: any): Ext.picker.Date;

        /**
         * Show the next year.
         * @return {Ext.picker.Date} this
         */
        showNextYear(): Ext.picker.Date;

        /**
         * Show the previous month.
         * @return {Ext.picker.Date} this
         */
        showPrevMonth(e: any): Ext.picker.Date;

        /**
         * Show the previous year.
         * @return {Ext.picker.Date} this
         */
        showPrevYear(): Ext.picker.Date;

        /**
         * Fires when a date is selected
         * @param {Ext.picker.Date} this DatePicker
         * @param {Date} date The selected date
         */
        select(that: Ext.picker.Date, date: Date);
    }

    interface MonthConfig extends Ext.ComponentConfig {
        /**
         *  The base CSS class to apply to the picker element.
         *
         * Optional, Defaults to: 'x-monthpicker'
         */
        baseCls?: string;

        /**
         * The text to display on the cancel button.
         */
        cancelText?: string;

        /**
         * The text to display on the ok button.
         */
        okText?: string;

        /**
         * The class to be added to selected items in the picker.
         *
         * Optional, Defaults to: 'x-monthpicker-selected'
         */
        selectedCls?: string;

        /**
         * True to show ok and cancel buttons below the picker.
         */
        showButtons?: boolean;

        /**
         * The default value to set. See {@link #setValue}
         */
        value?: Date|number;
    }

    /**
     * A month picker component. This class is used by the {@link Ext.picker.Date Date picker} class
     * to allow browsing and selection of year/months combinations.
     */
    export class Month extends Ext.Component implements Ext.picker.MonthConfig {
        /**
         *  The base CSS class to apply to the picker element.
         *
         * Optional, Defaults to: 'x-monthpicker'
         */
        baseCls: string;

        /**
         * The text to display on the cancel button.
         */
        cancelText: string;

        /**
         * The text to display on the ok button.
         */
        okText: string;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The class to be added to selected items in the picker.
         *
         * Optional, Defaults to: 'x-monthpicker-selected'
         */
        selectedCls: string;

        /**
         * True to show ok and cancel buttons below the picker.
         */
        showButtons: boolean;

        /**
         * The default value to set. See {@link #setValue}
         */
        value: Date|number;

        /**
         * Modify the year display by passing an offset.
         * @param {Number} [offset=10] The offset to move by.
         */
        adjustYear(offset?: number);

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Gets the selected value. It is returned as an array [month, year]. It may
         * be a partial value, for example [null, 2010]. The month is returned as
         * 0 based.
         * @return {Number[]} The selected value
         */
        getValue(): number;

        /**
         * Checks whether the picker has a selection
         * @return {Boolean} Returns true if both a month and year have been selected
         */
        hasSelection(): boolean;

        protected onDestroy();

        /**
         * Set the value for the picker.
         * @param {Date/Number[]} value The value to set. It can be a Date object, where the month/year will be extracted, or
         * it can be an array, with the month as the first index and the year as the second.
         * @return {Ext.picker.Month} this
         */
        setValue(value: Date|number): Ext.picker.Month;

        /**
         * Fires when the cancel button is pressed.
         */
        cancelclick(that: Ext.picker.Month);

        /**
         * Fires when a month is clicked.
         * @param {Array} value The current value
         */
        monthclick(that: Ext.picker.Month, value: any[]);

        /**
         * Fires when a month is clicked.
         * @param {Array} value The current value
         */
        monthdblclick(that: Ext.picker.Month, value: any[]);

        /**
         * Fires when the ok button is pressed.
         * @param {Array} value The current value
         */
        okclick(that: Ext.picker.Month, value: any[]);

        /**
         * Fires when a month/year is selected.
         * @param {Array} value The current value
         */
        select(that: Ext.picker.Month, value: any[]);

        /**
         * Fires when a year is clicked.
         * @param {Array} value The current value
         */
        yearclick(that: Ext.picker.Month, value: any[]);

        /**
         * Fires when a year is clicked.
         * @param {Array} value The current value
         */
        yeardblclick(that: Ext.picker.Month, value: any[]);
    }

    interface TimeConfig extends Ext.view.BoundListConfig {
        componentCls?: any;

        /**
         * The default time format string which can be overriden for localization support. The format must be valid
         * according to {@link Ext.Date#parse}.
         *
         * Defaults to ''g:i A'', e.g., ''3:15 PM''. For 24-hour time format try ''H:i'' instead.
         *
         * Optional, Defaults to: undefined
         */
        format?: string;

        /**
         * The number of minutes between each time value in the list.
         */
        increment?: number;

        /**
         * The maximum time to be shown in the list of times. This must be a Date object (only the time fields will be
         * used); no parsing of String values will be done.
         */
        maxValue?: Date;

        /**
         * The minimum time to be shown in the list of times. This must be a Date object (only the time fields will be
         * used); no parsing of String values will be done.
         */
        minValue?: Date;
    }

    /**
     * A time picker which provides a list of times from which to choose. This is used by the Ext.form.field.Time
     * class to allow browsing and selection of valid times, but could also be used with other components.
     *
     * By default, all times starting at midnight and incrementing every 15 minutes will be presented. This list of
     * available times can be controlled using the {@link #minValue}, {@link #maxValue}, and {@link #increment}
     * configuration properties. The format of the times presented in the list can be customized with the {@link #format}
     * config.
     *
     * To handle when the user selects a time from the list, you can subscribe to the {@link #selectionchange} event.
     *
     *     @example
     *     Ext.create('Ext.picker.Time', {
     *        width: 60,
     *        minValue: Ext.Date.parse('04:30:00 AM', 'h:i:s A'),
     *        maxValue: Ext.Date.parse('08:00:00 AM', 'h:i:s A'),
     *        renderTo: Ext.getBody()
     *     });
     */
    export class Time extends Ext.view.BoundList implements Ext.picker.TimeConfig {
        componentCls: string;

        /**
         * The default time format string which can be overriden for localization support. The format must be valid
         * according to {@link Ext.Date#parse}.
         *
         * Defaults to ''g:i A'', e.g., ''3:15 PM''. For 24-hour time format try ''H:i'' instead.
         *
         * Optional, Defaults to: undefined
         */
        format: string;

        /**
         * The number of minutes between each time value in the list.
         */
        increment: number;

        /**
         * The maximum time to be shown in the list of times. This must be a Date object (only the time fields will be
         * used); no parsing of String values will be done.
         */
        maxValue: Date;

        /**
         * The minimum time to be shown in the list of times. This must be a Date object (only the time fields will be
         * used); no parsing of String values will be done.
         */
        minValue: Date;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected initComponent();

        /**
         * Set the {@link #maxValue} and update the list of available times. This must be a Date object (only the time
         * fields will be used); no parsing of String values will be done.
         */
        setMaxValue(value: Date);

        /**
         * Set the {@link #minValue} and update the list of available times. This must be a Date object (only the time
         * fields will be used); no parsing of String values will be done.
         */
        setMinValue(value: Date);

        /**
         * Update the list of available times in the list to be constrained within the {@link #minValue}
         * and {@link #maxValue}.
         */
        updateList();
    }
}

declare module Ext.resizer {
    interface BorderSplitterConfig extends Ext.resizer.SplitterConfig {
        collapseTarget?: any;
    }

    /**
     * Private utility class for Ext.layout.container.Border.
     */
    export class BorderSplitter extends Ext.resizer.Splitter implements Ext.resizer.BorderSplitterConfig {
        collapseTarget: string|Ext.panel.Panel;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected getTrackerConfig();
    }

    /**
     * Private utility class for Ext.BorderSplitter.
     */
    export class BorderSplitterTracker extends Ext.resizer.SplitterTracker {
    }

    interface HandleConfig extends Ext.ComponentConfig {
        region?: any;
    }

    /**
     * Provides a handle for 9-point resizing of Elements or Components.
     */
    export class Handle extends Ext.Component implements Ext.resizer.HandleConfig {
        region: any;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface ResizerConfig {
        /**
         * An element, or a {@link Ext.util.Region Region} into which the resize operation must be constrained.
         */
        constrainTo?: Ext.dom.Element|Ext.util.Region;

        /**
         * Specify as true to update the {@link #target} (Element or {@link Ext.Component Component}) dynamically during
         * dragging. This is 'true' by default, but the {@link Ext.Component Component} class passes 'false' when it is
         * configured as {@link Ext.Component#resizable}.
         *
         * If specified as 'false', a proxy element is displayed during the resize operation, and the {@link #target} is
         * updated on mouseup.
         */
        dynamic?: boolean;

        /**
         * String consisting of the resize handles to display. Defaults to 's e se' for Elements and fixed position
         * Components. Defaults to 8 point resizing for floating Components (such as Windows). Specify either ''all'' or any
         * of ''n s e w ne nw se sw''.
         */
        handles?: string;

        /**
         * Optional. The height to set target to in pixels
         */
        height?: number;

        /**
         * The increment to snap the height resize in pixels.
         */
        heightIncrement?: number;

        /**
         * The maximum height for the element
         */
        maxHeight?: number;

        /**
         * The maximum width for the element
         */
        maxWidth?: number;

        /**
         * The minimum height for the element
         */
        minHeight?: number;

        /**
         * The minimum width for the element
         */
        minWidth?: number;

        /**
         * True to ensure that the resize handles are always visible, false indicates resizing by cursor changes only
         */
        pinned?: boolean;

        /**
         * True to preserve the original ratio between height and width during resize
         */
        preserveRatio?: boolean;

        /**
         * The Element or Component to resize.
         */
        target?: Ext.dom.Element|Ext.Component;

        /**
         * True for transparent handles. This is only applied at config time.
         */
        transparent?: boolean;

        /**
         * Optional. The width to set the target to in pixels
         */
        width?: number;

        /**
         * The increment to snap the width resize in pixels.
         */
        widthIncrement?: number;
    }

    /**
     * Applies drag handles to an element or component to make it resizable. The drag handles are inserted into the element
     * (or component's element) and positioned absolute.
     *
     * Textarea and img elements will be wrapped with an additional div because these elements do not support child nodes.
     * The original element can be accessed through the originalTarget property.
     *
     * Here is the list of valid resize handles:
     *
     *     Value   Description
     *     ------  -------------------
     *      'n'     north
     *      's'     south
     *      'e'     east
     *      'w'     west
     *      'nw'    northwest
     *      'sw'    southwest
     *      'se'    southeast
     *      'ne'    northeast
     *      'all'   all
     *
     * {@img Ext.resizer.Resizer/Ext.resizer.Resizer.png Ext.resizer.Resizer component}
     *
     * Here's an example showing the creation of a typical Resizer:
     *
     *     Ext.create('Ext.resizer.Resizer', {
     *         el: 'elToResize',
     *         handles: 'all',
     *         minWidth: 200,
     *         minHeight: 100,
     *         maxWidth: 500,
     *         maxHeight: 400,
     *         pinned: true
     *     });
     */
    export class Resizer extends Ext.Base implements Ext.resizer.ResizerConfig {
        /**
         * Outer element for resizing behavior.
         */
        el: Ext.dom.Element;

        /**
         * Reference to the original resize target if the element of the original resize target was a
         * {@link Ext.form.field.Field Field}, or an IMG or a TEXTAREA which must be wrapped in a DIV.
         */
        originalTarget: Ext.dom.Element|Ext.Component;

        resizeTracker: Ext.resizer.ResizeTracker;

        /**
         * An element, or a {@link Ext.util.Region Region} into which the resize operation must be constrained.
         */
        constrainTo: Ext.dom.Element|Ext.util.Region;

        /**
         * Specify as true to update the {@link #target} (Element or {@link Ext.Component Component}) dynamically during
         * dragging. This is 'true' by default, but the {@link Ext.Component Component} class passes 'false' when it is
         * configured as {@link Ext.Component#resizable}.
         *
         * If specified as 'false', a proxy element is displayed during the resize operation, and the {@link #target} is
         * updated on mouseup.
         */
        dynamic: boolean;

        /**
         * String consisting of the resize handles to display. Defaults to 's e se' for Elements and fixed position
         * Components. Defaults to 8 point resizing for floating Components (such as Windows). Specify either ''all'' or any
         * of ''n s e w ne nw se sw''.
         */
        handles: string;

        /**
         * Optional. The height to set target to in pixels
         */
        height: number;

        /**
         * The increment to snap the height resize in pixels.
         */
        heightIncrement: number;

        /**
         * The maximum height for the element
         */
        maxHeight: number;

        /**
         * The maximum width for the element
         */
        maxWidth: number;

        /**
         * The minimum height for the element
         */
        minHeight: number;

        /**
         * The minimum width for the element
         */
        minWidth: number;

        /**
         * True to ensure that the resize handles are always visible, false indicates resizing by cursor changes only
         */
        pinned: boolean;

        /**
         * True to preserve the original ratio between height and width during resize
         */
        preserveRatio: boolean;

        /**
         * The Element or Component to resize.
         */
        target: Ext.dom.Element|Ext.Component;

        /**
         * True for transparent handles. This is only applied at config time.
         */
        transparent: boolean;

        /**
         * Optional. The width to set the target to in pixels
         */
        width: number;

        /**
         * The increment to snap the width resize in pixels.
         */
        widthIncrement: number;

        /**
         * Returns the element that was configured with the el or target config property. If a component was configured with
         * the target property then this will return the element of this component.
         *
         * Textarea and img elements will be wrapped with an additional div because these elements do not support child
         * nodes. The original element can be accessed through the originalTarget property.
         * @return {Ext.Element} element
         */
        getEl(): Ext.dom.Element;

        /**
         * Returns the element or component that was configured with the target config property.
         *
         * Textarea and img elements will be wrapped with an additional div because these elements do not support child
         * nodes. The original element can be accessed through the originalTarget property.
         * @return {Ext.Element/Ext.Component}
         */
        getTarget(): Ext.dom.Element|Ext.Component;

        /**
         * Perform a manual resize and fires the 'resize' event.
         */
        resizeTo(width: number, height: number);

        /**
         * Fired before resize is allowed. Return false to cancel resize.
         * @param {Number} width The start width
         * @param {Number} height The start height
         * @param {Ext.EventObject} e The mousedown event
         */
        beforeresize(that: Ext.resizer.Resizer, width: number, height: number, e: Ext.EventObject);

        /**
         * Fired after a resize.
         * @param {Number} width The new width
         * @param {Number} height The new height
         * @param {Ext.EventObject} e The mouseup event
         */
        resize(that: Ext.resizer.Resizer, width: number, height: number, e: Ext.EventObject);

        /**
         * Fires during resizing. Return false to cancel resize.
         * @param {Number} width The new width
         * @param {Number} height The new height
         * @param {Ext.EventObject} e The mousedown event
         */
        resizedrag(that: Ext.resizer.Resizer, width: number, height: number, e: Ext.EventObject);
    }

    interface ResizeTrackerConfig extends Ext.dd.DragTrackerConfig {
        constrainTo?: any;
    }

    /**
     * Private utility class for Ext.resizer.Resizer.
     */
    export class ResizeTracker extends Ext.dd.DragTracker implements Ext.resizer.ResizeTrackerConfig {
        constrainTo: Ext.util.Region|Ext.dom.Element;

        constructor(config: Ext.resizer.ResizeTrackerConfig);

        /**
         * Create a proxy for this resizer
         * @param {Ext.Component/Ext.Element} target The target
         * @return {Ext.Element} A proxy element
         */
        createProxy(target: Ext.Component|Ext.dom.Element): Ext.dom.Element;
    }

    interface SplitterConfig extends Ext.ComponentConfig {
        baseCls?: any;

        /**
         * True to enable dblclick to toggle expand and collapse on the {@link #collapseTarget} Panel.
         */
        collapseOnDblClick?: boolean;

        /**
         * A string describing the relative position of the immediate sibling Panel to collapse. May be 'prev' or 'next'.
         *
         * Or the immediate sibling Panel to collapse.
         *
         * The orientation of the mini-collapse tool will be inferred from this setting.
         *
         * **Note that only Panels may be collapsed.**
         */
        collapseTarget?: string|Ext.panel.Panel;

        /**
         * A class to add to the splitter when it is collapsed. See {@link #collapsible}.
         */
        collapsedCls?: string;

        /**
         * True to show a mini-collapse tool in the Splitter to toggle expand and collapse on the {@link #collapseTarget} Panel.
         * Defaults to the {@link Ext.panel.Panel#collapsible collapsible} setting of the Panel.
         */
        collapsible?: boolean;

        /**
         * Provides a default maximum width or height for the two components
         * that the splitter is between.
         */
        defaultSplitMax?: number;

        /**
         * Provides a default minimum width or height for the two components
         * that the splitter is between.
         */
        defaultSplitMin?: number;

        /**
         * Set to false to prevent this Splitter's mini-collapse tool from managing the collapse
         * state of the {@link #collapseTarget}.
         */
        performCollapse?: boolean;

        /**
         * The size of the splitter. This becomes the height for vertical splitters and
         * width for horizontal splitters.
         */
        size?: number;
    }

    /**
     * This class functions **between siblings of a {@link Ext.layout.container.VBox VBox} or {@link Ext.layout.container.HBox HBox}
     * layout** to resize both immediate siblings.
     *
     * A Splitter will preserve the flex ratio of any flexed siblings it is required to resize. It does this by setting the 'flex' property of *all* flexed siblings
     * to equal their pixel size. The actual numerical 'flex' property in the Components will change, but the **ratio** to the total flex value will be preserved.
     *
     * A Splitter may be configured to show a centered mini-collapse tool orientated to collapse the {@link #collapseTarget}.
     * The Splitter will then call that sibling Panel's {@link Ext.panel.Panel#method-collapse collapse} or {@link Ext.panel.Panel#method-expand expand} method
     * to perform the appropriate operation (depending on the sibling collapse state). To create the mini-collapse tool but take care
     * of collapsing yourself, configure the splitter with '{@link #performCollapse}: false'.
     */
    export class Splitter extends Ext.Component implements Ext.resizer.SplitterConfig {
        /**
         * Orientation of this Splitter. ''vertical'' when used in an hbox layout, ''horizontal''
         * when used in a vbox layout.
         */
        orientation: string;

        baseCls: string;

        /**
         * A class to add to the splitter when it is collapsed. See {@link #collapsible}.
         */
        collapsedCls: string;

        /**
         * True to enable dblclick to toggle expand and collapse on the {@link #collapseTarget} Panel.
         */
        collapseOnDblClick: boolean;

        /**
         * A string describing the relative position of the immediate sibling Panel to collapse. May be 'prev' or 'next'.
         *
         * Or the immediate sibling Panel to collapse.
         *
         * The orientation of the mini-collapse tool will be inferred from this setting.
         *
         * **Note that only Panels may be collapsed.**
         */
        collapseTarget: string|Ext.panel.Panel;

        /**
         * True to show a mini-collapse tool in the Splitter to toggle expand and collapse on the {@link #collapseTarget} Panel.
         * Defaults to the {@link Ext.panel.Panel#collapsible collapsible} setting of the Panel.
         */
        collapsible: boolean;

        /**
         * Provides a default maximum width or height for the two components
         * that the splitter is between.
         */
        defaultSplitMax: number;

        /**
         * Provides a default minimum width or height for the two components
         * that the splitter is between.
         */
        defaultSplitMin: number;

        /**
         * Set to false to prevent this Splitter's mini-collapse tool from managing the collapse
         * state of the {@link #collapseTarget}.
         */
        performCollapse: boolean;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The size of the splitter. This becomes the height for vertical splitters and
         * width for horizontal splitters.
         */
        size: number;

        protected beforeDestroy();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Returns the config object (with an 'xclass' property) for the splitter tracker. This
         * is overridden by {@link Ext.resizer.BorderSplitter BorderSplitter} to create a
         * {@link Ext.resizer.BorderSplitterTracker BorderSplitterTracker}.
         */
        protected getTrackerConfig();

        protected onRender();
    }

    /**
     * Private utility class for Ext.Splitter.
     */
    export class SplitterTracker extends Ext.dd.DragTracker {
    }
}

declare module Ext.selection {
    interface CellModelConfig extends Ext.selection.ModelConfig {
        /**
         * Turns on/off keyboard navigation within the grid.
         */
        enableKeyNav?: boolean;

        /**
         * Mode of selection.  Valid values are:
         *
         * - **"SINGLE"** - Only allows selecting one item at a time. This is the default.
         */
        mode?: any;

        /**
         * Set this configuration to true to prevent wrapping around of selection as
         * a user navigates to the first or last column.
         */
        preventWrap?: boolean;
    }

    export class CellModel extends Ext.selection.Model implements Ext.selection.CellModelConfig {
        /**
         * Turns on/off keyboard navigation within the grid.
         */
        enableKeyNav: boolean;

        /**
         * Mode of selection.  Valid values are:
         *
         * - **"SINGLE"** - Only allows selecting one item at a time. This is the default.
         */
        mode: any;

        /**
         * Set this configuration to true to prevent wrapping around of selection as
         * a user navigates to the first or last column.
         */
        preventWrap: boolean;

        constructor();

        /**
         * Returns the current position in the format {row: row, column: column}
         */
        getCurrentPosition();

        /**
         * Sets the current position
         * @param {Object} position The position to set.
         * @param {Boolean} suppressEvent True to suppress selection events
         */
        setCurrentPosition(position: any, suppressEvent: boolean);
    }

    interface CheckboxModelConfig extends Ext.selection.RowModelConfig {
        /**
         * True if rows can only be selected by clicking on the checkbox column.
         */
        checkOnly?: boolean;

        /**
         * The selector for determining whether the checkbox element is clicked. This may be changed to
         * allow for a wider area to be clicked, for example, the whole cell for the selector.
         *
         * Optional, Defaults to: "x-grid-row-checker"
         */
        checkSelector?: string;

        /**
         * The index at which to insert the checkbox column.
         * Supported values are a numeric index, and the strings 'first' and 'last'.
         *
         * Optional, Defaults to: 0
         */
        injectCheckbox?: number|string;

        /**
         * Modes of selection.
         * Valid values are '"SINGLE"', '"SIMPLE"', and '"MULTI"'.
         */
        mode?: any;

        /**
         * Configure as 'false' to not display the header checkbox at the top of the column.
         * When {@link Ext.data.Store#buffered} is set to 'true', this configuration will
         * not be available because the buffered data set does not always contain all data.
         */
        showHeaderCheckbox?: boolean;
    }

    /**
     * A selection model that renders a column of checkboxes that can be toggled to
     * select or deselect rows. The default mode for this selection model is MULTI.
     *
     * The selection model will inject a header for the checkboxes in the first view
     * and according to the {@link #injectCheckbox} configuration.
     */
    export class CheckboxModel extends Ext.selection.RowModel implements Ext.selection.CheckboxModelConfig {
        /**
         * True if rows can only be selected by clicking on the checkbox column.
         */
        checkOnly: boolean;

        /**
         * The selector for determining whether the checkbox element is clicked. This may be changed to
         * allow for a wider area to be clicked, for example, the whole cell for the selector.
         *
         * Optional, Defaults to: "x-grid-row-checker"
         */
        checkSelector: string;

        /**
         * The index at which to insert the checkbox column.
         * Supported values are a numeric index, and the strings 'first' and 'last'.
         *
         * Optional, Defaults to: 0
         */
        injectCheckbox: number|string;

        /**
         * Modes of selection.
         * Valid values are '"SINGLE"', '"SIMPLE"', and '"MULTI"'.
         */
        mode: any;

        /**
         * Configure as 'false' to not display the header checkbox at the top of the column.
         * When {@link Ext.data.Store#buffered} is set to 'true', this configuration will
         * not be available because the buffered data set does not always contain all data.
         */
        showHeaderCheckbox: boolean;

        constructor();

        /**
         * Retrieve a configuration to be used in a HeaderContainer.
         * This should be used when injectCheckbox is set to false.
         */
        getHeaderConfig();

        /**
         * Toggle between selecting all and deselecting all when clicking on
         * a checkbox header.
         */
        onHeaderClick();

        /**
         * Generates the HTML to be rendered in the injected checkbox column for each row.
         * Creates the standard checkbox markup by default; can be overridden to provide custom rendering.
         * See {@link Ext.grid.column.Column#renderer} for description of allowed parameters.
         */
        renderer();
    }

    interface DataViewModelConfig extends Ext.selection.ModelConfig {
        /**
         * Turns on/off keyboard navigation within the DataView.
         */
        enableKeyNav?: boolean;
    }

    export class DataViewModel extends Ext.selection.Model implements Ext.selection.DataViewModelConfig {
        /**
         * Turns on/off keyboard navigation within the DataView.
         */
        enableKeyNav: boolean;

        constructor(cfg: any);

        /**
         * Fired before a record is deselected. If any listener returns false, the
         * deselection is cancelled.
         * @param {Ext.data.Model} record The deselected record
         */
        beforedeselect(that: Ext.selection.DataViewModel, record: Ext.data.Model);

        /**
         * Fired before a record is selected. If any listener returns false, the
         * selection is cancelled.
         * @param {Ext.data.Model} record The selected record
         */
        beforeselect(that: Ext.selection.DataViewModel, record: Ext.data.Model);
    }

    interface ModelConfig extends Ext.util.ObservableConfig {
        /**
         * Allow users to deselect a record in a DataView, List or Grid.
         * Only applicable when the {@link #mode} is 'SINGLE'.
         */
        allowDeselect?: boolean;

        /**
         * Mode of selection.  Valid values are:
         *
         * - **"SINGLE"** - Only allows selecting one item at a time.  Use {@link #allowDeselect} to allow
         *   deselecting that item.  Also see {@link #toggleOnClick}. This is the default.
         * - **"SIMPLE"** - Allows simple selection of multiple items one-by-one. Each click in grid will either
         *   select or deselect an item.
         * - **"MULTI"** - Allows complex selection of multiple items using Ctrl and Shift keys.
         */
        mode?: any;

        /**
         * Remove records from the selection when they are removed from the store.
         *
         * **Important:** When using {@link Ext.toolbar.Paging paging} or a {@link Ext.data.Store#buffered sparsely populated (buffered) Store},
         * records which are cached in the Store's {@link Ext.data.Store#property-data data collection} may be removed from the Store when pages change,
         * or when rows are scrolled out of view. For this reason 'pruneRemoved' should be set to 'false' when using a buffered Store.
         *
         * Also, when previously pruned pages are returned to the cache, the records objects in the page will be
         * *new instances*, and will not match the instances in the selection model's collection. For this reason,
         * you MUST ensure that the Model definition's {@link Ext.data.Model#idProperty idProperty} references a unique
         * key because in this situation, records in the Store have their **IDs** compared to records in the SelectionModel
         * in order to re-select a record which is scrolled back into view.
         *
         * Optional, Defaults to: true
         */
        pruneRemoved?: boolean;

        /**
         * 'true' to toggle the selection state of an item when clicked.
         * Only applicable when the {@link #mode} is 'SINGLE'.
         * Only applicable when the {@link #allowDeselect} is 'true'.
         */
        toggleOnClick?: boolean;
    }

    /**
     * Tracks what records are currently selected in a databound component.
     *
     * This is an abstract class and is not meant to be directly used. Databound UI widgets such as
     * {@link Ext.grid.Panel Grid} and {@link Ext.tree.Panel Tree} should subclass Ext.selection.Model
     * and provide a way to binding to the component.
     *
     * The abstract methods 'onSelectChange' and 'onLastFocusChanged' should be implemented in these
     * subclasses to update the UI widget.
     */
    export class Model extends Ext.util.Observable implements Ext.selection.ModelConfig {
        /**
         * A MixedCollection that maintains all of the currently selected records.
         * @readonly
         *
         * Optional, Defaults to: undefined
         */
        selected: Ext.util.MixedCollection;

        /**
         * Allow users to deselect a record in a DataView, List or Grid.
         * Only applicable when the {@link #mode} is 'SINGLE'.
         */
        allowDeselect: boolean;

        /**
         * Mode of selection.  Valid values are:
         *
         * - **"SINGLE"** - Only allows selecting one item at a time.  Use {@link #allowDeselect} to allow
         *   deselecting that item.  Also see {@link #toggleOnClick}. This is the default.
         * - **"SIMPLE"** - Allows simple selection of multiple items one-by-one. Each click in grid will either
         *   select or deselect an item.
         * - **"MULTI"** - Allows complex selection of multiple items using Ctrl and Shift keys.
         */
        mode: any;

        /**
         * Remove records from the selection when they are removed from the store.
         *
         * **Important:** When using {@link Ext.toolbar.Paging paging} or a {@link Ext.data.Store#buffered sparsely populated (buffered) Store},
         * records which are cached in the Store's {@link Ext.data.Store#property-data data collection} may be removed from the Store when pages change,
         * or when rows are scrolled out of view. For this reason 'pruneRemoved' should be set to 'false' when using a buffered Store.
         *
         * Also, when previously pruned pages are returned to the cache, the records objects in the page will be
         * *new instances*, and will not match the instances in the selection model's collection. For this reason,
         * you MUST ensure that the Model definition's {@link Ext.data.Model#idProperty idProperty} references a unique
         * key because in this situation, records in the Store have their **IDs** compared to records in the SelectionModel
         * in order to re-select a record which is scrolled back into view.
         *
         * Optional, Defaults to: true
         */
        pruneRemoved: boolean;

        /**
         * 'true' to toggle the selection state of an item when clicked.
         * Only applicable when the {@link #mode} is 'SINGLE'.
         * Only applicable when the {@link #allowDeselect} is 'true'.
         */
        toggleOnClick: boolean;

        bindStore();

        constructor(cfg: any);

        /**
         * Deselects a record instance by record instance or index.
         * @param {Ext.data.Model[]/Number} records An array of records or an index
         * @param {Boolean} [suppressEvent=false] True to not fire a deselect event
         */
        deselect(records: Ext.data.Model|number, suppressEvent?: boolean);

        /**
         * Deselects all records in the view.
         * @param {Boolean} [suppressEvent] True to suppress any deselect events
         */
        deselectAll(suppressEvent?: boolean);

        /**
         * Deselects a range of rows if the selection model {@link #isLocked is not locked}.
         * @param {Ext.data.Model/Number} startRow The record or index of the first row in the range
         * @param {Ext.data.Model/Number} endRow The record or index of the last row in the range
         */
        deselectRange(startRow: Ext.data.Model|number, endRow: Ext.data.Model|number);

        /**
         * Returns the count of selected records.
         * @return {Number} The number of selected records
         */
        getCount(): number;

        /**
         * @return {Ext.data.Model} Returns the last selected record.
         */
        getLastSelected(): Ext.data.Model;

        /**
         * Returns an array of the currently selected records.
         * @return {Ext.data.Model[]} The selected records
         */
        getSelection(): Ext.data.Model;

        /**
         * Returns the current selectionMode.
         * @return {String} The selectionMode: 'SINGLE', 'MULTI' or 'SIMPLE'.
         */
        getSelectionMode(): string;

        protected getStoreListeners();

        /**
         * Returns true if there are any a selected records.
         * @return {Boolean}
         */
        hasSelection(): boolean;

        /**
         * Determines if this record is currently focused.
         */
        isFocused(record: Ext.data.Model);

        /**
         * Returns true if the selections are locked.
         * @return {Boolean}
         */
        isLocked(): boolean;

        /**
         * Returns true if the specified row is selected.
         * @param {Ext.data.Model/Number} from The start of the range to check.
         * @param {Ext.data.Model/Number} to The end of the range to check.
         * @return {Boolean}
         */
        isRangeSelected(from: Ext.data.Model|number, to: Ext.data.Model|number): boolean;

        /**
         * Returns true if the specified row is selected.
         * @param {Ext.data.Model/Number} record The record or index of the record to check
         * @return {Boolean}
         */
        isSelected(record: Ext.data.Model|number): boolean;

        /**
         * Selects a record instance by record instance or index.
         * @param {Ext.data.Model[]/Number} records An array of records or an index
         * @param {Boolean} [keepExisting=false] True to retain existing selections
         * @param {Boolean} [suppressEvent=false] True to not fire a select event
         */
        select(records: Ext.data.Model|number, keepExisting?: boolean, suppressEvent?: boolean);

        /**
         * Selects all records in the view.
         * @param {Boolean} suppressEvent True to suppress any select events
         */
        selectAll(suppressEvent: boolean);

        /**
         * Selects a range of rows if the selection model {@link #isLocked is not locked}.
         * All rows in between startRow and endRow are also selected.
         * @param {Ext.data.Model/Number} startRow The record or index of the first row in the range
         * @param {Ext.data.Model/Number} endRow The record or index of the last row in the range
         * @param {Boolean} keepExisting (optional) True to retain existing selections
         */
        selectRange(startRow: Ext.data.Model|number, endRow: Ext.data.Model|number, keepExisting: boolean);

        /**
         * Sets a record as the last focused record. This does NOT mean
         * that the record has been selected.
         */
        setLastFocused(record: Ext.data.Model);

        /**
         * Locks the current selection and disables any changes from happening to the selection.
         * @param {Boolean} locked  True to lock, false to unlock.
         */
        setLocked(locked: boolean);

        /**
         * Sets the current selectionMode.
         * @param {String} selMode 'SINGLE', 'MULTI' or 'SIMPLE'.
         */
        setSelectionMode(selMode: string);

        /**
         * Fired when a row is focused
         * @param {Ext.data.Model} oldFocused The previously focused record
         * @param {Ext.data.Model} newFocused The newly focused record
         */
        focuschange(that: Ext.selection.Model, oldFocused: Ext.data.Model, newFocused: Ext.data.Model);

        /**
         * Fired after a selection change has occurred
         * @param {Ext.data.Model[]} selected The selected records
         */
        selectionchange(that: Ext.selection.Model, selected: Ext.data.Model);
    }

    interface RowModelConfig extends Ext.selection.ModelConfig {
        /**
         * Turns on/off keyboard navigation within the grid.
         */
        enableKeyNav?: boolean;

        /**
         * True to ignore selections that are made when using the right mouse button if there are
         * records that are already selected. If no records are selected, selection will continue
         * as normal
         *
         * Optional, Defaults to: false
         */
        ignoreRightMouseSelection?: boolean;
    }

    /**
     * Implements row based navigation via keyboard.
     *
     * Must synchronize across grid sections.
     */
    export class RowModel extends Ext.selection.Model implements Ext.selection.RowModelConfig {
        /**
         * Turns on/off keyboard navigation within the grid.
         */
        enableKeyNav: boolean;

        /**
         * True to ignore selections that are made when using the right mouse button if there are
         * records that are already selected. If no records are selected, selection will continue
         * as normal
         *
         * Optional, Defaults to: false
         */
        ignoreRightMouseSelection: boolean;

        constructor();

        /**
         * Returns position of the first selected cell in the selection in the format {row: row, column: column}
         */
        getCurrentPosition();

        /**
         * Selects the record immediately following the currently selected record.
         * @param {Boolean} [keepExisting] True to retain existing selections
         * @param {Boolean} [suppressEvent] Set to false to not fire a select event
         * @return {Boolean} 'true' if there is a next record, else 'false'
         */
        selectNext(keepExisting?: boolean, suppressEvent?: boolean): boolean;

        /**
         * Selects the record that precedes the currently selected record.
         * @param {Boolean} [keepExisting] True to retain existing selections
         * @param {Boolean} [suppressEvent] Set to false to not fire a select event
         * @return {Boolean} 'true' if there is a previous record, else 'false'
         */
        selectPrevious(keepExisting?: boolean, suppressEvent?: boolean): boolean;

        /**
         * Fired before a record is deselected. If any listener returns false, the
         * deselection is cancelled.
         * @param {Ext.data.Model} record The deselected record
         * @param {Number} index The row index deselected
         */
        beforedeselect(that: Ext.selection.RowModel, record: Ext.data.Model, index: number);

        /**
         * Fired before a record is selected. If any listener returns false, the
         * selection is cancelled.
         * @param {Ext.data.Model} record The selected record
         * @param {Number} index The row index selected
         */
        beforeselect(that: Ext.selection.RowModel, record: Ext.data.Model, index: number);
    }

    /**
     * Adds custom behavior for left/right keyboard navigation for use with a tree.
     * Depends on the view having an expand and collapse method which accepts a
     * record. This selection model is created by default for {@link Ext.tree.Panel}.
     */
    export class TreeModel extends Ext.selection.RowModel {
        bindStore();

        constructor();
    }
}

declare module Ext.slider {
    interface MultiConfig extends Ext.form.field.BaseConfig {
        /**
         * Determines whether or not clicking on the Slider axis will change the slider.
         */
        clickToChange?: boolean;

        componentLayout?: any;

        /**
         * True to disallow thumbs from overlapping one another.
         */
        constrainThumbs?: boolean;

        /**
         * The number of decimal places to which to round the Slider's value.
         *
         * To disable rounding, configure as **false**.
         */
        decimalPrecision?: number|boolean;

        /**
         * How many units to change the slider when adjusting by drag and drop. Use this option to enable 'snapping'.
         */
        increment?: number;

        /**
         * How many units to change the Slider when adjusting with keyboard navigation. If the increment
         * config is larger, it will be used instead.
         */
        keyIncrement?: number;

        /**
         * The maximum value for the Slider.
         */
        maxValue?: number;

        /**
         * The minimum value for the Slider.
         */
        minValue?: number;

        /**
         * A function used to display custom text for the slider tip.
         *
         * Defaults to null, which will use the default on the plugin.
         *
         * The Thumb that the Tip is attached to
         * The text to display in the tip
         *
         * Optional, Defaults to: undefined
         */
        tipText?: Function;

        /**
         * True to use an {@link Ext.slider.Tip} to display tips for the value. This option may also
         * provide a configuration object for an {@link Ext.slider.Tip}.
         */
        useTips?: any|boolean;

        /**
         * A value with which to initialize the slider. Setting this will only result in the creation
         * of a single slider thumb; if you want multiple thumbs then use the {@link #values} config instead.
         *
         * Defaults to #minValue.
         */
        value?: number;

        /**
         * Array of Number values with which to initalize the slider. A separate slider thumb will be created for each value
         * in this array. This will take precedence over the single {@link #value} config.
         */
        values?: number;

        /**
         * Orient the Slider vertically rather than horizontally.
         */
        vertical?: boolean;

        /**
         * Set to 'true' to calculate snap points based on {@link #increment}s from zero as opposed to
         * from this Slider's {@link #minValue}.
         *
         * By Default, valid snap points are calculated starting {@link #increment}s from the {@link #minValue}
         *
         * Optional, Defaults to: false
         */
        zeroBasedSnapping?: boolean;
    }

    /**
     * Slider which supports vertical or horizontal orientation, keyboard adjustments, configurable snapping, axis clicking
     * and animation. Can be added as an item to any container.
     *
     * Sliders can be created with more than one thumb handle by passing an array of values instead of a single one:
     *
     *     @example
     *     Ext.create('Ext.slider.Multi', {
     *         width: 200,
     *         values: [25, 50, 75],
     *         increment: 5,
     *         minValue: 0,
     *         maxValue: 100,
     *
     *         // this defaults to true, setting to false allows the thumbs to pass each other
     *         constrainThumbs: false,
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Multi extends Ext.form.field.Base implements Ext.slider.MultiConfig {
        /**
         * True while the thumb is in a drag operation
         */
        dragging: boolean;

        /**
         * Array containing references to each thumb
         */
        thumbs: any[];

        /**
         * Determines whether or not clicking on the Slider axis will change the slider.
         */
        clickToChange: boolean;

        componentLayout: string|any;

        /**
         * True to disallow thumbs from overlapping one another.
         */
        constrainThumbs: boolean;

        /**
         * The number of decimal places to which to round the Slider's value.
         *
         * To disable rounding, configure as **false**.
         */
        decimalPrecision: number|boolean;

        /**
         * How many units to change the slider when adjusting by drag and drop. Use this option to enable 'snapping'.
         */
        increment: number;

        /**
         * How many units to change the Slider when adjusting with keyboard navigation. If the increment
         * config is larger, it will be used instead.
         */
        keyIncrement: number;

        /**
         * The maximum value for the Slider.
         */
        maxValue: number;

        /**
         * The minimum value for the Slider.
         */
        minValue: number;

        /**
         * A function used to display custom text for the slider tip.
         *
         * Defaults to null, which will use the default on the plugin.
         *
         * The Thumb that the Tip is attached to
         * The text to display in the tip
         *
         * Optional, Defaults to: undefined
         */
        tipText: Function;

        /**
         * True to use an {@link Ext.slider.Tip} to display tips for the value. This option may also
         * provide a configuration object for an {@link Ext.slider.Tip}.
         */
        useTips: any|boolean;

        /**
         * A value with which to initialize the slider. Setting this will only result in the creation
         * of a single slider thumb; if you want multiple thumbs then use the {@link #values} config instead.
         *
         * Defaults to #minValue.
         */
        value: number;

        /**
         * Array of Number values with which to initalize the slider. A separate slider thumb will be created for each value
         * in this array. This will take precedence over the single {@link #value} config.
         */
        values: number;

        /**
         * Orient the Slider vertically rather than horizontally.
         */
        vertical: boolean;

        /**
         * Set to 'true' to calculate snap points based on {@link #increment}s from zero as opposed to
         * from this Slider's {@link #minValue}.
         *
         * By Default, valid snap points are calculated starting {@link #increment}s from the {@link #minValue}
         *
         * Optional, Defaults to: false
         */
        zeroBasedSnapping: boolean;

        /**
         * Creates a new thumb and adds it to the slider
         * @param {Number} [value=0] The initial value to set on the thumb.
         * @return {Ext.slider.Thumb} The thumb
         */
        addThumb(value?: number): Ext.slider.Thumb;

        protected beforeDestroy();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Returns an array of values - one for the location of each thumb
         * @return {Number[]} The set of thumb values
         */
        getValues(): number;

        protected initComponent();

        initValue();

        protected onDisable();

        protected onEnable();

        protected onRender();

        reset();

        /**
         * Sets the maximum value for the slider instance. If the current value is more than the maximum value, the current
         * value will be changed.
         * @param {Number} val The new maximum value
         */
        setMaxValue(val: number);

        /**
         * Sets the minimum value for the slider instance. If the current value is less than the minimum value, the current
         * value will be changed.
         * @param {Number} val The new minimum value
         */
        setMinValue(val: number);

        /**
         * Synchronizes thumbs position to the proper proportion of the total component width based on the current slider
         * {@link #value}. This will be called automatically when the Slider is resized by a layout, but if it is rendered
         * auto width, this method can be called from another resize handler to sync the Slider if necessary.
         */
        syncThumbs();

        /**
         * Fires before the slider value is changed. By returning false from an event handler, you can cancel the
         * event and prevent the slider from changing.
         * @param {Ext.slider.Multi} slider The slider
         * @param {Number} newValue The new value which the slider is being changed to.
         * @param {Number} oldValue The old value which the slider was previously.
         */
        beforechange(slider: Ext.slider.Multi, newValue: number, oldValue: number);

        /**
         * Fires when the slider value is changed.
         * @param {Ext.slider.Multi} slider The slider
         * @param {Number} newValue The new value which the slider has been changed to.
         * @param {Ext.slider.Thumb} thumb The thumb that was changed
         */
        change(slider: Ext.slider.Multi, newValue: number, thumb: Ext.slider.Thumb);

        /**
         * Fires when the slider value is changed by the user and any drag operations have completed.
         * @param {Ext.slider.Multi} slider The slider
         * @param {Number} newValue The new value which the slider has been changed to.
         * @param {Ext.slider.Thumb} thumb The thumb that was changed
         */
        changecomplete(slider: Ext.slider.Multi, newValue: number, thumb: Ext.slider.Thumb);

        /**
         * Fires continuously during the drag operation while the mouse is moving.
         * @param {Ext.slider.Multi} slider The slider
         * @param {Ext.EventObject} e The event fired from Ext.dd.DragTracker
         */
        drag(slider: Ext.slider.Multi, e: Ext.EventObject);

        /**
         * Fires after the drag operation has completed.
         * @param {Ext.slider.Multi} slider The slider
         * @param {Ext.EventObject} e The event fired from Ext.dd.DragTracker
         */
        dragend(slider: Ext.slider.Multi, e: Ext.EventObject);

        /**
         * Fires after a drag operation has started.
         * @param {Ext.slider.Multi} slider The slider
         * @param {Ext.EventObject} e The event fired from Ext.dd.DragTracker
         */
        dragstart(slider: Ext.slider.Multi, e: Ext.EventObject);
    }

    /**
     * Slider which supports vertical or horizontal orientation, keyboard adjustments, configurable snapping, axis clicking
     * and animation. Can be added as an item to any container.
     *
     *     @example
     *     Ext.create('Ext.slider.Single', {
     *         width: 200,
     *         value: 50,
     *         increment: 10,
     *         minValue: 0,
     *         maxValue: 100,
     *         renderTo: Ext.getBody()
     *     });
     *
     * The class Ext.slider.Single is aliased to Ext.Slider for backwards compatibility.
     */
    export class Single extends Ext.slider.Multi {
        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface ThumbConfig {
        /**
         * True to constrain the thumb so that it cannot overlap its siblings
         */
        constrain?: boolean;
    }

    /**
     * Represents a single thumb element on a Slider. This would not usually be created manually and would instead
     * be created internally by an {@link Ext.slider.Multi Multi slider}.
     */
    export class Thumb extends Ext.Base implements Ext.slider.ThumbConfig {
        /**
         * The slider this thumb is contained within
         */
        slider: Ext.slider.Multi;

        /**
         * True to constrain the thumb so that it cannot overlap its siblings
         */
        constrain: boolean;

        /**
         * Creates new slider thumb.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.slider.ThumbConfig);

        /**
         * Disables the thumb if it is currently enabled
         */
        disable();

        /**
         * Enables the thumb if it is currently disabled
         */
        enable();

        /**
         * Sets up an Ext.dd.DragTracker for this thumb
         */
        initEvents();

        /**
         * Renders the thumb into a slider
         */
        render();
    }

    interface TipConfig extends Ext.tip.TipConfig {
        /**
         * Alignment configuration for the tip to the slider. See {@link Ext.util.Positionable#alignTo}. Default
         * values for alignment are provided by specifying the {@link #position} config.
         *
         * Optional, Defaults to: null
         */
        align?: string;

        minWidth?: any;

        /**
         * Offsets for aligning the tip to the slider. See {@link Ext.util.Positionable#alignTo}. Default values
         * for offsets are provided by specifying the {@link #position} config.
         *
         * Optional, Defaults to: null
         */
        offsets?: any[];

        /**
         * Sets the position for where the tip will be displayed related to the thumb. This sets
         * defaults for {@link #align} and {@link #offsets} configurations. If {@link #align} or
         * {@link #offsets} configurations are specified, they will override the defaults defined
         * by position.
         *
         * Optional, Defaults to: For horizontal sliders, "top", for vertical sliders, "left"
         */
        position?: string;
    }

    /**
     * Simple plugin for using an Ext.tip.Tip with a slider to show the slider value. In general this class is not created
     * directly, instead pass the {@link Ext.slider.Multi#useTips} and {@link Ext.slider.Multi#tipText} configuration
     * options to the slider directly.
     *
     *     @example
     *     Ext.create('Ext.slider.Single', {
     *         width: 214,
     *         minValue: 0,
     *         maxValue: 100,
     *         useTips: true,
     *         renderTo: Ext.getBody()
     *     });
     *
     * Optionally provide your own tip text by passing tipText:
     *
     *     @example
     *     Ext.create('Ext.slider.Single', {
     *         width: 214,
     *         minValue: 0,
     *         maxValue: 100,
     *         useTips: true,
     *         tipText: function(thumb){
     *             return Ext.String.format('**{0}% complete**', thumb.value);
     *         },
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Tip extends Ext.tip.Tip implements Ext.slider.TipConfig {
        /**
         * Alignment configuration for the tip to the slider. See {@link Ext.util.Positionable#alignTo}. Default
         * values for alignment are provided by specifying the {@link #position} config.
         *
         * Optional, Defaults to: null
         */
        align: string;

        minWidth: number;

        /**
         * Offsets for aligning the tip to the slider. See {@link Ext.util.Positionable#alignTo}. Default values
         * for offsets are provided by specifying the {@link #position} config.
         *
         * Optional, Defaults to: null
         */
        offsets: any[];

        /**
         * Sets the position for where the tip will be displayed related to the thumb. This sets
         * defaults for {@link #align} and {@link #offsets} configurations. If {@link #align} or
         * {@link #offsets} configurations are specified, they will override the defaults defined
         * by position.
         *
         * Optional, Defaults to: For horizontal sliders, "top", for vertical sliders, "left"
         */
        position: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Used to create the text that appears in the Tip's body. By default this just returns the value of the Slider
         * Thumb that the Tip is attached to. Override to customize.
         * @param {Ext.slider.Thumb} thumb The Thumb that the Tip is attached to
         * @return {String} The text to display in the tip
         */
        protected getText(thumb: Ext.slider.Thumb): string;
    }
}

declare module Ext.state {
    interface CookieProviderConfig extends Ext.state.ProviderConfig {
        /**
         * The domain to save the cookie for. Note that you cannot specify a different domain than your page is on, but you can
         * specify a sub-domain, or simply the domain itself like 'sencha.com' to include all sub-domains if you need to access
         * cookies across different sub-domains. Defaults to null which uses the same domain the page is running on including
         * the 'www' like 'www.sencha.com'.
         */
        domain?: string;

        /**
         * The cookie expiration date. Defaults to 7 days from now.
         */
        expires?: Date;

        /**
         * The path for which the cookie is active. Defaults to root '/' which makes it active for all pages in the site.
         */
        path?: string;

        /**
         * True if the site is using SSL
         *
         * Optional, Defaults to: false
         */
        secure?: boolean;
    }

    /**
     * A Provider implementation which saves and retrieves state via cookies. The CookieProvider supports the usual cookie
     * options, such as:
     *
     * - {@link #path}
     * - {@link #expires}
     * - {@link #domain}
     * - {@link #secure}
     *
     * Example:
     *
     *     var cp = Ext.create('Ext.state.CookieProvider', {
     *         path: "/cgi-bin/",
     *         expires: new Date(new Date().getTime()+(1000*60*60*24*30)), //30 days
     *         domain: "sencha.com"
     *     });
     *
     *     Ext.state.Manager.setProvider(cp);
     */
    export class CookieProvider extends Ext.state.Provider implements Ext.state.CookieProviderConfig {
        /**
         * The domain to save the cookie for. Note that you cannot specify a different domain than your page is on, but you can
         * specify a sub-domain, or simply the domain itself like 'sencha.com' to include all sub-domains if you need to access
         * cookies across different sub-domains. Defaults to null which uses the same domain the page is running on including
         * the 'www' like 'www.sencha.com'.
         */
        domain: string;

        /**
         * The cookie expiration date. Defaults to 7 days from now.
         */
        expires: Date;

        /**
         * The path for which the cookie is active. Defaults to root '/' which makes it active for all pages in the site.
         */
        path: string;

        /**
         * True if the site is using SSL
         *
         * Optional, Defaults to: false
         */
        secure: boolean;

        /**
         * Creates a new CookieProvider.
         * @param {Object} [config] Config object.
         */
        constructor(config?: Ext.state.CookieProviderConfig);
    }

    /**
     * A Provider implementation which saves and retrieves state via the HTML5 localStorage object.
     * If the browser does not support local storage, there will be no attempt to read the state.
     * Before creating this class, a check should be made to {@link Ext.supports#LocalStorage}.
     */
    export class LocalStorageProvider extends Ext.state.Provider {
        constructor();
    }

    /**
     * This is the global state manager. By default all components that are "state aware" check this class
     * for state information if you don't pass them a custom state provider. In order for this class
     * to be useful, it must be initialized with a provider when your application initializes. Example usage:
     <pre><code>
     // in your initialization function
     init : function(){
     Ext.state.Manager.setProvider(new Ext.state.CookieProvider());
     }
     </code></pre>
     * This class passes on calls from components to the underlying {@link Ext.state.Provider} so that
     * there is a common interface that can be used without needing to refer to a specific provider instance
     * in every component.
     * @docauthor Evan Trimboli <evan@sencha.com>
     */
    export class Manager {
        /**
         * Clears a value from the state
         * @param {String} name The key name
         */
        static clear(name: string);

        /**
         * Returns the current value for a key
         * @param {String} name The key name
         * @param {Object} defaultValue The default value to return if the key lookup does not match
         * @return {Object} The state data
         */
        static get(name: string, defaultValue: any): any;

        /**
         * Gets the currently configured state provider
         * @return {Ext.state.Provider} The state provider
         */
        static getProvider(): Ext.state.Provider;

        /**
         * Sets the value for a key
         * @param {String} name The key name
         * @param {Object} value The state data
         */
        static set(name: string, value: any);

        /**
         * Configures the default state provider for your application
         * @param {Ext.state.Provider} stateProvider The state provider to set
         */
        static setProvider(stateProvider: Ext.state.Provider);
    }

    interface ProviderConfig {
        /**
         * A string to prefix to items stored in the underlying state store.
         * Defaults to <tt>'ext-'</tt>
         */
        prefix?: string;
    }

    /**
     * <p>Abstract base class for state provider implementations. The provider is responsible
     * for setting values  and extracting values to/from the underlying storage source. The
     * storage source can vary and the details should be implemented in a subclass. For example
     * a provider could use a server side database or the browser localstorage where supported.</p>
     *
     * <p>This class provides methods for encoding and decoding <b>typed</b> variables including
     * dates and defines the Provider interface. By default these methods put the value and the
     * type information into a delimited string that can be stored. These should be overridden in
     * a subclass if you want to change the format of the encoded value and subsequent decoding.</p>
     */
    export class Provider extends Ext.Base implements Ext.state.ProviderConfig {
        /**
         * A string to prefix to items stored in the underlying state store.
         * Defaults to <tt>'ext-'</tt>
         */
        prefix: string;

        /**
         * Clears a value from the state
         * @param {String} name The key name
         */
        clear(name: string);

        constructor(config: Ext.state.ProviderConfig);

        /**
         * Decodes a string previously encoded with {@link #encodeValue}.
         * @param {String} value The value to decode
         * @return {Object} The decoded value
         */
        decodeValue(value: string): any;

        /**
         * Encodes a value including type information.  Decode with {@link #decodeValue}.
         * @param {Object} value The value to encode
         * @return {String} The encoded value
         */
        encodeValue(value: any): string;

        /**
         * Returns the current value for a key
         * @param {String} name The key name
         * @param {Object} defaultValue A default value to return if the key's value is not found
         * @return {Object} The state data
         */
        get(name: string, defaultValue: any): any;

        /**
         * Sets the value for a key
         * @param {String} name The key name
         * @param {Object} value The value to set
         */
        set(name: string, value: any);

        /**
         * Fires when a state change occurs.
         * @param {Ext.state.Provider} this This state provider
         * @param {String} key The state key which was changed
         * @param {String} value The encoded value for the state
         */
        statechange(that: Ext.state.Provider, key: string, value: string);
    }

    interface StatefulConfig {
        /**
         * A buffer to be applied if many state events are fired within a short period.
         */
        saveDelay?: number;

        /**
         * <p>An array of events that, when fired, should trigger this object to
         * save its state. Defaults to none. <code>stateEvents</code> may be any type
         * of event supported by this object, including browser or custom events
         * (e.g., <tt>['click', 'customerchange']</tt>).</p>
         * <p>See <code>{@link #stateful}</code> for an explanation of saving and
         * restoring object state.</p>
         */
        stateEvents?: string;

        /**
         * The unique id for this object to use for state management purposes.
         * <p>See {@link #stateful} for an explanation of saving and restoring state.</p>
         */
        stateId?: string;

        /**
         * A flag which causes the object to attempt to restore the state of
         * internal properties from a saved state on startup. The object must have
         * a {@link #stateId} for state to be managed.
         *
         * Auto-generated ids are not guaranteed to be stable across page loads and
         * cannot be relied upon to save and restore the same state for a object.
         *
         * For state saving to work, the state manager's provider must have been
         * set to an implementation of {@link Ext.state.Provider} which overrides the
         * {@link Ext.state.Provider#set set} and {@link Ext.state.Provider#get get}
         * methods to save and recall name/value pairs. A built-in implementation,
         * {@link Ext.state.CookieProvider} is available.
         *
         * To set the state provider for the current page:
         *
         *    Ext.state.Manager.setProvider(new Ext.state.CookieProvider({
         *        expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
         *    }));
         *
         * A stateful object attempts to save state when one of the events
         * listed in the {@link #stateEvents} configuration fires.
         *
         * To save state, a stateful object first serializes its state by
         * calling *{@link #getState}*.
         *
         * The Component base class implements {@link #getState} to save its width and height within the state
         * only if they were initially configured, and have changed from the configured value.
         *
         * The Panel class saves its collapsed state in addition to that.
         *
         * The Grid class saves its column state in addition to its superclass state.
         *
         * If there is more application state to be save, the developer must provide an implementation which
         * first calls the superclass method to inherit the above behaviour, and then injects new properties
         * into the returned object.
         *
         * The value yielded by getState is passed to {@link Ext.state.Manager#set}
         * which uses the configured {@link Ext.state.Provider} to save the object
         * keyed by the {@link #stateId}.
         *
         * During construction, a stateful object attempts to *restore* its state by calling
         * {@link Ext.state.Manager#get} passing the {@link #stateId}
         *
         * The resulting object is passed to {@link #applyState}*. The default implementation of
         * {@link #applyState} simply copies properties into the object, but a developer may
         * override this to support restoration of more complex application state.
         *
         * You can perform extra processing on state save and restore by attaching
         * handlers to the {@link #beforestaterestore}, {@link #staterestore},
         * {@link #beforestatesave} and {@link #statesave} events.
         */
        stateful?: boolean;
    }

    /**
     * A mixin for being able to save the state of an object to an underlying
     * {@link Ext.state.Provider}.
     */
    export class Stateful extends Ext.Base implements Ext.state.StatefulConfig {
        /**
         * A buffer to be applied if many state events are fired within a short period.
         */
        saveDelay: number;

        /**
         * <p>An array of events that, when fired, should trigger this object to
         * save its state. Defaults to none. <code>stateEvents</code> may be any type
         * of event supported by this object, including browser or custom events
         * (e.g., <tt>['click', 'customerchange']</tt>).</p>
         * <p>See <code>{@link #stateful}</code> for an explanation of saving and
         * restoring object state.</p>
         */
        stateEvents: string;

        /**
         * A flag which causes the object to attempt to restore the state of
         * internal properties from a saved state on startup. The object must have
         * a {@link #stateId} for state to be managed.
         *
         * Auto-generated ids are not guaranteed to be stable across page loads and
         * cannot be relied upon to save and restore the same state for a object.
         *
         * For state saving to work, the state manager's provider must have been
         * set to an implementation of {@link Ext.state.Provider} which overrides the
         * {@link Ext.state.Provider#set set} and {@link Ext.state.Provider#get get}
         * methods to save and recall name/value pairs. A built-in implementation,
         * {@link Ext.state.CookieProvider} is available.
         *
         * To set the state provider for the current page:
         *
         *    Ext.state.Manager.setProvider(new Ext.state.CookieProvider({
         *        expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
         *    }));
         *
         * A stateful object attempts to save state when one of the events
         * listed in the {@link #stateEvents} configuration fires.
         *
         * To save state, a stateful object first serializes its state by
         * calling *{@link #getState}*.
         *
         * The Component base class implements {@link #getState} to save its width and height within the state
         * only if they were initially configured, and have changed from the configured value.
         *
         * The Panel class saves its collapsed state in addition to that.
         *
         * The Grid class saves its column state in addition to its superclass state.
         *
         * If there is more application state to be save, the developer must provide an implementation which
         * first calls the superclass method to inherit the above behaviour, and then injects new properties
         * into the returned object.
         *
         * The value yielded by getState is passed to {@link Ext.state.Manager#set}
         * which uses the configured {@link Ext.state.Provider} to save the object
         * keyed by the {@link #stateId}.
         *
         * During construction, a stateful object attempts to *restore* its state by calling
         * {@link Ext.state.Manager#get} passing the {@link #stateId}
         *
         * The resulting object is passed to {@link #applyState}*. The default implementation of
         * {@link #applyState} simply copies properties into the object, but a developer may
         * override this to support restoration of more complex application state.
         *
         * You can perform extra processing on state save and restore by attaching
         * handlers to the {@link #beforestaterestore}, {@link #staterestore},
         * {@link #beforestatesave} and {@link #statesave} events.
         */
        stateful: boolean;

        /**
         * The unique id for this object to use for state management purposes.
         * <p>See {@link #stateful} for an explanation of saving and restoring state.</p>
         */
        stateId: string;

        /**
         * Add events that will trigger the state to be saved. If the first argument is an
         * array, each element of that array is the name of a state event. Otherwise, each
         * argument passed to this method is the name of a state event.
         *
         * @param {String/String[]} events The event name or an array of event names.
         */
        addStateEvents(events: string);

        /**
         * Applies the state to the object. This should be overridden in subclasses to do
         * more complex state operations. By default it applies the state properties onto
         * the current object.
         * @param {Object} state The state
         */
        applyState(state: any);

        constructor(config: Ext.state.StatefulConfig);

        /**
         * Destroys this stateful object.
         */
        destroy();

        /**
         * Gets the current state of the object. By default this function returns null,
         * it should be overridden in subclasses to implement methods for getting the state.
         * @return {Object} The current state
         */
        getState(): any;

        /**
         * Gathers additional named properties of the instance and adds their current values
         * to the passed state object.
         * @param {String/String[]} propNames The name (or array of names) of the property to save.
         * @param {Object} state The state object in to which to save the property values.
         * @return {Object} state
         */
        savePropsToState(propNames: string, state: any): any;

        /**
         * Conditionally saves a single property from this object to the given state object.
         * The idea is to only save state which has changed from the initial state so that
         * current software settings do not override future software settings. Only those
         * values that are user-changed state should be saved.
         *
         * @param {String} propName The name of the property to save.
         * @param {Object} state The state object in to which to save the property.
         * @param {String} stateName (optional) The name to use for the property in state.
         * @return {Boolean} True if the property was saved, false if not.
         */
        savePropToState(propName: string, state: any, stateName: string): boolean;

        /**
         * Saves the state of the object to the persistence store.
         */
        saveState();

        /**
         * Fires before the state of the object is restored. Return false from an event handler to stop the restore.
         * @param {Object} state The hash of state values returned from the StateProvider. If this
         * event is not vetoed, then the state object is passed to <b><tt>applyState</tt></b>. By default,
         * that simply copies property values into this object. The method maybe overriden to
         * provide custom state restoration.
         */
        beforestaterestore(that: Ext.state.Stateful, state: any);

        /**
         * Fires before the state of the object is saved to the configured state provider. Return false to stop the save.
         * @param {Object} state The hash of state values. This is determined by calling
         * <b><tt>getState()</tt></b> on the object. This method must be provided by the
         * developer to return whetever representation of state is required, by default, Ext.state.Stateful
         * has a null implementation.
         */
        beforestatesave(that: Ext.state.Stateful, state: any);

        /**
         * Fires after the state of the object is restored.
         * @param {Object} state The hash of state values returned from the StateProvider. This is passed
         * to <b><tt>applyState</tt></b>. By default, that simply copies property values into this
         * object. The method maybe overriden to provide custom state restoration.
         */
        staterestore(that: Ext.state.Stateful, state: any);

        /**
         * Fires after the state of the object is saved to the configured state provider.
         * @param {Object} state The hash of state values. This is determined by calling
         * <b><tt>getState()</tt></b> on the object. This method must be provided by the
         * developer to return whetever representation of state is required, by default, Ext.state.Stateful
         * has a null implementation.
         */
        statesave(that: Ext.state.Stateful, state: any);
    }
}

declare module Ext.tab {
    interface BarConfig extends Ext.panel.HeaderConfig {
        baseCls?: any;

        /**
         * The maximum width for a tab in this tab Bar. Defaults to the tab Panel's {@link Ext.tab.Panel#maxTabWidth maxTabWidth} value.
         * @deprecated This config is deprecated. It is much easier to use the {@link Ext.tab.Panel#maxTabWidth maxTabWidth} config on the TabPanel.
         */
        maxTabWidth?: number;

        /**
         * The minimum width for a tab in this tab Bar. Defaults to the tab Panel's {@link Ext.tab.Panel#minTabWidth minTabWidth} value.
         * @deprecated This config is deprecated. It is much easier to use the {@link Ext.tab.Panel#minTabWidth minTabWidth} config on the TabPanel.
         */
        minTabWidth?: number;

        /**
         * True to not show the full background on the tabbar
         */
        plain?: boolean;
    }

    /**
     * @author Ed Spencer
     * TabBar is used internally by a {@link Ext.tab.Panel TabPanel} and typically should not need to be created manually.
     * The tab bar automatically removes the default title provided by {@link Ext.panel.Header}
     */
    export class Bar extends Ext.panel.Header implements Ext.tab.BarConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Tab Bar, or subclass thereof.
         */
        isTabBar: boolean;

        baseCls: string;

        /**
         * The maximum width for a tab in this tab Bar. Defaults to the tab Panel's {@link Ext.tab.Panel#maxTabWidth maxTabWidth} value.
         * @deprecated This config is deprecated. It is much easier to use the {@link Ext.tab.Panel#maxTabWidth maxTabWidth} config on the TabPanel.
         */
        maxTabWidth: number;

        /**
         * The minimum width for a tab in this tab Bar. Defaults to the tab Panel's {@link Ext.tab.Panel#minTabWidth minTabWidth} value.
         * @deprecated This config is deprecated. It is much easier to use the {@link Ext.tab.Panel#minTabWidth minTabWidth} config on the TabPanel.
         */
        minTabWidth: number;

        /**
         * True to not show the full background on the tabbar
         */
        plain: boolean;

        protected afterRender();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected onRender();

        /**
         * Fired when the currently-active tab has changed
         * @param {Ext.tab.Bar} tabBar The TabBar
         * @param {Ext.tab.Tab} tab The new Tab
         * @param {Ext.Component} card The card that was just shown in the TabPanel
         */
        change(tabBar: Ext.tab.Bar, tab: Ext.tab.Tab, card: Ext.Component);
    }

    interface PanelConfig extends Ext.panel.PanelConfig {
        /**
         * Doesn't apply for {@link Ext.tab.Panel TabPanel}, use {@link #activeTab} instead.
         */
        activeItem?: string|number;

        /**
         * The tab to activate initially. Either an ID, index or the tab component itself.
         */
        activeTab?: string|number|Ext.Component;

        /**
         * True by default to defer the rendering of child {@link Ext.container.Container#cfg-items items} to the browsers DOM
         * until a tab is activated. False will render all contained {@link Ext.container.Container#cfg-items items} as soon as
         * the {@link Ext.layout.container.Card layout} is rendered. If there is a significant amount of content or a lot of
         * heavy controls being rendered into panels that are not displayed by default, setting this to true might improve
         * performance.
         *
         * The deferredRender property is internally passed to the layout manager for TabPanels ({@link
         * Ext.layout.container.Card}) as its {@link Ext.layout.container.Card#deferredRender} configuration value.
         *
         * **Note**: leaving deferredRender as true means that the content within an unactivated tab will not be available
         */
        deferredRender?: boolean;

        /**
         * The class added to each child item of this TabPanel.
         *
         * Optional, Defaults to: 'x-tabpanel-child'
         */
        itemCls?: string;

        /**
         * Optional configuration object for the internal {@link Ext.layout.container.Card card layout}.
         * If present, this is passed straight through to the layout's constructor
         */
        layout?: Ext.enums.Layout|any;

        /**
         * The maximum width for each tab.
         */
        maxTabWidth?: number;

        /**
         * The minimum width for a tab in the {@link #cfg-tabBar}.
         */
        minTabWidth?: number;

        /**
         * True to not show the full background on the TabBar.
         */
        plain?: boolean;

        /**
         * True to instruct each Panel added to the TabContainer to not render its header element.
         * This is to ensure that the title of the panel does not appear twice.
         */
        removePanelHeader?: boolean;

        /**
         * The position where the tab strip should be rendered. Can be 'top', 'bottom',
         * 'left' or 'right'
         */
        tabPosition?: any;
    }

    /**
     * @author Ed Spencer, Tommy Maintz, Brian Moeskau
     *
     * A basic tab container. TabPanels can be used exactly like a standard {@link Ext.panel.Panel} for
     * layout purposes, but also have special support for containing child Components
     * ('{@link Ext.container.Container#cfg-items items}') that are managed using a
     * {@link Ext.layout.container.Card CardLayout layout manager}, and displayed as separate tabs.
     *
     * **Note:** By default, a tab's close tool _destroys_ the child tab Component and all its descendants.
     * This makes the child tab Component, and all its descendants **unusable**.  To enable re-use of a tab,
     * configure the TabPanel with '{@link #autoDestroy autoDestroy: false}'.
     *
     * ## TabPanel's layout
     *
     * TabPanels use a Dock layout to position the {@link Ext.tab.Bar TabBar} at the top of the widget.
     * Panels added to the TabPanel will have their header hidden by default because the Tab will
     * automatically take the Panel's configured title and icon.
     *
     * TabPanels use their {@link Ext.panel.Header header} or {@link Ext.panel.Panel#fbar footer}
     * element (depending on the {@link #tabPosition} configuration) to accommodate the tab selector buttons.
     * This means that a TabPanel will not display any configured title, and will not display any configured
     * header {@link Ext.panel.Panel#tools tools}.
     *
     * To display a header, embed the TabPanel in a {@link Ext.panel.Panel Panel} which uses
     * '{@link Ext.container.Container#layout layout: 'fit'}'.
     *
     * ## Controlling tabs
     *
     * Configuration options for the {@link Ext.tab.Tab} that represents the component can be passed in
     * by specifying the tabConfig option:
     *
     *     @example
     *     Ext.create('Ext.tab.Panel', {
     *         width: 400,
     *         height: 400,
     *         renderTo: document.body,
     *         items: [{
     *             title: 'Foo'
     *         }, {
     *             title: 'Bar',
     *             tabConfig: {
     *                 title: 'Custom Title',
     *                 tooltip: 'A button tooltip'
     *             }
     *         }]
     *     });
     *
     * ## Vetoing Changes
     *
     * User interaction when changing the tabs can be vetoed by listening to the {@link #beforetabchange} event.
     * By returning 'false', the tab change will not occur.
     *
     *     @example
     *     Ext.create('Ext.tab.Panel', {
     *         renderTo: Ext.getBody(),
     *         width: 200,
     *         height: 200,
     *         listeners: {
     *             beforetabchange: function(tabs, newTab, oldTab) {
     *                 return newTab.title != 'P2';
     *             }
     *         },
     *         items: [{
     *             title: 'P1'
     *         }, {
     *             title: 'P2'
     *         }, {
     *             title: 'P3'
     *         }]
     *     });
     *
     * # Examples
     *
     * Here is a basic TabPanel rendered to the body. This also shows the useful configuration {@link #activeTab},
     * which allows you to set the active tab on render. If you do not set an {@link #activeTab}, no tabs will be
     * active by default.
     *
     *     @example
     *     Ext.create('Ext.tab.Panel', {
     *         width: 300,
     *         height: 200,
     *         activeTab: 0,
     *         items: [
     *             {
     *                 title: 'Tab 1',
     *                 bodyPadding: 10,
     *                 html : 'A simple tab'
     *             },
     *             {
     *                 title: 'Tab 2',
     *                 html : 'Another one'
     *             }
     *         ],
     *         renderTo : Ext.getBody()
     *     });
     *
     * It is easy to control the visibility of items in the tab bar. Specify hidden: true to have the
     * tab button hidden initially. Items can be subsequently hidden and show by accessing the
     * tab property on the child item.
     *
     *     @example
     *     var tabs = Ext.create('Ext.tab.Panel', {
     *         width: 400,
     *         height: 400,
     *         renderTo: document.body,
     *         items: [{
     *             title: 'Home',
     *             html: 'Home',
     *             itemId: 'home'
     *         }, {
     *             title: 'Users',
     *             html: 'Users',
     *             itemId: 'users',
     *             hidden: true
     *         }, {
     *             title: 'Tickets',
     *             html: 'Tickets',
     *             itemId: 'tickets'
     *         }]
     *     });
     *
     *     setTimeout(function(){
     *         tabs.child('#home').tab.hide();
     *         var users = tabs.child('#users');
     *         users.tab.show();
     *         tabs.setActiveTab(users);
     *     }, 1000);
     *
     * You can remove the background of the TabBar by setting the {@link #plain} property to 'true'.
     *
     *     @example
     *     Ext.create('Ext.tab.Panel', {
     *         width: 300,
     *         height: 200,
     *         activeTab: 0,
     *         plain: true,
     *         items: [
     *             {
     *                 title: 'Tab 1',
     *                 bodyPadding: 10,
     *                 html : 'A simple tab'
     *             },
     *             {
     *                 title: 'Tab 2',
     *                 html : 'Another one'
     *             }
     *         ],
     *         renderTo : Ext.getBody()
     *     });
     *
     * Another useful configuration of TabPanel is {@link #tabPosition}. This allows you to change the
     * position where the tabs are displayed. The available options for this are ''top'' (default) and
     * ''bottom''.
     *
     *     @example
     *     Ext.create('Ext.tab.Panel', {
     *         width: 300,
     *         height: 200,
     *         activeTab: 0,
     *         bodyPadding: 10,
     *         tabPosition: 'bottom',
     *         items: [
     *             {
     *                 title: 'Tab 1',
     *                 html : 'A simple tab'
     *             },
     *             {
     *                 title: 'Tab 2',
     *                 html : 'Another one'
     *             }
     *         ],
     *         renderTo : Ext.getBody()
     *     });
     *
     * The {@link #setActiveTab} is a very useful method in TabPanel which will allow you to change the
     * current active tab. You can either give it an index or an instance of a tab. For example:
     *
     *     @example
     *     var tabs = Ext.create('Ext.tab.Panel', {
     *         items: [
     *             {
     *                 id   : 'my-tab',
     *                 title: 'Tab 1',
     *                 html : 'A simple tab'
     *             },
     *             {
     *                 title: 'Tab 2',
     *                 html : 'Another one'
     *             }
     *         ],
     *         renderTo : Ext.getBody()
     *     });
     *
     *     var tab = Ext.getCmp('my-tab');
     *
     *     Ext.create('Ext.button.Button', {
     *         renderTo: Ext.getBody(),
     *         text    : 'Select the first tab',
     *         scope   : this,
     *         handler : function() {
     *             tabs.setActiveTab(tab);
     *         }
     *     });
     *
     *     Ext.create('Ext.button.Button', {
     *         text    : 'Select the second tab',
     *         scope   : this,
     *         handler : function() {
     *             tabs.setActiveTab(1);
     *         },
     *         renderTo : Ext.getBody()
     *     });
     *
     * The {@link #getActiveTab} is a another useful method in TabPanel which will return the current active tab.
     *
     *     @example
     *     var tabs = Ext.create('Ext.tab.Panel', {
     *         items: [
     *             {
     *                 title: 'Tab 1',
     *                 html : 'A simple tab'
     *             },
     *             {
     *                 title: 'Tab 2',
     *                 html : 'Another one'
     *             }
     *         ],
     *         renderTo : Ext.getBody()
     *     });
     *
     *     Ext.create('Ext.button.Button', {
     *         text    : 'Get active tab',
     *         scope   : this,
     *         handler : function() {
     *             var tab = tabs.getActiveTab();
     *             alert('Current tab: ' + tab.title);
     *         },
     *         renderTo : Ext.getBody()
     *     });
     *
     * Adding a new tab is very simple with a TabPanel. You simple call the {@link #method-add} method with an config
     * object for a panel.
     *
     *     @example
     *     var tabs = Ext.create('Ext.tab.Panel', {
     *         items: [
     *             {
     *                 title: 'Tab 1',
     *                 html : 'A simple tab'
     *             },
     *             {
     *                 title: 'Tab 2',
     *                 html : 'Another one'
     *             }
     *         ],
     *         renderTo : Ext.getBody()
     *     });
     *
     *     Ext.create('Ext.button.Button', {
     *         text    : 'New tab',
     *         scope   : this,
     *         handler : function() {
     *             var tab = tabs.add({
     *                 // we use the tabs.items property to get the length of current items/tabs
     *                 title: 'Tab ' + (tabs.items.length + 1),
     *                 html : 'Another one'
     *             });
     *
     *             tabs.setActiveTab(tab);
     *         },
     *         renderTo : Ext.getBody()
     *     });
     *
     * Additionally, removing a tab is very also simple with a TabPanel. You simple call the {@link #method-remove} method
     * with an config object for a panel.
     *
     *     @example
     *     var tabs = Ext.create('Ext.tab.Panel', {
     *         items: [
     *             {
     *                 title: 'Tab 1',
     *                 html : 'A simple tab'
     *             },
     *             {
     *                 id   : 'remove-this-tab',
     *                 title: 'Tab 2',
     *                 html : 'Another one'
     *             }
     *         ],
     *         renderTo : Ext.getBody()
     *     });
     *
     *     Ext.create('Ext.button.Button', {
     *         text    : 'Remove tab',
     *         scope   : this,
     *         handler : function() {
     *             var tab = Ext.getCmp('remove-this-tab');
     *             tabs.remove(tab);
     *         },
     *         renderTo : Ext.getBody()
     *     });
     */
    export class Panel extends Ext.panel.Panel implements Ext.tab.PanelConfig {
        /**
         * Internal reference to the docked TabBar
         */
        tabBar: Ext.tab.Bar;

        /**
         * Doesn't apply for {@link Ext.tab.Panel TabPanel}, use {@link #activeTab} instead.
         */
        activeItem: string|number;

        /**
         * The tab to activate initially. Either an ID, index or the tab component itself.
         */
        activeTab: string|number|Ext.Component;

        /**
         * True by default to defer the rendering of child {@link Ext.container.Container#cfg-items items} to the browsers DOM
         * until a tab is activated. False will render all contained {@link Ext.container.Container#cfg-items items} as soon as
         * the {@link Ext.layout.container.Card layout} is rendered. If there is a significant amount of content or a lot of
         * heavy controls being rendered into panels that are not displayed by default, setting this to true might improve
         * performance.
         *
         * The deferredRender property is internally passed to the layout manager for TabPanels ({@link
         * Ext.layout.container.Card}) as its {@link Ext.layout.container.Card#deferredRender} configuration value.
         *
         * **Note**: leaving deferredRender as true means that the content within an unactivated tab will not be available
         */
        deferredRender: boolean;

        /**
         * The class added to each child item of this TabPanel.
         *
         * Optional, Defaults to: 'x-tabpanel-child'
         */
        itemCls: string;

        /**
         * Optional configuration object for the internal {@link Ext.layout.container.Card card layout}.
         * If present, this is passed straight through to the layout's constructor
         */
        layout: Ext.enums.Layout|any;

        /**
         * The maximum width for each tab.
         */
        maxTabWidth: number;

        /**
         * The minimum width for a tab in the {@link #cfg-tabBar}.
         */
        minTabWidth: number;

        /**
         * True to not show the full background on the TabBar.
         */
        plain: boolean;

        /**
         * True to instruct each Panel added to the TabContainer to not render its header element.
         * This is to ensure that the title of the panel does not appear twice.
         */
        removePanelHeader: boolean;

        /**
         * The position where the tab strip should be rendered. Can be 'top', 'bottom',
         * 'left' or 'right'
         */
        tabPosition: any;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Returns the item that is currently active inside this TabPanel.
         * @return {Ext.Component} The currently active item.
         */
        getActiveTab(): Ext.Component;

        /**
         * Returns the {@link Ext.tab.Bar} currently used in this TabPanel
         * @return {Ext.tab.Bar} The TabBar
         */
        getTabBar(): Ext.tab.Bar;

        /**
         * Makes the given card active. Makes it the visible card in the TabPanel's CardLayout and highlights the Tab.
         * @param {String/Number/Ext.Component} card The card to make active. Either an ID, index or the component itself.
         * @return {Ext.Component} The resulting active child Component. The call may have been vetoed, or otherwise
         * modified by an event listener.
         */
        setActiveTab(card: string|number|Ext.Component): Ext.Component;

        /**
         * Fires before a tab change (activated by {@link #setActiveTab}). Return false in any listener to cancel
         * the tabchange
         * @param {Ext.tab.Panel} tabPanel The TabPanel
         * @param {Ext.Component} newCard The card that is about to be activated
         * @param {Ext.Component} oldCard The card that is currently active
         */
        beforetabchange(tabPanel: Ext.tab.Panel, newCard: Ext.Component, oldCard: Ext.Component);

        /**
         * Fires when a new tab has been activated (activated by {@link #setActiveTab}).
         * @param {Ext.tab.Panel} tabPanel The TabPanel
         * @param {Ext.Component} newCard The newly activated item
         * @param {Ext.Component} oldCard The previously active item
         */
        tabchange(tabPanel: Ext.tab.Panel, newCard: Ext.Component, oldCard: Ext.Component);
    }

    interface TabConfig extends Ext.button.ButtonConfig {
        /**
         * The CSS class to be applied to a Tab when it is active.
         * Providing your own CSS for this class enables you to customize the active state.
         */
        activeCls?: string;

        baseCls?: any;

        /**
         * The CSS class which is added to the tab when it is closable
         */
        closableCls?: string;

        /**
         * The accessible text label for the close button link; only used when {@link #cfg-closable} = true.
         */
        closeText?: string;

        /**
         * The CSS class to be applied to a Tab when it is disabled.
         *
         * Optional, Defaults to: 'x-tab-disabled'
         */
        disabledCls?: string;

        scale?: any;
    }

    /**
     * @author Ed Spencer
     *
     * Represents a single Tab in a {@link Ext.tab.Panel TabPanel}. A Tab is simply a slightly customized {@link Ext.button.Button Button},
     * styled to look like a tab. Tabs are optionally closable, and can also be disabled. 99% of the time you will not
     * need to create Tabs manually as the framework does so automatically when you use a {@link Ext.tab.Panel TabPanel}
     */
    export class Tab extends Ext.button.Button implements Ext.tab.TabConfig {
        /**
         * Indicates that this tab is currently active. This is NOT a public configuration.
         * @readonly
         */
        active: boolean;

        /**
         * True if the tab is currently closable
         */
        closable: boolean;

        /**
         * 'true' in this class to identify an object as an instantiated Tab, or subclass thereof.
         */
        isTab: boolean;

        /**
         * The CSS class to be applied to a Tab when it is active.
         * Providing your own CSS for this class enables you to customize the active state.
         */
        activeCls: string;

        baseCls: string;

        /**
         * The CSS class which is added to the tab when it is closable
         */
        closableCls: string;

        /**
         * The accessible text label for the close button link; only used when {@link #cfg-closable} = true.
         */
        closeText: string;

        /**
         * The CSS class to be applied to a Tab when it is disabled.
         *
         * Optional, Defaults to: 'x-tab-disabled'
         */
        disabledCls: string;

        scale: any;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        protected initComponent();

        /**
         * Sets this tab's attached card. Usually this is handled automatically by the {@link Ext.tab.Panel} that this Tab
         * belongs to and would not need to be done by the developer
         * @param {Ext.Component} card The card to set
         */
        setCard(card: Ext.Component);

        /**
         * Sets the tab as either closable or not.
         * @param {Boolean} closable Pass false to make the tab not closable. Otherwise the tab will be made closable (eg a
         * close button will appear on the tab)
         */
        setClosable(closable: boolean);

        /**
         * Fires if the user clicks on the Tab's close button, but before the {@link #close} event is fired. Return
         * false from any listener to stop the close event being fired
         * @param {Ext.tab.Tab} tab The Tab object
         */
        beforeclose(tab: Ext.tab.Tab);

        /**
         * Fires to indicate that the tab is to be closed, usually because the user has clicked the close button.
         * @param {Ext.tab.Tab} tab The Tab object
         */
        close(tab: Ext.tab.Tab);
    }
}

declare module Ext.tip {
    interface QuickTipConfig extends Ext.tip.ToolTipConfig {
        /**
         * 'true' to automatically use the element's DOM title value if available.
         */
        interceptTitles?: boolean;

        title?: any;
    }

    /**
     * A specialized tooltip class for tooltips that can be specified in markup and automatically managed
     * by the global {@link Ext.tip.QuickTipManager} instance.  See the QuickTipManager documentation for
     * additional usage details and examples.
     */
    export class QuickTip extends Ext.tip.ToolTip implements Ext.tip.QuickTipConfig {
        /**
         * 'true' to automatically use the element's DOM title value if available.
         */
        interceptTitles: boolean;

        title: string;

        /**
         * Hides a visible tip or cancels an impending show for a particular element.
         * @param {String/HTMLElement/Ext.Element} el The element that is the target of
         * the tip or ID of the element.
         */
        cancelShow(el: string|HTMLElement|Ext.dom.Element);

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Configures a new quick tip instance and assigns it to a target element.
         *
         * For example usage, see the {@link Ext.tip.QuickTipManager} class header.
         *
         * @param {Object} config The config object with the following properties:
         * @param config.dismissDelay overrides the singleton value
         */
        register(config: Ext.tip.QuickTipConfig);

        /**
         * Removes this quick tip from its element and destroys it.
         * @param {String/HTMLElement/Ext.Element} el The element from which the quick tip
         * is to be removed or ID of the element.
         */
        unregister(el: string|HTMLElement|Ext.dom.Element);
    }

    /**
     * Provides attractive and customizable tooltips for any element. The QuickTips
     * singleton is used to configure and manage tooltips globally for multiple elements
     * in a generic manner.  To create individual tooltips with maximum customizability,
     * you should consider either {@link Ext.tip.Tip} or {@link Ext.tip.ToolTip}.
     *
     * Quicktips can be configured via tag attributes directly in markup, or by
     * registering quick tips programmatically via the {@link #register} method.
     *
     * The singleton's instance of {@link Ext.tip.QuickTip} is available via
     * {@link #getQuickTip}, and supports all the methods, and all the all the
     * configuration properties of Ext.tip.QuickTip. These settings will apply to all
     * tooltips shown by the singleton.
     *
     * Below is the summary of the configuration properties which can be used.
     * For detailed descriptions see the config options for the
     * {@link Ext.tip.QuickTip QuickTip} class
     *
     * ## QuickTips singleton configs (all are optional)
     *
     *  - 'dismissDelay'
     *  - 'hideDelay'
     *  - 'maxWidth'
     *  - 'minWidth'
     *  - 'showDelay'
     *  - 'trackMouse'
     *
     * ## Target element configs (optional unless otherwise noted)
     *
     *  - 'autoHide'
     *  - 'cls'
     *  - 'dismissDelay' (overrides singleton value)
     *  - 'target' (required)
     *  - 'text' (required)
     *  - 'title'
     *  - 'width'
     *
     * Here is an example showing how some of these config options could be used:
     *
     *     @example
     *     // Init the singleton.  Any tag-based quick tips will start working.
     *     Ext.tip.QuickTipManager.init();
     *
     *     // Apply a set of config properties to the singleton
     *     Ext.apply(Ext.tip.QuickTipManager.getQuickTip(), {
     *         maxWidth: 200,
     *         minWidth: 100,
     *         showDelay: 50      // Show 50ms after entering target
     *     });
     *
     *     // Create a small panel to add a quick tip to
     *     Ext.create('Ext.container.Container', {
     *         id: 'quickTipContainer',
     *         width: 200,
     *         height: 150,
     *         style: {
     *             backgroundColor:'#000000'
     *         },
     *         renderTo: Ext.getBody()
     *     });
     *
     *
     *     // Manually register a quick tip for a specific element
     *     Ext.tip.QuickTipManager.register({
     *         target: 'quickTipContainer',
     *         title: 'My Tooltip',
     *         text: 'This tooltip was added in code',
     *         width: 100,
     *         dismissDelay: 10000 // Hide after 10 seconds hover
     *     });
     *
     * To register a quick tip in markup, you simply add one or more of the valid QuickTip
     * attributes prefixed with the **data-** namespace.  The HTML element itself is
     * automatically set as the quick tip target. Here is the summary of supported attributes
     * (optional unless otherwise noted):
     *
     *  - 'hide': Specifying "user" is equivalent to setting autoHide = false.
     *     Any other value will be the same as autoHide = true.
     *  - 'qclass': A CSS class to be applied to the quick tip
     *     (equivalent to the 'cls' target element config).
     *  - 'qtip (required)': The quick tip text (equivalent to the 'text' target element config).
     *  - 'qtitle': The quick tip title (equivalent to the 'title' target element config).
     *  - 'qwidth': The quick tip width (equivalent to the 'width' target element config).
     *
     * Here is an example of configuring an HTML element to display a tooltip from markup:
     *
     *     // Add a quick tip to an HTML button
     *     <input type="button" value="OK" data-qtitle="OK Button" data-qwidth="100"
     *          data-qtip="This is a quick tip from markup!"></input>
     */
    export class QuickTipManager {
        /**
         * Destroys the QuickTips instance.
         */
        static destroy();

        /**
         * Disables quick tips globally.
         */
        static disable();

        /**
         * Enables quick tips globally.
         */
        static enable();

        /**
         * Gets the single {@link Ext.tip.QuickTip QuickTip} instance used to show tips
         * from all registered elements.
         * @return {Ext.tip.QuickTip}
         */
        static getQuickTip(): Ext.tip.QuickTip;

        /**
         * Initializes the global QuickTips instance and prepare any quick tips.
         * @param {Boolean} [autoRender=true] True to render the QuickTips container
         * immediately to preload images.
         * @param {Object} [config] config object for the created QuickTip. By
         * default, the {@link Ext.tip.QuickTip QuickTip} class is instantiated, but this can
         * be changed by supplying an xtype property or a className property in this object.
         * All other properties on this object are configuration for the created component.
         */
        static init(autoRender?: boolean, config?: any);

        /**
         * Returns true if quick tips are enabled, else false.
         * @return {Boolean}
         */
        static isEnabled(): boolean;

        /**
         * Configures a new quick tip instance and assigns it to a target element.  See
         * {@link Ext.tip.QuickTip#register} for details.
         * @param {Object} config The config object
         */
        static register(config: any);

        /**
         * Alias of {@link #register}.
         */
        static tips();

        /**
         * Removes any registered quick tip from the target element and destroys it.
         * @param {String/HTMLElement/Ext.Element} el The element from which the quick tip
         * is to be removed or ID of the element.
         */
        static unregister(el: string|HTMLElement|Ext.dom.Element);
    }

    interface TipConfig extends Ext.panel.PanelConfig {
        autoRender?: any;

        baseCls?: any;

        /**
         * True to render a close tool button into the tooltip header.
         *
         * Optional, Defaults to: false
         */
        closable?: boolean;

        /**
         * The action to take when the close header tool is clicked:
         *
         * - **{@link #method-destroy}** : {@link #method-remove remove} the window from the DOM and
         *   {@link Ext.Component#method-destroy destroy} it and all descendant Components. The
         *   window will **not** be available to be redisplayed via the {@link #method-show} method.
         *
         * - **{@link #method-hide}** : **Default.** {@link #method-hide} the window by setting visibility
         *   to hidden and applying negative offsets. The window will be available to be
         *   redisplayed via the {@link #method-show} method.
         *
         * **Note:** This behavior has changed! setting *does* affect the {@link #method-close} method
         * which will invoke the approriate closeAction.
         */
        closeAction?: string;

        /**
         * If 'true', then the tooltip will be automatically constrained to stay within
         * the browser viewport.
         */
        constrainPosition?: boolean;

        /**
         * **Experimental**. The default {@link Ext.util.Positionable#alignTo} anchor position value
         * for this tip relative to its element of origin.
         */
        defaultAlign?: string;

        floating?: any;

        focusOnToFront?: any;

        frameHeader?: any;

        hidden?: any;

        /**
         * The maximum width of the tip in pixels.  The maximum supported value is 500.
         */
        maxWidth?: number;

        /**
         * The minimum width of the tip in pixels.
         */
        minWidth?: number;

        /**
         * 'true' or "sides" for the default effect, "frame" for 4-way shadow, and "drop"
         * for bottom-right shadow.
         */
        shadow?: boolean|string;

        /**
         * Width in pixels of the tip.  Width will be ignored if it
         * exceeds the bounds of {@link #minWidth} or {@link #maxWidth}.
         *
         * Optional, Defaults to: 'auto'
         */
        width?: number;
    }

    /**
     * This is the base class for {@link Ext.tip.QuickTip} and {@link Ext.tip.ToolTip} that provides the basic layout and
     * positioning that all tip-based classes require. This class can be used directly for simple, statically-positioned
     * tips that are displayed programmatically, or it can be extended to provide custom tip implementations.
     * @xtype tip
     */
    export class Tip extends Ext.panel.Panel implements Ext.tip.TipConfig {
        autoRender: boolean|string|HTMLElement|Ext.dom.Element;

        baseCls: string;

        /**
         * True to render a close tool button into the tooltip header.
         *
         * Optional, Defaults to: false
         */
        closable: boolean;

        /**
         * The action to take when the close header tool is clicked:
         *
         * - **{@link #method-destroy}** : {@link #method-remove remove} the window from the DOM and
         *   {@link Ext.Component#method-destroy destroy} it and all descendant Components. The
         *   window will **not** be available to be redisplayed via the {@link #method-show} method.
         *
         * - **{@link #method-hide}** : **Default.** {@link #method-hide} the window by setting visibility
         *   to hidden and applying negative offsets. The window will be available to be
         *   redisplayed via the {@link #method-show} method.
         *
         * **Note:** This behavior has changed! setting *does* affect the {@link #method-close} method
         * which will invoke the approriate closeAction.
         */
        closeAction: string;

        /**
         * If 'true', then the tooltip will be automatically constrained to stay within
         * the browser viewport.
         */
        constrainPosition: boolean;

        /**
         * **Experimental**. The default {@link Ext.util.Positionable#alignTo} anchor position value
         * for this tip relative to its element of origin.
         */
        defaultAlign: string;

        floating: boolean;

        focusOnToFront: any;

        frameHeader: boolean;

        hidden: boolean;

        /**
         * The maximum width of the tip in pixels.  The maximum supported value is 500.
         */
        maxWidth: number;

        /**
         * The minimum width of the tip in pixels.
         */
        minWidth: number;

        /**
         * 'true' or "sides" for the default effect, "frame" for 4-way shadow, and "drop"
         * for bottom-right shadow.
         */
        shadow: boolean|string;

        /**
         * Width in pixels of the tip.  Width will be ignored if it
         * exceeds the bounds of {@link #minWidth} or {@link #maxWidth}.
         *
         * Optional, Defaults to: 'auto'
         */
        width: number;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface ToolTipConfig extends Ext.tip.TipConfig {
        /**
         * If specified, indicates that the tip should be anchored to a
         * particular side of the target element or mouse pointer ("top", "right", "bottom",
         * or "left"), with an arrow pointing back at the target or mouse pointer. If
         * {@link #constrainPosition} is enabled, this will be used as a preferred value
         * only and may be flipped as needed.
         */
        anchor?: string;

        /**
         * A numeric pixel value used to offset the default position of the anchor arrow.  When the anchor
         * position is on the top or bottom of the tooltip, 'anchorOffset' will be used as a horizontal offset.
         * Likewise, when the anchor position is on the left or right side, 'anchorOffset' will be used as
         * a vertical offset.
         */
        anchorOffset?: number;

        /**
         * True to anchor the tooltip to the target element, false to anchor it relative to the mouse coordinates.
         * When 'anchorToTarget' is true, use '{@link #defaultAlign}' to control tooltip alignment to the
         * target element.  When 'anchorToTarget' is false, use '{@link #anchor}' instead to control alignment.
         */
        anchorToTarget?: boolean;

        /**
         * True to automatically hide the tooltip after the
         * mouse exits the target element or after the '{@link #dismissDelay}'
         * has expired if set.  If '{@link #closable} = true'
         * a close tool button will be rendered into the tooltip header.
         *
         * Optional, Defaults to: true
         */
        autoHide?: boolean;

        /**
         * A {@link Ext.DomQuery DomQuery} selector which allows selection of individual elements within the
         * '{@link #target}' element to trigger showing and hiding the ToolTip as the mouse moves within the
         * target.
         *
         * When specified, the child element of the target which caused a show event is placed into the
         * '{@link #triggerElement}' property before the ToolTip is shown.
         *
         * This may be useful when a Component has regular, repeating elements in it, each of which need a
         * ToolTip which contains information specific to that element.
         *
         * See the delegate example in class documentation of {@link Ext.tip.ToolTip}.
         */
        delegate?: string;

        /**
         * Delay in milliseconds before the tooltip automatically hides. To disable automatic hiding, set
         * dismissDelay = 0.
         */
        dismissDelay?: number;

        /**
         * Delay in milliseconds after the mouse exits the target element but before the tooltip actually hides.
         * Set to 0 for the tooltip to hide immediately.
         */
        hideDelay?: number;

        /**
         * An XY offset from the mouse position where the tooltip should be shown.
         *
         * Optional, Defaults to: [15,18
         */
        mouseOffset?: number;

        /**
         * Delay in milliseconds before the tooltip displays after the mouse enters the target element.
         */
        showDelay?: number;

        /**
         * The target element or string id to monitor for mouseover events to trigger
         * showing this ToolTip.
         */
        target?: HTMLElement|Ext.dom.Element|string;

        /**
         * True to have the tooltip follow the mouse as it moves over the target element.
         */
        trackMouse?: boolean;
    }

    /**
     * ToolTip is a {@link Ext.tip.Tip} implementation that handles the common case of displaying a
     * tooltip when hovering over a certain element or elements on the page. It allows fine-grained
     * control over the tooltip's alignment relative to the target element or mouse, and the timing
     * of when it is automatically shown and hidden.
     *
     * This implementation does **not** have a built-in method of automatically populating the tooltip's
     * text based on the target element; you must either configure a fixed {@link #html} value for each
     * ToolTip instance, or implement custom logic (e.g. in a {@link #beforeshow} event listener) to
     * generate the appropriate tooltip content on the fly. See {@link Ext.tip.QuickTip} for a more
     * convenient way of automatically populating and configuring a tooltip based on specific DOM
     * attributes of each target element.
     *
     * # Basic Example
     *
     *     var tip = Ext.create('Ext.tip.ToolTip', {
     *         target: 'clearButton',
     *         html: 'Press this button to clear the form'
     *     });
     *
     * {@img Ext.tip.ToolTip/Ext.tip.ToolTip1.png Basic Ext.tip.ToolTip}
     *
     * # Delegation
     *
     * In addition to attaching a ToolTip to a single element, you can also use delegation to attach
     * one ToolTip to many elements under a common parent. This is more efficient than creating many
     * ToolTip instances. To do this, point the {@link #target} config to a common ancestor of all the
     * elements, and then set the {@link #delegate} config to a CSS selector that will select all the
     * appropriate sub-elements.
     *
     * When using delegation, it is likely that you will want to programmatically change the content
     * of the ToolTip based on each delegate element; you can do this by implementing a custom
     * listener for the {@link #beforeshow} event. Example:
     *
     *     var store = Ext.create('Ext.data.ArrayStore', {
     *         fields: ['company', 'price', 'change'],
     *         data: [
     *             ['3m Co',                               71.72, 0.02],
     *             ['Alcoa Inc',                           29.01, 0.42],
     *             ['Altria Group Inc',                    83.81, 0.28],
     *             ['American Express Company',            52.55, 0.01],
     *             ['American International Group, Inc.',  64.13, 0.31],
     *             ['AT&T Inc.',                           31.61, -0.48]
     *         ]
     *     });
     *
     *     var grid = Ext.create('Ext.grid.Panel', {
     *         title: 'Array Grid',
     *         store: store,
     *         columns: [
     *             {text: 'Company', flex: 1, dataIndex: 'company'},
     *             {text: 'Price', width: 75, dataIndex: 'price'},
     *             {text: 'Change', width: 75, dataIndex: 'change'}
     *         ],
     *         height: 200,
     *         width: 400,
     *         renderTo: Ext.getBody()
     *     });
     *
     *     var view = grid.getView();
     *     var tip = Ext.create('Ext.tip.ToolTip', {
     *         // The overall target element.
     *         target: view.el,
     *         // Each grid row causes its own separate show and hide.
     *         delegate: view.itemSelector,
     *         // Moving within the row should not hide the tip.
     *         trackMouse: true,
     *         // Render immediately so that tip.body can be referenced prior to the first show.
     *         renderTo: Ext.getBody(),
     *         listeners: {
     *             // Change content dynamically depending on which element triggered the show.
     *             beforeshow: function updateTipBody(tip) {
     *                 tip.update('Over company "' + view.getRecord(tip.triggerElement).get('company') + '"');
     *             }
     *         }
     *     });
     *
     * {@img Ext.tip.ToolTip/Ext.tip.ToolTip2.png Ext.tip.ToolTip with delegation}
     *
     * # Alignment
     *
     * The following configuration properties allow control over how the ToolTip is aligned relative to
     * the target element and/or mouse pointer:
     *
     * - {@link #anchor}
     * - {@link #anchorToTarget}
     * - {@link #anchorOffset}
     * - {@link #trackMouse}
     * - {@link #mouseOffset}
     *
     * # Showing/Hiding
     *
     * The following configuration properties allow control over how and when the ToolTip is automatically
     * shown and hidden:
     *
     * - {@link #autoHide}
     * - {@link #showDelay}
     * - {@link #hideDelay}
     * - {@link #dismissDelay}
     *
     * @docauthor Jason Johnston <jason@sencha.com>
     */
    export class ToolTip extends Ext.tip.Tip implements Ext.tip.ToolTipConfig {
        /**
         * When a ToolTip is configured with the '{@link #delegate}'
         * option to cause selected child elements of the '{@link #target}'
         * Element to each trigger a separate show event, this property is set to
         * the DOM element which triggered the show.
         */
        triggerElement: HTMLElement;

        /**
         * If specified, indicates that the tip should be anchored to a
         * particular side of the target element or mouse pointer ("top", "right", "bottom",
         * or "left"), with an arrow pointing back at the target or mouse pointer. If
         * {@link #constrainPosition} is enabled, this will be used as a preferred value
         * only and may be flipped as needed.
         */
        anchor: string;

        /**
         * A numeric pixel value used to offset the default position of the anchor arrow.  When the anchor
         * position is on the top or bottom of the tooltip, 'anchorOffset' will be used as a horizontal offset.
         * Likewise, when the anchor position is on the left or right side, 'anchorOffset' will be used as
         * a vertical offset.
         */
        anchorOffset: number;

        /**
         * True to anchor the tooltip to the target element, false to anchor it relative to the mouse coordinates.
         * When 'anchorToTarget' is true, use '{@link #defaultAlign}' to control tooltip alignment to the
         * target element.  When 'anchorToTarget' is false, use '{@link #anchor}' instead to control alignment.
         */
        anchorToTarget: boolean;

        /**
         * True to automatically hide the tooltip after the
         * mouse exits the target element or after the '{@link #dismissDelay}'
         * has expired if set.  If '{@link #closable} = true'
         * a close tool button will be rendered into the tooltip header.
         *
         * Optional, Defaults to: true
         */
        autoHide: boolean;

        /**
         * A {@link Ext.DomQuery DomQuery} selector which allows selection of individual elements within the
         * '{@link #target}' element to trigger showing and hiding the ToolTip as the mouse moves within the
         * target.
         *
         * When specified, the child element of the target which caused a show event is placed into the
         * '{@link #triggerElement}' property before the ToolTip is shown.
         *
         * This may be useful when a Component has regular, repeating elements in it, each of which need a
         * ToolTip which contains information specific to that element.
         *
         * See the delegate example in class documentation of {@link Ext.tip.ToolTip}.
         */
        delegate: string;

        /**
         * Delay in milliseconds before the tooltip automatically hides. To disable automatic hiding, set
         * dismissDelay = 0.
         */
        dismissDelay: number;

        /**
         * Delay in milliseconds after the mouse exits the target element but before the tooltip actually hides.
         * Set to 0 for the tooltip to hide immediately.
         */
        hideDelay: number;

        /**
         * An XY offset from the mouse position where the tooltip should be shown.
         *
         * Optional, Defaults to: [15,18
         */
        mouseOffset: number;

        /**
         * Delay in milliseconds before the tooltip displays after the mouse enters the target element.
         */
        showDelay: number;

        /**
         * The target element or string id to monitor for mouseover events to trigger
         * showing this ToolTip.
         */
        target: HTMLElement|Ext.dom.Element|string;

        /**
         * True to have the tooltip follow the mouse as it moves over the target element.
         */
        trackMouse: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Binds this ToolTip to the specified element. The tooltip will be displayed when the mouse moves over the element.
         * @param {String/HTMLElement/Ext.Element} t The Element, HtmlElement, or ID of an element to bind to
         */
        setTarget(t: string|HTMLElement|Ext.dom.Element);
    }
}

declare module Ext.toolbar {
    /**
     * A non-rendering placeholder item which instructs the Toolbar's Layout to begin using
     * the right-justified button container.
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *          title: 'Toolbar Fill Example',
     *          width: 300,
     *          height: 200,
     *          tbar : [
     *              'Item 1',
     *              { xtype: 'tbfill' },
     *              'Item 2'
     *          ],
     *          renderTo: Ext.getBody()
     *      });
     */
    export class Fill extends Ext.Component {
        /**
         * 'true' in this class to identify an object as an instantiated Fill, or subclass thereof.
         */
        isFill: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface ItemConfig extends Ext.ComponentConfig {
        /**
         * Text to be used for the menu if the item is overflowed.
         */
        overflowText?: string;
    }

    /**
     * The base class that other non-interacting Toolbar Item classes should extend in order to
     * get some basic common toolbar item functionality.
     */
    export class Item extends Ext.Component implements Ext.toolbar.ItemConfig {
        /**
         * Text to be used for the menu if the item is overflowed.
         */
        overflowText: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface PagingConfig extends Ext.toolbar.ToolbarConfig {
        /**
         * Customizable piece of the default paging text. Note that this string is formatted using
         * {0} as a token that is replaced by the number of total pages. This token should be preserved when overriding this
         * string if showing the total page count is desired.
         */
        afterPageText?: string;

        /**
         * The text displayed before the input item.
         */
        beforePageText?: string;

        /**
         * true to display the displayMsg
         */
        displayInfo?: boolean;

        /**
         * The paging status message to display. Note that this string is
         * formatted using the braced numbers {0}-{2} as tokens that are replaced by the values for start, end and total
         * respectively. These tokens should be preserved when overriding this string if showing those values is desired.
         */
        displayMsg?: string;

        /**
         * The message to display when no records are found.
         */
        emptyMsg?: string;

        /**
         * The quicktip text displayed for the first page button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        firstText?: string;

        /**
         * The width in pixels of the input field used to display and change the current page number.
         */
        inputItemWidth?: number;

        /**
         * The quicktip text displayed for the last page button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        lastText?: string;

        /**
         * The quicktip text displayed for the next page button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        nextText?: string;

        /**
         * true to insert any configured items _before_ the paging buttons.
         */
        prependButtons?: boolean;

        /**
         * The quicktip text displayed for the previous page button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        prevText?: string;

        /**
         * The quicktip text displayed for the Refresh button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        refreshText?: string;

        /**
         * (required)
         * The {@link Ext.data.Store} the paging toolbar should use as its data source.
         */
        store?: Ext.data.Store;
    }

    /**
     * As the number of records increases, the time required for the browser to render them increases. Paging is used to
     * reduce the amount of data exchanged with the client. Note: if there are more records/rows than can be viewed in the
     * available screen area, vertical scrollbars will be added.
     *
     * Paging is typically handled on the server side (see exception below). The client sends parameters to the server side,
     * which the server needs to interpret and then respond with the appropriate data.
     *
     * Ext.toolbar.Paging is a specialized toolbar that is bound to a {@link Ext.data.Store} and provides automatic
     * paging control. This Component {@link Ext.data.Store#method-load load}s blocks of data into the {@link #store} by passing
     * parameters used for paging criteria.
     *
     * {@img Ext.toolbar.Paging/Ext.toolbar.Paging.png Ext.toolbar.Paging component}
     *
     * Paging Toolbar is typically used as one of the Grid's toolbars:
     *
     *     @example
     *     var itemsPerPage = 2;   // set the number of items you want per page
     *
     *     var store = Ext.create('Ext.data.Store', {
     *         id:'simpsonsStore',
     *         autoLoad: false,
     *         fields:['name', 'email', 'phone'],
     *         pageSize: itemsPerPage, // items per page
     *         proxy: {
     *             type: 'ajax',
     *             url: 'pagingstore.js',  // url that will load data with respect to start and limit params
     *             reader: {
     *                 type: 'json',
     *                 root: 'items',
     *                 totalProperty: 'total'
     *             }
     *         }
     *     });
     *
     *     // specify segment of data you want to load using params
     *     store.load({
     *         params:{
     *             start:0,
     *             limit: itemsPerPage
     *         }
     *     });
     *
     *     Ext.create('Ext.grid.Panel', {
     *         title: 'Simpsons',
     *         store: store,
     *         columns: [
     *             { header: 'Name',  dataIndex: 'name' },
     *             { header: 'Email', dataIndex: 'email', flex: 1 },
     *             { header: 'Phone', dataIndex: 'phone' }
     *         ],
     *         width: 400,
     *         height: 125,
     *         dockedItems: [{
     *             xtype: 'pagingtoolbar',
     *             store: store,   // same store GridPanel is using
     *             dock: 'bottom',
     *             displayInfo: true
     *         }],
     *         renderTo: Ext.getBody()
     *     });
     *
     * To use paging, you need to set a pageSize configuration on the Store, and pass the paging requirements to
     * the server when the store is first loaded.
     *
     *     store.load({
     *         params: {
     *             // specify params for the first page load if using paging
     *             start: 0,
     *             limit: myPageSize,
     *             // other params
     *             foo:   'bar'
     *         }
     *     });
     *
     * If using {@link Ext.data.Store#autoLoad store's autoLoad} configuration:
     *
     *     var myStore = Ext.create('Ext.data.Store', {
     *         {@link Ext.data.Store#autoLoad autoLoad}: {start: 0, limit: 25},
     *         ...
     *     });
     *
     * The packet sent back from the server would have this form:
     *
     *     {
     *         "success": true,
     *         "results": 2000,
     *         "rows": [ // ***Note:** this must be an Array
     *             { "id":  1, "name": "Bill", "occupation": "Gardener" },
     *             { "id":  2, "name":  "Ben", "occupation": "Horticulturalist" },
     *             ...
     *             { "id": 25, "name":  "Sue", "occupation": "Botanist" }
     *         ]
     *     }
     *
     * ## Paging with Local Data
     *
     * Paging can also be accomplished with local data using extensions:
     *
     *   - [Ext.ux.data.PagingStore][1]
     *   - Paging Memory Proxy (examples/ux/PagingMemoryProxy.js)
     *
     *    [1]: http://sencha.com/forum/showthread.php?t=71532
     */
    export class Paging extends Ext.toolbar.Toolbar implements Ext.toolbar.PagingConfig {
        /**
         * Customizable piece of the default paging text. Note that this string is formatted using
         * {0} as a token that is replaced by the number of total pages. This token should be preserved when overriding this
         * string if showing the total page count is desired.
         */
        afterPageText: string;

        /**
         * The text displayed before the input item.
         */
        beforePageText: string;

        /**
         * true to display the displayMsg
         */
        displayInfo: boolean;

        /**
         * The paging status message to display. Note that this string is
         * formatted using the braced numbers {0}-{2} as tokens that are replaced by the values for start, end and total
         * respectively. These tokens should be preserved when overriding this string if showing those values is desired.
         */
        displayMsg: string;

        /**
         * The message to display when no records are found.
         */
        emptyMsg: string;

        /**
         * The quicktip text displayed for the first page button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        firstText: string;

        /**
         * The width in pixels of the input field used to display and change the current page number.
         */
        inputItemWidth: number;

        /**
         * The quicktip text displayed for the last page button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        lastText: string;

        /**
         * The quicktip text displayed for the next page button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        nextText: string;

        /**
         * true to insert any configured items _before_ the paging buttons.
         */
        prependButtons: boolean;

        /**
         * The quicktip text displayed for the previous page button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        prevText: string;

        /**
         * The quicktip text displayed for the Refresh button.
         * **Note**: quick tips must be initialized for the quicktip to show.
         */
        refreshText: string;

        /**
         * (required)
         * The {@link Ext.data.Store} the paging toolbar should use as its data source.
         */
        store: Ext.data.Store;

        /**
         * Binds the paging toolbar to the specified {@link Ext.data.Store} **(deprecated)**
         * @param {Ext.data.Store} store The data store to bind
         */
        bind(store: Ext.data.Store);

        /**
         * Basic Toolbar class. Although the {@link Ext.container.Container#defaultType defaultType} for
         * Toolbar is {@link Ext.button.Button button}, Toolbar elements (child items for the Toolbar container)
         * may be virtually any type of Component. Toolbar elements can be created explicitly via their
         * constructors, or implicitly via their xtypes, and can be {@link #method-add}ed dynamically.
         *
         * ## Some items have shortcut strings for creation:
         *
         * | Shortcut | xtype         | Class                         | Description
         * |:---------|:--------------|:------------------------------|:---------------------------------------------------
         * | '->'     | 'tbfill'      | {@link Ext.toolbar.Fill}      | begin using the right-justified button container
         * | '-'      | 'tbseparator' | {@link Ext.toolbar.Separator} | add a vertical separator bar between toolbar items
         * | ' '      | 'tbspacer'    | {@link Ext.toolbar.Spacer}    | add horizontal space between elements
         *
         *     @example
         *     Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 500,
         *         items: [
         *             {
         *                 // xtype: 'button', // default for Toolbars
         *                 text: 'Button'
         *             },
         *             {
         *                 xtype: 'splitbutton',
         *                 text : 'Split Button'
         *             },
         *             // begin using the right-justified button container
         *             '->', // same as { xtype: 'tbfill' }
         *             {
         *                 xtype    : 'textfield',
         *                 name     : 'field1',
         *                 emptyText: 'enter search term'
         *             },
         *             // add a vertical separator bar between toolbar items
         *             '-', // same as {xtype: 'tbseparator'} to create Ext.toolbar.Separator
         *             'text 1', // same as {xtype: 'tbtext', text: 'text1'} to create Ext.toolbar.TextItem
         *             { xtype: 'tbspacer' },// same as ' ' to create Ext.toolbar.Spacer
         *             'text 2',
         *             { xtype: 'tbspacer', width: 50 }, // add a 50px space
         *             'text 3'
         *         ]
         *     });
         *
         * Toolbars have {@link #method-enable} and {@link #method-disable} methods which when called, will
         * enable/disable all items within your toolbar.
         *
         *     @example
         *     Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 400,
         *         items: [
         *             {
         *                 text: 'Button'
         *             },
         *             {
         *                 xtype: 'splitbutton',
         *                 text : 'Split Button'
         *             },
         *             '->',
         *             {
         *                 xtype    : 'textfield',
         *                 name     : 'field1',
         *                 emptyText: 'enter search term'
         *             }
         *         ]
         *     });
         *
         * Example
         *
         *     @example
         *     var enableBtn = Ext.create('Ext.button.Button', {
         *         text    : 'Enable All Items',
         *         disabled: true,
         *         scope   : this,
         *         handler : function() {
         *             //disable the enable button and enable the disable button
         *             enableBtn.disable();
         *             disableBtn.enable();
         *
         *             //enable the toolbar
         *             toolbar.enable();
         *         }
         *     });
         *
         *     var disableBtn = Ext.create('Ext.button.Button', {
         *         text    : 'Disable All Items',
         *         scope   : this,
         *         handler : function() {
         *             //enable the enable button and disable button
         *             disableBtn.disable();
         *             enableBtn.enable();
         *
         *             //disable the toolbar
         *             toolbar.disable();
         *         }
         *     });
         *
         *     var toolbar = Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 400,
         *         margin  : '5 0 0 0',
         *         items   : [enableBtn, disableBtn]
         *     });
         *
         * Adding items to and removing items from a toolbar is as simple as calling the {@link #method-add}
         * and {@link #method-remove} methods. There is also a {@link #removeAll} method
         * which remove all items within the toolbar.
         *
         *     @example
         *     var toolbar = Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 700,
         *         items: [
         *             {
         *                 text: 'Example Button'
         *             }
         *         ]
         *     });
         *
         *     var addedItems = [];
         *
         *     Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 700,
         *         margin  : '5 0 0 0',
         *         items   : [
         *             {
         *                 text   : 'Add a button',
         *                 scope  : this,
         *                 handler: function() {
         *                     var text = prompt('Please enter the text for your button:');
         *                     addedItems.push(toolbar.add({
         *                         text: text
         *                     }));
         *                 }
         *             },
         *             {
         *                 text   : 'Add a text item',
         *                 scope  : this,
         *                 handler: function() {
         *                     var text = prompt('Please enter the text for your item:');
         *                     addedItems.push(toolbar.add(text));
         *                 }
         *             },
         *             {
         *                 text   : 'Add a toolbar separator',
         *                 scope  : this,
         *                 handler: function() {
         *                     addedItems.push(toolbar.add('-'));
         *                 }
         *             },
         *             {
         *                 text   : 'Add a toolbar spacer',
         *                 scope  : this,
         *                 handler: function() {
         *                     addedItems.push(toolbar.add('->'));
         *                 }
         *             },
         *             '->',
         *             {
         *                 text   : 'Remove last inserted item',
         *                 scope  : this,
         *                 handler: function() {
         *                     if (addedItems.length) {
         *                         toolbar.remove(addedItems.pop());
         *                     } else if (toolbar.items.length) {
         *                         toolbar.remove(toolbar.items.last());
         *                     } else {
         *                         alert('No items in the toolbar');
         *                     }
         *                 }
         *             },
         *             {
         *                 text   : 'Remove all items',
         *                 scope  : this,
         *                 handler: function() {
         *                     toolbar.removeAll();
         *                 }
         *             }
         *         ]
         *     });
         *
         * @constructor
         * Creates a new Toolbar
         * @param {Object/Object[]} config A config object or an array of buttons to {@link #method-add}
         * @docauthor Robert Dougan <rob@sencha.com>
         */
        constructor(config: Ext.toolbar.PagingConfig);

        /**
         * Refresh the current page, has the same effect as clicking the 'refresh' button.
         */
        doRefresh();

        protected getStoreListeners();

        /**
         * Move to the first page, has the same effect as clicking the 'first' button.
         */
        moveFirst();

        /**
         * Move to the last page, has the same effect as clicking the 'last' button.
         */
        moveLast();

        /**
         * Move to the next page, has the same effect as clicking the 'next' button.
         */
        moveNext();

        /**
         * Move to the previous page, has the same effect as clicking the 'previous' button.
         */
        movePrevious();

        /**
         * Unbinds the paging toolbar from the specified {@link Ext.data.Store} **(deprecated)**
         * @param {Ext.data.Store} store The data store to unbind
         */
        unbind(store: Ext.data.Store);

        /**
         * Fires just before the active page is changed. Return false to prevent the active page from being changed.
         * @param {Number} page The page number that will be loaded on change
         */
        beforechange(that: Ext.toolbar.Paging, page: number);

        /**
         * Fires after the active page has been changed.
         * @param {Object} pageData An object that has these properties:
         *
         * - 'total' : Number
         *
         *   The total number of records in the dataset as returned by the server
         *
         * - 'currentPage' : Number
         *
         *   The current page number
         *
         * - 'pageCount' : Number
         *
         *   The total number of pages (calculated from the total number of records in the dataset as returned by the
         *   server and the current {@link Ext.data.Store#pageSize pageSize})
         *
         * - 'toRecord' : Number
         *
         *   The starting record index for the current page
         *
         * - 'fromRecord' : Number
         *
         *   The ending record index for the current page
         */
        change(that: Ext.toolbar.Paging, pageData: any);
    }

    interface SeparatorConfig extends Ext.toolbar.ItemConfig {
        baseCls?: any;
    }

    /**
     * A simple class that adds a vertical separator bar between toolbar items (css class: 'x-toolbar-separator').
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Toolbar Separator Example',
     *         width: 300,
     *         height: 200,
     *         tbar : [
     *             'Item 1',
     *             { xtype: 'tbseparator' },
     *             'Item 2'
     *         ],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Separator extends Ext.toolbar.Item implements Ext.toolbar.SeparatorConfig {
        baseCls: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface SpacerConfig extends Ext.ComponentConfig {
        baseCls?: any;
    }

    /**
     * A simple element that adds extra horizontal space between items in a toolbar.
     * By default a 2px wide space is added via CSS specification:
     *
     *     .x-toolbar .x-toolbar-spacer {
     *         width: 2px;
     *     }
     *
     * Example:
     *
     *     @example
     *     Ext.create('Ext.panel.Panel', {
     *         title: 'Toolbar Spacer Example',
     *         width: 300,
     *         height: 200,
     *         tbar : [
     *             'Item 1',
     *             { xtype: 'tbspacer' }, // or ' '
     *             'Item 2',
     *             // space width is also configurable via javascript
     *             { xtype: 'tbspacer', width: 50 }, // add a 50px space
     *             'Item 3'
     *         ],
     *         renderTo: Ext.getBody()
     *     });
     */
    export class Spacer extends Ext.Component implements Ext.toolbar.SpacerConfig {
        baseCls: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface TextItemConfig extends Ext.toolbar.ItemConfig {
        baseCls?: any;

        /**
         * The text to be used as innerHTML (html tags are accepted).
         */
        text?: string;
    }

    export class TextItem extends Ext.toolbar.Item implements Ext.toolbar.TextItemConfig {
        baseCls: string;

        protected renderTpl: Ext.XTemplate|string;

        /**
         * The text to be used as innerHTML (html tags are accepted).
         */
        text: string;

        /**
         * A simple class that renders text directly into a toolbar.
         *
         *     @example
         *     Ext.create('Ext.panel.Panel', {
         *         title: 'Panel with TextItem',
         *         width: 300,
         *         height: 200,
         *         tbar: [
         *             { xtype: 'tbtext', text: 'Sample Text Item' }
         *         ],
         *         renderTo: Ext.getBody()
         *     });
         *
         * @constructor
         * Creates a new TextItem
         * @param {Object} text A text string, or a config object containing a #text property
         */
        constructor(text: any);

        /**
         * Updates this item's text, setting the text to be used as innerHTML.
         * @param {String} text The text to display (html accepted).
         */
        setText(text: string);
    }

    interface ToolbarConfig extends Ext.container.ContainerConfig {
        baseCls?: any;

        /**
         * A default {@link Ext.Component#ui ui} to use for {@link Ext.button.Button Button} items
         */
        defaultButtonUI?: string;

        defaultType?: any;

        /**
         * Configure true to make the toolbar provide a button which activates a dropdown Menu to show
         * items which overflow the Toolbar's width.
         */
        enableOverflow?: boolean;

        /**
         * This class assigns a default layout ('layout: 'hbox'').
         * Developers _may_ override this configuration option if another layout
         * is required (the constructor must be passed a configuration object in this
         * case instead of an array).
         * See {@link Ext.container.Container#layout} for additional information.
         */
        layout?: Ext.enums.Layout|any;

        /**
         * Configure the icon class of the overflow button.
         */
        menuTriggerCls?: string;

        /**
         * Set to 'true' to make the toolbar vertical. The layout will become a 'vbox'.
         */
        vertical?: boolean;
    }

    export class Toolbar extends Ext.container.Container implements Ext.toolbar.ToolbarConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Toolbar, or subclass thereof.
         */
        isToolbar: boolean;

        baseCls: string;

        /**
         * A default {@link Ext.Component#ui ui} to use for {@link Ext.button.Button Button} items
         */
        defaultButtonUI: string;

        defaultType: string;

        /**
         * Configure true to make the toolbar provide a button which activates a dropdown Menu to show
         * items which overflow the Toolbar's width.
         */
        enableOverflow: boolean;

        /**
         * This class assigns a default layout ('layout: 'hbox'').
         * Developers _may_ override this configuration option if another layout
         * is required (the constructor must be passed a configuration object in this
         * case instead of an array).
         * See {@link Ext.container.Container#layout} for additional information.
         */
        layout: Ext.enums.Layout|any;

        /**
         * Configure the icon class of the overflow button.
         */
        menuTriggerCls: string;

        /**
         * Set to 'true' to make the toolbar vertical. The layout will become a 'vbox'.
         */
        vertical: boolean;

        /**
         * Basic Toolbar class. Although the {@link Ext.container.Container#defaultType defaultType} for
         * Toolbar is {@link Ext.button.Button button}, Toolbar elements (child items for the Toolbar container)
         * may be virtually any type of Component. Toolbar elements can be created explicitly via their
         * constructors, or implicitly via their xtypes, and can be {@link #method-add}ed dynamically.
         *
         * ## Some items have shortcut strings for creation:
         *
         * | Shortcut | xtype         | Class                         | Description
         * |:---------|:--------------|:------------------------------|:---------------------------------------------------
         * | '->'     | 'tbfill'      | {@link Ext.toolbar.Fill}      | begin using the right-justified button container
         * | '-'      | 'tbseparator' | {@link Ext.toolbar.Separator} | add a vertical separator bar between toolbar items
         * | ' '      | 'tbspacer'    | {@link Ext.toolbar.Spacer}    | add horizontal space between elements
         *
         *     @example
         *     Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 500,
         *         items: [
         *             {
         *                 // xtype: 'button', // default for Toolbars
         *                 text: 'Button'
         *             },
         *             {
         *                 xtype: 'splitbutton',
         *                 text : 'Split Button'
         *             },
         *             // begin using the right-justified button container
         *             '->', // same as { xtype: 'tbfill' }
         *             {
         *                 xtype    : 'textfield',
         *                 name     : 'field1',
         *                 emptyText: 'enter search term'
         *             },
         *             // add a vertical separator bar between toolbar items
         *             '-', // same as {xtype: 'tbseparator'} to create Ext.toolbar.Separator
         *             'text 1', // same as {xtype: 'tbtext', text: 'text1'} to create Ext.toolbar.TextItem
         *             { xtype: 'tbspacer' },// same as ' ' to create Ext.toolbar.Spacer
         *             'text 2',
         *             { xtype: 'tbspacer', width: 50 }, // add a 50px space
         *             'text 3'
         *         ]
         *     });
         *
         * Toolbars have {@link #method-enable} and {@link #method-disable} methods which when called, will
         * enable/disable all items within your toolbar.
         *
         *     @example
         *     Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 400,
         *         items: [
         *             {
         *                 text: 'Button'
         *             },
         *             {
         *                 xtype: 'splitbutton',
         *                 text : 'Split Button'
         *             },
         *             '->',
         *             {
         *                 xtype    : 'textfield',
         *                 name     : 'field1',
         *                 emptyText: 'enter search term'
         *             }
         *         ]
         *     });
         *
         * Example
         *
         *     @example
         *     var enableBtn = Ext.create('Ext.button.Button', {
         *         text    : 'Enable All Items',
         *         disabled: true,
         *         scope   : this,
         *         handler : function() {
         *             //disable the enable button and enable the disable button
         *             enableBtn.disable();
         *             disableBtn.enable();
         *
         *             //enable the toolbar
         *             toolbar.enable();
         *         }
         *     });
         *
         *     var disableBtn = Ext.create('Ext.button.Button', {
         *         text    : 'Disable All Items',
         *         scope   : this,
         *         handler : function() {
         *             //enable the enable button and disable button
         *             disableBtn.disable();
         *             enableBtn.enable();
         *
         *             //disable the toolbar
         *             toolbar.disable();
         *         }
         *     });
         *
         *     var toolbar = Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 400,
         *         margin  : '5 0 0 0',
         *         items   : [enableBtn, disableBtn]
         *     });
         *
         * Adding items to and removing items from a toolbar is as simple as calling the {@link #method-add}
         * and {@link #method-remove} methods. There is also a {@link #removeAll} method
         * which remove all items within the toolbar.
         *
         *     @example
         *     var toolbar = Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 700,
         *         items: [
         *             {
         *                 text: 'Example Button'
         *             }
         *         ]
         *     });
         *
         *     var addedItems = [];
         *
         *     Ext.create('Ext.toolbar.Toolbar', {
         *         renderTo: document.body,
         *         width   : 700,
         *         margin  : '5 0 0 0',
         *         items   : [
         *             {
         *                 text   : 'Add a button',
         *                 scope  : this,
         *                 handler: function() {
         *                     var text = prompt('Please enter the text for your button:');
         *                     addedItems.push(toolbar.add({
         *                         text: text
         *                     }));
         *                 }
         *             },
         *             {
         *                 text   : 'Add a text item',
         *                 scope  : this,
         *                 handler: function() {
         *                     var text = prompt('Please enter the text for your item:');
         *                     addedItems.push(toolbar.add(text));
         *                 }
         *             },
         *             {
         *                 text   : 'Add a toolbar separator',
         *                 scope  : this,
         *                 handler: function() {
         *                     addedItems.push(toolbar.add('-'));
         *                 }
         *             },
         *             {
         *                 text   : 'Add a toolbar spacer',
         *                 scope  : this,
         *                 handler: function() {
         *                     addedItems.push(toolbar.add('->'));
         *                 }
         *             },
         *             '->',
         *             {
         *                 text   : 'Remove last inserted item',
         *                 scope  : this,
         *                 handler: function() {
         *                     if (addedItems.length) {
         *                         toolbar.remove(addedItems.pop());
         *                     } else if (toolbar.items.length) {
         *                         toolbar.remove(toolbar.items.last());
         *                     } else {
         *                         alert('No items in the toolbar');
         *                     }
         *                 }
         *             },
         *             {
         *                 text   : 'Remove all items',
         *                 scope  : this,
         *                 handler: function() {
         *                     toolbar.removeAll();
         *                 }
         *             }
         *         ]
         *     });
         *
         * @constructor
         * Creates a new Toolbar
         * @param {Object/Object[]} config A config object or an array of buttons to {@link #method-add}
         * @docauthor Robert Dougan <rob@sencha.com>
         */
        constructor(config: Ext.toolbar.PagingConfig);

        /**
         * Fires after the overflow state has changed.
         * @param {Number} lastHiddenCount The number of overflowing items that used to be hidden.
         * @param {Number} hiddenCount The number of overflowing items that are hidden now.
         * @param {Array} The hidden items
         */
        overflowchange(lastHiddenCount: number, hiddenCount: number, The: any[]);
    }
}

declare module Ext.tree {
    interface ColumnConfig extends Ext.grid.column.ColumnConfig {
        hideable?: any;

        lockable?: any;

        tdCls?: any;
    }

    /**
     * Provides indentation and folder structure markup for a Tree taking into account
     * depth and position within the tree hierarchy.
     */
    export class Column extends Ext.grid.column.Column implements Ext.tree.ColumnConfig {
        draggable: boolean;

        hideable: boolean;

        lockable: boolean;

        tdCls: string;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);
    }

    interface PanelConfig extends Ext.panel.TableConfig {
        deferRowRender?: any;

        /**
         * The field inside the model that will be used as the node's text.
         */
        displayField?: string;

        /**
         * True to automatically prepend a leaf sorter to the store.
         */
        folderSort?: boolean;

        /**
         * True to hide the headers.
         */
        hideHeaders?: boolean;

        /**
         * False to disable tree lines.
         */
        lines?: boolean;

        /**
         * Allows you to not specify a store on this TreePanel. This is useful for creating a simple tree with preloaded
         * data without having to specify a TreeStore and Model. A store and model will be created and root will be passed
         * to that store. For example:
         *
         *     Ext.create('Ext.tree.Panel', {
         *         title: 'Simple Tree',
         *         root: {
         *             text: "Root node",
         *             expanded: true,
         *             children: [
         *                 { text: "Child 1", leaf: true },
         *                 { text: "Child 2", leaf: true }
         *             ]
         *         },
         *         renderTo: Ext.getBody()
         *     });
         */
        root?: Ext.data.Model|Ext.data.NodeInterface|any;

        /**
         * False to hide the root node.
         */
        rootVisible?: boolean;

        /**
         * False so that rows are not separated by lines.
         */
        rowLines?: boolean;

        selType?: any;

        /**
         * True if only 1 node per branch may be expanded.
         */
        singleExpand?: boolean;

        /**
         * True to use Vista-style arrows in the tree.
         */
        useArrows?: boolean;
    }

    /**
     * The TreePanel provides tree-structured UI representation of tree-structured data.
     * A TreePanel must be bound to a {@link Ext.data.TreeStore}. TreePanel's support
     * multiple columns through the {@link #columns} configuration.
     *
     * Simple TreePanel using inline data:
     *
     *     @example
     *     var store = Ext.create('Ext.data.TreeStore', {
     *         root: {
     *             expanded: true,
     *             children: [
     *                 { text: "detention", leaf: true },
     *                 { text: "homework", expanded: true, children: [
     *                     { text: "book report", leaf: true },
     *                     { text: "algebra", leaf: true}
     *                 ] },
     *                 { text: "buy lottery tickets", leaf: true }
     *             ]
     *         }
     *     });
     *
     *     Ext.create('Ext.tree.Panel', {
     *         title: 'Simple Tree',
     *         width: 200,
     *         height: 150,
     *         store: store,
     *         rootVisible: false,
     *         renderTo: Ext.getBody()
     *     });
     *
     * For the tree node config options (like 'text', 'leaf', 'expanded'), see the documentation of
     * {@link Ext.data.NodeInterface NodeInterface} config options.
     */
    export class Panel extends Ext.panel.Table implements Ext.tree.PanelConfig {
        deferRowRender: boolean;

        /**
         * The field inside the model that will be used as the node's text.
         */
        displayField: string;

        /**
         * True to automatically prepend a leaf sorter to the store.
         */
        folderSort: boolean;

        /**
         * True to hide the headers.
         */
        hideHeaders: boolean;

        /**
         * False to disable tree lines.
         */
        lines: boolean;

        /**
         * Allows you to not specify a store on this TreePanel. This is useful for creating a simple tree with preloaded
         * data without having to specify a TreeStore and Model. A store and model will be created and root will be passed
         * to that store. For example:
         *
         *     Ext.create('Ext.tree.Panel', {
         *         title: 'Simple Tree',
         *         root: {
         *             text: "Root node",
         *             expanded: true,
         *             children: [
         *                 { text: "Child 1", leaf: true },
         *                 { text: "Child 2", leaf: true }
         *             ]
         *         },
         *         renderTo: Ext.getBody()
         *     });
         */
        root: Ext.data.Model|Ext.data.NodeInterface|any;

        /**
         * False to hide the root node.
         */
        rootVisible: boolean;

        /**
         * False so that rows are not separated by lines.
         */
        rowLines: boolean;

        selType: string;

        /**
         * True if only 1 node per branch may be expanded.
         */
        singleExpand: boolean;

        /**
         * True to use Vista-style arrows in the tree.
         */
        useArrows: boolean;

        protected viewType: string;

        /**
         * Collapse all nodes
         * @param {Function} [callback] A function to execute when the collapse finishes.
         * @param {Object} [scope] The scope of the callback function
         */
        collapseAll(callback?: Function, scope?: any);

        /**
         * Collapses a record that is loaded in the tree.
         * @param {Ext.data.Model} record The record to collapse
         * @param {Boolean} [deep] True to collapse nodes all the way up the tree hierarchy.
         * @param {Function} [callback] The function to run after the collapse is completed
         * @param {Object} [scope] The scope of the callback function.
         */
        collapseNode(record: Ext.data.Model, deep?: boolean, callback?: Function, scope?: any);

        constructor(config: Ext.tree.PanelConfig);

        /**
         * Expand all nodes
         * @param {Function} [callback] A function to execute when the expand finishes.
         * @param {Object} [scope] The scope of the callback function
         */
        expandAll(callback?: Function, scope?: any);

        /**
         * Expands a record that is loaded in the tree.
         * @param {Ext.data.Model} record The record to expand
         * @param {Boolean} [deep] True to expand nodes all the way down the tree hierarchy.
         * @param {Function} [callback] The function to run after the expand is completed
         * @param {Object} [scope] The scope of the callback function.
         */
        expandNode(record: Ext.data.Model, deep?: boolean, callback?: Function, scope?: any);

        /**
         * Expand the tree to the path of a particular node.
         * @param {String} path The path to expand. The path should include a leading separator.
         * @param {String} [field] The field to get the data from. Defaults to the model idProperty.
         * @param {String} [separator='/'] A separator to use.
         * @param {Function} [callback] A function to execute when the expand finishes. The callback will be called with
         * (success, lastNode) where success is if the expand was successful and lastNode is the last node that was expanded.
         * @param {Object} [scope] The scope of the callback function
         */
        expandPath(path: string, field?: string, separator?: string, callback?: Function, scope?: any);

        /**
         * Retrieve an array of checked records.
         * @return {Ext.data.NodeInterface[]} An array containing the checked records
         */
        getChecked(): Ext.data.NodeInterface;

        /**
         * Returns the root node for this tree.
         * @return {Ext.data.NodeInterface}
         */
        getRootNode(): Ext.data.NodeInterface;

        /**
         * Expand the tree to the path of a particular node, then select it.
         * @param {String} path The path to select. The path should include a leading separator.
         * @param {String} [field] The field to get the data from. Defaults to the model idProperty.
         * @param {String} [separator='/'] A separator to use.
         * @param {Function} [callback] A function to execute when the select finishes. The callback will be called with
         * (bSuccess, oLastNode) where bSuccess is if the select was successful and oLastNode is the last node that was expanded.
         * @param {Object} [scope] The scope of the callback function
         */
        selectPath(path: string, field?: string, separator?: string, callback?: Function, scope?: any);

        /**
         * Sets root node of this tree.
         * @return {Ext.data.NodeInterface} The new root
         */
        setRootNode(root: Ext.data.Model|Ext.data.NodeInterface|any): Ext.data.NodeInterface;

        afteritemcollapse();

        afteritemexpand();

        beforeitemappend();

        beforeitemcollapse();

        beforeitemexpand();

        beforeiteminsert();

        beforeitemmove();

        beforeitemremove();

        beforeload();

        /**
         * Fires when a node with a checkbox's checked property changes
         * @param {Ext.data.NodeInterface} node The node who's checked property was changed
         * @param {Boolean} checked The node's new checked state
         */
        checkchange(node: Ext.data.NodeInterface, checked: boolean);

        itemappend();

        itemcollapse();

        itemexpand();

        iteminsert();

        itemmove();

        itemremove();

        load();
    }

    interface ViewConfig extends Ext.view.TableConfig {
        blockRefresh?: any;

        /**
         * Must be false for Tree Views because the root node must be rendered in order to be updated with its child nodes.
         */
        deferInitialRefresh?: boolean;

        loadMask?: any;

        loadingCls?: any;

        /**
         * False to hide the root node.
         */
        rootVisible?: boolean;

        stripeRows?: any;
    }

    /**
     * Used as a view by {@link Ext.tree.Panel TreePanel}.
     */
    export class View extends Ext.view.Table implements Ext.tree.ViewConfig {
        /**
         * 'true' in this class to identify an object as an instantiated TreeView, or subclass thereof.
         */
        isTreeView: boolean;

        blockRefresh: boolean;

        /**
         * Must be false for Tree Views because the root node must be rendered in order to be updated with its child nodes.
         */
        deferInitialRefresh: boolean;

        loadingCls: string;

        /**
         * False to disable a load mask from displaying while the view is loading. This can also be a
         * {@link Ext.LoadMask} configuration object.
         */
        loadMask: boolean|any;

        /**
         * False to hide the root node.
         */
        rootVisible: boolean;

        stripeRows: boolean;

        /**
         * Collapses a record that is loaded in the view.
         *
         * If an animated collapse or expand of the record is in progress, this call will be ignored.
         * @param {Ext.data.Model} record The record to collapse
         * @param {Boolean} [deep] True to collapse nodes all the way up the tree hierarchy.
         * @param {Function} [callback] The function to run after the collapse is completed
         * @param {Object} [scope] The scope of the callback function.
         */
        collapse(record: Ext.data.Model, deep?: boolean, callback?: Function, scope?: any);

        constructor(config: Ext.grid.ViewConfig);

        /**
         * Expands a record that is loaded in the view.
         *
         * If an animated collapse or expand of the record is in progress, this call will be ignored.
         * @param {Ext.data.Model} record The record to expand
         * @param {Boolean} [deep] True to expand nodes all the way down the tree hierarchy.
         * @param {Function} [callback] The function to run after the expand is completed
         * @param {Object} [scope] The scope of the callback function.
         */
        expand(record: Ext.data.Model, deep?: boolean, callback?: Function, scope?: any);

        protected getStoreListeners();

        /**
         * Gets the base TreeStore from the bound TreePanel.
         */
        getTreeStore();

        protected initComponent();

        /**
         * Toggles a record between expanded and collapsed.
         *
         * If an animated collapse or expand of the record is in progress, this call will be ignored.
         * @param {Boolean} [deep] True to collapse nodes all the way up the tree hierarchy.
         * @param {Function} [callback] The function to run after the expand/collapse is completed
         * @param {Object} [scope] The scope of the callback function.
         */
        toggle(record: Ext.data.Model, deep?: boolean, callback?: Function, scope?: any);

        /**
         * Fires after an item has been visually collapsed and is no longer visible in the tree.
         * @param {Ext.data.NodeInterface} node         The node that was collapsed
         * @param {Number} index                        The index of the node
         * @param {HTMLElement} item                    The HTML element for the node that was collapsed
         */
        afteritemcollapse(node: Ext.data.NodeInterface, index: number, item: HTMLElement);

        /**
         * Fires after an item has been visually expanded and is visible in the tree.
         * @param {Ext.data.NodeInterface} node         The node that was expanded
         * @param {Number} index                        The index of the node
         * @param {HTMLElement} item                    The HTML element for the node that was expanded
         */
        afteritemexpand(node: Ext.data.NodeInterface, index: number, item: HTMLElement);

        /**
         * Fires when a tree node is being targeted for a drag drop, return false to signal drop not allowed.
         * @param {Ext.data.NodeInterface} targetNode The target node
         * @param {String} position The drop position, "before", "after" or "append",
         * @param {Object} dragData Data relating to the drag operation
         * @param {Ext.EventObject} e The event object for the drag
         */
        nodedragover(targetNode: Ext.data.NodeInterface, position: string, dragData: any, e: Ext.EventObject);
    }

    export class ViewDragZone extends Ext.view.DragZone {
        constructor(config: Ext.view.DragZoneConfig);
    }

    interface ViewDropZoneConfig extends Ext.dd.DropTargetConfig {
        /**
         * True if drops on the tree container (outside of a specific tree node) are allowed.
         */
        allowContainerDrop?: boolean;

        /**
         * Allow inserting a dragged node between an expanded parent node and its first child that will become a
         * sibling of the parent when dropped.
         */
        allowParentInserts?: boolean;

        /**
         * True if the tree should only allow append drops (use for trees which are sorted).
         */
        appendOnly?: boolean;

        /**
         * The delay in milliseconds to wait before expanding a target tree node while dragging a droppable node
         * over the target.
         */
        expandDelay?: number;
    }

    export class ViewDropZone extends Ext.view.DropZone implements Ext.tree.ViewDropZoneConfig {
        /**
         * True if drops on the tree container (outside of a specific tree node) are allowed.
         */
        allowContainerDrop: boolean;

        /**
         * Allow inserting a dragged node between an expanded parent node and its first child that will become a
         * sibling of the parent when dropped.
         */
        allowParentInserts: boolean;

        /**
         * True if the tree should only allow append drops (use for trees which are sorted).
         */
        appendOnly: boolean;

        /**
         * The delay in milliseconds to wait before expanding a target tree node while dragging a droppable node
         * over the target.
         */
        expandDelay: number;

        constructor(config: Ext.tree.ViewDropZoneConfig);
    }
}

declare module Ext.tree.plugin {
    interface TreeViewDragDropConfig extends Ext.AbstractPluginConfig {
        /**
         * True if drops on the tree container (outside of a specific tree node) are allowed.
         */
        allowContainerDrops?: boolean;

        /**
         * Allow inserting a dragged node between an expanded parent node and its first child that will become a sibling of
         * the parent when dropped.
         */
        allowParentInserts?: boolean;

        /**
         * True if the tree should only allow append drops (use for trees which are sorted).
         */
        appendOnly?: boolean;

        /**
         * True to register this container with the Scrollmanager for auto scrolling during drag operations.
         * A {@link Ext.dd.ScrollManager} configuration may also be passed.
         */
        containerScroll?: any|boolean;

        /**
         * A named drag drop group to which this object belongs. If a group is specified, then both the DragZones and
         * DropZone used by this plugin will only interact with other drag drop objects in the same group.
         */
        ddGroup?: string;

        /**
         * The name of the model field that is used to display the text for the nodes
         */
        displayField?: string;

        /**
         * The ddGroup to which the DragZone will belong.
         *
         * This defines which other DropZones the DragZone will interact with. Drag/DropZones only interact with other
         * Drag/DropZones which are members of the same ddGroup.
         */
        dragGroup?: string;

        /**
         * The text to show while dragging.
         *
         * Two placeholders can be used in the text:
         *
         * - '{0}' The number of selected items.
         * - '{1}' 's' when more than 1 items (only useful for English).
         */
        dragText?: any;

        /**
         * The ddGroup to which the DropZone will belong.
         *
         * This defines which other DragZones the DropZone will interact with. Drag/DropZones only interact with other
         * Drag/DropZones which are members of the same ddGroup.
         */
        dropGroup?: string;

        /**
         * Set to 'false' to disallow dragging items from the View.
         */
        enableDrag?: boolean;

        /**
         * Set to 'false' to disallow the View from accepting drop gestures.
         */
        enableDrop?: boolean;

        /**
         * The delay in milliseconds to wait before expanding a target tree node while dragging a droppable node over the
         * target.
         */
        expandDelay?: number;

        /**
         * The color to use when visually highlighting the dragged or dropped node (default value is light blue).
         * The color must be a 6 digit hex value, without a preceding '#'. See also {@link #nodeHighlightOnDrop} and
         * {@link #nodeHighlightOnRepair}.
         */
        nodeHighlightColor?: string;

        /**
         * Whether or not to highlight any nodes after they are
         * successfully dropped on their target. Defaults to the value of 'Ext.enableFx'.
         * See also {@link #nodeHighlightColor} and {@link #nodeHighlightOnRepair}.
         */
        nodeHighlightOnDrop?: boolean;

        /**
         * Whether or not to highlight any nodes after they are
         * repaired from an unsuccessful drag/drop. Defaults to the value of 'Ext.enableFx'.
         * See also {@link #nodeHighlightColor} and {@link #nodeHighlightOnDrop}.
         */
        nodeHighlightOnRepair?: boolean;

        /**
         * Configure as 'true' to sort the target node into the current tree sort order after the dropped node is added.
         *
         * Optional, Defaults to: false
         */
        sortOnDrop?: boolean;
    }

    /**
     * This plugin provides drag and/or drop functionality for a TreeView.
     *
     * It creates a specialized instance of {@link Ext.dd.DragZone DragZone} which knows how to drag out of a
     * {@link Ext.tree.View TreeView} and loads the data object which is passed to a cooperating
     * {@link Ext.dd.DragZone DragZone}'s methods with the following properties:
     *
     *   - copy : Boolean
     *
     *     The value of the TreeView's 'copy' property, or 'true' if the TreeView was configured with 'allowCopy: true' *and*
     *     the control key was pressed when the drag operation was begun.
     *
     *   - view : TreeView
     *
     *     The source TreeView from which the drag originated.
     *
     *   - ddel : HtmlElement
     *
     *     The drag proxy element which moves with the mouse
     *
     *   - item : HtmlElement
     *
     *     The TreeView node upon which the mousedown event was registered.
     *
     *   - records : Array
     *
     *     An Array of {@link Ext.data.Model Models} representing the selected data being dragged from the source TreeView.
     *
     * It also creates a specialized instance of {@link Ext.dd.DropZone} which cooperates with other DropZones which are
     * members of the same ddGroup which processes such data objects.
     *
     * Adding this plugin to a view means that two new events may be fired from the client TreeView, {@link #beforedrop} and
     * {@link #drop}.
     *
     * Note that the plugin must be added to the tree view, not to the tree panel. For example using viewConfig:
     *
     *     viewConfig: {
     *         plugins: { ptype: 'treeviewdragdrop' }
     *     }
     */
    export class TreeViewDragDrop extends Ext.AbstractPlugin implements Ext.tree.plugin.TreeViewDragDropConfig {
        /**
         * True if drops on the tree container (outside of a specific tree node) are allowed.
         */
        allowContainerDrops: boolean;

        /**
         * Allow inserting a dragged node between an expanded parent node and its first child that will become a sibling of
         * the parent when dropped.
         */
        allowParentInserts: boolean;

        /**
         * True if the tree should only allow append drops (use for trees which are sorted).
         */
        appendOnly: boolean;

        /**
         * True to register this container with the Scrollmanager for auto scrolling during drag operations.
         * A {@link Ext.dd.ScrollManager} configuration may also be passed.
         */
        containerScroll: any|boolean;

        /**
         * A named drag drop group to which this object belongs. If a group is specified, then both the DragZones and
         * DropZone used by this plugin will only interact with other drag drop objects in the same group.
         */
        ddGroup: string;

        /**
         * The name of the model field that is used to display the text for the nodes
         */
        displayField: string;

        /**
         * The ddGroup to which the DragZone will belong.
         *
         * This defines which other DropZones the DragZone will interact with. Drag/DropZones only interact with other
         * Drag/DropZones which are members of the same ddGroup.
         */
        dragGroup: string;

        /**
         * The text to show while dragging.
         *
         * Two placeholders can be used in the text:
         *
         * - '{0}' The number of selected items.
         * - '{1}' 's' when more than 1 items (only useful for English).
         */
        dragText: any;

        /**
         * The ddGroup to which the DropZone will belong.
         *
         * This defines which other DragZones the DropZone will interact with. Drag/DropZones only interact with other
         * Drag/DropZones which are members of the same ddGroup.
         */
        dropGroup: string;

        /**
         * Set to 'false' to disallow dragging items from the View.
         */
        enableDrag: boolean;

        /**
         * Set to 'false' to disallow the View from accepting drop gestures.
         */
        enableDrop: boolean;

        /**
         * The delay in milliseconds to wait before expanding a target tree node while dragging a droppable node over the
         * target.
         */
        expandDelay: number;

        /**
         * The color to use when visually highlighting the dragged or dropped node (default value is light blue).
         * The color must be a 6 digit hex value, without a preceding '#'. See also {@link #nodeHighlightOnDrop} and
         * {@link #nodeHighlightOnRepair}.
         */
        nodeHighlightColor: string;

        /**
         * Whether or not to highlight any nodes after they are
         * successfully dropped on their target. Defaults to the value of 'Ext.enableFx'.
         * See also {@link #nodeHighlightColor} and {@link #nodeHighlightOnRepair}.
         */
        nodeHighlightOnDrop: boolean;

        /**
         * Whether or not to highlight any nodes after they are
         * repaired from an unsuccessful drag/drop. Defaults to the value of 'Ext.enableFx'.
         * See also {@link #nodeHighlightColor} and {@link #nodeHighlightOnDrop}.
         */
        nodeHighlightOnRepair: boolean;

        /**
         * Configure as 'true' to sort the target node into the current tree sort order after the dropped node is added.
         *
         * Optional, Defaults to: false
         */
        sortOnDrop: boolean;

        /**
         * Instantiates the plugin.
         * @param {Object} [config] Configuration object.
         */
        constructor(config?: Ext.AbstractPluginConfig);

        /**
         * **This event is fired through the TreeView. Add listeners to the TreeView object**
         *
         * Fired when a drop gesture has been triggered by a mouseup event in a valid drop position in the TreeView.
         *
         * Returning 'false' to this event signals that the drop gesture was invalid, and if the drag proxy will animate
         * back to the point from which the drag began.
         *
         * The dropHandlers parameter can be used to defer the processing of this event. For example to wait for the result of
         * a message box confirmation or an asynchronous server call. See the details of this property for more information.
         *
         *     @example
         *     view.on('beforedrop', function(node, data, overModel, dropPosition, dropHandlers) {
         *         // Defer the handling
         *         dropHandlers.wait = true;
         *         Ext.MessageBox.confirm('Drop', 'Are you sure', function(btn){
         *             if (btn === 'yes') {
         *                 dropHandlers.processDrop();
         *             } else {
         *                 dropHandlers.cancelDrop();
         *             }
         *         });
         *     });
         *
         * Any other return value continues with the data transfer operation, unless the wait property is set.
         *
         * @param {HTMLElement} node The TreeView node **if any** over which the mouse was positioned.
         *
         * @param {Object} data The data object gathered at mousedown time by the cooperating
         * {@link Ext.dd.DragZone DragZone}'s {@link Ext.dd.DragZone#getDragData getDragData} method it contains the following
         * properties:
         * @param {Boolean} data.copy The value of the TreeView's 'copy' property, or 'true' if the TreeView was configured with
         * 'allowCopy: true' and the control key was pressed when the drag operation was begun
         * @param {Ext.tree.View} data.view The source TreeView from which the drag originated.
         * @param {HTMLElement} data.ddel The drag proxy element which moves with the mouse
         * @param {HTMLElement} data.item The TreeView node upon which the mousedown event was registered.
         * @param {Ext.data.Model[]} data.records An Array of {@link Ext.data.Model Model}s representing the selected data being
         * dragged from the source TreeView.
         *
         * @param {Ext.data.Model} overModel The Model over which the drop gesture took place.
         *
         * @param {String} dropPosition '"before"', '"after"' or '"append"' depending on whether the mouse is above or below
         * the midline of the node, or the node is a branch node which accepts new child nodes.
         *
         * This parameter allows the developer to control when the drop action takes place. It is useful if any asynchronous
         * processing needs to be completed before performing the drop. This object has the following properties:
         *
         * @param {Boolean} dropHandlers.wait Indicates whether the drop should be deferred. Set this property to true to defer the drop.
         * @param {Function} dropHandlers.processDrop A function to be called to complete the drop operation.
         * @param {Function} dropHandlers.cancelDrop A function to be called to cancel the drop operation.
         */
        beforedrop(node: HTMLElement, data: any, data_copy: boolean, data_view: Ext.tree.View, data_ddel: HTMLElement, data_item: HTMLElement, data_records: Ext.data.Model, overModel: Ext.data.Model, dropPosition: string, dropHandlers: any, dropHandlers_wait: boolean, dropHandlers_processDrop: Function, dropHandlers_cancelDrop: Function);

        /**
         * **This event is fired through the TreeView. Add listeners to the TreeView object** Fired when a drop operation
         * has been completed and the data has been moved or copied.
         *
         * @param {HTMLElement} node The TreeView node **if any** over which the mouse was positioned.
         *
         * @param {Object} data The data object gathered at mousedown time by the cooperating
         * {@link Ext.dd.DragZone DragZone}'s {@link Ext.dd.DragZone#getDragData getDragData} method it contains the following
         * properties:
         * @param {Boolean} data.copy The value of the TreeView's 'copy' property, or 'true' if the TreeView was configured with
         * 'allowCopy: true' and the control key was pressed when the drag operation was begun
         * @param {Ext.tree.View} data.view The source TreeView from which the drag originated.
         * @param {HTMLElement} data.ddel The drag proxy element which moves with the mouse
         * @param {HTMLElement} data.item The TreeView node upon which the mousedown event was registered.
         * @param {Ext.data.Model[]} data.records An Array of {@link Ext.data.Model Model}s representing the selected data being
         * dragged from the source TreeView.
         *
         * @param {Ext.data.Model} overModel The Model over which the drop gesture took place.
         *
         * @param {String} dropPosition '"before"', '"after"' or '"append"' depending on whether the mouse is above or below
         * the midline of the node, or the node is a branch node which accepts new child nodes.
         */
        drop(node: HTMLElement, data: any, data_copy: boolean, data_view: Ext.tree.View, data_ddel: HTMLElement, data_item: HTMLElement, data_records: Ext.data.Model, overModel: Ext.data.Model, dropPosition: string);
    }
}

declare module Ext.util {
    interface AbstractMixedCollectionConfig {
        /**
         * Specify <code>true</code> if the {@link #addAll}
         * function should add function references to the collection. Defaults to
         * <code>false</code>.
         * @since 3.4.0
         */
        allowFunctions?: boolean;
    }

    export class AbstractMixedCollection extends Ext.Base implements Ext.util.AbstractMixedCollectionConfig {
        /**
         * 'true' in this class to identify an object as an instantiated MixedCollection, or subclass thereof.
         */
        isMixedCollection: boolean;

        /**
         * Specify <code>true</code> if the {@link #addAll}
         * function should add function references to the collection. Defaults to
         * <code>false</code>.
         * @since 3.4.0
         */
        allowFunctions: boolean;

        /**
         * Adds an item to the collection. Fires the {@link #event-add} event when complete.
         *
         * @param {String/Object} key The key to associate with the item, or the new item.
         *
         * If a {@link #getKey} implementation was specified for this MixedCollection,
         * or if the key of the stored items is in a property called 'id',
         * the MixedCollection will be able to *derive* the key for the new item.
         * In this case just pass the new item in this parameter.
         *
         * @param {Object} [obj] The item to add.
         *
         * @return {Object} The item added.
         * @since 1.1.0
         */
        add(key: string|any, obj?: any): any;

        /**
         * Adds all elements of an Array or an Object to the collection.
         * @param {Object/Array} objs An Object containing properties which will be added
         * to the collection, or an Array of values, each of which are added to the collection.
         * Functions references will be added to the collection if '{@link #allowFunctions}'
         * has been set to 'true'.
         * @since 1.1.0
         */
        addAll(objs: any|any[]);

        /**
         * Removes all items from the collection.  Fires the {@link #event-clear} event when complete.
         * @since 1.1.0
         */
        clear();

        /**
         * Creates a shallow copy of this collection
         * @return {Ext.util.MixedCollection}
         * @since 1.1.0
         */
        clone(): Ext.util.MixedCollection;

        /**
         * Collects unique values of a particular property in this MixedCollection
         * @param {String} property The property to collect on
         * @param {String} root (optional) 'root' property to extract the first argument from. This is used mainly when
         * summing fields in records, where the fields are all stored inside the 'data' object
         * @param {Boolean} allowBlank (optional) Pass true to allow null, undefined or empty string values
         * @return {Array} The unique values
         */
        collect(property: string, root: string, allowBlank: boolean): any[];

        constructor(allowFunctions: any, keyFn: any);

        /**
         * Returns true if the collection contains the passed Object as an item.
         * @param {Object} o  The Object to look for in the collection.
         * @return {Boolean} True if the collection contains the Object as an item.
         * @since 1.1.0
         */
        contains(o: any): boolean;

        /**
         * Returns true if the collection contains the passed Object as a key.
         * @param {String} key The key to look for in the collection.
         * @return {Boolean} True if the collection contains the Object as a key.
         * @since 1.1.0
         */
        containsKey(key: string): boolean;

        /**
         * Executes the specified function once for every item in the collection.
         * The function should return a boolean value.
         * Returning false from the function will stop the iteration.
         *
         * @param {Function} fn The function to execute for each item.
         * @param {Mixed} fn.item The collection item.
         * @param {Number} fn.index The index of item.
         * @param {Number} fn.len Total length of collection.
         * @param {Object} scope (optional) The scope (<code>this</code> reference)
         * in which the function is executed. Defaults to the current item in the iteration.
         *
         * @since 1.1.0
         */
        each(fn: Function, fn_item: any, fn_index: number, fn_len: number, scope: any);

        /**
         * Executes the specified function once for every key in the collection, passing each
         * key, and its associated item as the first two parameters.
         * @param {Function} fn The function to execute for each item.
         * @param {String} fn.key The key of collection item.
         * @param {Mixed} fn.item The collection item.
         * @param {Number} fn.index The index of item.
         * @param {Number} fn.len Total length of collection.
         * @param {Object} scope (optional) The scope (<code>this</code> reference) in which the
         * function is executed. Defaults to the browser window.
         *
         * @since 1.1.0
         */
        eachKey(fn: Function, fn_key: string, fn_item: any, fn_index: number, fn_len: number, scope: any);

        /**
         * <p>Filters the objects in this collection by a set of {@link Ext.util.Filter Filter}s, or by a single
         * property/value pair with optional parameters for substring matching and case sensitivity. See
         * {@link Ext.util.Filter Filter} for an example of using Filter objects (preferred). Alternatively,
         * MixedCollection can be easily filtered by property like this:</p>
         *
         *    //create a simple store with a few people defined
         *    var people = new Ext.util.MixedCollection();
         *    people.addAll([
         *        {id: 1, age: 25, name: 'Ed'},
         *        {id: 2, age: 24, name: 'Tommy'},
         *        {id: 3, age: 24, name: 'Arne'},
         *        {id: 4, age: 26, name: 'Aaron'}
         *    ]);
         *
         *    //a new MixedCollection containing only the items where age == 24
         *    var middleAged = people.filter('age', 24);
         *
         * @param {Ext.util.Filter[]/String} property A property on your objects, or an array of {@link Ext.util.Filter Filter} objects
         * @param {String/RegExp} value Either string that the property values
         * should start with or a RegExp to test against the property
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just the beginning
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison.
         * @return {Ext.util.MixedCollection} The new filtered collection
         * @since 1.1.0
         */
        filter(property: Ext.util.Filter|string, value: string|RegExp, anyMatch?: boolean, caseSensitive?: boolean): Ext.util.MixedCollection;

        /**
         * Filter by a function. Returns a <i>new</i> collection that has been filtered.
         * The passed function will be called with each object in the collection.
         * If the function returns true, the value is included otherwise it is filtered.
         * @param {Function} fn The function to be called.
         * @param {Mixed} fn.item The collection item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} scope (optional) The scope (<code>this</code> reference) in
         * which the function is executed. Defaults to this MixedCollection.
         * @return {Ext.util.MixedCollection} The new filtered collection
         * @since 1.1.0
         */
        filterBy(fn: Function, fn_item: any, fn_key: string, scope: any): Ext.util.MixedCollection;

        /**
         * Returns the first item in the collection which elicits a true return value from the passed selection function.
         * @deprecated 4.0 Use {@link #findBy} instead.
         * @since 1.1.0
         */
        find();

        /**
         * Returns the first item in the collection which elicits a true return value from the
         * passed selection function.
         * @param {Function} fn The selection function to execute for each item.
         * @param {Mixed} fn.item The collection item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} scope (optional) The scope (<code>this</code> reference) in which the
         * function is executed. Defaults to the browser window.
         * @return {Object} The first item in the collection which returned true from the selection
         * function, or null if none was found.
         */
        findBy(fn: Function, fn_item: any, fn_key: string, scope: any): any;

        /**
         * Finds the index of the first matching object in this collection by a specific property/value.
         * @param {String} property The name of a property on your objects.
         * @param {String/RegExp} value A string that the property values
         * should start with or a RegExp to test against the property.
         * @param {Number} [start=0] The index to start searching at.
         * @param {Boolean} [anyMatch=false] True to match any part of the string, not just the beginning.
         * @param {Boolean} [caseSensitive=false] True for case sensitive comparison.
         * @return {Number} The matched index or -1
         * @since 2.3.0
         */
        findIndex(property: string, value: string|RegExp, start?: number, anyMatch?: boolean, caseSensitive?: boolean): number;

        /**
         * Find the index of the first matching object in this collection by a function.
         * If the function returns <i>true</i> it is considered a match.
         * @param {Function} fn The function to be called.
         * @param {Mixed} fn.item The collection item.
         * @param {String} fn.key The key of collection item.
         * @param {Object} [scope] The scope (<code>this</code> reference) in which the function is executed. Defaults to this MixedCollection.
         * @param {Number} [start=0] The index to start searching at.
         * @return {Number} The matched index or -1
         * @since 2.3.0
         */
        findIndexBy(fn: Function, fn_item: any, fn_key: string, scope?: any, start?: number): number;

        /**
         * Returns the first item in the collection.
         * @return {Object} the first item in the collection..
         * @since 1.1.0
         */
        first(): any;

        /**
         * Returns the item associated with the passed key OR index.
         * Key has priority over index.  This is the equivalent
         * of calling {@link #getByKey} first, then if nothing matched calling {@link #getAt}.
         * @param {String/Number} key The key or index of the item.
         * @return {Object} If the item is found, returns the item.  If the item was not found, returns <code>undefined</code>.
         * If an item was found, but is a Class, returns <code>null</code>.
         * @since 1.1.0
         */
        get(key: string|number): any;

        /**
         * Returns the item at the specified index.
         * @param {Number} index The index of the item.
         * @return {Object} The item at the specified index.
         */
        getAt(index: number): any;

        /**
         * Returns the item associated with the passed key.
         * @param {String/Number} key The key of the item.
         * @return {Object} The item associated with the passed key.
         */
        getByKey(key: string|number): any;

        /**
         * Returns the number of items in the collection.
         * @return {Number} the number of items in the collection.
         * @since 1.1.0
         */
        getCount(): number;

        /**
         * A function which will be called, passing a newly added object
         * when the object is added without a separate id.  The function
         * should yield the key by which that object will be indexed.
         *
         * If no key is yielded, then the object will be added, but it
         * cannot be accessed or removed quickly. Finding it in this
         * collection for interrogation or removal will require a linear
         * scan of this collection's items.
         *
         * The default implementation simply returns 'item.id' but you can
         * provide your own implementation to return a different value as
         * in the following examples:
         *
         *     // normal way
         *     var mc = new Ext.util.MixedCollection();
         *     mc.add(someEl.dom.id, someEl);
         *     mc.add(otherEl.dom.id, otherEl);
         *     //and so on
         *
         *     // using getKey
         *     var mc = new Ext.util.MixedCollection({
         *         getKey: function(el){
         *             return el.dom.id;
         *         }
         *     });
         *     mc.add(someEl);
         *     mc.add(otherEl);
         *
         * @param {Object} item The item for which to find the key.
         * @return {Object} The key for the passed item.
         * @since 1.1.0
         */
        getKey(item: any): any;

        /**
         * Returns a range of items in this collection
         * @param {Number} startIndex (optional) The starting index. Defaults to 0.
         * @param {Number} endIndex (optional) The ending index. Defaults to the last item.
         * @return {Array} An array of items
         * @since 1.1.0
         */
        getRange(startIndex: number, endIndex: number): any[];

        /**
         * Returns index within the collection of the passed Object.
         * @param {Object} o The item to find the index of.
         * @return {Number} index of the item. Returns -1 if not found.
         * @since 1.1.0
         */
        indexOf(o: any): number;

        /**
         * Returns index within the collection of the passed key.
         * @param {String} key The key to find the index of.
         * @return {Number} index of the key.
         * @since 1.1.0
         */
        indexOfKey(key: string): number;

        /**
         * Inserts an item at the specified index in the collection. Fires the {@link #event-add} event when complete.
         * @param {Number} index The index to insert the item at.
         * @param {String/Object/String[]/Object[]} key The key to associate with the new item, or the item itself.
         * May also be an array of either to insert multiple items at once.
         * @param {Object/Object[]} o (optional) If the second parameter was a key, the new item.
         * May also be an array to insert multiple items at once.
         * @return {Object} The item inserted or an array of items inserted.
         * @since 1.1.0
         */
        insert(index: number, key: string|any, o: any): any;

        /**
         * Returns the last item in the collection.
         * @return {Object} the last item in the collection..
         * @since 1.1.0
         */
        last(): any;

        /**
         * Remove an item from the collection.
         * @param {Object} o The item to remove.
         * @return {Object} The item removed or false if no item was removed.
         * @since 1.1.0
         */
        remove(o: any): any;

        /**
         * Remove all items in the collection. Can also be used
         * to remove only the items in the passed array.
         * @param {Array} [items] An array of items to be removed.
         * @return {Ext.util.MixedCollection} this object
         */
        removeAll(items?: any[]): Ext.util.MixedCollection;

        /**
         * Remove an item from a specified index in the collection. Fires the {@link #event-remove} event when complete.
         * @param {Number} index The index within the collection of the item to remove.
         * @return {Object} The item removed or false if no item was removed.
         * @since 1.1.0
         */
        removeAt(index: number): any;

        /**
         * Removes an item associated with the passed key fom the collection.
         * @param {String} key The key of the item to remove. If 'null' is passed,
         * all objects which yielded no key from the configured {@link #getKey} function are removed.
         * @return {Object} Only returned if removing at a specified key. The item removed or false if no item was removed.
         */
        removeAtKey(key: string): any;

        /**
         * Remove a range of items starting at a specified index in the collection.
         * Does not fire the remove event.
         * @param {Number} index The index within the collection of the item to remove.
         * @param {Number} [removeCount=1] The nuber of items to remove beginning at the specified index.
         * @return {Object} The last item removed or false if no item was removed.
         */
        removeRange(index: number, removeCount?: number): any;

        /**
         * Replaces an item in the collection. Fires the {@link #event-replace} event when complete.
         * @param {String} key The key associated with the item to replace, or the replacement item.
         *
         * If you supplied a {@link #getKey} implementation for this MixedCollection, or if the key
         * of your stored items is in a property called *'id'*, then the MixedCollection
         * will be able to <i>derive</i> the key of the replacement item. If you want to replace an item
         * with one having the same key value, then just pass the replacement item in this parameter.
         *
         * @param o {Object} o (optional) If the first parameter passed was a key, the item to associate
         * with that key.
         * @return {Object}  The new item.
         * @since 1.1.0
         */
        replace(key: string): any;

        /**
         * Collects all of the values of the given property and returns their sum
         * @param {String} property The property to sum by
         * @param {String} [root] 'root' property to extract the first argument from. This is used mainly when
         * summing fields in records, where the fields are all stored inside the 'data' object
         * @param {Number} [start=0] The record index to start at
         * @param {Number} [end=-1] The record index to end at
         * @return {Number} The total
         */
        sum(property: string, root?: string, start?: number, end?: number): number;

        /**
         * Change the key for an existing item in the collection. If the old key
         * does not exist this is a no-op.
         * @param {Object} oldKey The old key
         * @param {Object} newKey The new key
         */
        updateKey(oldKey: any, newKey: any);
    }

    /**
     * This animation class is a mixin.
     *
     * Ext.util.Animate provides an API for the creation of animated transitions of properties and styles.
     * This class is used as a mixin and currently applied to {@link Ext.Element}, {@link Ext.CompositeElement},
     * {@link Ext.draw.Sprite}, {@link Ext.draw.CompositeSprite}, and {@link Ext.Component}.  Note that Components
     * have a limited subset of what attributes can be animated such as top, left, x, y, height, width, and
     * opacity (color, paddings, and margins can not be animated).
     *
     * ## Animation Basics
     *
     * All animations require three things - 'easing', 'duration', and 'to' (the final end value for each property)
     * you wish to animate. Easing and duration are defaulted values specified below.
     * Easing describes how the intermediate values used during a transition will be calculated.
     * {@link Ext.fx.Anim#easing Easing} allows for a transition to change speed over its duration.
     * You may use the defaults for easing and duration, but you must always set a
     * {@link Ext.fx.Anim#to to} property which is the end value for all animations.
     *
     * Popular element 'to' configurations are:
     *
     *  - opacity
     *  - x
     *  - y
     *  - color
     *  - height
     *  - width
     *
     * Popular sprite 'to' configurations are:
     *
     *  - translation
     *  - path
     *  - scale
     *  - stroke
     *  - rotation
     *
     * The default duration for animations is 250 (which is a 1/4 of a second).  Duration is denoted in
     * milliseconds.  Therefore 1 second is 1000, 1 minute would be 60000, and so on. The default easing curve
     * used for all animations is 'ease'.  Popular easing functions are included and can be found in {@link Ext.fx.Anim#easing Easing}.
     *
     * For example, a simple animation to fade out an element with a default easing and duration:
     *
     *     var p1 = Ext.get('myElementId');
     *
     *     p1.animate({
     *         to: {
     *             opacity: 0
     *         }
     *     });
     *
     * To make this animation fade out in a tenth of a second:
     *
     *     var p1 = Ext.get('myElementId');
     *
     *     p1.animate({
     *        duration: 100,
     *         to: {
     *             opacity: 0
     *         }
     *     });
     *
     * ## Animation Queues
     *
     * By default all animations are added to a queue which allows for animation via a chain-style API.
     * For example, the following code will queue 4 animations which occur sequentially (one right after the other):
     *
     *     p1.animate({
     *         to: {
     *             x: 500
     *         }
     *     }).animate({
     *         to: {
     *             y: 150
     *         }
     *     }).animate({
     *         to: {
     *             backgroundColor: '#f00'  //red
     *         }
     *     }).animate({
     *         to: {
     *             opacity: 0
     *         }
     *     });
     *
     * You can change this behavior by calling the {@link Ext.util.Animate#syncFx syncFx} method and all
     * subsequent animations for the specified target will be run concurrently (at the same time).
     *
     *     p1.syncFx();  //this will make all animations run at the same time
     *
     *     p1.animate({
     *         to: {
     *             x: 500
     *         }
     *     }).animate({
     *         to: {
     *             y: 150
     *         }
     *     }).animate({
     *         to: {
     *             backgroundColor: '#f00'  //red
     *         }
     *     }).animate({
     *         to: {
     *             opacity: 0
     *         }
     *     });
     *
     * This works the same as:
     *
     *     p1.animate({
     *         to: {
     *             x: 500,
     *             y: 150,
     *             backgroundColor: '#f00'  //red
     *             opacity: 0
     *         }
     *     });
     *
     * The {@link Ext.util.Animate#stopAnimation stopAnimation} method can be used to stop any
     * currently running animations and clear any queued animations.
     *
     * ## Animation Keyframes
     *
     * You can also set up complex animations with {@link Ext.fx.Anim#keyframes keyframes} which follow the
     * CSS3 Animation configuration pattern. Note rotation, translation, and scaling can only be done for sprites.
     * The previous example can be written with the following syntax:
     *
     *     p1.animate({
     *         duration: 1000,  //one second total
     *         keyframes: {
     *             25: {     //from 0 to 250ms (25%)
     *                 x: 0
     *             },
     *             50: {   //from 250ms to 500ms (50%)
     *                 y: 0
     *             },
     *             75: {  //from 500ms to 750ms (75%)
     *                 backgroundColor: '#f00'  //red
     *             },
     *             100: {  //from 750ms to 1sec
     *                 opacity: 0
     *             }
     *         }
     *     });
     *
     * ## Animation Events
     *
     * Each animation you create has events for {@link Ext.fx.Anim#beforeanimate beforeanimate},
     * {@link Ext.fx.Anim#afteranimate afteranimate}, and {@link Ext.fx.Anim#lastframe lastframe}.
     * Keyframed animations adds an additional {@link Ext.fx.Animator#keyframe keyframe} event which
     * fires for each keyframe in your animation.
     *
     * All animations support the {@link Ext.util.Observable#listeners listeners} configuration to attact functions to these events.
     *
     *     startAnimate: function() {
     *         var p1 = Ext.get('myElementId');
     *         p1.animate({
     *            duration: 100,
     *             to: {
     *                 opacity: 0
     *             },
     *             listeners: {
     *                 beforeanimate:  function() {
     *                     // Execute my custom method before the animation
     *                     this.myBeforeAnimateFn();
     *                 },
     *                 afteranimate: function() {
     *                     // Execute my custom method after the animation
     *                     this.myAfterAnimateFn();
     *                 },
     *                 scope: this
     *         });
     *     },
     *     myBeforeAnimateFn: function() {
     *       // My custom logic
     *     },
     *     myAfterAnimateFn: function() {
     *       // My custom logic
     *     }
     *
     * Due to the fact that animations run asynchronously, you can determine if an animation is currently
     * running on any target by using the {@link Ext.util.Animate#getActiveAnimation getActiveAnimation}
     * method.  This method will return false if there are no active animations or return the currently
     * running {@link Ext.fx.Anim} instance.
     *
     * In this example, we're going to wait for the current animation to finish, then stop any other
     * queued animations before we fade our element's opacity to 0:
     *
     *     var curAnim = p1.getActiveAnimation();
     *     if (curAnim) {
     *         curAnim.on('afteranimate', function() {
     *             p1.stopAnimation();
     *             p1.animate({
     *                 to: {
     *                     opacity: 0
     *                 }
     *             });
     *         });
     *     }
     */
    export class Animate extends Ext.Base {
        /**
         * Performs custom animation on this object.
         *
         * This method is applicable to both the {@link Ext.Component Component} class and the {@link Ext.draw.Sprite Sprite}
         * class. It performs animated transitions of certain properties of this object over a specified timeline.
         *
         * ### Animating a {@link Ext.Component Component}
         *
         * When animating a Component, the following properties may be specified in 'from', 'to', and 'keyframe' objects:
         *
         *   - 'x' - The Component's page X position in pixels.
         *
         *   - 'y' - The Component's page Y position in pixels
         *
         *   - 'left' - The Component's 'left' value in pixels.
         *
         *   - 'top' - The Component's 'top' value in pixels.
         *
         *   - 'width' - The Component's 'width' value in pixels.
         *
         *   - 'height' - The Component's 'height' value in pixels.
         *
         *   - 'dynamic' - Specify as true to update the Component's layout (if it is a Container) at every frame of the animation.
         *     *Use sparingly as laying out on every intermediate size change is an expensive operation.*
         *
         * For example, to animate a Window to a new size, ensuring that its internal layout and any shadow is correct:
         *
         *     myWindow = Ext.create('Ext.window.Window', {
         *         title: 'Test Component animation',
         *         width: 500,
         *         height: 300,
         *         layout: {
         *             type: 'hbox',
         *             align: 'stretch'
         *         },
         *         items: [{
         *             title: 'Left: 33%',
         *             margins: '5 0 5 5',
         *             flex: 1
         *         }, {
         *             title: 'Left: 66%',
         *             margins: '5 5 5 5',
         *             flex: 2
         *         }]
         *     });
         *     myWindow.show();
         *     myWindow.header.el.on('click', function() {
         *         myWindow.animate({
         *             to: {
         *                 width: (myWindow.getWidth() == 500) ? 700 : 500,
         *                 height: (myWindow.getHeight() == 300) ? 400 : 300
         *             }
         *         });
         *     });
         *
         * For performance reasons, by default, the internal layout is only updated when the Window reaches its final '"to"'
         * size. If dynamic updating of the Window's child Components is required, then configure the animation with
         * 'dynamic: true' and the two child items will maintain their proportions during the animation.
         *
         * @param {Object} config  Configuration for {@link Ext.fx.Anim}.
         * Note that the {@link Ext.fx.Anim#to to} config is required.
         * @return {Object} this
         */
        animate(config: any): any;

        /**
         * Returns the current animation if this object has any effects actively running or queued, else returns false.
         * @return {Ext.fx.Anim/Boolean} Anim if element has active effects, else false
         */
        getActiveAnimation(): Ext.fx.Anim|boolean;

        /**
         * @deprecated 4.0 Replaced by {@link #getActiveAnimation}
         */
        hasActiveFx();

        /**
         * Ensures that all effects queued after sequenceFx is called on this object are run in sequence. This is the
         * opposite of {@link #syncFx}.
         * @return {Object} this
         */
        sequenceFx(): any;

        /**
         * Stops any running effects and clears this object's internal effects queue if it contains any additional effects
         * that haven't started yet.
         * @return {Ext.Element} The Element
         */
        stopAnimation(): Ext.dom.Element;

        /**
         * Stops any running effects and clears this object's internal effects queue if it contains any additional effects
         * that haven't started yet.
         * @deprecated 4.0 Replaced by {@link #stopAnimation}
         * @return {Ext.Element} The Element
         */
        stopFx(): Ext.dom.Element;

        /**
         * Ensures that all effects queued after syncFx is called on this object are run concurrently. This is the opposite
         * of {@link #sequenceFx}.
         * @return {Object} this
         */
        syncFx(): any;
    }

    /**
     * This class is used as a mixin.
     *
     * This class is to be used to provide basic methods for binding/unbinding stores to other
     * classes. In general it will not be used directly.
     */
    export class Bindable extends Ext.Base {
        /**
         * Binds a store to this instance.
         * @param {Ext.data.AbstractStore/String} [store] The store to bind or ID of the store.
         * When no store given (or when 'null' or 'undefined' passed), unbinds the existing store.
         */
        bindStore(store?: Ext.data.AbstractStore|string);

        /**
         * Binds listeners for this component to the store. By default it will add
         * anything bound by the getStoreListeners method, however it can be overridden
         * in a subclass to provide any more complicated handling.
         * @param {Ext.data.AbstractStore} store The store to bind to
         */
        protected bindStoreListeners(store: Ext.data.AbstractStore);

        /**
         * Gets the current store instance.
         * @return {Ext.data.AbstractStore} The store, null if one does not exist.
         */
        getStore(): Ext.data.AbstractStore;

        /**
         * Gets the listeners to bind to a new store.
         * @param {Ext.data.Store} store The Store which is being bound to for which a listeners object should be returned.
         * @return {Object} The listeners to be bound to the store in object literal form. The scope
         * may be omitted, it is assumed to be the current instance.
         */
        protected getStoreListeners(store: Ext.data.Store): any;

        /**
         * Template method, it is called when a new store is bound
         * to the current instance.
         * @param {Ext.data.AbstractStore} store The store being bound
         * @param {Boolean} initial True if this store is being bound as initialization of the instance.
         */
        protected onBindStore(store: Ext.data.AbstractStore, initial: boolean);

        /**
         * Template method, it is called when an existing store is unbound
         * from the current instance.
         * @param {Ext.data.AbstractStore} store The store being unbound
         * @param {Boolean} initial True if this store is being bound as initialization of the instance.
         */
        protected onUnbindStore(store: Ext.data.AbstractStore, initial: boolean);

        /**
         * Unbinds listeners from this component to the store. By default it will remove
         * anything bound by the bindStoreListeners method, however it can be overridden
         * in a subclass to provide any more complicated handling.
         * @param {Ext.data.AbstractStore} store The store to unbind from
         */
        protected unbindStoreListeners(store: Ext.data.AbstractStore);
    }

    interface ClickRepeaterConfig extends Ext.util.ObservableConfig {
        /**
         * True if autorepeating should start slowly and accelerate.
         * "interval" and "delay" are ignored.
         */
        accelerate?: boolean;

        /**
         * The initial delay before the repeating event begins firing.
         * Similar to an autorepeat key delay.
         */
        delay?: number;

        /**
         * The element to act as a button.
         */
        el?: string|HTMLElement|Ext.dom.Element;

        /**
         * The interval between firings of the "click" event (in milliseconds).
         */
        interval?: number;

        /**
         * A CSS class name to be applied to the element while pressed.
         */
        pressedCls?: string;

        /**
         * True to prevent the default click event
         */
        preventDefault?: boolean;

        /**
         * True to stop the default click event
         */
        stopDefault?: boolean;
    }

    /**
     * A wrapper class which can be applied to any element. Fires a "click" event while the
     * mouse is pressed. The interval between firings may be specified in the config but
     * defaults to 20 milliseconds.
     *
     * Optionally, a CSS class may be applied to the element during the time it is pressed.
     */
    export class ClickRepeater extends Ext.util.Observable implements Ext.util.ClickRepeaterConfig {
        /**
         * True if autorepeating should start slowly and accelerate.
         * "interval" and "delay" are ignored.
         */
        accelerate: boolean;

        /**
         * The initial delay before the repeating event begins firing.
         * Similar to an autorepeat key delay.
         */
        delay: number;

        /**
         * The element to act as a button.
         */
        el: string|HTMLElement|Ext.dom.Element;

        /**
         * The interval between firings of the "click" event (in milliseconds).
         */
        interval: number;

        /**
         * A CSS class name to be applied to the element while pressed.
         */
        pressedCls: string;

        /**
         * True to prevent the default click event
         */
        preventDefault: boolean;

        /**
         * True to stop the default click event
         */
        stopDefault: boolean;

        /**
         * Creates new ClickRepeater.
         * @param {String/HTMLElement/Ext.Element} el The element or its ID to listen on
         * @param {Object} [config] Config object.
         */
        constructor(el: string|HTMLElement|Ext.dom.Element, config?: Ext.util.ClickRepeaterConfig);

        /**
         * Disables the repeater and stops events from firing.
         */
        disable();

        /**
         * Enables the repeater and allows events to fire.
         */
        enable();

        /**
         * Convenience function for setting disabled/enabled by boolean.
         */
        setDisabled(disabled: boolean);

        /**
         * Fires on a specified interval during the time the element is pressed.
         */
        click(that: Ext.util.ClickRepeater, e: Ext.EventObject);

        /**
         * Fires when the mouse button is depressed.
         */
        mousedown(that: Ext.util.ClickRepeater, e: Ext.EventObject);

        /**
         * Fires when the mouse key is released.
         */
        mouseup(that: Ext.util.ClickRepeater, e: Ext.EventObject);
    }

    interface ComponentDraggerConfig extends Ext.dd.DragTrackerConfig {
        /**
         * Specify as 'true' to constrain the Component to within the bounds of the {@link #constrainTo} region.
         */
        constrain?: boolean;

        /**
         * Specify as 'true' to constrain the drag handles within the {@link #constrainTo} region.
         */
        constrainDelegate?: boolean;
    }

    /**
     * A subclass of Ext.dd.DragTracker which handles dragging any Component.
     *
     * This is configured with a Component to be made draggable, and a config object for the {@link Ext.dd.DragTracker}
     * class.
     *
     * A {@link #delegate} may be provided which may be either the element to use as the mousedown target or a {@link
     * Ext.DomQuery} selector to activate multiple mousedown targets.
     *
     * When the Component begins to be dragged, its 'beginDrag' method will be called if implemented.
     *
     * When the drag ends, its 'endDrag' method will be called if implemented.
     */
    export class ComponentDragger extends Ext.dd.DragTracker implements Ext.util.ComponentDraggerConfig {
        /**
         * Specify as 'true' to constrain the Component to within the bounds of the {@link #constrainTo} region.
         */
        constrain: boolean;

        /**
         * Specify as 'true' to constrain the drag handles within the {@link #constrainTo} region.
         */
        constrainDelegate: boolean;

        /**
         * Creates new ComponentDragger.
         * @param {Object} comp The Component to provide dragging for.
         * @param {Object} [config] Config object
         */
        constructor(comp: any, config?: Ext.util.ComponentDraggerConfig);
    }

    /**
     * Utility class for setting/reading values from browser cookies.
     * Values can be written using the {@link #set} method.
     * Values can be read using the {@link #get} method.
     * A cookie can be invalidated on the client machine using the {@link #clear} method.
     */
    export class Cookies {
        /**
         * Removes a cookie with the provided name from the browser
         * if found by setting its expiration date to sometime in the past.
         * @param {String} name The name of the cookie to remove
         * @param {String} [path] The path for the cookie.
         * This must be included if you included a path while setting the cookie.
         */
        static clear(name: string, path?: string);

        /**
         * Retrieves cookies that are accessible by the current page. If a cookie does not exist, 'get()' returns null. The
         * following example retrieves the cookie called "valid" and stores the String value in the variable validStatus.
         *
         *     var validStatus = Ext.util.Cookies.get("valid");
         *
         * @param {String} name The name of the cookie to get
         * @return {Object} Returns the cookie value for the specified name;
         * null if the cookie name does not exist.
         */
        static get(name: string): any;

        /**
         * Creates a cookie with the specified name and value. Additional settings for the cookie may be optionally specified
         * (for example: expiration, access restriction, SSL).
         * @param {String} name The name of the cookie to set.
         * @param {Object} value The value to set for the cookie.
         * @param {Object} [expires] Specify an expiration date the cookie is to persist until. Note that the specified Date
         * object will be converted to Greenwich Mean Time (GMT).
         * @param {String} [path] Setting a path on the cookie restricts access to pages that match that path. Defaults to all
         * pages ('/').
         * @param {String} [domain] Setting a domain restricts access to pages on a given domain (typically used to allow
         * cookie access across subdomains). For example, "sencha.com" will create a cookie that can be accessed from any
         * subdomain of sencha.com, including www.sencha.com, support.sencha.com, etc.
         * @param {Boolean} [secure] Specify true to indicate that the cookie should only be accessible via SSL on a page
         * using the HTTPS protocol. Defaults to false. Note that this will only work if the page calling this code uses the
         * HTTPS protocol, otherwise the cookie will be created with default options.
         */
        static set(name: string, value: any, expires?: any, path?: string, domain?: string, secure?: boolean);
    }

    /**
     * Utility class for manipulating CSS rules
     */
    export class CSS {
        /**
         * Creates a rule.
         * @param {CSSStyleSheet} styleSheet The StyleSheet to create the rule in as returned from {@link #createStyleSheet}.
         * @param {String} selector The selector to target the rule.
         * @param {String} property The cssText specification eg '"color:red;font-weight:bold;text-decoration:underline"'
         * @return {CSSStyleRule} The created rule
         */
        static createRule(styleSheet: any, selector: string, property: string): any;

        /**
         * Creates a stylesheet from a text blob of rules.
         * These rules will be wrapped in a STYLE tag and appended to the HEAD of the document.
         * @param {String} cssText The text containing the css rules
         * @param {String} id An id to add to the stylesheet for later removal
         * @return {CSSStyleSheet}
         */
        static createStyleSheet(cssText: string, id: string): any;

        /**
         * Gets an an individual CSS rule by selector(s)
         * @param {String/String[]} selector The CSS selector or an array of selectors to try. The first selector that is found is returned.
         * @param {Boolean} refreshCache true to refresh the internal cache if you have recently updated any rules or added styles dynamically
         * @return {CSSStyleRule} The CSS rule or null if one is not found
         */
        static getRule(selector: string, refreshCache: boolean): any;

        /**
         * Gets all css rules for the document
         * @param {Boolean} refreshCache true to refresh the internal cache
         * @return {Object} An object (hash) of rules indexed by selector
         */
        static getRules(refreshCache: boolean): any;

        /**
         * Refresh the rule cache if you have dynamically added stylesheets
         * @return {Object} An object (hash) of rules indexed by selector
         */
        static refreshCache(): any;

        /**
         * Removes a style or link tag by id
         * @param {String} id The id of the tag
         */
        static removeStyleSheet(id: string);

        /**
         * Dynamically swaps an existing stylesheet reference for a new one
         * @param {String} id The id of an existing link tag to remove
         * @param {String} url The href of the new stylesheet to include
         */
        static swapStyleSheet(id: string, url: string);

        /**
         * Updates a rule property
         * @param {String/String[]} selector If it's an array it tries each selector until it finds one. Stops immediately once one is found.
         * @param {String} property The css property or a cssText specification eg '"color:red;font-weight:bold;text-decoration:underline"'
         * @param {String} value The new value for the property
         * @return {Boolean} true If a rule was found and updated
         */
        static updateRule(selector: string, property: string, value: string): boolean;
    }

    export class DelayedTask {
        /**
         * The id of the currently pending invocation.  Will be set to 'null' if there is no
         * invocation pending.
         */
        id: number;

        /**
         * Cancel the last queued timeout
         */
        cancel();

        /**
         * The DelayedTask class provides a convenient way to "buffer" the execution of a method,
         * performing setTimeout where a new timeout cancels the old timeout. When called, the
         * task will wait the specified time period before executing. If durng that time period,
         * the task is called again, the original call will be cancelled. This continues so that
         * the function is only called a single time for each iteration.
         *
         * This method is especially useful for things like detecting whether a user has finished
         * typing in a text field. An example would be performing validation on a keypress. You can
         * use this class to buffer the keypress events for a certain number of milliseconds, and
         * perform only if they stop for that amount of time.
         *
         * ## Usage
         *
         *     var task = new Ext.util.DelayedTask(function(){
         *         alert(Ext.getDom('myInputField').value.length);
         *     });
         *
         *     // Wait 500ms before calling our function. If the user presses another key
         *     // during that 500ms, it will be cancelled and we'll wait another 500ms.
         *     Ext.get('myInputField').on('keypress', function() {
         *         task.{@link #delay}(500);
         *     });
         *
         * Note that we are using a DelayedTask here to illustrate a point. The configuration
         * option 'buffer' for {@link Ext.util.Observable#addListener addListener/on} will
         * also setup a delayed task for you to buffer events.
         *
         * @constructor The parameters to this constructor serve as defaults and are not required.
         * @param {Function} fn (optional) The default function to call. If not specified here, it must be specified during the {@link #delay} call.
         * @param {Object} scope (optional) The default scope (The **'this'** reference) in which the
         * function is called. If not specified, 'this' will refer to the browser window.
         * @param {Array} args (optional) The default Array of arguments.
         * @param {Boolean} [cancelOnDelay=true] By default, each call to {@link #delay} cancels any pending invocation and reschedules a new
         * invocation. Specifying this as 'false' means that calls to {@link #delay} when an invocation is pending just update the call settings,
         * 'newDelay', 'newFn', 'newScope' or 'newArgs', whichever are passed.
         */
        constructor(fn: Function, scope: any, args: any[], cancelOnDelay?: boolean);

        /**
         * By default, cancels any pending timeout and queues a new one.
         *
         * If the 'cancelOnDelay' parameter was specified as 'false' in the constructor, this does not cancel and
         * reschedule, but just updates the call settings, 'newDelay', 'newFn', 'newScope' or 'newArgs', whichever are passed.
         *
         * @param {Number} newDelay The milliseconds to delay
         * @param {Function} newFn (optional) Overrides function passed to constructor
         * @param {Object} newScope (optional) Overrides scope passed to constructor. Remember that if no scope
         * is specified, <code>this</code> will refer to the browser window.
         * @param {Array} newArgs (optional) Overrides args passed to constructor
         */
        delay(newDelay: number, newFn: Function, newScope: any, newArgs: any[]);
    }

    /**
     * This mixin enables classes to declare relationships to child elements and provides the
     * mechanics for acquiring the {@link Ext.Element elements} and storing them on an object
     * instance as properties.
     *
     * This class is used by {@link Ext.Component components} and {@link Ext.layout.container.Container container layouts} to
     * manage their child elements.
     *
     * A typical component that uses these features might look something like this:
     *
     *      Ext.define('Ext.ux.SomeComponent', {
     *          extend: 'Ext.Component',
     *
     *          childEls: [
     *              'bodyEl'
     *          ],
     *
     *          renderTpl: [
     *              '<div id="{id}-bodyEl"></div>'
     *          ],
     *
     *          // ...
     *      });
     *
     * The 'childEls' array lists one or more relationships to child elements managed by the
     * component. The items in this array can be either of the following types:
     *
     * - String: the id suffix and property name in one. For example, "bodyEl" in the above
     * example means a "bodyEl" property will be added to the instance with the result of
     * {@link Ext#get} given "componentId-bodyEl" where "componentId" is the component instance's
     * id.
     * - Object: with a 'name' property that names the instance property for the element, and
     * one of the following additional properties:
     *      - 'id': The full id of the child element.
     *      - 'itemId': The suffix part of the id to which "componentId-" is prepended.
     *      - 'select': A selector that will be passed to {@link Ext#select}.
     *      - 'selectNode': A selector that will be passed to {@link Ext.DomQuery#selectNode}.
     *
     * The example above could have used this instead to achieve the same result:
     *
     *      childEls: [
     *          { name: 'bodyEl', itemId: 'bodyEl' }
     *      ]
     *
     * When using 'select', the property will be an instance of {@link Ext.CompositeElement}. In
     * all other cases, the property will be an {@link Ext.Element} or 'null' if not found.
     *
     * Care should be taken when using 'select' or 'selectNode' to find child elements. The
     * following issues should be considered:
     *
     * - Performance: using selectors can be slower than id lookup by a factor 10x or more.
     * - Over-selecting: selectors are applied after the DOM elements for all children have
     * been rendered, so selectors can match elements from child components (including nested
     * versions of the same component) accidentally.
     *
     * This above issues are most important when using 'select' since it returns multiple
     * elements.
     *
     * **IMPORTANT**
     * Unlike a 'renderTpl' where there is a single value for an instance, 'childEls' are aggregated
     * up the class hierarchy so that they are effectively inherited. In other words, if a
     * class where to derive from 'Ext.ux.SomeComponent' in the example above, it could also
     * have a 'childEls' property in the same way as 'Ext.ux.SomeComponent'.
     *
     *      Ext.define('Ext.ux.AnotherComponent', {
     *          extend: 'Ext.ux.SomeComponent',
     *
     *          childEls: [
     *              // 'bodyEl' is inherited
     *              'innerEl'
     *          ],
     *
     *          renderTpl: [
     *              '<div id="{id}-bodyEl">'
     *                  '<div id="{id}-innerEl"></div>'
     *              '</div>'
     *          ],
     *
     *          // ...
     *      });
     *
     * The 'renderTpl' contains both child elements and unites them in the desired markup, but
     * the 'childEls' only contains the new child element. The {@link #applyChildEls} method
     * takes care of looking up all 'childEls' for an instance and considers 'childEls'
     * properties on all the super classes and mixins.
     */
    export class ElementContainer extends Ext.Base {
        /**
         * Adds each argument passed to this method to the {@link Ext.AbstractComponent#cfg-childEls childEls} array.
         */
        addChildEls();

        constructor();

        /**
         * Removes items in the childEls array based on the return value of a supplied test
         * function. The function is called with a entry in childEls and if the test function
         * return true, that entry is removed. If false, that entry is kept.
         *
         * @param {Function} testFn The test function.
         */
        removeChildEls(testFn: Function);
    }

    /**
     * Represents single event type that an Observable object listens to.
     * All actual listeners are tracked inside here.  When the event fires,
     * it calls all the registered listener functions.
     */
    export class Event extends Ext.Base {
        /**
         * 'true' in this class to identify an object as an instantiated Event, or subclass thereof.
         */
        isEvent: boolean;
    }

    interface FilterConfig {
        /**
         * True to allow any match - no regex start/end line anchors will be added.
         */
        anyMatch?: boolean;

        /**
         * True to make the regex case sensitive (adds 'i' switch to regex).
         */
        caseSensitive?: boolean;

        /**
         * True to force exact match (^ and $ characters added to the regex). Ignored if anyMatch is true.
         */
        exactMatch?: boolean;

        /**
         * A custom filter function which is passed each item in the {@link Ext.util.MixedCollection} in turn. Should return
         * 'true' to accept each item or 'false' to reject it.
         */
        filterFn?: Function;

        /**
         * An identifier by which this Filter is indexed in a {@link Ext.data.Store#property-filters Store's filters collection}
         *
         * Identified Filters may be individually removed from a Store's filter set by using {@link Ext.data.Store#removeFilter}.
         *
         * Anonymous Filters may be removed en masse by passing 'null' to {@link Ext.data.Store#removeFilter}.
         *
         * Optional
         */
        id?: string;

        /**
         * The operator to use to compare the {@link #cfg-property} to this Filter's {@link #cfg-value}
         *
         * Possible values are:
         *    * <
         *    * <=
         *    * =
         *    * >=
         *    * >
         *    * !=
         *
         * Optional
         */
        operator?: string;

        /**
         * The property to filter on. Required unless a {@link #filterFn} is passed
         */
        property?: string;

        /**
         * Optional root property. This is mostly useful when filtering a Store, in which case we set the root to 'data' to
         * make the filter pull the {@link #property} out of the data object of each item
         */
        root?: string;

        /**
         * The value to filter on. Required unless a {@link #filterFn} is passed.
         */
        value?: any;
    }

    /**
     * Represents a filter that can be applied to a {@link Ext.util.MixedCollection MixedCollection}. Can either simply
     * filter on a property/value pair or pass in a filter function with custom logic. Filters are always used in the
     * context of MixedCollections, though {@link Ext.data.Store Store}s frequently create them when filtering and searching
     * on their records. Example usage:
     *
     *     //set up a fictional MixedCollection containing a few people to filter on
     *     var allNames = new Ext.util.MixedCollection();
     *     allNames.addAll([
     *         {id: 1, name: 'Ed',    age: 25},
     *         {id: 2, name: 'Jamie', age: 37},
     *         {id: 3, name: 'Abe',   age: 32},
     *         {id: 4, name: 'Aaron', age: 26},
     *         {id: 5, name: 'David', age: 32}
     *     ]);
     *
     *     var ageFilter = new Ext.util.Filter({
     *         property: 'age',
     *         value   : 32
     *     });
     *
     *     var longNameFilter = new Ext.util.Filter({
     *         filterFn: function(item) {
     *             return item.name.length > 4;
     *         }
     *     });
     *
     *     //a new MixedCollection with the 3 names longer than 4 characters
     *     var longNames = allNames.filter(longNameFilter);
     *
     *     //a new MixedCollection with the 2 people of age 32:
     *     var youngFolk = allNames.filter(ageFilter);
     */
    export class Filter extends Ext.Base implements Ext.util.FilterConfig {
        /**
         * Setting this property to 'true' disables this individual Filter so that it no longer contributes to a {@link Ext.data.Store#property-filters Store's filter set}
         *
         * When disabled, the next time the store is filtered, the Filter plays no part in filtering and records eliminated by it may rejoin the dataset.
         */
        disabled: boolean;

        /**
         * True to allow any match - no regex start/end line anchors will be added.
         */
        anyMatch: boolean;

        /**
         * True to make the regex case sensitive (adds 'i' switch to regex).
         */
        caseSensitive: boolean;

        /**
         * True to force exact match (^ and $ characters added to the regex). Ignored if anyMatch is true.
         */
        exactMatch: boolean;

        /**
         * A custom filter function which is passed each item in the {@link Ext.util.MixedCollection} in turn. Should return
         * 'true' to accept each item or 'false' to reject it.
         */
        filterFn: Function;

        /**
         * An identifier by which this Filter is indexed in a {@link Ext.data.Store#property-filters Store's filters collection}
         *
         * Identified Filters may be individually removed from a Store's filter set by using {@link Ext.data.Store#removeFilter}.
         *
         * Anonymous Filters may be removed en masse by passing 'null' to {@link Ext.data.Store#removeFilter}.
         *
         * Optional
         */
        id: string;

        /**
         * The operator to use to compare the {@link #cfg-property} to this Filter's {@link #cfg-value}
         *
         * Possible values are:
         *    * <
         *    * <=
         *    * =
         *    * >=
         *    * >
         *    * !=
         *
         * Optional
         */
        operator: string;

        /**
         * The property to filter on. Required unless a {@link #filterFn} is passed
         */
        property: string;

        /**
         * Optional root property. This is mostly useful when filtering a Store, in which case we set the root to 'data' to
         * make the filter pull the {@link #property} out of the data object of each item
         */
        root: string;

        /**
         * The value to filter on. Required unless a {@link #filterFn} is passed.
         */
        value: any;

        /**
         * Creates new Filter.
         * @param {Object} [config] Config object
         */
        constructor(config?: Ext.util.FilterConfig);

        /**
         * Changes the filtering function which this Filter uses to choose items to include.
         *
         * This replaces any configured {@link #cfg-filterFn} and overrides any {@link #cfg-property} and {@link #cfg-value) settings.
         * @param {Function} filterFn A function which returns 'true' or 'false' to either include or exclude the passed object.
         * @param {Object} filterFn.value The value for consideration to be included or excluded.
         */
        setFilterFn(filterFn: Function, filterFn_value: any);

        /**
         * Changes the value that this filter tests its configured (@link #cfg-property} with.
         * @param {Mixed} value The new value to compare the property with.
         */
        setValue(value: any);

        /**
         * Creates a single filter function which encapsulates the passed Filter array.
         * @param {Ext.util.Filter[]} filters The filter set for which to create a filter function
         * @return {Function} a function, which when passed a candidate object returns 'true' if
         * the candidate passes all the specified Filters.
         */
        static createFilterFn(filters: Ext.util.Filter): Function;
    }

    interface FloatingConfig {
        /**
         * True to constrain this Components within its containing element, false to allow it to fall outside of its containing
         * element. By default this Component will be rendered to 'document.body'. To render and constrain this Component within
         * another element specify {@link Ext.AbstractComponent#renderTo renderTo}.
         */
        constrain?: boolean;

        /**
         * Configure as 'true' to have this Component fixed at its 'X, Y' coordinates in the browser viewport, immune
         * to scrolling the document.
         *
         * *Only in browsers that support 'position:fixed'*
         *
         * *IE6 and IE7, 8 and 9 quirks do not support 'position: fixed'*
         *
         * Optional, Defaults to: false
         */
        fixed?: boolean;

        /**
         * Specifies whether the floated component should be automatically {@link Ext.Component#method-focus focused} when
         * it is {@link #toFront brought to the front}.
         */
        focusOnToFront?: boolean;

        /**
         * Specifies whether the floating component should be given a shadow. Set to true to automatically create an
         * {@link Ext.Shadow}, or a string indicating the shadow's display {@link Ext.Shadow#mode}. Set to false to
         * disable the shadow.
         */
        shadow?: string|boolean;

        /**
         * Number of pixels to offset the shadow.
         */
        shadowOffset?: number;
    }

    /**
     * A mixin to add floating capability to a Component.
     */
    export class Floating extends Ext.Base implements Ext.util.FloatingConfig {
        /**
         * True to constrain this Components within its containing element, false to allow it to fall outside of its containing
         * element. By default this Component will be rendered to 'document.body'. To render and constrain this Component within
         * another element specify {@link Ext.AbstractComponent#renderTo renderTo}.
         */
        constrain: boolean;

        /**
         * Configure as 'true' to have this Component fixed at its 'X, Y' coordinates in the browser viewport, immune
         * to scrolling the document.
         *
         * *Only in browsers that support 'position:fixed'*
         *
         * *IE6 and IE7, 8 and 9 quirks do not support 'position: fixed'*
         *
         * Optional, Defaults to: false
         */
        fixed: boolean;

        /**
         * Specifies whether the floated component should be automatically {@link Ext.Component#method-focus focused} when
         * it is {@link #toFront brought to the front}.
         */
        focusOnToFront: boolean;

        /**
         * Specifies whether the floating component should be given a shadow. Set to true to automatically create an
         * {@link Ext.Shadow}, or a string indicating the shadow's display {@link Ext.Shadow#mode}. Set to false to
         * disable the shadow.
         */
        shadow: string|boolean;

        /**
         * Number of pixels to offset the shadow.
         */
        shadowOffset: number;

        /**
         * Center this Component in its container.
         * @return {Ext.Component} this
         */
        center(): Ext.Component;

        /**
         * Moves this floating Component into a constrain region.
         *
         * By default, this Component is constrained to be within the container it was added to, or the element it was
         * rendered to.
         *
         * An alternative constraint may be passed.
         * @param {String/HTMLElement/Ext.Element/Ext.util.Region} [constrainTo] The Element or {@link Ext.util.Region Region}
         * into which this Component is to be constrained. Defaults to the element into which this floating Component
         * was rendered.
         */
        doConstrain(constrainTo?: string|HTMLElement|Ext.dom.Element|Ext.util.Region);

        /**
         * This method is called internally by {@link Ext.ZIndexManager} to signal that a floating Component has either been
         * moved to the top of its zIndex stack, or pushed from the top of its zIndex stack.
         *
         * If a _Window_ is superceded by another Window, deactivating it hides its shadow.
         *
         * This method also fires the {@link Ext.Component#activate activate} or
         * {@link Ext.Component#deactivate deactivate} event depending on which action occurred.
         *
         * @param {Boolean} [active=false] True to activate the Component, false to deactivate it.
         * @param {Ext.Component} [newActive] The newly active Component which is taking over topmost zIndex position.
         */
        setActive(active?: boolean, newActive?: Ext.Component);

        /**
         * Sends this Component to the back of (lower z-index than) any other visible windows
         * @return {Ext.Component} this
         */
        toBack(): Ext.Component;

        /**
         * Brings this floating Component to the front of any other visible, floating Components managed by the same
         * {@link Ext.ZIndexManager ZIndexManager}
         *
         * If this Component is modal, inserts the modal mask just below this Component in the z-index stack.
         *
         * @param {Boolean} [preventFocus=false] Specify 'true' to prevent the Component from being focused.
         * @return {Ext.Component} this
         */
        toFront(preventFocus?: boolean): Ext.Component;
    }

    /**
     * This class is a centralized place for formatting functions. It includes
     * functions to format various different types of data, such as text, dates and numeric values.
     *
     * ## Localization
     *
     * This class contains several options for localization. These can be set once the library has loaded,
     * all calls to the functions from that point will use the locale settings that were specified.
     *
     * Options include:
     *
     * - thousandSeparator
     * - decimalSeparator
     * - currenyPrecision
     * - currencySign
     * - currencyAtEnd
     *
     * This class also uses the default date format defined here: {@link Ext.Date#defaultFormat}.
     *
     * ## Using with renderers
     *
     * There are two helper functions that return a new function that can be used in conjunction with
     * grid renderers:
     *
     *     columns: [{
     *         dataIndex: 'date',
     *         renderer: Ext.util.Format.dateRenderer('Y-m-d')
     *     }, {
     *         dataIndex: 'time',
     *         renderer: Ext.util.Format.numberRenderer('0.000')
     *     }]
     *
     * Functions that only take a single argument can also be passed directly:
     *
     *     columns: [{
     *         dataIndex: 'cost',
     *         renderer: Ext.util.Format.usMoney
     *     }, {
     *         dataIndex: 'productCode',
     *         renderer: Ext.util.Format.uppercase
     *     }]
     *
     * ## Using with XTemplates
     *
     * XTemplates can also directly use Ext.util.Format functions:
     *
     *     new Ext.XTemplate([
     *         'Date: {startDate:date("Y-m-d")}',
     *         'Cost: {cost:usMoney}'
     *     ]);
     */
    export class Format {
        /**
         * This may be set to <code>true</code> to make the {@link #currency} function
         * append the currency sign to the formatted value.
         *
         * This may be overridden in a locale file.
         */
        static currencyAtEnd: boolean;

        /**
         * The number of decimal places that the {@link #currency} function displays.
         *
         * This may be overridden in a locale file.
         */
        static currencyPrecision: number;

        /**
         * The currency sign that the {@link #currency} function displays.
         *
         * This may be overridden in a locale file.
         */
        static currencySign: string;

        /**
         * The character that the {@link #number} function uses as a decimal point.
         *
         * This may be overridden in a locale file.
         */
        static decimalSeparator: string;

        /**
         * The character that the {@link #number} function uses as a thousand separator.
         *
         * This may be overridden in a locale file.
         */
        static thousandSeparator: string;

        /**
         * Formats an object of name value properties as HTML element attribute values suitable for using when creating textual markup.
         * @param {Object} attributes An object containing the HTML attributes as properties eg: '{height:40, vAlign:'top'}'
         */
        static attributes(attributes: any);

        /**
         * Alias for {@link Ext.String#capitalize}.
         */
        static capitalize();

        /**
         * Format a number as a currency.
         * @param {Number/String} value The numeric value to format
         * @param {String} [sign] The currency sign to use (defaults to {@link #currencySign})
         * @param {Number} [decimals] The number of decimals to use for the currency
         * (defaults to {@link #currencyPrecision})
         * @param {Boolean} [end] True if the currency sign should be at the end of the string
         * (defaults to {@link #currencyAtEnd})
         * @return {String} The formatted currency string
         */
        static currency(value: number|string, sign?: string, decimals?: number, end?: boolean): string;

        /**
         * Formats the passed date using the specified format pattern.
         * @param {String/Date} value The value to format. If a string is passed, it is converted to a Date
         * by the Javascript's built-in Date#parse method.
         * @param {String} [format] Any valid date format string. Defaults to {@link Ext.Date#defaultFormat}.
         * @return {String} The formatted date string.
         */
        static date(value: string|Date, format?: string): string;

        /**
         * Returns a date rendering function that can be reused to apply a date format multiple times efficiently.
         * @param {String} format Any valid date format string. Defaults to {@link Ext.Date#defaultFormat}.
         * @return {Function} The date formatting function
         */
        static dateRenderer(format: string): Function;

        /**
         * Checks a reference and converts it to the default value if it's empty.
         * @param {Object} value Reference to check
         * @param {String} [defaultValue=""] The value to insert of it's undefined.
         * @return {String}
         */
        static defaultValue(value: any, defaultValue?: string): string;

        /**
         * Alias for {@link Ext.String#ellipsis}.
         */
        static ellipsis();

        /**
         * Escapes the passed string for use in a regular expression.
         * @return {String}
         */
        static escapeRegex(str: string): string;

        /**
         * Simple format for a file size (xxx bytes, xxx KB, xxx MB).
         * @param {Number/String} size The numeric value to format
         * @return {String} The formatted file size
         */
        static fileSize(size: number|string): string;

        /**
         * Alias for {@link Ext.String#format}.
         */
        static format();

        /**
         * Alias for {@link Ext.String#htmlDecode}.
         */
        static htmlDecode();

        /**
         * Alias for {@link Ext.String#htmlEncode}.
         */
        static htmlEncode();

        /**
         * Alias for {@link Ext.String#leftPad}.
         */
        static leftPad();

        /**
         * Converts a string to all lower case letters.
         * @param {String} value The text to convert
         * @return {String} The converted text
         */
        static lowercase(value: string): string;

        /**
         * It does simple math for use in a template, for example:
         *
         *     var tpl = new Ext.Template('{value} * 10 = {value:math("* 10")}');
         *
         * @return {Function} A function that operates on the passed value.
         */
        static math(): Function;

        /**
         * Converts newline characters to the HTML tag '<br/>'
         *
         * @param {String} v The string value to format.
         * @return {String} The string with embedded '<br/>' tags in place of newlines.
         */
        static nl2br(v: string): string;

        /**
         * Formats the passed number according to the passed format string.
         *
         * The number of digits after the decimal separator character specifies the number of
         * decimal places in the resulting string. The *local-specific* decimal character is
         * used in the result.
         *
         * The *presence* of a thousand separator character in the format string specifies that
         * the *locale-specific* thousand separator (if any) is inserted separating thousand groups.
         *
         * By default, "," is expected as the thousand separator, and "." is expected as the decimal separator.
         *
         * ## New to Ext JS 4
         *
         * Locale-specific characters are always used in the formatted output when inserting
         * thousand and decimal separators.
         *
         * The format string must specify separator characters according to US/UK conventions ("," as the
         * thousand separator, and "." as the decimal separator)
         *
         * To allow specification of format strings according to local conventions for separator characters, add
         * the string '/i' to the end of the format string.
         *
         * examples (123456.789):
         *
         * - '0' - (123456) show only digits, no precision
         * - '0.00' - (123456.78) show only digits, 2 precision
         * - '0.0000' - (123456.7890) show only digits, 4 precision
         * - '0,000' - (123,456) show comma and digits, no precision
         * - '0,000.00' - (123,456.78) show comma and digits, 2 precision
         * - '0,0.00' - (123,456.78) shortcut method, show comma and digits, 2 precision
         * - '0.####' - (123,456,789) Allow maximum 4 decimal places, but do not right pad with zeroes
         *
         * @param {Number} v The number to format.
         * @param {String} format The way you would like to format this text.
         * @return {String} The formatted number.
         */
        static number(v: number, format: string): string;

        /**
         * Returns a number rendering function that can be reused to apply a number format multiple
         * times efficiently.
         *
         * @param {String} format Any valid number format string for {@link #number}
         * @return {Function} The number formatting function
         */
        static numberRenderer(format: string): Function;

        /**
         * Parses a number or string representing margin sizes into an object.
         * Supports CSS-style margin declarations (e.g. 10, "10", "10 10", "10 10 10" and
         * "10 10 10 10" are all valid options and would return the same result).
         *
         * @param {Number/String} v The encoded margins
         * @return {Object} An object with margin sizes for top, right, bottom and left
         */
        static parseBox(v: number|string): any;

        /**
         * Selectively do a plural form of a word based on a numeric value. For example, in a template,
         * '{commentCount:plural("Comment")}'  would result in '"1 Comment"' if commentCount was 1 or
         * would be '"x Comments"' if the value is 0 or greater than 1.
         *
         * @param {Number} value The value to compare against
         * @param {String} singular The singular form of the word
         * @param {String} [plural] The plural form of the word (defaults to the singular with an "s")
         */
        static plural(value: number, singular: string, plural?: string);

        /**
         * Rounds the passed number to the required decimal precision.
         * @param {Number/String} value The numeric value to round.
         * @param {Number} precision The number of decimal places to which to round the first parameter's value.
         * @return {Number} The rounded value.
         */
        static round(value: number|string, precision: number): number;

        /**
         * Strips all script tags.
         * @param {Object} value The text from which to strip script tags
         * @return {String} The stripped text
         */
        static stripScripts(value: any): string;

        /**
         * Strips all HTML tags.
         * @param {Object} value The text from which to strip tags
         * @return {String} The stripped text
         */
        static stripTags(value: any): string;

        /**
         * Returns a substring from within an original string.
         * @param {String} value The original text
         * @param {Number} start The start index of the substring
         * @param {Number} length The length of the substring
         * @return {String} The substring
         */
        static substr(value: string, start: number, length: number): string;

        /**
         * Alias for {@link Ext.String#trim}.
         */
        static trim();

        /**
         * Checks a reference and converts it to empty string if it is undefined.
         * @param {Object} value Reference to check
         * @return {Object} Empty string if converted, otherwise the original value
         */
        static undef(value: any): any;

        /**
         * Converts a string to all upper case letters.
         * @param {String} value The text to convert
         * @return {String} The converted text
         */
        static uppercase(value: string): string;

        /**
         * Format a number as US currency.
         * @param {Number/String} value The numeric value to format
         * @return {String} The formatted currency string
         */
        static usMoney(value: number|string): string;
    }

    /**
     Represents a single grouper that can be applied to a Store. The grouper works
     in the same fashion as the {@link Ext.util.Sorter}.
     * @markdown
     */
    export class Grouper extends Ext.util.Sorter {
        constructor(config: Ext.util.SorterConfig);

        /**
         * Returns the value for grouping to be used.
         * @param {Ext.data.Model} instance The Model instance
         * @return {String} The group string for this model
         */
        getGroupString(instance: Ext.data.Model): string;
    }

    interface HashMapConfig {
        /**
         * A function that is used to retrieve a default key for a passed object.
         * A default is provided that returns the 'id' property on the object. This function is only used
         * if the 'add' method is called with a single argument.
         */
        keyFn?: Function;
    }

    /**
     * Represents a collection of a set of key and value pairs. Each key in the HashMap
     * must be unique, the same key cannot exist twice. Access to items is provided via
     * the key only. Sample usage:
     *
     *     var map = new Ext.util.HashMap();
     *     map.add('key1', 1);
     *     map.add('key2', 2);
     *     map.add('key3', 3);
     *
     *     map.each(function(key, value, length){
     *         console.log(key, value, length);
     *     });
     *
     * The HashMap is an unordered class,
     * there is no guarantee when iterating over the items that they will be in any particular
     * order. If this is required, then use a {@link Ext.util.MixedCollection}.
     */
    export class HashMap extends Ext.Base implements Ext.util.HashMapConfig {
        /**
         * A function that is used to retrieve a default key for a passed object.
         * A default is provided that returns the 'id' property on the object. This function is only used
         * if the 'add' method is called with a single argument.
         */
        keyFn: Function;

        /**
         * Adds an item to the collection. Fires the {@link #event-add} event when complete.
         *
         * @param {String/Object} key The key to associate with the item, or the new item.
         *
         * If a {@link #getKey} implementation was specified for this HashMap,
         * or if the key of the stored items is in a property called 'id',
         * the HashMap will be able to *derive* the key for the new item.
         * In this case just pass the new item in this parameter.
         *
         * @param {Object} [o] The item to add.
         *
         * @return {Object} The item added.
         */
        add(key: string|any, o?: any): any;

        /**
         * Removes all items from the hash.
         * @return {Ext.util.HashMap} this
         */
        clear(): Ext.util.HashMap;

        /**
         * Performs a shallow copy on this hash.
         * @return {Ext.util.HashMap} The new hash object.
         */
        clone(): Ext.util.HashMap;

        /**
         * Creates new HashMap.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.util.HashMapConfig);

        /**
         * Checks whether a value exists in the hash.
         * @param {Object} value The value to check for.
         * @return {Boolean} True if the value exists in the dictionary.
         */
        contains(value: any): boolean;

        /**
         * Checks whether a key exists in the hash.
         * @param {String} key The key to check for.
         * @return {Boolean} True if they key exists in the hash.
         */
        containsKey(key: string): boolean;

        /**
         * Executes the specified function once for each item in the hash.
         * Returning false from the function will cease iteration.
         *
         * @param {Function} fn The function to execute.
         * @param {String} fn.key The key of the item.
         * @param {Number} fn.value The value of the item.
         * @param {Number} fn.length The total number of items in the hash.
         * @param {Object} [scope] The scope to execute in. Defaults to <tt>this</tt>.
         * @return {Ext.util.HashMap} this
         */
        each(fn: Function, fn_key: string, fn_value: number, fn_length: number, scope?: any): Ext.util.HashMap;

        /**
         * Retrieves an item with a particular key.
         * @param {String} key The key to lookup.
         * @return {Object} The value at that key. If it doesn't exist, 'undefined' is returned.
         */
        get(key: string): any;

        /**
         * Gets the number of items in the hash.
         * @return {Number} The number of items in the hash.
         */
        getCount(): number;

        /**
         * Extracts the key from an object. This is a default implementation, it may be overridden
         * @param {Object} o The object to get the key from
         * @return {String} The key to use.
         */
        getKey(o: any): string;

        /**
         * Return all of the keys in the hash.
         * @return {Array} An array of keys.
         */
        getKeys(): any[];

        /**
         * Return all of the values in the hash.
         * @return {Array} An array of values.
         */
        getValues(): any[];

        /**
         * Remove an item from the hash.
         * @param {Object} o The value of the item to remove.
         * @return {Boolean} True if the item was successfully removed.
         */
        remove(o: any): boolean;

        /**
         * Remove an item from the hash.
         * @param {String} key The key to remove.
         * @return {Boolean} True if the item was successfully removed.
         */
        removeAtKey(key: string): boolean;

        /**
         * Replaces an item in the hash. If the key doesn't exist, the
         * {@link #method-add} method will be used.
         * @param {String} key The key of the item.
         * @param {Object} value The new value for the item.
         * @return {Object} The new value of the item.
         */
        replace(key: string, value: any): any;
    }

    /**
     * History management component that allows you to register arbitrary tokens that signify application
     * history state on navigation actions.  You can then handle the history {@link #change} event in order
     * to reset your application UI to the appropriate state when the user navigates forward or backward through
     * the browser history stack.
     *
     * ## Initializing
     *
     * The {@link #init} method of the History object must be called before using History. This sets up the internal
     * state and must be the first thing called before using History.
     */
    export class History {
        /**
         * The id of the hidden field required for storing the current history token.
         */
        static fieldId: any;

        /**
         * The id of the iframe required by IE to manage the history stack.
         */
        static iframeId: any;

        /**
         * True to use 'window.top.location.hash' or false to use 'window.location.hash'.
         */
        static useTopWindow: any;

        /**
         * Add a new token to the history stack. This can be any arbitrary value, although it would
         * commonly be the concatenation of a component id and another id marking the specific history
         * state of that component. Example usage:
         *
         *     // Handle tab changes on a TabPanel
         *     tabPanel.on('tabchange', function(tabPanel, tab){
         *          Ext.History.add(tabPanel.id + ':' + tab.id);
         *     });
         *
         * @param {String} token The value that defines a particular application-specific history state
         * @param {Boolean} [preventDuplicates=true] When true, if the passed token matches the current token
         * it will not save a new history step. Set to false if the same state can be saved more than once
         * at the same history stack location.
         */
        static add(token: string, preventDuplicates?: boolean);

        /**
         * Programmatically steps back one step in browser history (equivalent to the user pressing the Back button).
         */
        static back();

        /**
         * Programmatically steps forward one step in browser history (equivalent to the user pressing the Forward button).
         */
        static forward();

        /**
         * Retrieves the currently-active history token.
         * @return {String} The token
         */
        static getToken(): string;

        /**
         * Initializes the global History instance.
         * @param {Function} [onReady] A callback function that will be called once the history
         * component is fully initialized.
         * @param {Object} [scope] The scope ('this' reference) in which the callback is executed.
         * Defaults to the browser window.
         */
        static init(onReady?: Function, scope?: any);

        /**
         * Fires when navigation back or forwards within the local page's history occurs.
         * @param {String} token An identifier associated with the page state at that point in its history.
         */
        static change(token: string);

        /**
         * Fires when the Ext.util.History singleton has been initialized and is ready for use.
         * @param {Ext.util.History} The Ext.util.History singleton.
         */
        static ready(The: Ext.util.History);
    }

    /**
     * General purpose inflector class that {@link #pluralize pluralizes}, {@link #singularize singularizes} and
     * {@link #ordinalize ordinalizes} words. Sample usage:
     *
     *     //turning singular words into plurals
     *     Ext.util.Inflector.pluralize('word'); //'words'
     *     Ext.util.Inflector.pluralize('person'); //'people'
     *     Ext.util.Inflector.pluralize('sheep'); //'sheep'
     *
     *     //turning plurals into singulars
     *     Ext.util.Inflector.singularize('words'); //'word'
     *     Ext.util.Inflector.singularize('people'); //'person'
     *     Ext.util.Inflector.singularize('sheep'); //'sheep'
     *
     *     //ordinalizing numbers
     *     Ext.util.Inflector.ordinalize(11); //"11th"
     *     Ext.util.Inflector.ordinalize(21); //"21st"
     *     Ext.util.Inflector.ordinalize(1043); //"1043rd"
     *
     * # Customization
     *
     * The Inflector comes with a default set of US English pluralization rules. These can be augmented with additional
     * rules if the default rules do not meet your application's requirements, or swapped out entirely for other languages.
     * Here is how we might add a rule that pluralizes "ox" to "oxen":
     *
     *     Ext.util.Inflector.plural(/^(ox)$/i, "$1en");
     *
     * Each rule consists of two items - a regular expression that matches one or more rules, and a replacement string. In
     * this case, the regular expression will only match the string "ox", and will replace that match with "oxen". Here's
     * how we could add the inverse rule:
     *
     *     Ext.util.Inflector.singular(/^(ox)en$/i, "$1");
     *
     * Note that the ox/oxen rules are present by default.
     */
    export class Inflector {
        /**
         * Returns the correct {@link Ext.data.Model Model} name for a given string. Mostly used internally by the data
         * package
         * @param {String} word The word to classify
         * @return {String} The classified version of the word
         */
        static classify(word: string): string;

        /**
         * Removes all registered pluralization rules
         */
        static clearPlurals();

        /**
         * Removes all registered singularization rules
         */
        static clearSingulars();

        /**
         * Returns true if the given word is transnumeral (the word is its own singular and plural form - e.g. sheep, fish)
         * @param {String} word The word to test
         * @return {Boolean} True if the word is transnumeral
         */
        static isTransnumeral(word: string): boolean;

        /**
         * Ordinalizes a given number by adding a prefix such as 'st', 'nd', 'rd' or 'th' based on the last digit of the
         * number. 21 -> 21st, 22 -> 22nd, 23 -> 23rd, 24 -> 24th etc
         * @param {Number} number The number to ordinalize
         * @return {String} The ordinalized number
         */
        static ordinalize(number: number): string;

        /**
         * Adds a new pluralization rule to the Inflector. See the intro docs for more information
         * @param {RegExp} matcher The matcher regex
         * @param {String} replacer The replacement string, which can reference matches from the matcher argument
         */
        static plural(matcher: RegExp, replacer: string);

        /**
         * Returns the pluralized form of a word (e.g. Ext.util.Inflector.pluralize('word') returns 'words')
         * @param {String} word The word to pluralize
         * @return {String} The pluralized form of the word
         */
        static pluralize(word: string): string;

        /**
         * Adds a new singularization rule to the Inflector. See the intro docs for more information
         * @param {RegExp} matcher The matcher regex
         * @param {String} replacer The replacement string, which can reference matches from the matcher argument
         */
        static singular(matcher: RegExp, replacer: string);

        /**
         * Returns the singularized form of a word (e.g. Ext.util.Inflector.singularize('words') returns 'word')
         * @param {String} word The word to singularize
         * @return {String} The singularized form of the word
         */
        static singularize(word: string): string;
    }

    interface KeyMapConfig {
        /**
         * Either a single object describing a handling function for s specified key (or set of keys), or
         * an array of such objects.
         * A single keycode or an array of keycodes to handle
         * True to handle key only when shift is pressed, False to handle the
         *  key only when shift is not pressed (defaults to undefined)
         * True to handle key only when ctrl is pressed, False to handle the
         *  key only when ctrl is not pressed (defaults to undefined)
         * True to handle key only when alt is pressed, False to handle the key
         *  only when alt is not pressed (defaults to undefined)
         * The function to call when KeyMap finds the expected key combination
         * Alias of handler (for backwards-compatibility)
         * The scope of the callback function
         * A default action to apply to the event. Possible values
         *  are: stopEvent, stopPropagation, preventDefault. If no value is set no action is performed.
         */
        binding?: any;

        /**
         * The event to listen for to pick up key events.
         */
        eventName?: string;

        /**
         * Configure this as 'true' if there are any input fields within the {@link #target}, and this KeyNav
         * should not process events from input fields, ('&lt;input>, &lt;textarea> and elements with 'contentEditable="true"')
         *
         * Optional, Defaults to: false
         */
        ignoreInputFields?: boolean;

        /**
         * An optional event processor function which accepts the argument list provided by the
         * {@link #eventName configured event} of the {@link #target}, and returns a keyEvent for processing by the KeyMap.
         *
         * This may be useful when the {@link #target} is a Component with s complex event signature, where the event is not
         * the first parameter. Extra information from the event arguments may be injected into the event for use by the handler
         * functions before returning it.
         */
        processEvent?: Function;

        /**
         * The scope ('this' context) in which the {@link #processEvent} method is executed.
         *
         * Optional, Defaults to: this
         */
        processEventScope?: any;

        /**
         * The object on which to listen for the event specified by the {@link #eventName} config option.
         */
        target?: Ext.Component|Ext.dom.Element|HTMLElement|string;
    }

    /**
     * Handles mapping key events to handling functions for an element or a Component. One KeyMap can be used for multiple
     * actions.
     *
     * A KeyMap must be configured with a {@link #target} as an event source which may be an Element or a Component.
     *
     * If the target is an element, then the 'keydown' event will trigger the invocation of {@link #binding}s.
     *
     * It is possible to configure the KeyMap with a custom {@link #eventName} to listen for. This may be useful when the
     * {@link #target} is a Component.
     *
     * The KeyMap's event handling requires that the first parameter passed is a key event. So if the Component's event
     * signature is different, specify a {@link #processEvent} configuration which accepts the event's parameters and
     * returns a key event.
     *
     * Functions specified in {@link #binding}s are called with this signature : '(String key, Ext.EventObject e)' (if the
     * match is a multi-key combination the callback will still be called only once). A KeyMap can also handle a string
     * representation of keys. By default KeyMap starts enabled.
     *
     * Usage:
     *
     *     // map one key by key code
     *     var map = new Ext.util.KeyMap({
     *         target: "my-element",
     *         key: 13, // or Ext.EventObject.ENTER
     *         fn: myHandler,
     *         scope: myObject
     *     });
     *
     *     // map multiple keys to one action by string
     *     var map = new Ext.util.KeyMap({
     *         target: "my-element",
     *         key: "a\r\n\t",
     *         fn: myHandler,
     *         scope: myObject
     *     });
     *
     *     // map multiple keys to multiple actions by strings and array of codes
     *     var map = new Ext.util.KeyMap({
     *         target: "my-element",
     *         binding: [{
     *             key: [10,13],
     *             fn: function(){ alert("Return was pressed"); }
     *         }, {
     *             key: "abc",
     *             fn: function(){ alert('a, b or c was pressed'); }
     *         }, {
     *             key: "\t",
     *             ctrl:true,
     *             shift:true,
     *             fn: function(){ alert('Control + shift + tab was pressed.'); }
     *         }]
     *     });
     *
     * Since 4.1.0, KeyMaps can bind to Components and process key-based events fired by Components.
     *
     * To bind to a Component, use the single parameter form of constructor and include the Component event name
     * to listen for, and a 'processEvent' implementation which returns the key event for further processing by
     * the KeyMap:
     *
     *     var map = new Ext.util.KeyMap({
     *         target: myGridView,
     *         eventName: 'itemkeydown',
     *         processEvent: function(view, record, node, index, event) {
     *
     *             // Load the event with the extra information needed by the mappings
     *             event.view = view;
     *             event.store = view.getStore();
     *             event.record = record;
     *             event.index = index;
     *             return event;
     *         },
     *         binding: {
     *             key: Ext.EventObject.DELETE,
     *             fn: function(keyCode, e) {
     *                 e.store.remove(e.record);
     *
     *                 // Attempt to select the record that's now in its place
     *                 e.view.getSelectionModel().select(e.index);
     *                 e.view.el.focus();
     *             }
     *         }
     *     });
     */
    export class KeyMap extends Ext.Base implements Ext.util.KeyMapConfig {
        /**
         * Either a single object describing a handling function for s specified key (or set of keys), or
         * an array of such objects.
         * A single keycode or an array of keycodes to handle
         * True to handle key only when shift is pressed, False to handle the
         *  key only when shift is not pressed (defaults to undefined)
         * True to handle key only when ctrl is pressed, False to handle the
         *  key only when ctrl is not pressed (defaults to undefined)
         * True to handle key only when alt is pressed, False to handle the key
         *  only when alt is not pressed (defaults to undefined)
         * The function to call when KeyMap finds the expected key combination
         * Alias of handler (for backwards-compatibility)
         * The scope of the callback function
         * A default action to apply to the event. Possible values
         *  are: stopEvent, stopPropagation, preventDefault. If no value is set no action is performed.
         */
        binding: any;

        /**
         * The event to listen for to pick up key events.
         */
        eventName: string;

        /**
         * Configure this as 'true' if there are any input fields within the {@link #target}, and this KeyNav
         * should not process events from input fields, ('&lt;input>, &lt;textarea> and elements with 'contentEditable="true"')
         *
         * Optional, Defaults to: false
         */
        ignoreInputFields: boolean;

        /**
         * An optional event processor function which accepts the argument list provided by the
         * {@link #eventName configured event} of the {@link #target}, and returns a keyEvent for processing by the KeyMap.
         *
         * This may be useful when the {@link #target} is a Component with s complex event signature, where the event is not
         * the first parameter. Extra information from the event arguments may be injected into the event for use by the handler
         * functions before returning it.
         */
        processEvent: Function;

        /**
         * The scope ('this' context) in which the {@link #processEvent} method is executed.
         *
         * Optional, Defaults to: this
         */
        processEventScope: any;

        /**
         * The object on which to listen for the event specified by the {@link #eventName} config option.
         */
        target: Ext.Component|Ext.dom.Element|HTMLElement|string;

        /**
         * Add a new binding to this KeyMap.
         *
         * Usage:
         *
         *     // Create a KeyMap
         *     var map = new Ext.util.KeyMap(document, {
         *         key: Ext.EventObject.ENTER,
         *         fn: handleKey,
         *         scope: this
         *     });
         *
         *     //Add a new binding to the existing KeyMap later
         *     map.addBinding({
         *         key: 'abc',
         *         shift: true,
         *         fn: handleKey,
         *         scope: this
         *     });
         *
         * @param {Object/Object[]} binding A single KeyMap config or an array of configs.
         * The following config object properties are supported:
         * @param {String/Array} binding.key A single keycode or an array of keycodes to handle.
         * @param {Boolean} binding.shift True to handle key only when shift is pressed,
         * False to handle the keyonly when shift is not pressed (defaults to undefined).
         * @param {Boolean} binding.ctrl True to handle key only when ctrl is pressed,
         * False to handle the key only when ctrl is not pressed (defaults to undefined).
         * @param {Boolean} binding.alt True to handle key only when alt is pressed,
         * False to handle the key only when alt is not pressed (defaults to undefined).
         * @param {Function} binding.handler The function to call when KeyMap finds the
         * expected key combination.
         * @param {Function} binding.fn Alias of handler (for backwards-compatibility).
         * @param {Object} binding.scope The scope of the callback function.
         * @param {String} binding.defaultEventAction A default action to apply to the event.
         * Possible values are: stopEvent, stopPropagation, preventDefault. If no value is
         * set no action is performed..
         */
        addBinding(binding: any, binding_key: string|any[], binding_shift: boolean, binding_ctrl: boolean, binding_alt: boolean, binding_handler: Function, binding_fn: Function, binding_scope: any, binding_defaultEventAction: string);

        constructor(config: Ext.util.KeyMapConfig);

        /**
         * Destroys the KeyMap instance and removes all handlers.
         * @param {Boolean} removeTarget True to also remove the {@link #target}
         */
        destroy(removeTarget: boolean);

        /**
         * Disable this KeyMap
         */
        disable();

        /**
         * Enables this KeyMap
         */
        enable();

        /**
         * Returns true if this KeyMap is enabled
         * @return {Boolean}
         */
        isEnabled(): boolean;

        /**
         * Shorthand for adding a single key listener.
         *
         * @param {Number/Number[]/Object} key Either the numeric key code, array of key codes or an object with the
         * following options: '{key: (number or array), shift: (true/false), ctrl: (true/false), alt: (true/false)}'
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope ('this' reference) in which the function is executed.
         * Defaults to the browser window.
         */
        on(key: number|any, fn: Function, scope?: any);

        /**
         * Remove a binding from this KeyMap.
         * @param {Object} binding See {@link #addBinding for options}
         */
        removeBinding(binding: any);

        /**
         * Convenience function for setting disabled/enabled by boolean.
         */
        setDisabled(disabled: boolean);

        /**
         * Shorthand for removing a single key listener.
         *
         * @param {Number/Number[]/Object} key Either the numeric key code, array of key codes or an object with the
         * following options: '{key: (number or array), shift: (true/false), ctrl: (true/false), alt: (true/false)}'
         * @param {Function} fn The function to call
         * @param {Object} [scope] The scope ('this' reference) in which the function is executed.
         * Defaults to the browser window.
         */
        un(key: number|any, fn: Function, scope?: any);
    }

    interface KeyNavConfig {
        /**
         * The method to call on the {@link Ext.EventObject} after this KeyNav intercepts a key. Valid values are {@link
         * Ext.EventObject#stopEvent}, {@link Ext.EventObject#preventDefault} and {@link Ext.EventObject#stopPropagation}.
         *
         * If a falsy value is specified, no method is called on the key event.
         */
        defaultEventAction?: string;

        /**
         * True to disable this KeyNav instance.
         */
        disabled?: boolean;

        /**
         * The event to listen for to pick up key events.
         */
        eventName?: string;

        /**
         * Handle the keydown event instead of keypress. KeyNav automatically does this for IE since IE does not propagate
         * special keys on keypress, but setting this to true will force other browsers to also handle keydown instead of
         * keypress.
         */
        forceKeyDown?: boolean;

        /**
         * Configure this as 'true' if there are any input fields within the {@link #target}, and this KeyNav
         * should not process events from input fields, ('&lt;input>, &lt;textarea> and elements with 'contentEditable="true"')
         *
         * Optional, Defaults to: false
         */
        ignoreInputFields?: boolean;

        /**
         * An optional pre-existing {@link Ext.util.KeyMap KeyMap} to use to listen for key events. If not specified,
         * one is created.
         *
         * Optional
         */
        keyMap?: Ext.util.KeyMap;

        /**
         * An optional event processor function which accepts the argument list provided by the {@link #eventName configured
         * event} of the {@link #target}, and returns a keyEvent for processing by the KeyMap.
         *
         * This may be useful when the {@link #target} is a Component with s complex event signature. Extra information from
         * the event arguments may be injected into the event for use by the handler functions before returning it.
         */
        processEvent?: Function;

        /**
         * The scope ('this' context) in which the {@link #processEvent} method is executed.
         *
         * Optional, Defaults to: this
         */
        processEventScope?: any;

        /**
         * The object on which to listen for the event specified by the {@link #eventName} config option.
         */
        target?: Ext.Component|Ext.dom.Element|HTMLElement|string;
    }

    /**
     * Provides a convenient wrapper for normalized keyboard navigation. KeyNav allows you to bind navigation keys to
     * function calls that will get called when the keys are pressed, providing an easy way to implement custom navigation
     * schemes for any UI component.
     *
     * The following are all of the possible keys that can be implemented: enter, space, left, right, up, down, tab, esc,
     * pageUp, pageDown, del, backspace, home, end.
     *
     * Usage:
     *
     *     var nav = new Ext.util.KeyNav({
     *         target : "my-element",
     *         left   : function(e){
     *             this.moveLeft(e.ctrlKey);
     *         },
     *         right  : function(e){
     *             this.moveRight(e.ctrlKey);
     *         },
     *         enter  : function(e){
     *             this.save();
     *         },
     *
     *         // Binding may be a function specifiying fn, scope and defaultAction
     *         esc: {
     *             fn: this.onEsc,
     *             defaultEventAction: false
     *         },
     *         scope : this
     *     });
     */
    export class KeyNav extends Ext.Base implements Ext.util.KeyNavConfig {
        /**
         * The method to call on the {@link Ext.EventObject} after this KeyNav intercepts a key. Valid values are {@link
         * Ext.EventObject#stopEvent}, {@link Ext.EventObject#preventDefault} and {@link Ext.EventObject#stopPropagation}.
         *
         * If a falsy value is specified, no method is called on the key event.
         */
        defaultEventAction: string;

        /**
         * True to disable this KeyNav instance.
         */
        disabled: boolean;

        /**
         * The event to listen for to pick up key events.
         */
        eventName: string;

        /**
         * Handle the keydown event instead of keypress. KeyNav automatically does this for IE since IE does not propagate
         * special keys on keypress, but setting this to true will force other browsers to also handle keydown instead of
         * keypress.
         */
        forceKeyDown: boolean;

        /**
         * Configure this as 'true' if there are any input fields within the {@link #target}, and this KeyNav
         * should not process events from input fields, ('&lt;input>, &lt;textarea> and elements with 'contentEditable="true"')
         *
         * Optional, Defaults to: false
         */
        ignoreInputFields: boolean;

        /**
         * An optional pre-existing {@link Ext.util.KeyMap KeyMap} to use to listen for key events. If not specified,
         * one is created.
         *
         * Optional
         */
        keyMap: Ext.util.KeyMap;

        /**
         * An optional event processor function which accepts the argument list provided by the {@link #eventName configured
         * event} of the {@link #target}, and returns a keyEvent for processing by the KeyMap.
         *
         * This may be useful when the {@link #target} is a Component with s complex event signature. Extra information from
         * the event arguments may be injected into the event for use by the handler functions before returning it.
         */
        processEvent: Function;

        /**
         * The scope ('this' context) in which the {@link #processEvent} method is executed.
         *
         * Optional, Defaults to: this
         */
        processEventScope: any;

        /**
         * The object on which to listen for the event specified by the {@link #eventName} config option.
         */
        target: Ext.Component|Ext.dom.Element|HTMLElement|string;

        constructor(config: Ext.util.KeyNavConfig);

        /**
         * Destroy this KeyNav.
         * @param {Boolean} removeEl Pass 'true' to remove the element associated with this KeyNav.
         */
        destroy(removeEl: boolean);

        /**
         * Disables this KeyNav.
         */
        disable();

        /**
         * Enables this KeyNav.
         */
        enable();

        /**
         * Convenience function for setting disabled/enabled by boolean.
         */
        setDisabled(disabled: boolean);
    }

    interface LruCacheConfig extends Ext.util.HashMapConfig {
        /**
         * The maximum size the cache is allowed to grow to before further additions cause
         * removal of the least recently used entry.
         */
        maxSize?: number;
    }

    /**
     * @extend Ext.util.HashMap
     * A linked {@link Ext.util.HashMap HashMap} implementation which maintains most recently accessed
     * items at the end of the list, and purges the cache down to the most recently accessed {@link #maxSize} items
     * upon add.
     */
    export class LruCache extends Ext.util.HashMap implements Ext.util.LruCacheConfig {
        /**
         * The maximum size the cache is allowed to grow to before further additions cause
         * removal of the least recently used entry.
         */
        maxSize: number;

        /**
         * Performs a shallow copy on this haLruCachesh.
         * @return {Ext.util.HashMap} The new hash object.
         */
        clone(): Ext.util.HashMap;

        /**
         * Creates new HashMap.
         * @param {Object} config (optional) Config object.
         */
        constructor(config: Ext.util.HashMapConfig);

        /**
         * Purge the least recently used entries if the maxSize has been exceeded.
         */
        prune();
    }

    /**
     * This class manages a set of captured properties from an object. These captured properties
     * can later be restored to an object.
     */
    export class Memento extends Ext.Base {
        /**
         * The default target object for capture/restore (passed to the constructor).
         */
        target: any;

        /**
         * Captures the specified properties from the target object in this memento.
         * @param {String/String[]} props The property or array of properties to capture.
         * @param {Object} target The object from which to capture properties.
         */
        capture(props: string, target: any);

        /**
         * Creates a new memento and optionally captures properties from the target object.
         * @param {Object} target The target from which to capture properties. If specified in the
         * constructor, this target becomes the default target for all other operations.
         * @param {String/String[]} props The property or array of properties to capture.
         */
        constructor(target: any, props: string);

        /**
         * Removes the specified properties from this memento. These properties will not be
         * restored later without re-capturing their values.
         * @param {String/String[]} props The property or array of properties to remove.
         */
        remove(props: string);

        /**
         * Restores the specified properties from this memento to the target object.
         * @param {String/String[]} props The property or array of properties to restore.
         * @param {Boolean} clear True to remove the restored properties from this memento or
         * false to keep them (default is true).
         * @param {Object} target The object to which to restore properties.
         */
        restore(props: string, clear: boolean, target: any);

        /**
         * Restores all captured properties in this memento to the target object.
         * @param {Boolean} clear True to remove the restored properties from this memento or
         * false to keep them (default is true).
         * @param {Object} target The object to which to restore properties.
         */
        restoreAll(clear: boolean, target: any);
    }

    interface MixedCollectionConfig extends Ext.util.AbstractMixedCollectionConfig {
        /**
         * Configure as 'true' if the {@link #addAll} function should add function references to the collection.
         */
        allowFunctions?: boolean;
    }

    /**
     * Represents a collection of a set of key and value pairs. Each key in the MixedCollection
     * must be unique, the same key cannot exist twice. This collection is ordered, items in the
     * collection can be accessed by index  or via the key. Newly added items are added to
     * the end of the collection. This class is similar to {@link Ext.util.HashMap} however it
     * is heavier and provides more functionality. Sample usage:
     *
     *     var coll = new Ext.util.MixedCollection();
     *     coll.add('key1', 'val1');
     *     coll.add('key2', 'val2');
     *     coll.add('key3', 'val3');
     *
     *     console.log(coll.get('key1')); // prints 'val1'
     *     console.log(coll.indexOfKey('key3')); // prints 2
     *
     * The MixedCollection also has support for sorting and filtering of the values in the collection.
     *
     *     var coll = new Ext.util.MixedCollection();
     *     coll.add('key1', 100);
     *     coll.add('key2', -100);
     *     coll.add('key3', 17);
     *     coll.add('key4', 0);
     *     var biggerThanZero = coll.filterBy(function(value){
     *         return value > 0;
     *     });
     *     console.log(biggerThanZero.getCount()); // prints 2
     */
    export class MixedCollection extends Ext.util.AbstractMixedCollection implements Ext.util.MixedCollectionConfig {
        /**
         * Configure as 'true' if the {@link #addAll} function should add function references to the collection.
         */
        allowFunctions: boolean;

        /**
         * Creates new MixedCollection.
         * @param {Object} config A configuration object.
         *  @param {Boolean} [config.allowFunctions=false] Specify 'true' if the {@link #addAll}
         * function should add function references to the collection.
         *  @param {Function} [config.getKey] A function that can accept an item of the type(s) stored in this MixedCollection
         * and return the key value for that item.  This is used when available to look up the key on items that
         * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
         * equivalent to overriding the {@link #method-getKey} method.
         */
        constructor(config: Ext.util.MixedCollectionConfig);

        /**
         * Calculates the insertion index of the new item based upon the comparison function passed, or the current sort order.
         * @param {Object} newItem The new object to find the insertion position of.
         * @param {Function} [sorterFn] The function to sort by. This is the same as the sorting function
         * passed to {@link #sortBy}. It accepts 2 items from this MixedCollection, and returns -1 0, or 1
         * depending on the relative sort positions of the 2 compared items.
         *
         * If omitted, a function {@link #generateComparator generated} from the currently defined set of
         * {@link #cfg-sorters} will be used.
         *
         * @return {Number} The insertion point to add the new item into this MixedCollection at using {@link #insert}
         */
        findInsertionIndex(newItem: any, sorterFn?: Function): number;

        /**
         * Reorders each of the items based on a mapping from old index to new index. Internally this
         * just translates into a sort. The 'sort' event is fired whenever reordering has occured.
         * @param {Object} mapping Mapping from old item index to new item index
         */
        reorder(mapping: any);

        /**
         * Sorts the collection by a single sorter function
         * @param {Function} sorterFn The function to sort by
         */
        sortBy(sorterFn: Function);

        /**
         * Sorts this collection by <b>key</b>s.
         * @param {String} direction (optional) 'ASC' or 'DESC'. Defaults to 'ASC'.
         * @param {Function} fn (optional) Comparison function that defines the sort order.
         * Defaults to sorting by case insensitive string.
         */
        sortByKey(direction: string, fn: Function);
    }

    interface ObservableConfig {
        /**
         * A config object containing one or more event handlers to be added to this object during initialization. This
         * should be a valid listeners config object as specified in the {@link #addListener} example for attaching multiple
         * handlers at once.
         *
         * **DOM events from Ext JS {@link Ext.Component Components}**
         *
         * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
         * only done when extra value can be added. For example the {@link Ext.view.View DataView}'s **'{@link
         * Ext.view.View#itemclick itemclick}'** event passing the node clicked on. To access DOM events directly from a
         * child element of a Component, we need to specify the 'element' option to identify the Component property to add a
         * DOM listener to:
         *
         *     new Ext.panel.Panel({
         *         width: 400,
         *         height: 200,
         *         dockedItems: [{
         *             xtype: 'toolbar'
         *         }],
         *         listeners: {
         *             click: {
         *                 element: 'el', //bind to the underlying el property on the panel
         *                 fn: function(){ console.log('click el'); }
         *             },
         *             dblclick: {
         *                 element: 'body', //bind to the underlying body property on the panel
         *                 fn: function(){ console.log('dblclick body'); }
         *             }
         *         }
         *     });
         */
        listeners?: any;
    }

    /**
     * Base class that provides a common interface for publishing events. Subclasses are expected to to have a property
     * "events" with all the events defined, and, optionally, a property "listeners" with configured listeners defined.
     *
     * For example:
     *
     *     Ext.define('Employee', {
     *         mixins: {
     *             observable: 'Ext.util.Observable'
     *         },
     *
     *         constructor: function (config) {
     *             // The Observable constructor copies all of the properties of 'config' on
     *             // to 'this' using {@link Ext#apply}. Further, the 'listeners' property is
     *             // processed to add listeners.
     *             //
     *             this.mixins.observable.constructor.call(this, config);
     *
     *             this.addEvents(
     *                 'fired',
     *                 'quit'
     *             );
     *         }
     *     });
     *
     * This could then be used like this:
     *
     *     var newEmployee = new Employee({
     *         name: employeeName,
     *         listeners: {
     *             quit: function() {
     *                 // By default, "this" will be the object that fired the event.
     *                 alert(this.name + " has quit!");
     *             }
     *         }
     *     });
     */
    export class Observable extends Ext.Base implements Ext.util.ObservableConfig {
        /**
         * @readonly
         * This object holds a key for any event that has a listener. The listener may be set
         * directly on the instance, or on its class or a super class (via {@link #observe}) or
         * on the {@link Ext.app.EventBus MVC EventBus}. The values of this object are truthy
         * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
         * of listeners. The value for an event is truthy if the event must be fired and is
         * falsy if there is no need to fire the event.
         *
         * The intended use of this property is to avoid the expense of fireEvent calls when
         * there are no listeners. This can be particularly helpful when one would otherwise
         * have to call fireEvent hundreds or thousands of times. It is used like this:
         *
         *      if (this.hasListeners.foo) {
         *          this.fireEvent('foo', this, arg1);
         *      }
         */
        hasListeners: any;

        /**
         * 'true' in this class to identify an object as an instantiated Observable, or subclass thereof.
         */
        isObservable: boolean;

        /**
         * A config object containing one or more event handlers to be added to this object during initialization. This
         * should be a valid listeners config object as specified in the {@link #addListener} example for attaching multiple
         * handlers at once.
         *
         * **DOM events from Ext JS {@link Ext.Component Components}**
         *
         * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
         * only done when extra value can be added. For example the {@link Ext.view.View DataView}'s **'{@link
         * Ext.view.View#itemclick itemclick}'** event passing the node clicked on. To access DOM events directly from a
         * child element of a Component, we need to specify the 'element' option to identify the Component property to add a
         * DOM listener to:
         *
         *     new Ext.panel.Panel({
         *         width: 400,
         *         height: 200,
         *         dockedItems: [{
         *             xtype: 'toolbar'
         *         }],
         *         listeners: {
         *             click: {
         *                 element: 'el', //bind to the underlying el property on the panel
         *                 fn: function(){ console.log('click el'); }
         *             },
         *             dblclick: {
         *                 element: 'body', //bind to the underlying body property on the panel
         *                 fn: function(){ console.log('dblclick body'); }
         *             }
         *         }
         *     });
         */
        listeners: any;

        /**
         * Adds the specified events to the list of events which this Observable may fire.
         *
         * @param {Object/String...} eventNames Either an object with event names as properties with
         * a value of 'true'. For example:
         *
         *     this.addEvents({
         *         storeloaded: true,
         *         storecleared: true
         *     });
         *
         * Or any number of event names as separate parameters. For example:
         *
         *     this.addEvents('storeloaded', 'storecleared');
         */
        addEvents(eventNames: any[]|string[]);

        /**
         * Appends an event handler to this object.  For example:
         *
         *     myGridPanel.on("mouseover", this.onMouseOver, this);
         *
         * The method also allows for a single argument to be passed which is a config object
         * containing properties which specify multiple events. For example:
         *
         *     myGridPanel.on({
         *         cellClick: this.onCellClick,
         *         mouseover: this.onMouseOver,
         *         mouseout: this.onMouseOut,
         *         scope: this // Important. Ensure "this" is correct during handler execution
         *     });
         *
         * One can also specify options for each event handler separately:
         *
         *     myGridPanel.on({
         *         cellClick: {fn: this.onCellClick, scope: this, single: true},
         *         mouseover: {fn: panel.onMouseOver, scope: panel}
         *     });
         *
         * *Names* of methods in a specified scope may also be used. Note that
         * 'scope' MUST be specified to use this option:
         *
         *     myGridPanel.on({
         *         cellClick: {fn: 'onCellClick', scope: this, single: true},
         *         mouseover: {fn: 'onMouseOver', scope: panel}
         *     });
         *
         * @param {String/Object} eventName The name of the event to listen for.
         * May also be an object who's property names are event names.
         *
         * @param {Function} [fn] The method the event invokes, or *if 'scope' is specified, the *name* of the method within
         * the specified 'scope'.  Will be called with arguments
         * given to {@link Ext.util.Observable#fireEvent} plus the 'options' parameter described below.
         *
         * @param {Object} [scope] The scope ('this' reference) in which the handler function is
         * executed. **If omitted, defaults to the object which fired the event.**
         *
         * @param {Object} [options] An object containing handler configuration.
         *
         * **Note:** Unlike in ExtJS 3.x, the options object will also be passed as the last
         * argument to every event handler.
         *
         * This object may contain any of the following properties:
         *
         *   The scope ('this' reference) in which the handler function is executed. **If omitted,
         *   defaults to the object which fired the event.**
         *
         *   The number of milliseconds to delay the invocation of the handler after the event fires.
         *
         *   True to add a handler to handle just the next firing of the event, and then remove itself.
         *
         *   Causes the handler to be scheduled to run in an {@link Ext.util.DelayedTask} delayed
         *   by the specified number of milliseconds. If the event fires again within that time,
         *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
         *
         *   Only call the handler if the event was fired on the target Observable, _not_ if the event
         *   was bubbled up from a child Observable.
         *
         *   **This option is only valid for listeners bound to {@link Ext.Component Components}.**
         *   The name of a Component property which references an element to add a listener to.
         *
         *   This option is useful during Component construction to add DOM event listeners to elements of
         *   {@link Ext.Component Components} which will exist only after the Component is rendered.
         *   For example, to add a click listener to a Panel's body:
         *
         *       new Ext.panel.Panel({
         *           title: 'The title',
         *           listeners: {
         *               click: this.handlePanelClick,
         *               element: 'body'
         *           }
         *       });
         *
         * @param {Boolean} [options.destroyable=false]
         *   When specified as 'true', the function returns A 'Destroyable' object. An object which implements the 'destroy' method which removes all listeners added in this call.
         *
         * @param {Number} [options.priority]
         *   An optional numeric priority that determines the order in which event handlers
         *   are run. Event handlers with no priority will be run as if they had a priority
         *   of 0. Handlers with a higher priority will be prioritized to run sooner than
         *   those with a lower priority.  Negative numbers can be used to set a priority
         *   lower than the default. Internally, the framework uses a range of 1000 or
         *   greater, and -1000 or lesser for handers that are intended to run before or
         *   after all others, so it is recommended to stay within the range of -999 to 999
         *   when setting the priority of event handlers in application-level code.
         *
         * **Combining Options**
         *
         * Using the options argument, it is possible to combine different types of listeners:
         *
         * A delayed, one-time listener.
         *
         *     myPanel.on('hide', this.handleClick, this, {
         *         single: true,
         *         delay: 100
         *     });
         *
         * @return {Object} **Only when the 'destroyable' option is specified. **
         *
         *  A 'Destroyable' object. An object which implements the 'destroy' method which removes all listeners added in this call. For example:
         *
         *     this.btnListeners =  = myButton.on({
         *         destroyable: true
         *         mouseover:   function() { console.log('mouseover'); },
         *         mouseout:    function() { console.log('mouseout'); },
         *         click:       function() { console.log('click'); }
         *     });
         *
         * And when those listeners need to be removed:
         *
         *     Ext.destroy(this.btnListeners);
         *
         * or
         *
         *     this.btnListeners.destroy();
         */
        addListener(eventName: string|any, fn?: Function, scope?: any, options?: any, options_scope?: any, options_delay?: number, options_single?: boolean, options_buffer?: number, options_target?: Ext.util.Observable, options_element?: string, options_destroyable?: boolean, options_priority?: number): any;

        /**
         * Adds listeners to any Observable object (or Ext.Element) which are automatically removed when this Component is
         * destroyed.
         *
         * @param {Ext.util.Observable/Ext.Element} item The item to which to add a listener/listeners.
         * @param {Object/String} ename The event name, or an object containing event name properties.
         * @param {Function} fn (optional) If the 'ename' parameter was an event name, this is the handler function.
         * @param {Object} scope (optional) If the 'ename' parameter was an event name, this is the scope ('this' reference)
         * in which the handler function is executed.
         * @param {Object} options (optional) If the 'ename' parameter was an event name, this is the
         * {@link Ext.util.Observable#addListener addListener} options.
         * @return {Object} **Only when the 'destroyable' option is specified. **
         *
         *  A 'Destroyable' object. An object which implements the 'destroy' method which removes all listeners added in this call. For example:
         *
         *     this.btnListeners =  = myButton.mon({
         *         destroyable: true
         *         mouseover:   function() { console.log('mouseover'); },
         *         mouseout:    function() { console.log('mouseout'); },
         *         click:       function() { console.log('click'); }
         *     });
         *
         * And when those listeners need to be removed:
         *
         *     Ext.destroy(this.btnListeners);
         *
         * or
         *
         *     this.btnListeners.destroy();
         */
        addManagedListener(item: Ext.util.Observable|Ext.dom.Element, ename: any|string, fn: Function, scope: any, options: any): any;

        /**
         * Removes all listeners for this object including the managed listeners
         */
        clearListeners();

        /**
         * Removes all managed listeners for this object.
         */
        clearManagedListeners();

        /**
         * Enables events fired by this Observable to bubble up an owner hierarchy by calling 'this.getBubbleTarget()' if
         * present. There is no implementation in the Observable base class.
         *
         * This is commonly used by Ext.Components to bubble events to owner Containers.
         * See {@link Ext.Component#getBubbleTarget}. The default implementation in Ext.Component returns the
         * Component's immediate owner. But if a known target is required, this can be overridden to access the
         * required target more quickly.
         *
         * Example:
         *
         *     Ext.define('Ext.overrides.form.field.Base', {
         *         override: 'Ext.form.field.Base',
         *
         *         //  Add functionality to Field's initComponent to enable the change event to bubble
         *         initComponent: function () {
         *             this.callParent();
         *             this.enableBubble('change');
         *         }
         *     });
         *
         *     var myForm = Ext.create('Ext.form.Panel', {
         *         title: 'User Details',
         *         items: [{
         *             ...
         *         }],
         *         listeners: {
         *             change: function() {
         *                 // Title goes red if form has been modified.
         *                 myForm.header.setStyle('color', 'red');
         *             }
         *         }
         *     });
         *
         * @param {String/String[]} eventNames The event name to bubble, or an Array of event names.
         */
        enableBubble(eventNames: string);

        /**
         * Fires the specified event with the passed parameters (minus the event name, plus the 'options' object passed
         * to {@link #addListener}).
         *
         * An event may be set to bubble up an Observable parent hierarchy (See {@link Ext.Component#getBubbleTarget}) by
         * calling {@link #enableBubble}.
         *
         * @param {String} eventName The name of the event to fire.
         * @param {Object...} args Variable number of parameters are passed to handlers.
         * @return {Boolean} returns false if any of the handlers return false otherwise it returns true.
         */
        fireEvent(eventName: string, args: any): boolean;

        /**
         * Fires the specified event with the passed parameter list.
         *
         * An event may be set to bubble up an Observable parent hierarchy (See {@link Ext.Component#getBubbleTarget}) by
         * calling {@link #enableBubble}.
         *
         * @param {String} eventName The name of the event to fire.
         * @param {Object[]} args An array of parameters which are passed to handlers.
         * @return {Boolean} returns false if any of the handlers return false otherwise it returns true.
         */
        fireEventArgs(eventName: string, args: any): boolean;

        /**
         * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
         * indicates whether the event needs firing or not.
         *
         * @param {String} eventName The name of the event to check for
         * @return {Boolean} 'true' if the event is being listened for or bubbles, else 'false'
         */
        hasListener(eventName: string): boolean;

        /**
         * Shorthand for {@link #addManagedListener}.
         */
        mon();

        /**
         * Shorthand for {@link #removeManagedListener}.
         */
        mun();

        /**
         * Shorthand for {@link #addListener}.
         */
        on();

        /**
         * Relays selected events from the specified Observable as if the events were fired by 'this'.
         *
         * For example if you are extending Grid, you might decide to forward some events from store.
         * So you can do this inside your initComponent:
         *
         *     this.relayEvents(this.getStore(), ['load']);
         *
         * The grid instance will then have an observable 'load' event which will be passed the
         * parameters of the store's load event and any function fired with the grid's load event
         * would have access to the grid using the 'this' keyword.
         *
         * @param {Object} origin The Observable whose events this object is to relay.
         * @param {String[]} events Array of event names to relay.
         * @param {String} [prefix] A common prefix to prepend to the event names. For example:
         *
         *     this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
         *
         * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
         *
         * @return {Object} A 'Destroyable' object. An object which implements the 'destroy' method which, when destroyed, removes all relayers. For example:
         *
         *     this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
         *
         * Can be undone by calling
         *
         *     Ext.destroy(this.storeRelayers);
         *
         * or
         *     this.store.relayers.destroy();
         */
        relayEvents(origin: any, events: string, prefix?: string): any;

        /**
         * Removes an event handler.
         *
         * @param {String} eventName The type of event the handler was associated with.
         * @param {Function} fn The handler to remove. **This must be a reference to the function passed into the
         * {@link Ext.util.Observable#addListener} call.**
         * @param {Object} scope (optional) The scope originally specified for the handler. It must be the same as the
         * scope argument specified in the original call to {@link Ext.util.Observable#addListener} or the listener will not be removed.
         */
        removeListener(eventName: string, fn: Function, scope: any);

        /**
         * Removes listeners that were added by the {@link #mon} method.
         *
         * @param {Ext.util.Observable/Ext.Element} item The item from which to remove a listener/listeners.
         * @param {Object/String} ename The event name, or an object containing event name properties.
         * @param {Function} fn (optional) If the 'ename' parameter was an event name, this is the handler function.
         * @param {Object} scope (optional) If the 'ename' parameter was an event name, this is the scope ('this' reference)
         * in which the handler function is executed.
         */
        removeManagedListener(item: Ext.util.Observable|Ext.dom.Element, ename: any|string, fn: Function, scope: any);

        /**
         * Resumes firing of the named event(s).
         *
         * After calling this method to resume events, the events will fire when requested to fire.
         *
         * **Note that if the {@link #suspendEvent} method is called multiple times for a certain event,
         * this converse method will have to be called the same number of times for it to resume firing.**
         */
        resumeEvent();

        /**
         * Resumes firing events (see {@link #suspendEvents}).
         *
         * If events were suspended using the 'queueSuspended' parameter, then all events fired
         * during event suspension will be sent to any listeners now.
         */
        resumeEvents();

        /**
         * Suspends firing of the named event(s).
         *
         * After calling this method to suspend events, the events will no longer fire when requested to fire.
         *
         * **Note that if this is called multiple times for a certain event, the converse method
         * {@link #resumeEvent} will have to be called the same number of times for it to resume firing.**
         */
        suspendEvent();

        /**
         * Suspends the firing of all events. (see {@link #resumeEvents})
         *
         * @param {Boolean} queueSuspended Pass as true to queue up suspended events to be fired
         * after the {@link #resumeEvents} call instead of discarding all suspended events.
         */
        suspendEvents(queueSuspended: boolean);

        /**
         * Shorthand for {@link #removeListener}.
         */
        un();

        /**
         * Starts capture on the specified Observable. All events will be passed to the supplied function with the event
         * name + standard signature of the event **before** the event is fired. If the supplied function returns false,
         * the event will not fire.
         *
         * @param {Ext.util.Observable} o The Observable to capture events from.
         * @param {Function} fn The function to call when an event is fired.
         * @param {Object} scope (optional) The scope ('this' reference) in which the function is executed. Defaults to
         * the Observable firing the event.
         */
        static capture(o: Ext.util.Observable, fn: Function, scope: any);

        /**
         * Sets observability on the passed class constructor.
         *
         * This makes any event fired on any instance of the passed class also fire a single event through
         * the **class** allowing for central handling of events on many instances at once.
         *
         * Usage:
         *
         *     Ext.util.Observable.observe(Ext.data.Connection);
         *     Ext.data.Connection.on('beforerequest', function(con, options) {
         *         console.log('Ajax request made to ' + options.url);
         *     });
         *
         * @param {Function} c The class constructor to make observable.
         * @param {Object} listeners An object containing a series of listeners to add. See {@link #addListener}.
         */
        static observe(c: Function, listeners: any);

        /**
         * Removes **all** added captures from the Observable.
         *
         * @param {Ext.util.Observable} o The Observable to release
         */
        static releaseCapture(o: Ext.util.Observable);
    }

    export class Offset extends Ext.Base {
        constructor();
    }

    /**
     * Represents a 2D point with x and y properties, useful for comparison and instantiation
     * from an event:
     *
     *     var point = Ext.util.Point.fromEvent(e);
     */
    export class Point extends Ext.util.Region {
        /**
         * Creates a point from two coordinates.
         * @param {Number} x X coordinate.
         * @param {Number} y Y coordinate.
         */
        constructor(x: number, y: number);

        /**
         * Determins whether this Point contained by the passed Region, Component or element.
         * The rectangle to check that this Point is within.
         * @return {Boolean}
         */
        isContainedBy(region: Ext.util.Region|Ext.Component|Ext.dom.Element|HTMLElement): boolean;

        /**
         * Whether the given point is not away from this point within the given threshold amount.
         * @param {Ext.util.Point/Object} p The point to check with, either an instance
         * of Ext.util.Point or an object with left and top properties
         * @param {Object/Number} threshold Can be either an object with x and y properties or a number
         * @return {Boolean}
         */
        isWithin(p: Ext.util.Point|any, threshold: any|number): boolean;

        /**
         * Compare this point with another point when the x and y values of both points are rounded. E.g:
         * [100.3,199.8] will equals to [100, 200]
         * @param {Ext.util.Point/Object} p The point to compare with, either an instance
         * of Ext.util.Point or an object with x and y properties
         * @return {Boolean}
         */
        roundedEquals(p: Ext.util.Point|any): boolean;

        /**
         * Returns a human-eye-friendly string that represents this point,
         * useful for debugging
         * @return {String}
         */
        toString(): string;

        /**
         * Alias for {@link #translateBy}
         */
        translate();

        /**
         * Returns a new instance of Ext.util.Point base on the pageX / pageY values of the given event
         * @param {Ext.EventObject/Event} e The event
         * @return {Ext.util.Point}
         */
        static fromEvent(e: Ext.EventObject|Event): Ext.util.Point;
    }

    /**
     * This mixin provides a common interface for objects that can be positioned, e.g.
     * {@link Ext.Component Components} and {@link Ext.dom.Element Elements}
     */
    export class Positionable extends Ext.Base {
        /**
         * Aligns the element with another element relative to the specified anchor points. If
         * the other element is the document it aligns it to the viewport. The position
         * parameter is optional, and can be specified in any one of the following formats:
         *
         * - **Blank**: Defaults to aligning the element's top-left corner to the target's
         *   bottom-left corner ("tl-bl").
         * - **One anchor (deprecated)**: The passed anchor position is used as the target
         *   element's anchor point.  The element being aligned will position its top-left
         *   corner (tl) to that point. *This method has been deprecated in favor of the newer
         *   two anchor syntax below*.
         * - **Two anchors**: If two values from the table below are passed separated by a dash,
         *   the first value is used as the element's anchor point, and the second value is
         *   used as the target's anchor point.
         *
         * In addition to the anchor points, the position parameter also supports the "?"
         * character. If "?" is passed at the end of the position string, the element will
         * attempt to align as specified, but the position will be adjusted to constrain to
         * the viewport if necessary. Note that the element being aligned might be swapped to
         * align to a different position than that specified in order to enforce the viewport
         * constraints. Following are all of the supported anchor positions:
         *
         * <pre>
         * Value  Description
         * -----  -----------------------------
         * tl     The top left corner (default)
         * t      The center of the top edge
         * tr     The top right corner
         * l      The center of the left edge
         * c      In the center of the element
         * r      The center of the right edge
         * bl     The bottom left corner
         * b      The center of the bottom edge
         * br     The bottom right corner
         * </pre>
         *
         * Example Usage:
         *
         *     // align el to other-el using the default positioning
         *     // ("tl-bl", non-constrained)
         *     el.alignTo("other-el");
         *
         *     // align the top left corner of el with the top right corner of other-el
         *     // (constrained to viewport)
         *     el.alignTo("other-el", "tr?");
         *
         *     // align the bottom right corner of el with the center left edge of other-el
         *     el.alignTo("other-el", "br-l?");
         *
         *     // align the center of el with the bottom left corner of other-el and
         *     // adjust the x position by -6 pixels (and the y position by 0)
         *     el.alignTo("other-el", "c-bl", [-6, 0]);
         *
         * @param {Ext.util.Positionable/HTMLElement/String} element The Positionable,
         * HTMLElement, or id of the element to align to.
         * @param {String} [position="tl-bl?"] The position to align to
         * @param {Number[]} [offsets] Offset the positioning by [x, y]
         * @param {Boolean/Object} [animate] true for the default animation or a standard
         * Element animation config object
         * @return {Ext.util.Positionable} this
         */
        alignTo(element: Ext.util.Positionable|HTMLElement|string, position?: string, offsets?: number, animate?: boolean|any): Ext.util.Positionable;

        /**
         * Anchors an element to another element and realigns it when the window is resized.
         * @param {Ext.util.Positionable/HTMLElement/String} element The Positionable,
         * HTMLElement, or id of the element to align to.
         * @param {String} [position="tl-bl?"] The position to align to
         * @param {Number[]} [offsets] Offset the positioning by [x, y]
         * @param {Boolean/Object} [animate] true for the default animation or a standard
         * Element animation config object
         * @param {Boolean/Number} [monitorScroll=50] True to monitor body scroll and
         * reposition. If this parameter is a number, it is used as the buffer delay in
         * milliseconds.
         * @param {Function} [callback] The function to call after the animation finishes
         * @return {Ext.util.Positionable} this
         */
        anchorTo(element: Ext.util.Positionable|HTMLElement|string, position?: string, offsets?: number, animate?: boolean|any, monitorScroll?: boolean|number, callback?: Function): Ext.util.Positionable;

        /**
         * Calculates the new [x,y] position to move this Positionable into a constrain region.
         *
         * By default, this Positionable is constrained to be within the container it was added to, or the element it was
         * rendered to.
         *
         * Priority is given to constraining the top and left within the constraint.
         *
         * An alternative constraint may be passed.
         * @param {String/HTMLElement/Ext.Element/Ext.util.Region} [constrainTo] The Element or {@link Ext.util.Region Region}
         * into which this Component is to be constrained. Defaults to the element into which this Positionable
         * was rendered, or this Component's {@link Ext.Component#constrainTo.
         * @param {Number[]} [proposedPosition] A proposed '[X, Y]' position to test for validity
         * and to coerce into constraints instead of using this Positionable's current position.
         * @param {Boolean} [local] The proposedPosition is local *(relative to floatParent if a floating Component)*
         * @param {Number[]} [proposedSize] A proposed '[width, height]' size to use when calculating
         * constraints instead of using this Positionable's current size.
         * @return {Number[]} **If** the element *needs* to be translated, the new '[X, Y]' position within
         * constraints if possible, giving priority to keeping the top and left edge in the constrain region.
         * Otherwise, 'false'.
         */
        calculateConstrainedPosition(constrainTo?: string|HTMLElement|Ext.dom.Element|Ext.util.Region, proposedPosition?: number, local?: boolean, proposedSize?: number): number;

        /**
         * Gets the x,y coordinates to align this element with another element. See
         * {@link #alignTo} for more info on the supported position values.
         * @param {Ext.util.Positionable/HTMLElement/String} element The Positionable,
         * HTMLElement, or id of the element to align to.
         * @param {String} [position="tl-bl?"] The position to align to
         * @param {Number[]} [offsets] Offset the positioning by [x, y]
         * @return {Number[]} [x, y]
         */
        getAlignToXY(element: Ext.util.Positionable|HTMLElement|string, position?: string, offsets?: number): number;

        /**
         * Gets the x,y coordinates specified by the anchor position on the element.
         * @param {String} [anchor='tl'] The specified anchor position.
         * See {@link #alignTo} for details on supported anchor positions.
         * @param {Boolean} [local] True to get the local (element top/left-relative) anchor
         * position instead of page coordinates
         * @param {Object} [size] An object containing the size to use for calculating anchor
         * position {width: (target width), height: (target height)} (defaults to the
         * element's current size)
         * @return {Number[]} [x, y] An array containing the element's x and y coordinates
         */
        getAnchorXY(anchor?: string, local?: boolean, size?: any): number;

        /**
         * Return an object defining the area of this Element which can be passed to
         * {@link #setBox} to set another Element's size/location to match this element.
         *
         * @param {Boolean} [contentBox] If true a box for the content of the element is
         * returned.
         * @param {Boolean} [local] If true the element's left and top relative to its
         * 'offsetParent' are returned instead of page x/y.
         * @return {Object} box An object in the format:
         *
         *     {
         *         x: <Element's X position>,
         *         y: <Element's Y position>,
         *         left: <Element's X position (an alias for x)>,
         *         top: <Element's Y position (an alias for y)>,
         *         width: <Element's width>,
         *         height: <Element's height>,
         *         bottom: <Element's lower bound>,
         *         right: <Element's rightmost bound>
         *     }
         *
         * The returned object may also be addressed as an Array where index 0 contains the X
         * position and index 1 contains the Y position. The result may also be used for
         * {@link #setXY}
         */
        getBox(contentBox?: boolean, local?: boolean): any;

        /**
         * Returns the '[X, Y]' vector by which this Positionable's element must be translated to make a best
         * attempt to constrain within the passed constraint. Returns 'false' if the element
         * does not need to be moved.
         *
         * Priority is given to constraining the top and left within the constraint.
         *
         * The constraint may either be an existing element into which the element is to be
         * constrained, or a {@link Ext.util.Region Region} into which this element is to be
         * constrained.
         *
         * By default, any extra shadow around the element is **not** included in the constrain calculations - the edges
         * of the element are used as the element bounds. To constrain the shadow within the constrain region, set the
         * 'constrainShadow' property on this element to 'true'.
         *
         * @param {Ext.util.Positionable/HTMLElement/String/Ext.util.Region} [constrainTo] The
         * Positionable, HTMLElement, element id, or Region into which the element is to be
         * constrained.
         * @param {Number[]} [proposedPosition] A proposed '[X, Y]' position to test for validity
         * and to produce a vector for instead of using the element's current position
         * @param {Number[]} [proposedSize] A proposed '[width, height]' size to constrain
         * instead of using the element's current size
         * @return {Number[]/Boolean} **If** the element *needs* to be translated, an '[X, Y]'
         * vector by which this element must be translated. Otherwise, 'false'.
         */
        getConstrainVector(constrainTo?: Ext.util.Positionable|HTMLElement|string|Ext.util.Region, proposedPosition?: number, proposedSize?: number): number|boolean;

        /**
         * Returns the x coordinate of this element reletive to its 'offsetParent'.
         * @return {Number} The local x coordinate
         */
        getLocalX(): number;

        /**
         * Returns the x and y coordinates of this element relative to its 'offsetParent'.
         * @return {Number[]} The local XY position of the element
         */
        getLocalXY(): number;

        /**
         * Returns the y coordinate of this element reletive to its 'offsetParent'.
         * @return {Number} The local y coordinate
         */
        getLocalY(): number;

        /**
         * Returns the offsets of this element from the passed element. The element must both
         * be part of the DOM tree and not have display:none to have page coordinates.
         * @param {Ext.util.Positionable/HTMLElement/String} offsetsTo The Positionable,
         * HTMLElement, or element id to get get the offsets from.
         * @return {Number[]} The XY page offsets (e.g. '[100, -200]')
         */
        getOffsetsTo(offsetsTo: Ext.util.Positionable|HTMLElement|string): number;

        /**
         * Returns a region object that defines the area of this element.
         * @return {Ext.util.Region} A Region containing "top, left, bottom, right" properties.
         */
        getRegion(): Ext.util.Region;

        /**
         * Returns the **content** region of this element. That is the region within the borders
         * and padding.
         * @return {Ext.util.Region} A Region containing "top, left, bottom, right" member data.
         */
        getViewRegion(): Ext.util.Region;

        /**
         * Gets the current X position of the DOM element based on page coordinates.
         * @return {Number} The X position of the element
         */
        getX(): number;

        /**
         * Gets the current position of the DOM element based on page coordinates.
         * @return {Number[]} The XY position of the element
         */
        getXY(): number;

        /**
         * Gets the current Y position of the DOM element based on page coordinates.
         * @return {Number} The Y position of the element
         */
        getY(): number;

        /**
         * Move the element relative to its current position.
         * @param {String} direction Possible values are:
         *
         * - '"l"' (or '"left"')
         * - '"r"' (or '"right"')
         * - '"t"' (or '"top"', or '"up"')
         * - '"b"' (or '"bottom"', or '"down"')
         *
         * @param {Number} distance How far to move the element in pixels
         * @param {Boolean/Object} [animate] true for the default animation or a standard
         * Element animation config object
         */
        move(direction: string, distance: number, animate?: boolean|any);

        /**
         * Remove any anchor to this element. See {@link #anchorTo}.
         * @return {Ext.util.Positionable} this
         */
        removeAnchor(): Ext.util.Positionable;

        /**
         * Sets the element's box. If animate is true then x, y, width, and height will be
         * animated concurrently.
         * @param {Object} box The box to fill {x, y, width, height}
         * @param {Boolean/Object} [animate] true for the default animation or a standard
         * Element animation config object
         * @return {Ext.util.Positionable} this
         */
        setBox(box: any, animate?: boolean|any): Ext.util.Positionable;

        /**
         * Sets the local x coordinate of this element using CSS style. When used on an
         * absolute positioned element this method is symmetrical with {@link #getLocalX}, but
         * may not be symmetrical when used on a relatively positioned element.
         * @param {Number} x The x coordinate. A value of 'null' sets the left style to 'auto'.
         * @return {Ext.util.Positionable} this
         */
        setLocalX(x: number): Ext.util.Positionable;

        /**
         * Sets the local x and y coordinates of this element using CSS style. When used on an
         * absolute positioned element this method is symmetrical with {@link #getLocalXY}, but
         * may not be symmetrical when used on a relatively positioned element.
         * @param {Number/Array} x The x coordinate or an array containing [x, y]. A value of
         * 'null' sets the left style to 'auto'
         * @param {Number} [y] The y coordinate, required if x is not an array. A value of
         * 'null' sets the top style to 'auto'
         * @return {Ext.util.Positionable} this
         */
        setLocalXY(x: number|any[], y?: number): Ext.util.Positionable;

        /**
         * Sets the local y coordinate of this element using CSS style. When used on an
         * absolute positioned element this method is symmetrical with {@link #getLocalY}, but
         * may not be symmetrical when used on a relatively positioned element.
         * @param {Number} y The y coordinate. A value of 'null' sets the top style to 'auto'.
         * @return {Ext.util.Positionable} this
         */
        setLocalY(y: number): Ext.util.Positionable;

        /**
         * Sets the element's position and size to the specified region. If animation is true
         * then width, height, x and y will be animated concurrently.
         *
         * @param {Ext.util.Region} region The region to fill
         * @param {Boolean/Object} [animate] true for the default animation or a standard
         * Element animation config object
         * @return {Ext.util.Positionable} this
         */
        setRegion(region: Ext.util.Region, animate?: boolean|any): Ext.util.Positionable;

        /**
         * Sets the X position of the DOM element based on page coordinates.
         * @param {Number} The X position
         * @param {Boolean/Object} [animate] True for the default animation, or a standard
         * Element animation config object
         * @return {Ext.util.Positionable} this
         */
        setX(The: number, animate?: boolean|any): Ext.util.Positionable;

        /**
         * Sets the position of the DOM element in page coordinates.
         * @param {Number[]} pos Contains X & Y [x, y] values for new position (coordinates
         * are page-based)
         * @param {Boolean/Object} [animate] True for the default animation, or a standard
         * Element animation config object
         * @return {Ext.util.Positionable} this
         */
        setXY(pos: number, animate?: boolean|any): Ext.util.Positionable;

        /**
         * Sets the Y position of the DOM element based on page coordinates.
         * @param {Number} The Y position
         * @param {Boolean/Object} [animate] True for the default animation, or a standard
         * Element animation config object
         * @return {Ext.util.Positionable} this
         */
        setY(The: number, animate?: boolean|any): Ext.util.Positionable;

        /**
         * Translates the passed page coordinates into left/top css values for the element
         * @param {Number/Array} x The page x or an array containing [x, y]
         * @param {Number} [y] The page y, required if x is not an array
         * @return {Object} An object with left and top properties. e.g.
         * {left: (value), top: (value)}
         */
        translatePoints(x: number|any[], y?: number): any;
    }

    /**
     * Manages certain element-like data prior to rendering. These values are passed
     * on to the render process. This is currently used to manage the "class" and "style" attributes
     * of a component's primary el as well as the bodyEl of panels. This allows things like
     * addBodyCls in Panel to share logic with addCls in AbstractComponent.
     */
    export class ProtoElement extends Ext.Base {
        /**
         * The property name for the className on the data object passed to {@link #writeTo}.
         */
        clsProp: any;

        /**
         * The property name for the removed classes on the data object passed to {@link #writeTo}.
         */
        removedProp: any;

        /**
         * True if the style must be converted to text during {@link #writeTo}. When used to
         * populate tpl data, this will be true. When used to populate {@link Ext.DomHelper}
         * specs, this will be false (the default).
         */
        styleIsText: any;

        /**
         * The property name for the style on the data object passed to {@link #writeTo}.
         */
        styleProp: any;

        /**
         * Adds class to the element.
         * @param {String} cls One or more classnames separated with spaces.
         * @return {Ext.util.ProtoElement} this
         */
        addCls(cls: string): Ext.util.ProtoElement;

        /**
         * Indicates that the current state of the object has been flushed to the DOM, so we need
         * to track any subsequent changes
         */
        flush();

        /**
         * True if the element has given class.
         * @return {Boolean}
         */
        hasCls(cls: string): boolean;

        /**
         * Removes class from the element.
         * @param {String} cls One or more classnames separated with spaces.
         * @return {Ext.util.ProtoElement} this
         */
        removeCls(cls: string): Ext.util.ProtoElement;

        /**
         * Adds styles to the element.
         * @param {String/Object} prop The style property to be set, or an object of multiple styles.
         * @param {String} [value] The value to apply to the given property.
         * @return {Ext.util.ProtoElement} this
         */
        setStyle(prop: string|any, value?: string): Ext.util.ProtoElement;

        /**
         * Writes style and class properties to given object.
         * Styles will be written to {@link #styleProp} and class names to {@link #clsProp}.
         * @return {Object} to
         */
        writeTo(to: any): any;
    }

    /**
     * An internal Queue class.
     */
    export class Queue extends Ext.Base {
        /**
         * Removes all items from the collection.
         */
        clear();

        constructor();

        /**
         * Returns the number of items in the collection.
         * @return {Number} the number of items in the collection.
         */
        getCount(): number;

        /**
         * Remove an item from the collection.
         * @param {Object} obj The item to remove.
         * @return {Object} The item removed or false if no item was removed.
         */
        remove(obj: any): any;
    }

    /**
     * This class represents a rectangular region in X,Y space, and performs geometric
     * transformations or tests upon the region.
     *
     * This class may be used to compare the document regions occupied by elements.
     */
    export class Region extends Ext.Base {
        /**
         * Modifies the current region to be adjusted by offsets.
         * @param {Number} top top offset
         * @param {Number} right right offset
         * @param {Number} bottom bottom offset
         * @param {Number} left left offset
         * @return {Ext.util.Region} this
         */
        adjust(top: number, right: number, bottom: number, left: number): Ext.util.Region;

        /**
         * Modifies the current region to be constrained to the targetRegion.
         * @return {Ext.util.Region} this
         */
        constrainTo(targetRegion: Ext.util.Region): Ext.util.Region;

        /**
         * Creates a region from the bounding sides.
         * @param {Number} top Top The topmost pixel of the Region.
         * @param {Number} right Right The rightmost pixel of the Region.
         * @param {Number} bottom Bottom The bottom pixel of the Region.
         * @param {Number} left Left The leftmost pixel of the Region.
         */
        constructor(top: number, right: number, bottom: number, left: number);

        /**
         * Checks if this region completely contains the region that is passed in.
         * @return {Boolean}
         */
        contains(region: Ext.util.Region): boolean;

        /**
         * Create a copy of this Region.
         * @return {Ext.util.Region}
         */
        copy(): Ext.util.Region;

        /**
         * Copy the values of another Region to this Region
         * @param {Ext.util.Region} p The region to copy from.
         * @return {Ext.util.Region} This Region
         */
        copyFrom(p: Ext.util.Region): Ext.util.Region;

        /**
         * Check whether this region is equivalent to the given region
         * @param {Ext.util.Region} region The region to compare with
         * @return {Boolean}
         */
        equals(region: Ext.util.Region): boolean;

        /**
         * Get the offset amount of a point outside the region
         * @param {String} [axis]
         * @param {Ext.util.Point} [p] the point
         * @return {Ext.util.Offset}
         */
        getOutOfBoundOffset(axis?: string, p?: Ext.util.Point): Ext.util.Offset;

        /**
         * Get the offset amount on the x-axis
         * @param {Number} p the offset
         * @return {Number}
         */
        getOutOfBoundOffsetX(p: number): number;

        /**
         * Get the offset amount on the y-axis
         * @param {Number} p the offset
         * @return {Number}
         */
        getOutOfBoundOffsetY(p: number): number;

        /**
         * Checks if this region intersects the region passed in.
         * @return {Ext.util.Region/Boolean} Returns the intersected region or false if there is no intersection.
         */
        intersect(region: Ext.util.Region): Ext.util.Region|boolean;

        /**
         * Check whether the point / offset is out of bound
         * @param {String} [axis]
         * @param {Ext.util.Point/Number} [p] the point / offset
         * @return {Boolean}
         */
        isOutOfBound(axis?: string, p?: Ext.util.Point|number): boolean;

        /**
         * Check whether the offset is out of bound in the x-axis
         * @param {Number} p the offset
         * @return {Boolean}
         */
        isOutOfBoundX(p: number): boolean;

        /**
         * Check whether the offset is out of bound in the y-axis
         * @param {Number} p the offset
         * @return {Boolean}
         */
        isOutOfBoundY(p: number): boolean;

        /**
         * Round all the properties of this region
         * @return {Ext.util.Region} this This Region
         */
        round(): Ext.util.Region;

        /**
         * Translate this region by the given offset amount
         * @param {Ext.util.Offset/Object} x Object containing the 'x' and 'y' properties.
         * Or the x value is using the two argument form.
         * @param {Number} y The y value unless using an Offset object.
         * @return {Ext.util.Region} this This Region
         */
        translateBy(x: Ext.util.Offset|any, y: number): Ext.util.Region;

        /**
         * Returns the smallest region that contains the current AND targetRegion.
         * @return {Ext.util.Region} a new region
         */
        union(region: Ext.util.Region): Ext.util.Region;

        /**
         * Creates a Region from a "box" Object which contains four numeric properties 'top', 'right', 'bottom' and 'left'.
         * @param {Object} o An object with 'top', 'right', 'bottom' and 'left' properties.
         * @return {Ext.util.Region} region The Region constructed based on the passed object
         */
        static from(o: any): Ext.util.Region;

        /**
         * Retrieves an Ext.util.Region for a particular element.
         * @param {String/HTMLElement/Ext.Element} el An element ID, htmlElement or Ext.Element representing an element in the document.
         * @returns {Ext.util.Region} region
         */
        static getRegion(el: string|HTMLElement|Ext.dom.Element);
    }

    /**
     * Given a component hierarchy of this:
     *
     *      {
     *          xtype: 'panel',
     *          id: 'ContainerA',
     *          layout: 'hbox',
     *          renderTo: Ext.getBody(),
     *          items: [
     *              {
     *                  id: 'ContainerB',
     *                  xtype: 'container',
     *                  items: [
     *                      { id: 'ComponentA' }
     *                  ]
     *              }
     *          ]
     *      }
     *
     * The rendering of the above proceeds roughly like this:
     *
     *  - ContainerA's initComponent calls #render passing the 'renderTo' property as the
     *    container argument.
     *  - 'render' calls the 'getRenderTree' method to get a complete {@link Ext.DomHelper} spec.
     *  - 'getRenderTree' fires the "beforerender" event and calls the #beforeRender
     *    method. Its result is obtained by calling #getElConfig.
     *  - The #getElConfig method uses the 'renderTpl' and its render data as the content
     *    of the 'autoEl' described element.
     *  - The result of 'getRenderTree' is passed to {@link Ext.DomHelper#append}.
     *  - The 'renderTpl' contains calls to render things like docked items, container items
     *    and raw markup (such as the 'html' or 'tpl' config properties). These calls are to
     *    methods added to the {@link Ext.XTemplate} instance by #setupRenderTpl.
     *  - The #setupRenderTpl method adds methods such as 'renderItems', 'renderContent', etc.
     *    to the template. These are directed to "doRenderItems", "doRenderContent" etc..
     *  - The #setupRenderTpl calls traverse from components to their {@link Ext.layout.Layout}
     *    object.
     *  - When a container is rendered, it also has a 'renderTpl'. This is processed when the
     *    'renderContainer' method is called in the component's 'renderTpl'. This call goes to
     *    Ext.layout.container.Container#doRenderContainer. This method repeats this
     *    process for all components in the container.
     *  - After the top-most component's markup is generated and placed in to the DOM, the next
     *    step is to link elements to their components and finish calling the component methods
     *    'onRender' and 'afterRender' as well as fire the corresponding events.
     *  - The first step in this is to call #finishRender. This method descends the
     *    component hierarchy and calls 'onRender' and fires the 'render' event. These calls
     *    are delivered top-down to approximate the timing of these calls/events from previous
     *    versions.
     *  - During the pass, the component's 'el' is set. Likewise, the 'renderSelectors' and
     *    'childEls' are applied to capture references to the component's elements.
     *  - These calls are also made on the {@link Ext.layout.container.Container} layout to
     *    capture its elements. Both of these classes use {@link Ext.util.ElementContainer} to
     *    handle 'childEls' processing.
     *  - Once this is complete, a similar pass is made by calling #finishAfterRender.
     *    This call also descends the component hierarchy, but this time the calls are made in
     *    a bottom-up order to 'afterRender'.
     */
    export class Renderable extends Ext.Base {
        /**
         * Allows addition of behavior after rendering is complete. At this stage the Components Element
         * will have been styled according to the configuration, will have had any configured CSS class
         * names added, and will be in the configured visibility and the configured enable state.
         */
        protected afterRender();

        /**
         * Handles autoRender.
         * Floating Components may have an ownerCt. If they are asking to be constrained, constrain them within that
         * ownerCt, and have their z-index managed locally. Floating Components are always rendered to document.body
         */
        doAutoRender();

        /**
         * Ensures that this component is attached to 'document.body'. If the component was
         * rendered to {@link Ext#getDetachedBody}, then it will be appended to 'document.body'.
         * Any configured position is also restored.
         * @param {Boolean} [runLayout=false] True to run the component's layout.
         */
        ensureAttachedToBody(runLayout?: boolean);

        /**
         * This function takes the position argument passed to onRender and returns a
         * DOM element that you can use in the insertBefore.
         * @param {String/Number/Ext.dom.Element/HTMLElement} position Index, element id or element you want
         * to put this component before.
         * @return {HTMLElement} DOM element that you can use in the insertBefore
         */
        getInsertPosition(position: string|number|Ext.dom.Element|HTMLElement): HTMLElement;

        /**
         * Initialized the renderData to be used when rendering the renderTpl.
         * @return {Object} Object with keys and values that are going to be applied to the renderTpl
         */
        protected initRenderData(): any;

        /**
         * Template method called when this Component's DOM structure is created.
         *
         * At this point, this Component's (and all descendants') DOM structure *exists* but it has not
         * been layed out (positioned and sized).
         *
         * Subclasses which override this to gain access to the structure at render time should
         * call the parent class's method before attempting to access any child elements of the Component.
         *
         * @param {Ext.core.Element} parentNode The parent Element in which this Component's encapsulating element is contained.
         * @param {Number} containerIdx The index within the parent Container's child collection of this Component.
         */
        protected onRender(parentNode: Ext.dom.Element, containerIdx: number);

        /**
         * Renders the Component into the passed HTML element.
         *
         * **If you are using a {@link Ext.container.Container Container} object to house this
         * Component, then do not use the render method.**
         *
         * A Container's child Components are rendered by that Container's
         * {@link Ext.container.Container#layout layout} manager when the Container is first rendered.
         *
         * If the Container is already rendered when a new child Component is added, you may need to call
         * the Container's {@link Ext.container.Container#doLayout doLayout} to refresh the view which
         * causes any unrendered child Components to be rendered. This is required so that you can add
         * multiple child components if needed while only refreshing the layout once.
         *
         * When creating complex UIs, it is important to remember that sizing and positioning
         * of child items is the responsibility of the Container's {@link Ext.container.Container#layout layout}
         * manager.  If you expect child items to be sized in response to user interactions, you must
         * configure the Container with a layout manager which creates and manages the type of layout you
         * have in mind.
         *
         * **Omitting the Container's {@link Ext.Container#layout layout} config means that a basic
         * layout manager is used which does nothing but render child components sequentially into the
         * Container. No sizing or positioning will be performed in this situation.**
         *
         * @param {Ext.Element/HTMLElement/String} [container] The element this Component should be
         * rendered into. If it is being created from existing markup, this should be omitted.
         * @param {String/Number} [position] The element ID or DOM node index within the container **before**
         * which this component will be inserted (defaults to appending to the end of the container)
         */
        render(container?: Ext.dom.Element|HTMLElement|string, position?: string|number);
    }

    interface SortableConfig {
        /**
         * The default sort direction to use if one is not specified.
         */
        defaultSortDirection?: string;

        /**
         * The property in each item that contains the data to sort.
         */
        sortRoot?: string;
    }

    /**
     * @docauthor Tommy Maintz <tommy@sencha.com>
     *
     * A mixin which allows a data component to be sorted. This is used by e.g. {@link Ext.data.Store} and {@link Ext.data.TreeStore}.
     *
     * **NOTE**: This mixin is mainly for internal use and most users should not need to use it directly. It
     * is more likely you will want to use one of the component classes that import this mixin, such as
     * {@link Ext.data.Store} or {@link Ext.data.TreeStore}.
     */
    export class Sortable extends Ext.Base implements Ext.util.SortableConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Sortable, or subclass thereof.
         */
        isSortable: boolean;

        /**
         * The collection of {@link Ext.util.Sorter Sorters} currently applied to this Store
         */
        sorters: Ext.util.MixedCollection;

        /**
         * The default sort direction to use if one is not specified.
         */
        defaultSortDirection: string;

        /**
         * The property in each item that contains the data to sort.
         */
        sortRoot: string;

        /**
         * Returns a comparator function which compares two items and returns -1, 0, or 1 depending
         * on the currently defined set of {@link #cfg-sorters}.
         *
         * If there are no {@link #cfg-sorters} defined, it returns a function which returns '0' meaning
         * that no sorting will occur.
         */
        generateComparator();

        /**
         * Gets the first sorter from the sorters collection, excluding
         * any groupers that may be in place
         * @return {Ext.util.Sorter} The sorter, null if none exist
         */
        protected getFirstSorter(): Ext.util.Sorter;

        /**
         * Performs initialization of this mixin. Component classes using this mixin should call this method during their
         * own initialization.
         */
        initSortable();

        /**
         * Sorts the data in the Store by one or more of its properties. Example usage:
         *
         *     //sort by a single field
         *     myStore.sort('myField', 'DESC');
         *
         *     //sorting by multiple fields
         *     myStore.sort([
         *         {
         *             property : 'age',
         *             direction: 'ASC'
         *         },
         *         {
         *             property : 'name',
         *             direction: 'DESC'
         *         }
         *     ]);
         *
         * Internally, Store converts the passed arguments into an array of {@link Ext.util.Sorter} instances, and delegates
         * the actual sorting to its internal {@link Ext.util.MixedCollection}.
         *
         * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
         *
         *     store.sort('myField');
         *     store.sort('myField');
         *
         * Is equivalent to this code, because Store handles the toggling automatically:
         *
         *     store.sort('myField', 'ASC');
         *     store.sort('myField', 'DESC');
         *
         * @param {String/Ext.util.Sorter[]} [sorters] Either a string name of one of the fields in this Store's configured
         * {@link Ext.data.Model Model}, or an array of sorter configurations.
         * @param {String} [direction="ASC"] The overall direction to sort the data by.
         * @return {Ext.util.Sorter[]}
         */
        sort(sorters?: string|Ext.util.Sorter, direction?: string): Ext.util.Sorter;

        /**
         * Creates a single comparator function which encapsulates the passed Sorter array.
         * @param {Ext.util.Sorter[]} sorters The sorter set for which to create a comparator function
         * @return {Function} a function, which when passed two comparable objects returns the result
         * of the whole sorter comparator functions.
         */
        static createComparator(sorters: Ext.util.Sorter): Function;
    }

    interface SorterConfig {
        /**
         * The direction to sort by.
         */
        direction?: string;

        /**
         * The property to sort by. Required unless {@link #sorterFn} is provided. The property is extracted from the object
         * directly and compared for sorting using the built in comparison operators.
         */
        property?: string;

        /**
         * Optional root property. This is mostly useful when sorting a Store, in which case we set the root to 'data' to
         * make the filter pull the {@link #property} out of the data object of each item
         */
        root?: string;

        /**
         * A specific sorter function to execute. Can be passed instead of {@link #property}. This sorter function allows
         * for any kind of custom/complex comparisons. The sorterFn receives two arguments, the objects being compared. The
         * function should return:
         *
         *   - -1 if o1 is "less than" o2
         *   - 0 if o1 is "equal" to o2
         *   - 1 if o1 is "greater than" o2
         */
        sorterFn?: Function;

        /**
         * A function that will be run on each value before it is compared in the sorter. The function will receive a single
         * argument, the value.
         */
        transform?: Function;
    }

    /**
     * Represents a single sorter that can be applied to a Store. The sorter is used
     * to compare two values against each other for the purpose of ordering them. Ordering
     * is achieved by specifying either:
     *
     * - {@link #property A sorting property}
     * - {@link #sorterFn A sorting function}
     *
     * As a contrived example, we can specify a custom sorter that sorts by rank:
     *
     *     Ext.define('Person', {
     *         extend: 'Ext.data.Model',
     *         fields: ['name', 'rank']
     *     });
     *
     *     Ext.create('Ext.data.Store', {
     *         model: 'Person',
     *         proxy: 'memory',
     *         sorters: [{
     *             sorterFn: function(o1, o2){
     *                 var getRank = function(o){
     *                     var name = o.get('rank');
     *                     if (name === 'first') {
     *                         return 1;
     *                     } else if (name === 'second') {
     *                         return 2;
     *                     } else {
     *                         return 3;
     *                     }
     *                 },
     *                 rank1 = getRank(o1),
     *                 rank2 = getRank(o2);
     *
     *                 if (rank1 === rank2) {
     *                     return 0;
     *                 }
     *
     *                 return rank1 < rank2 ? -1 : 1;
     *             }
     *         }],
     *         data: [{
     *             name: 'Person1',
     *             rank: 'second'
     *         }, {
     *             name: 'Person2',
     *             rank: 'third'
     *         }, {
     *             name: 'Person3',
     *             rank: 'first'
     *         }]
     *     });
     */
    export class Sorter extends Ext.Base implements Ext.util.SorterConfig {
        /**
         * The direction to sort by.
         */
        direction: string;

        /**
         * The property to sort by. Required unless {@link #sorterFn} is provided. The property is extracted from the object
         * directly and compared for sorting using the built in comparison operators.
         */
        property: string;

        /**
         * Optional root property. This is mostly useful when sorting a Store, in which case we set the root to 'data' to
         * make the filter pull the {@link #property} out of the data object of each item
         */
        root: string;

        /**
         * A specific sorter function to execute. Can be passed instead of {@link #property}. This sorter function allows
         * for any kind of custom/complex comparisons. The sorterFn receives two arguments, the objects being compared. The
         * function should return:
         *
         *   - -1 if o1 is "less than" o2
         *   - 0 if o1 is "equal" to o2
         *   - 1 if o1 is "greater than" o2
         */
        sorterFn: Function;

        /**
         * A function that will be run on each value before it is compared in the sorter. The function will receive a single
         * argument, the value.
         */
        transform: Function;

        constructor(config: Ext.util.SorterConfig);

        /**
         * Set the sorting direction for this sorter.
         * @param {String} direction The direction to sort in. Should be either 'ASC' or 'DESC'.
         */
        setDirection(direction: string);

        /**
         * Toggles the sorting direction for this sorter.
         */
        toggle();

        /**
         * Update the sort function for this sorter.
         * @param {Function} [fn] A new sorter function for this sorter. If not specified it will use the default
         * sorting function.
         */
        updateSortFunction(fn?: Function);
    }

    /**
     * A static {@link Ext.util.TaskRunner} instance that can be used to start and stop
     * arbitrary tasks. See {@link Ext.util.TaskRunner} for supported methods and task
     * config properties.
     *
     *    // Start a simple clock task that updates a div once per second
     *    var task = {
     *       run: function(){
     *           Ext.fly('clock').update(new Date().format('g:i:s A'));
     *       },
     *       interval: 1000 //1 second
     *    }
     *
     *    Ext.TaskManager.start(task);
     *
     * See the {@link #start} method for details about how to configure a task object.
     */
    export class TaskManager {
        /**
         * Provides the ability to execute one or more arbitrary tasks in a asynchronous manner.
         * Generally, you can use the singleton {@link Ext.TaskManager} instead, but if needed,
         * you can create separate instances of TaskRunner. Any number of separate tasks can be
         * started at any time and will run independently of each other.
         *
         * Example usage:
         *
         *      // Start a simple clock task that updates a div once per second
         *      var updateClock = function () {
         *          Ext.fly('clock').update(new Date().format('g:i:s A'));
         *      }
         *
         *      var runner = new Ext.util.TaskRunner();
         *      var task = runner.start({
         *          run: updateClock,
         *          interval: 1000
         *      }
         *
         * The equivalent using TaskManager:
         *
         *      var task = Ext.TaskManager.start({
         *          run: updateClock,
         *          interval: 1000
         *      });
         *
         * To end a running task:
         *
         *      task.destroy();
         *
         * If a task needs to be started and stopped repeated over time, you can create a
         * {@link Ext.util.TaskRunner.Task Task} instance.
         *
         *      var task = runner.newTask({
         *          run: function () {
         *              // useful code
         *          },
         *          interval: 1000
         *      });
         *
         *      task.start();
         *
         *      // ...
         *
         *      task.stop();
         *
         *      // ...
         *
         *      task.start();
         *
         * A re-usable, one-shot task can be managed similar to the above:
         *
         *      var task = runner.newTask({
         *          run: function () {
         *              // useful code to run once
         *          },
         *          repeat: 1
         *      });
         *
         *      task.start();
         *
         *      // ...
         *
         *      task.start();
         *
         * See the {@link #start} method for details about how to configure a task object.
         *
         * Also see {@link Ext.util.DelayedTask}.
         *
         * @constructor
         * @param {Number/Object} [interval=10] The minimum precision in milliseconds supported by this
         * TaskRunner instance. Alternatively, a config object to apply to the new instance.
         */
        constructor(interval?: number|any);
    }

    interface TaskRunnerConfig {
        /**
         * This may be configured 'false' to inhibit firing of the {@link Ext.EventManager#idleEvent idle event} after task invocation.
         *
         * Optional, Defaults to: true
         */
        fireIdleEvent?: boolean;

        /**
         * The timer resolution.
         */
        interval?: any;
    }

    export class TaskRunner extends Ext.Base implements Ext.util.TaskRunnerConfig {
        /**
         * This may be configured 'false' to inhibit firing of the {@link Ext.EventManager#idleEvent idle event} after task invocation.
         *
         * Optional, Defaults to: true
         */
        fireIdleEvent: boolean;

        /**
         * The timer resolution.
         */
        interval: any;

        /**
         * Provides the ability to execute one or more arbitrary tasks in a asynchronous manner.
         * Generally, you can use the singleton {@link Ext.TaskManager} instead, but if needed,
         * you can create separate instances of TaskRunner. Any number of separate tasks can be
         * started at any time and will run independently of each other.
         *
         * Example usage:
         *
         *      // Start a simple clock task that updates a div once per second
         *      var updateClock = function () {
         *          Ext.fly('clock').update(new Date().format('g:i:s A'));
         *      }
         *
         *      var runner = new Ext.util.TaskRunner();
         *      var task = runner.start({
         *          run: updateClock,
         *          interval: 1000
         *      }
         *
         * The equivalent using TaskManager:
         *
         *      var task = Ext.TaskManager.start({
         *          run: updateClock,
         *          interval: 1000
         *      });
         *
         * To end a running task:
         *
         *      task.destroy();
         *
         * If a task needs to be started and stopped repeated over time, you can create a
         * {@link Ext.util.TaskRunner.Task Task} instance.
         *
         *      var task = runner.newTask({
         *          run: function () {
         *              // useful code
         *          },
         *          interval: 1000
         *      });
         *
         *      task.start();
         *
         *      // ...
         *
         *      task.stop();
         *
         *      // ...
         *
         *      task.start();
         *
         * A re-usable, one-shot task can be managed similar to the above:
         *
         *      var task = runner.newTask({
         *          run: function () {
         *              // useful code to run once
         *          },
         *          repeat: 1
         *      });
         *
         *      task.start();
         *
         *      // ...
         *
         *      task.start();
         *
         * See the {@link #start} method for details about how to configure a task object.
         *
         * Also see {@link Ext.util.DelayedTask}.
         *
         * @constructor
         * @param {Number/Object} [interval=10] The minimum precision in milliseconds supported by this
         * TaskRunner instance. Alternatively, a config object to apply to the new instance.
         */
        constructor(interval?: number|any);

        /**
         * Destroys this instance, stopping all tasks that are currently running.
         */
        destroy();

        /**
         * Creates a new {@link Ext.util.TaskRunner.Task Task} instance. These instances can
         * be easily started and stopped.
         * @param {Object} config The config object. For details on the supported properties,
         * see {@link #start}.
         */
        newTask(config: Ext.util.TaskRunnerConfig);

        /**
         * Starts a new task.
         *
         * Before each invocation, Ext injects the property 'taskRunCount' into the task object
         * so that calculations based on the repeat count can be performed.
         *
         * The returned task will contain a 'destroy' method that can be used to destroy the
         * task and cancel further calls. This is equivalent to the {@link #stop} method.
         *
         * @param {Object} task A config object that supports the following properties:
         * @param {Function} task.run The function to execute each time the task is invoked. The
         * function will be called at each interval and passed the 'args' argument if specified,
         * and the current invocation count if not.
         *
         * If a particular scope ('this' reference) is required, be sure to specify it using
         * the 'scope' argument.
         *
         * @param {Function} task.onError The function to execute in case of unhandled
         * error on task.run.
         *
         * @param {Boolean} task.run.return 'false' from this function to terminate the task.
         *
         * @param {Number} task.interval The frequency in milliseconds with which the task
         * should be invoked.
         *
         * @param {Object[]} task.args An array of arguments to be passed to the function
         * specified by 'run'. If not specified, the current invocation count is passed.
         *
         * @param {Object} task.scope The scope ('this' reference) in which to execute the
         * 'run' function. Defaults to the task config object.
         *
         * @param {Number} task.duration The length of time in milliseconds to invoke the task
         * before stopping automatically (defaults to indefinite).
         *
         * @param {Number} task.repeat The number of times to invoke the task before stopping
         * automatically (defaults to indefinite).
         * @return {Object} The task
         */
        start(task: any, task_run: Function, task_onError: Function, task_run_return: boolean, task_interval: number, task_args: any, task_scope: any, task_duration: number, task_repeat: number): any;

        /**
         * Stops an existing running task.
         * @param {Object} task The task to stop
         * @return {Object} The task
         */
        stop(task: any): any;

        /**
         * Stops all tasks that are currently running.
         */
        stopAll();
    }

    /**
     * Provides precise pixel measurements for blocks of text so that you can determine exactly how high and
     * wide, in pixels, a given block of text will be. Note that when measuring text, it should be plain text and
     * should not contain any HTML, otherwise it may not be measured correctly.
     *
     * The measurement works by copying the relevant CSS styles that can affect the font related display,
     * then checking the size of an element that is auto-sized. Note that if the text is multi-lined, you must
     * provide a **fixed width** when doing the measurement.
     *
     * If multiple measurements are being done on the same element, you create a new instance to initialize
     * to avoid the overhead of copying the styles to the element repeatedly.
     */
    export class TextMetrics extends Ext.Base {
        /**
         * Binds this TextMetrics instance to a new element
         * @param {String/HTMLElement/Ext.Element} el The element or its ID.
         */
        bind(el: string|HTMLElement|Ext.dom.Element);

        /**
         * Creates new TextMetrics.
         * @param {String/HTMLElement/Ext.Element} bindTo The element or its ID to bind to.
         * @param {Number} [fixedWidth] A fixed width to apply to the measuring element.
         */
        constructor(bindTo: string|HTMLElement|Ext.dom.Element, fixedWidth?: number);

        /**
         * Returns the measured height of the specified text
         * @param {String} text The text to measure
         * @return {Number} height The height in pixels
         */
        getHeight(text: string): number;

        /**
         * Returns the size of the specified text based on the internal element's style and width properties
         * @param {String} text The text to measure
         * @return {Object} An object containing the text's size '{width: (width), height: (height)}'
         */
        getSize(text: string): any;

        /**
         * Returns the measured width of the specified text
         * @param {String} text The text to measure
         * @return {Number} width The width in pixels
         */
        getWidth(text: string): number;

        /**
         * Sets a fixed width on the internal measurement element.  If the text will be multiline, you have
         * to set a fixed width in order to accurately measure the text height.
         * @param {Number} width The width to set on the element
         */
        setFixedWidth(width: number);

        /**
         * Destroy the TextMetrics instance created by {@link #measure}.
         */
        static destroy();

        /**
         * Measures the size of the specified text
         * @param {String/HTMLElement} el The element, dom node or id from which to copy existing CSS styles
         * that can affect the size of the rendered text
         * @param {String} text The text to measure
         * @param {Number} fixedWidth (optional) If the text will be multiline, you have to set a fixed width
         * in order to accurately measure the text height
         * @return {Object} An object containing the text's size '{width: (width), height: (height)}'
         */
        static measure(el: string|HTMLElement, text: string, fixedWidth: number): any;
    }
}

declare module Ext.util.TaskRunner {
    /**
     * Instances of this class are created by {@link Ext.util.TaskRunner#newTask} method.
     *
     * For details on config properties, see {@link Ext.util.TaskRunner#start}.
     */
    export class Task {
        /**
         * Override default behavior
         */
        fireOnStart: any;

        /**
         * Destroys this instance, stopping this task's execution.
         */
        destroy();

        /**
         * Restarts this task, clearing it duration, expiration and run count.
         * @param {Number} [interval] Optionally reset this task's interval.
         */
        restart(interval?: number);

        /**
         * Starts this task if it is not already started.
         * @param {Number} [interval] Optionally reset this task's interval.
         */
        start(interval?: number);

        /**
         * Stops this task.
         */
        stop();
    }
}

declare module Ext.view {
    interface AbstractViewConfig extends Ext.ComponentConfig {
        /**
         * Set this to true to ignore refresh events on the bound store. This is useful if
         * you wish to provide custom transition animations via a plugin
         * @since 3.4.0
         */
        blockRefresh?: boolean;

        /**
         * True to defer emptyText being applied until the store's first load.
         * @since 2.3.0
         */
        deferEmptyText?: boolean;

        /**
         * <p>Defaults to <code>true</code> to defer the initial refresh of the view.</p>
         * <p>This allows the View to execute its render and initial layout more quickly because the process will not be encumbered
         * by the expensive update of the view structure.</p>
         * <p><b>Important: </b>Be aware that this will mean that the View's item elements will not be available immediately upon render, so
         * <i>selection</i> may not take place at render time. To access a View's item elements as soon as possible, use the {@link #viewready} event.
         * Or set <code>deferInitialrefresh</code> to false, but this will be at the cost of slower rendering.</p>
         */
        deferInitialRefresh?: boolean;

        /**
         * True to disable selection within the DataView. This configuration will lock the selection model
         * that the DataView uses.
         */
        disableSelection?: boolean;

        /**
         * The text to display in the view when there is no data to display.
         * Note that when using local data the emptyText will not be displayed unless you set
         * the {@link #deferEmptyText} option to false.
         * @since 2.3.0
         */
        emptyText?: string;

        /**
         * Specifies the class to be assigned to each element in the view when used in conjunction with the
         * {@link #itemTpl} configuration.
         * @since 2.3.0
         */
        itemCls?: string;

        /**
         * (required)
         * <b>This is a required setting</b>. A simple CSS selector (e.g. <tt>div.some-class</tt> or
         * <tt>span:first-child</tt>) that will be used to determine what nodes this DataView will be
         * working with. The itemSelector is used to map DOM nodes to records. As such, there should
         * only be one root level element that matches the selector for each record.
         * @since 2.3.0
         */
        itemSelector?: string;

        /**
         * The inner portion of the item template to be rendered. Follows an XTemplate
         * structure and will be placed inside of a tpl.
         */
        itemTpl?: string|Ext.XTemplate;

        /**
         * False to disable a load mask from displaying while the view is loading. This can also be a
         * {@link Ext.LoadMask} configuration object.
         */
        loadMask?: boolean|any;

        /**
         * The CSS class to apply to the loading message element. Defaults to Ext.LoadMask.prototype.msgCls "x-mask-loading".
         */
        loadingCls?: string;

        /**
         * If specified, gives an explicit height for the data view when it is showing the {@link #loadingText},
         * if that is specified. This is useful to prevent the view's height from collapsing to zero when the
         * loading mask is applied and there are no other contents in the data view.
         */
        loadingHeight?: number;

        /**
         * A string to display during data load operations.  If specified, this text will be
         * displayed in a loading div and the view's contents will be cleared while loading, otherwise the view's
         * contents will continue to display normally until the new data is loaded and the contents are replaced.
         * @since 2.3.0
         */
        loadingText?: string;

        /**
         * True to allow selection of more than one item at a time, false to allow selection of only a single item
         * at a time or no selection at all, depending on the value of {@link #singleSelect}.
         * @deprecated 4.0 Use {@link Ext.selection.Model#mode} 'MULTI' instead.
         * @since 2.3.0
         *
         * Optional, Defaults to: false
         */
        multiSelect?: boolean;

        /**
         * A CSS class to apply to each item in the view on mouseover.
         * Setting this will automatically set {@link #trackOver} to 'true'.
         */
        overItemCls?: string;

        /**
         * True to preserve scroll position across refresh operations.
         */
        preserveScrollOnRefresh?: boolean;

        /**
         * A CSS class to apply to each selected item in the view.
         */
        selectedItemCls?: string;

        /**
         * True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl,
         * false to force the user to hold Ctrl or Shift to select more than on item.
         * @deprecated 4.0 Use {@link Ext.selection.Model#mode} 'SIMPLE' instead.
         * @since 2.3.0
         *
         * Optional, Defaults to: false
         */
        simpleSelect?: boolean;

        /**
         * Allows selection of exactly one item at a time. As this is the default selection mode anyway, this config
         * is completely ignored.
         * @removed 4.0 Use {@link Ext.selection.Model#mode} 'SINGLE' instead.
         * @since 2.3.0
         *
         * Optional
         */
        singleSelect?: boolean;

        /**
         * (required)
         * The {@link Ext.data.Store} to bind this DataView to.
         * @since 2.3.0
         */
        store?: Ext.data.Store;

        /**
         * When 'true' the {@link #overItemCls} will be applied to rows when hovered over.
         * This in return will also cause {@link Ext.view.View#highlightitem highlightitem} and
         * {@link Ext.view.View#unhighlightitem unhighlightitem} events to be fired.
         *
         * Enabled automatically when the {@link #overItemCls} config is set.
         *
         * @since 2.3.0
         */
        trackOver?: boolean;
    }

    /**
     * This is an abstract superclass and should not be used directly. Please see {@link Ext.view.View}.
     */
    export class AbstractView extends Ext.Component implements Ext.view.AbstractViewConfig {
        /**
         * Set this to true to ignore refresh events on the bound store. This is useful if
         * you wish to provide custom transition animations via a plugin
         * @since 3.4.0
         */
        blockRefresh: boolean;

        /**
         * True to defer emptyText being applied until the store's first load.
         * @since 2.3.0
         */
        deferEmptyText: boolean;

        /**
         * <p>Defaults to <code>true</code> to defer the initial refresh of the view.</p>
         * <p>This allows the View to execute its render and initial layout more quickly because the process will not be encumbered
         * by the expensive update of the view structure.</p>
         * <p><b>Important: </b>Be aware that this will mean that the View's item elements will not be available immediately upon render, so
         * <i>selection</i> may not take place at render time. To access a View's item elements as soon as possible, use the {@link #viewready} event.
         * Or set <code>deferInitialrefresh</code> to false, but this will be at the cost of slower rendering.</p>
         */
        deferInitialRefresh: boolean;

        /**
         * True to disable selection within the DataView. This configuration will lock the selection model
         * that the DataView uses.
         */
        disableSelection: boolean;

        /**
         * The text to display in the view when there is no data to display.
         * Note that when using local data the emptyText will not be displayed unless you set
         * the {@link #deferEmptyText} option to false.
         * @since 2.3.0
         */
        emptyText: string;

        /**
         * Specifies the class to be assigned to each element in the view when used in conjunction with the
         * {@link #itemTpl} configuration.
         * @since 2.3.0
         */
        itemCls: string;

        /**
         * (required)
         * <b>This is a required setting</b>. A simple CSS selector (e.g. <tt>div.some-class</tt> or
         * <tt>span:first-child</tt>) that will be used to determine what nodes this DataView will be
         * working with. The itemSelector is used to map DOM nodes to records. As such, there should
         * only be one root level element that matches the selector for each record.
         * @since 2.3.0
         */
        itemSelector: string;

        /**
         * The inner portion of the item template to be rendered. Follows an XTemplate
         * structure and will be placed inside of a tpl.
         */
        itemTpl: string|Ext.XTemplate;

        /**
         * The CSS class to apply to the loading message element. Defaults to Ext.LoadMask.prototype.msgCls "x-mask-loading".
         */
        loadingCls: string;

        /**
         * If specified, gives an explicit height for the data view when it is showing the {@link #loadingText},
         * if that is specified. This is useful to prevent the view's height from collapsing to zero when the
         * loading mask is applied and there are no other contents in the data view.
         */
        loadingHeight: number;

        /**
         * A string to display during data load operations.  If specified, this text will be
         * displayed in a loading div and the view's contents will be cleared while loading, otherwise the view's
         * contents will continue to display normally until the new data is loaded and the contents are replaced.
         * @since 2.3.0
         */
        loadingText: string;

        /**
         * False to disable a load mask from displaying while the view is loading. This can also be a
         * {@link Ext.LoadMask} configuration object.
         */
        loadMask: boolean|any;

        /**
         * True to allow selection of more than one item at a time, false to allow selection of only a single item
         * at a time or no selection at all, depending on the value of {@link #singleSelect}.
         * @deprecated 4.0 Use {@link Ext.selection.Model#mode} 'MULTI' instead.
         * @since 2.3.0
         *
         * Optional, Defaults to: false
         */
        multiSelect: boolean;

        /**
         * A CSS class to apply to each item in the view on mouseover.
         * Setting this will automatically set {@link #trackOver} to 'true'.
         */
        overItemCls: string;

        /**
         * True to preserve scroll position across refresh operations.
         */
        preserveScrollOnRefresh: boolean;

        /**
         * A CSS class to apply to each selected item in the view.
         */
        selectedItemCls: string;

        /**
         * True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl,
         * false to force the user to hold Ctrl or Shift to select more than on item.
         * @deprecated 4.0 Use {@link Ext.selection.Model#mode} 'SIMPLE' instead.
         * @since 2.3.0
         *
         * Optional, Defaults to: false
         */
        simpleSelect: boolean;

        /**
         * Allows selection of exactly one item at a time. As this is the default selection mode anyway, this config
         * is completely ignored.
         * @removed 4.0 Use {@link Ext.selection.Model#mode} 'SINGLE' instead.
         * @since 2.3.0
         *
         * Optional
         */
        singleSelect: boolean;

        /**
         * (required)
         * The {@link Ext.data.Store} to bind this DataView to.
         * @since 2.3.0
         */
        store: Ext.data.Store;

        /**
         * When 'true' the {@link #overItemCls} will be applied to rows when hovered over.
         * This in return will also cause {@link Ext.view.View#highlightitem highlightitem} and
         * {@link Ext.view.View#unhighlightitem unhighlightitem} events to be fired.
         *
         * Enabled automatically when the {@link #overItemCls} config is set.
         *
         * @since 2.3.0
         */
        trackOver: boolean;

        protected afterRender();

        /**
         * Changes the data store bound to this view and refreshes it.
         * @param {Ext.data.Store} store The store to bind to this view
         * @since 3.4.0
         */
        bindStore(store: Ext.data.Store);

        /**
         * Deselects all selected records.
         * @deprecated 4.0 Use {@link Ext.selection.Model#deselectAll} instead.
         * @since 2.3.0
         */
        clearSelections();

        /**
         * Function which can be overridden which returns the data object passed to this
         * DataView's {@link #cfg-tpl template} to render the whole DataView.
         *
         * This is usually an Array of data objects, each element of which is processed by an
         * {@link Ext.XTemplate XTemplate} which uses ''&lt;tpl for="."&gt;'' to iterate over its supplied
         * data object as an Array. However, <i>named</i> properties may be placed into the data object to
         * provide non-repeating data such as headings, totals etc.
         *
         * @param {Ext.data.Model[]} records An Array of {@link Ext.data.Model}s to be rendered into the DataView.
         * @param {Number} startIndex the index number of the Record being prepared for rendering.
         * @return {Object[]} An Array of data objects to be processed by a repeating XTemplate. May also
         * contain <i>named</i> properties.
         * @since 2.3.0
         */
        collectData(records: Ext.data.Model, startIndex: number): any;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Deselects a record instance by record instance or index.
         * @param {Ext.data.Model[]/Number} records An array of records or an index
         * @param {Boolean} suppressEvent Set to false to not fire a deselect event
         * @since 2.3.0
         */
        deselect(records: Ext.data.Model|number, suppressEvent: boolean);

        /**
         * Returns the template node the passed child belongs to, or null if it doesn't belong to one.
         * @return {HTMLElement} The template node
         */
        findItemByChild(node: HTMLElement): HTMLElement;

        /**
         * Returns the template node by the Ext.EventObject or null if it is not found.
         */
        findTargetByEvent(e: Ext.EventObject);

        /**
         * Gets a template node.
         * @param {HTMLElement/String/Number/Ext.data.Model} nodeInfo An HTMLElement template node, index of a template node,
         * the id of a template node or the record associated with the node.
         * @return {HTMLElement} The node or null if it wasn't found
         * @since 2.3.0
         */
        getNode(nodeInfo: HTMLElement|string|number|Ext.data.Model): HTMLElement;

        /**
         * Gets a range nodes.
         * @param {Number} start (optional) The index of the first node in the range
         * @param {Number} end (optional) The index of the last node in the range
         * @return {HTMLElement[]} An array of nodes
         * @since 2.3.0
         */
        getNodes(start: number, end: number): HTMLElement;

        /**
         * Gets a record from a node
         * @param {Ext.Element/HTMLElement} node The node to evaluate
         *
         * @return {Ext.data.Model} record The {@link Ext.data.Model} object
         * @since 2.3.0
         */
        getRecord(node: Ext.dom.Element|HTMLElement): Ext.data.Model;

        /**
         * Gets an array of the records from an array of nodes
         * @param {HTMLElement[]} nodes The nodes to evaluate
         * @return {Ext.data.Model[]} records The {@link Ext.data.Model} objects
         * @since 2.3.0
         */
        getRecords(nodes: HTMLElement): Ext.data.Model;

        /**
         * Gets the currently selected nodes.
         * @return {HTMLElement[]} An array of HTMLElements
         * @since 2.3.0
         */
        getSelectedNodes(): HTMLElement;

        /**
         * Gets an array of the selected records
         * @return {Ext.data.Model[]} An array of {@link Ext.data.Model} objects
         * @deprecated 4.0 Use {@link Ext.selection.Model#getSelection} instead.
         * @since 2.3.0
         */
        getSelectedRecords(): Ext.data.Model;

        /**
         * Gets the number of selected nodes.
         * @return {Number} The node count
         * @deprecated 4.0 Use {@link Ext.selection.Model#getCount} instead.
         * @since 2.3.0
         */
        getSelectionCount(): number;

        /**
         * Gets the selection model for this view.
         * @return {Ext.selection.Model} The selection model
         */
        getSelectionModel(): Ext.selection.Model;

        /**
         * Returns the store associated with this DataView.
         * @return {Ext.data.Store} The store
         */
        getStore(): Ext.data.Store;

        protected getStoreListeners();

        /**
         * Finds the index of the passed node.
         * @param {HTMLElement/String/Number/Ext.data.Model} nodeInfo An HTMLElement template node, index of a template node, the id of a template node
         * or a record associated with a node.
         * @return {Number} The index of the node or -1
         * @since 2.3.0
         */
        indexOf(nodeInfo: HTMLElement|string|number|Ext.data.Model): number;

        protected initComponent();

        /**
         * Returns true if the passed node is selected, else false.
         * @param {HTMLElement/Number/Ext.data.Model} node The node, node index or record to check
         * @return {Boolean} True if selected, else false
         * @since 2.3.0
         */
        isSelected(node: HTMLElement|number|Ext.data.Model): boolean;

        protected onBindStore(store: any, initial: any, propName: any);

        protected onDestroy();

        protected onRender();

        protected onUnbindStore(store: any);

        /**
         * Function which can be overridden to provide custom formatting for each Record that is used by this
         * DataView's {@link #tpl template} to render each node.
         * @param {Object/Object[]} data The raw data object that was used to create the Record.
         * @param {Number} recordIndex the index number of the Record being prepared for rendering.
         * @param {Ext.data.Model} record The Record being prepared for rendering.
         * @return {Array/Object} The formatted data in a format expected by the internal {@link #tpl template}'s overwrite() method.
         * (either an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: 'bar'}))
         * @since 2.3.0
         */
        prepareData(data: any, recordIndex: number, record: Ext.data.Model): any[]|any;

        /**
         * Refreshes the view by reloading the data from the store and re-rendering the template.
         * @since 2.3.0
         */
        refresh();

        /**
         * Refreshes an individual node's data from the store.
         * @param {Number} index The item's data index in the store
         * @since 2.3.0
         */
        refreshNode(index: number);

        /**
         * Selects a record instance by record instance or index.
         * @param {Ext.data.Model[]/Number} records An array of records or an index
         * @param {Boolean} suppressEvent Set to false to not fire a select event
         * @deprecated 4.0 Use {@link Ext.selection.Model#select} instead.
         * @since 2.3.0
         */
        select(records: Ext.data.Model|number, keepExisting: boolean, suppressEvent: boolean);

        /**
         * Fires before the view is refreshed
         * @param {Ext.view.View} this The DataView object
         */
        beforerefresh(that: Ext.view.View);

        /**
         * Fires when the nodes associated with an recordset have been added to the underlying store
         * @param {Ext.data.Model[]} records The model instance
         * @param {Number} index The index at which the set of record/nodes starts
         * @param {HTMLElement[]} node The node that has just been updated
         */
        itemadd(records: Ext.data.Model, index: number, node: HTMLElement);

        /**
         * Fires when the node associated with an individual record is removed
         * @param {Ext.data.Model} record The model instance
         * @param {Number} index The index of the record/node
         */
        itemremove(record: Ext.data.Model, index: number);

        /**
         * Fires when the node associated with an individual record is updated
         * @param {Ext.data.Model} record The model instance
         * @param {Number} index The index of the record/node
         * @param {HTMLElement} node The node that has just been updated
         */
        itemupdate(record: Ext.data.Model, index: number, node: HTMLElement);

        /**
         * Fires when the View's item elements representing Store items has been rendered. If the {@link #deferInitialRefresh} flag
         * was set (and it is <code>true</code> by default), this will be <b>after</b> initial render, and no items will be available
         * for selection until this event fires.
         */
        viewready(that: Ext.view.View);
    }

    interface BoundListConfig extends Ext.view.ViewConfig {
        baseCls?: any;

        componentLayout?: any;

        deferInitialRefresh?: any;

        /**
         * The field from the store to show in the view.
         *
         * Optional, Defaults to: ""
         */
        displayField?: string;

        itemCls?: any;

        /**
         * If greater than '0', a {@link Ext.toolbar.Paging} is displayed at the bottom of the list and store
         * queries will execute with page {@link Ext.data.Operation#start start} and
         * {@link Ext.data.Operation#limit limit} parameters.
         *
         * Optional, Defaults to: 0
         */
        pageSize?: number;

        shadow?: any;

        trackOver?: any;
    }

    /**
     * An internally used DataView for {@link Ext.form.field.ComboBox ComboBox}.
     */
    export class BoundList extends Ext.view.View implements Ext.view.BoundListConfig {
        /**
         * A reference to the PagingToolbar instance in this view. Only populated if {@link #pageSize} is greater
         * than zero and the BoundList has been rendered.
         */
        pagingToolbar: Ext.toolbar.Paging;

        baseCls: string;

        componentLayout: string|any;

        deferInitialRefresh: boolean;

        /**
         * The field from the store to show in the view.
         *
         * Optional, Defaults to: ""
         */
        displayField: string;

        itemCls: string;

        /**
         * If greater than '0', a {@link Ext.toolbar.Paging} is displayed at the bottom of the list and store
         * queries will execute with page {@link Ext.data.Operation#start start} and
         * {@link Ext.data.Operation#limit limit} parameters.
         *
         * Optional, Defaults to: 0
         */
        pageSize: number;

        protected renderTpl: Ext.XTemplate|string;

        shadow: any;

        trackOver: boolean;

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * A method that returns the inner template for displaying items in the list.
         * This method is useful to override when using a more complex display value, for example
         * inserting an icon along with the text.
         *
         * The XTemplate is created with a reference to the owning form field in the 'field' property to provide access
         * to context. For example to highlight the currently typed value, the getInnerTpl may be configured into a
         * ComboBox as part of the {@link Ext.form.field.ComboBox#listConfig listConfig}:
         *
         *    listConfig: {
         *        getInnerTpl: function() {
         *            return '{[values.name.replace(this.field.getRawValue(), "<b>" + this.field.getRawValue() + "</b>")]}';
         *        }
         *    }
         * @param {String} displayField The {@link #displayField} for the BoundList.
         * @return {String} The inner template
         */
        getInnerTpl(displayField: string): string;

        protected onDestroy();

        refresh();
    }

    interface BoundListKeyNavConfig extends Ext.util.KeyNavConfig {
        /**
         * (required)
         * The {@link Ext.view.BoundList} instance for which key navigation will be managed.
         */
        boundList?: Ext.view.BoundList;
    }

    /**
     * A specialized {@link Ext.util.KeyNav} implementation for navigating a {@link Ext.view.BoundList} using
     * the keyboard. The up, down, pageup, pagedown, home, and end keys move the active highlight
     * through the list. The enter key invokes the selection model's select action using the highlighted item.
     */
    export class BoundListKeyNav extends Ext.util.KeyNav implements Ext.view.BoundListKeyNavConfig {
        /**
         * (required)
         * The {@link Ext.view.BoundList} instance for which key navigation will be managed.
         */
        boundList: Ext.view.BoundList;

        constructor(config: Ext.util.KeyNavConfig);

        /**
         * Highlights the item at the given index.
         */
        highlightAt(index: number);

        /**
         * Triggers selection of the currently highlighted item according to the behavior of
         * the configured SelectionModel.
         */
        selectHighlighted();
    }

    interface DragZoneConfig extends Ext.dd.DragZoneConfig {
        containerScroll?: any;
    }

    export class DragZone extends Ext.dd.DragZone implements Ext.view.DragZoneConfig {
        containerScroll: any|boolean;

        constructor(config: Ext.view.DragZoneConfig);
    }

    export class DropZone extends Ext.dd.DropZone {
        constructor(config: Ext.tree.ViewDropZoneConfig);

        destroy();
    }

    /**
     * A cache of View elements keyed using the index of the associated record in the store.
     *
     * This implements the methods of {Ext.dom.CompositeElement} which are used by {@link Ext.view.AbstractView}
     * to privide a map of record nodes and methods to manipulate the nodes.
     */
    export class NodeCache extends Ext.Base {
        /**
         * Removes all elements from this NodeCache.
         * @param {Boolean} [removeDom] True to also remove the elements from the document.
         */
        clear(removeDom?: boolean);

        constructor(view: any);

        /**
         * Clears this NodeCache and adds the elements passed.
         * @param {HTMLElement[]} els An array of DOM elements from which to fill this NodeCache.
         * @return {Ext.view.NodeCache} this
         */
        fill(els: HTMLElement): Ext.view.NodeCache;

        /**
         * Find the index of the passed element within the composite collection.
         * @param {String/HTMLElement/Ext.Element/Number} el The id of an element, or an Ext.dom.Element, or an HtmlElement
         * to find within the composite collection.
         * @return {Number} The index of the passed Ext.dom.Element in the composite collection, or -1 if not found.
         */
        indexOf(el: string|HTMLElement|Ext.dom.Element|number): number;

        /**
         * Removes the specified element(s).
         * @param {String/HTMLElement/Ext.Element/Number} el The id of an element, the Element itself, the index of the
         * element in this composite or an array of any of those.
         * @param {Boolean} [removeDom] True to also remove the element from the document
         */
        removeElement(el: string|HTMLElement|Ext.dom.Element|number, removeDom?: boolean);

        /**
         * Replaces the specified element with the passed element.
         * @param {String/HTMLElement/Ext.Element/Number} el The id of an element, the Element itself, the index of the
         * element in this composite to replace.
         * @param {String/Ext.Element} replacement The id of an element or the Element itself.
         * @param {Boolean} [domReplace] True to remove and replace the element in the document too.
         */
        replaceElement(el: string|HTMLElement|Ext.dom.Element|number, replacement: string|Ext.dom.Element, domReplace?: boolean);

        /**
         * Appends/prepends records depending on direction flag
         * @param {Ext.data.Model[]} newRecords Items to append/prepend
         * @param {Number} direction '-1' = scroll up, '0' = scroll down.
         * @param {Number} removeCount The number of records to remove from the end. if scrolling
         * down, rows are removed from the top and the new rows are added at the bottom.
         */
        scroll(newRecords: Ext.data.Model, direction: number, removeCount: number);
    }

    interface TableConfig extends Ext.view.ViewConfig {
        baseCls?: any;

        componentLayout?: any;

        /**
         * True to enable text selections.
         */
        enableTextSelection?: boolean;

        /**
         * A CSS class to add to the *first* cell in every row to enable special styling for the first column.
         * If no styling is needed on the first column, this may be configured as 'null'.
         *
         * Optional, Defaults to: 'x-grid-cell-first'
         */
        firstCls?: string;

        itemSelector?: any;

        /**
         * A CSS class to add to the *last* cell in every row to enable special styling for the last column.
         * If no styling is needed on the last column, this may be configured as 'null'.
         *
         * Optional, Defaults to: 'x-grid-cell-last'
         */
        lastCls?: string;

        /**
         * True to show the dirty cell indicator when a cell has been modified.
         */
        markDirty?: boolean;

        overItemCls?: any;

        selectedItemCls?: any;

        /**
         * True to stripe the rows.
         *
         * This causes the CSS class **'x-grid-row-alt'** to be added to alternate rows of
         * the grid. A default CSS rule is provided which sets a background color, but you can override this
         * with a rule which either overrides the **background-color** style using the '!important'
         * modifier, or which uses a CSS selector of higher specificity.
         */
        stripeRows?: boolean;

        trackOver?: any;
    }

    /**
     * This class encapsulates the user interface for a tabular data set.
     * It acts as a centralized manager for controlling the various interface
     * elements of the view. This includes handling events, such as row and cell
     * level based DOM events. It also reacts to events from the underlying {@link Ext.selection.Model}
     * to provide visual feedback to the user.
     *
     * This class does not provide ways to manipulate the underlying data of the configured
     * {@link Ext.data.Store}.
     *
     * This is the base class for both {@link Ext.grid.View} and {@link Ext.tree.View} and is not
     * to be used directly.
     */
    export class Table extends Ext.view.View implements Ext.view.TableConfig {
        baseCls: string;

        componentLayout: string|any;

        /**
         * True to enable text selections.
         */
        enableTextSelection: boolean;

        /**
         * A CSS class to add to the *first* cell in every row to enable special styling for the first column.
         * If no styling is needed on the first column, this may be configured as 'null'.
         *
         * Optional, Defaults to: 'x-grid-cell-first'
         */
        firstCls: string;

        itemSelector: string;

        /**
         * A CSS class to add to the *last* cell in every row to enable special styling for the last column.
         * If no styling is needed on the last column, this may be configured as 'null'.
         *
         * Optional, Defaults to: 'x-grid-cell-last'
         */
        lastCls: string;

        /**
         * True to show the dirty cell indicator when a cell has been modified.
         */
        markDirty: boolean;

        overItemCls: string;

        selectedItemCls: string;

        /**
         * True to stripe the rows.
         *
         * This causes the CSS class **'x-grid-row-alt'** to be added to alternate rows of
         * the grid. A default CSS rule is provided which sets a background color, but you can override this
         * with a rule which either overrides the **background-color** style using the '!important'
         * modifier, or which uses a CSS selector of higher specificity.
         */
        stripeRows: boolean;

        trackOver: boolean;

        /**
         * Adds a CSS Class to a specific row.
         * @param {HTMLElement/String/Number/Ext.data.Model} rowInfo An HTMLElement, index or instance of a model
         * representing this row
         */
        addRowCls(rowInfo: HTMLElement|string|number|Ext.data.Model, cls: string);

        /**
         * Sizes the passed header to fit the max content width.
         * *Note that group columns shrinkwrap around the size of leaf columns. Auto sizing a group column
         * autosizes descendant leaf columns.*
         * @param {Ext.grid.column.Column/Number} header The header (or index of header) to auto size.
         */
        autoSizeColumn(header: Ext.grid.column.Column|number);

        protected beforeDestroy();

        constructor(config: Ext.grid.ViewConfig);

        /**
         * Expands a particular header to fit the max content width.
         * @deprecated Use {@link #autoSizeColumn} instead.
         */
        expandToFit();

        /**
         * Focuses a particular row and brings it into view. Will fire the rowfocus event.
         * @param {HTMLElement/String/Number/Ext.data.Model} row An HTMLElement template node, index of a template node, the id of a template node or the
         * @param {Boolean/Number} [delay] Delay the focus this number of milliseconds (true for 10 milliseconds).
         * record associated with the node.
         */
        focusRow(row: HTMLElement|string|number|Ext.data.Model, delay?: boolean|number);

        /**
         * Returns a CSS selector which selects the outermost element(s) in this view.
         */
        getBodySelector();

        /**
         * Returns a CSS selector which selects a particular column if the desired header is passed,
         * or a general cell selector is no parameter is passed.
         *
         * @param {Ext.grid.column.Column} [header] The column for which to return the selector. If
         * omitted, the general cell selector which matches **ant cell** will be returned.
         */
        getCellSelector(header?: Ext.grid.column.Column);

        /**
         * Returns a CSS selector which selects the element(s) which define the width of a column.
         *
         * This is used by the {@link Ext.view.TableLayout} when resizing columns.
         */
        getColumnSizerSelector();

        /**
         * Returns a CSS selector which selects a row which contains cells.
         *
         * These *may not* correspond to actual records in the store. This selector may be used
         * to identify things like total rows or header rows as injected by features which modify
         * the rowTpl.
         */
        getDataRowSelector();

        /**
         * Get a reference to a feature
         * @param {String} id The id of the feature
         * @return {Ext.grid.feature.Feature} The feature. Undefined if not found
         */
        getFeature(id: string): Ext.grid.feature.Feature;

        /**
         * Returns a CSS selector which selects items of the view rendered by the rowTpl
         */
        getItemSelector();

        /**
         * Returns a CSS selector which selects the element which contains record nodes.
         */
        getNodeContainerSelector();

        /**
         * Override this function to apply custom CSS classes to rows during rendering. This function should return the
         * CSS class name (or empty string '' for none) that will be added to the row's wrapping div. To apply multiple
         * class names, simply return them space-delimited within the string (e.g. 'my-class another-class').
         * Example usage:
         *
         *     viewConfig: {
         *         getRowClass: function(record, rowIndex, rowParams, store){
         *             return record.get("valid") ? "row-valid" : "row-error";
         *         }
         *     }
         *
         * @param {Ext.data.Model} record The record corresponding to the current row.
         * @param {Number} index The row index.
         * @param {Object} rowParams **DEPRECATED.** For row body use the
         * {@link Ext.grid.feature.RowBody#getAdditionalData getAdditionalData} method of the rowbody feature.
         * @param {Ext.data.Store} store The store this grid is bound to
         * @return {String} a CSS class name to add to the row.
         */
        getRowClass(record: Ext.data.Model, index: number, rowParams: any, store: Ext.data.Store): string;

        protected initComponent();

        protected onDestroy();

        /**
         * Refreshes the grid view. Sets the sort state and focuses the previously focused row.
         */
        refresh();

        /**
         * Removes a CSS Class from a specific row.
         * @param {HTMLElement/String/Number/Ext.data.Model} rowInfo An HTMLElement, index or instance of a model
         * representing this row
         */
        removeRowCls(rowInfo: HTMLElement|string|number|Ext.data.Model, cls: string);

        /**
         * Navigates from the passed record by the passed increment which may be +ve or -ve
         *
         * Skips hidden records.
         *
         * If no record is visible in the specified direction, returns the starting record index unchanged.
         * @param {Ext.data.Model} startRec The Record to start from.
         * @param {Number} distance The distance to move from the record. May be +ve or -ve.
         */
        walkRecs(startRec: Ext.data.Model, distance: number);

        /**
         * Increments the passed row index by the passed increment which may be +ve or -ve
         *
         * Skips hidden rows.
         *
         * If no row is visible in the specified direction, returns the input row index unchanged.
         * @param {Number} startRow The zero-based row index to start from.
         * @param {Number} distance The distance to move the row by. May be +ve or -ve.
         */
        walkRows(startRow: number, distance: number);

        /**
         * Fired before the cell click is processed. Return false to cancel the default action.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        beforecellclick(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired before the cell right click is processed. Return false to cancel the default action.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        beforecellcontextmenu(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired before the cell double click is processed. Return false to cancel the default action.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        beforecelldblclick(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired before the cell key down is processed. Return false to cancel the default action.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        beforecellkeydown(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired before the cell mouse down is processed. Return false to cancel the default action.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        beforecellmousedown(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired before the cell mouse up is processed. Return false to cancel the default action.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        beforecellmouseup(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired when table cell is clicked.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        cellclick(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired when table cell is right clicked.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        cellcontextmenu(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired when table cell is double clicked.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        celldblclick(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired when the keydown event is captured on the cell.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        cellkeydown(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired when the mousedown event is captured on the cell.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        cellmousedown(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);

        /**
         * Fired when the mouseup event is captured on the cell.
         * @param {HTMLElement} td The TD element for the cell.
         * @param {HTMLElement} tr The TR element for the cell.
         */
        cellmouseup(that: Ext.view.Table, td: HTMLElement, cellIndex: number, record: Ext.data.Model, tr: HTMLElement, rowIndex: number, e: Ext.EventObject);
    }

    /**
     *  Component layout for {@link Ext.view.Table}
     *  @private
     */
    export class TableLayout extends Ext.layout.component.Auto {
        constructor(config: Ext.grid.ColumnComponentLayoutConfig);
    }

    interface ViewConfig extends Ext.view.AbstractViewConfig {
        /**
         * The number of milliseconds to buffer mouseover and mouseout event handling on view items.
         *
         * Configure this as 'false' to process mouseover and mouseout events immediately.
         *
         * Optional, Defaults to: 20
         */
        mouseOverOutBuffer?: number;
    }

    /**
     * A mechanism for displaying data using custom layout templates and formatting.
     *
     * The View uses an {@link Ext.XTemplate} as its internal templating mechanism, and is bound to an
     * {@link Ext.data.Store} so that as the data in the store changes the view is automatically updated
     * to reflect the changes. The view also provides built-in behavior for many common events that can
     * occur for its contained items including click, doubleclick, mouseover, mouseout, etc. as well as a
     * built-in selection model. **In order to use these features, an {@link #itemSelector} config must
     * be provided for the View to determine what nodes it will be working with.**
     *
     * The example below binds a View to a {@link Ext.data.Store} and renders it into an {@link Ext.panel.Panel}.
     *
     *     @example
     *     Ext.define('Image', {
     *         extend: 'Ext.data.Model',
     *         fields: [
     *             { name:'src', type:'string' },
     *             { name:'caption', type:'string' }
     *         ]
     *     });
     *
     *     Ext.create('Ext.data.Store', {
     *         id:'imagesStore',
     *         model: 'Image',
     *         data: [
     *             { src:'http://www.sencha.com/img/20110215-feat-drawing.png', caption:'Drawing & Charts' },
     *             { src:'http://www.sencha.com/img/20110215-feat-data.png', caption:'Advanced Data' },
     *             { src:'http://www.sencha.com/img/20110215-feat-html5.png', caption:'Overhauled Theme' },
     *             { src:'http://www.sencha.com/img/20110215-feat-perf.png', caption:'Performance Tuned' }
     *         ]
     *     });
     *
     *     var imageTpl = new Ext.XTemplate(
     *         '<tpl for=".">',
     *             '<div style="margin-bottom: 10px;" class="thumb-wrap">',
     *               '<img src="{src}" />',
     *               '<br/><span>{caption}</span>',
     *             '</div>',
     *         '</tpl>'
     *     );
     *
     *     Ext.create('Ext.view.View', {
     *         store: Ext.data.StoreManager.lookup('imagesStore'),
     *         tpl: imageTpl,
     *         itemSelector: 'div.thumb-wrap',
     *         emptyText: 'No images available',
     *         renderTo: Ext.getBody()
     *     });
     */
    export class View extends Ext.view.AbstractView implements Ext.view.ViewConfig {
        /**
         * The number of milliseconds to buffer mouseover and mouseout event handling on view items.
         *
         * Configure this as 'false' to process mouseover and mouseout events immediately.
         *
         * Optional, Defaults to: 20
         */
        mouseOverOutBuffer: number;

        /**
         * Un-highlights the currently highlighted item, if any.
         */
        clearHighlight();

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Focuses a node in the view.
         * @param {Ext.data.Model} rec The record associated to the node that is to be focused.
         */
        focusNode(rec: Ext.data.Model);

        /**
         * Highlights a given item in the View. This is called by the mouseover handler if {@link #overItemCls}
         * and {@link #trackOver} are configured, but can also be called manually by other code, for instance to
         * handle stepping through the list via keyboard navigation.
         * @param {HTMLElement} item The item to highlight
         */
        highlightItem(item: HTMLElement);

        protected initComponent();

        refresh();

        /**
         * Fires before the click event on the container is processed. Returns false to cancel the default action.
         * @param {Ext.EventObject} e The raw event object
         */
        beforecontainerclick(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires before the contextmenu event on the container is processed. Returns false to cancel the default action.
         * @param {Ext.EventObject} e The raw event object
         */
        beforecontainercontextmenu(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires before the dblclick event on the container is processed. Returns false to cancel the default action.
         * @param {Ext.EventObject} e The raw event object
         */
        beforecontainerdblclick(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires before the keydown event on the container is processed. Returns false to cancel the default action.
         * @param {Ext.EventObject} e The raw event object. Use {@link Ext.EventObject#getKey getKey()} to retrieve the key that was pressed.
         */
        beforecontainerkeydown(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires before the mousedown event on the container is processed. Returns false to cancel the default action.
         * @param {Ext.EventObject} e The raw event object
         */
        beforecontainermousedown(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires before the mouseout event on the container is processed. Returns false to cancel the default action.
         * @param {Ext.EventObject} e The raw event object
         */
        beforecontainermouseout(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires before the mouseover event on the container is processed. Returns false to cancel the default action.
         * @param {Ext.EventObject} e The raw event object
         */
        beforecontainermouseover(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires before the mouseup event on the container is processed. Returns false to cancel the default action.
         * @param {Ext.EventObject} e The raw event object
         */
        beforecontainermouseup(that: Ext.view.View, e: Ext.EventObject);

        beforedeselect();

        /**
         * Fires before the click event on an item is processed. Returns false to cancel the default action.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        beforeitemclick(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires before the contextmenu event on an item is processed. Returns false to cancel the default action.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        beforeitemcontextmenu(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires before the dblclick event on an item is processed. Returns false to cancel the default action.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        beforeitemdblclick(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires before the keydown event on an item is processed. Returns false to cancel the default action.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object. Use {@link Ext.EventObject#getKey getKey()} to retrieve the key that was pressed.
         */
        beforeitemkeydown(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires before the mousedown event on an item is processed. Returns false to cancel the default action.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        beforeitemmousedown(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires before the mouseenter event on an item is processed. Returns false to cancel the default action.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        beforeitemmouseenter(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires before the mouseleave event on an item is processed. Returns false to cancel the default action.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        beforeitemmouseleave(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires before the mouseup event on an item is processed. Returns false to cancel the default action.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        beforeitemmouseup(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        beforeselect();

        /**
         * Fires when the container is clicked.
         * @param {Ext.EventObject} e The raw event object
         */
        containerclick(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires when the container is right clicked.
         * @param {Ext.EventObject} e The raw event object
         */
        containercontextmenu(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires when the container is double clicked.
         * @param {Ext.EventObject} e The raw event object
         */
        containerdblclick(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires when a key is pressed while the container is focused, and no item is currently selected.
         * @param {Ext.EventObject} e The raw event object. Use {@link Ext.EventObject#getKey getKey()} to retrieve the key that was pressed.
         */
        containerkeydown(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires when you move the mouse out of the container.
         * @param {Ext.EventObject} e The raw event object
         */
        containermouseout(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires when you move the mouse over the container.
         * @param {Ext.EventObject} e The raw event object
         */
        containermouseover(that: Ext.view.View, e: Ext.EventObject);

        /**
         * Fires when there is a mouse up on the container
         * @param {Ext.EventObject} e The raw event object
         */
        containermouseup(that: Ext.view.View, e: Ext.EventObject);

        focuschange();

        /**
         * Fires when a node is highlighted using keyboard navigation, or mouseover.
         * @param {Ext.view.View} view This View Component.
         * @param {Ext.Element} node The highlighted node.
         */
        highlightitem(view: Ext.view.View, node: Ext.dom.Element);

        /**
         * Fires when an item is clicked.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        itemclick(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires when an item is right clicked.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        itemcontextmenu(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires when an item is double clicked.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        itemdblclick(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires when a key is pressed while an item is currently selected.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object. Use {@link Ext.EventObject#getKey getKey()} to retrieve the key that was pressed.
         */
        itemkeydown(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires when there is a mouse down on an item
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        itemmousedown(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires when the mouse enters an item.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        itemmouseenter(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires when the mouse leaves an item.
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        itemmouseleave(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        /**
         * Fires when there is a mouse up on an item
         * @param {Ext.data.Model} record The record that belongs to the item
         * @param {HTMLElement} item The item's element
         * @param {Number} index The item's index
         * @param {Ext.EventObject} e The raw event object
         */
        itemmouseup(that: Ext.view.View, record: Ext.data.Model, item: HTMLElement, index: number, e: Ext.EventObject);

        selectionchange();

        /**
         * Fires when a node is unhighlighted using keyboard navigation, or mouseout.
         * @param {Ext.view.View} view This View Component.
         * @param {Ext.Element} node The previously highlighted node.
         */
        unhighlightitem(view: Ext.view.View, node: Ext.dom.Element);
    }
}

declare module Ext.window {
    interface MessageBoxConfig extends Ext.window.WindowConfig {
        closeAction?: any;

        cls?: any;

        constrain?: any;

        hideMode?: any;

        layout?: any;

        maxHeight?: any;

        maxWidth?: any;

        minHeight?: any;

        minWidth?: any;

        resizable?: any;

        shrinkWrapDock?: any;

        title?: any;
    }

    /**
     * Utility class for generating different styles of message boxes.  The singleton instance, Ext.MessageBox
     * alias 'Ext.Msg' can also be used.
     *
     * Note that a MessageBox is asynchronous.  Unlike a regular JavaScript 'alert' (which will halt
     * browser execution), showing a MessageBox will not cause the code to stop.  For this reason, if you have code
     * that should only run *after* some user feedback from the MessageBox, you must use a callback function
     * (see the 'function' parameter for {@link #method-show} for more details).
     *
     * Basic alert
     *
     *     @example
     *     Ext.Msg.alert('Status', 'Changes saved successfully.');
     *
     * Prompt for user data and process the result using a callback
     *
     *     @example
     *     Ext.Msg.prompt('Name', 'Please enter your name:', function(btn, text){
     *         if (btn == 'ok'){
     *             // process text value and close...
     *         }
     *     });
     *
     * Show a dialog using config options
     *
     *     @example
     *     Ext.Msg.show({
     *          title:'Save Changes?',
     *          msg: 'You are closing a tab that has unsaved changes. Would you like to save your changes?',
     *          buttons: Ext.Msg.YESNOCANCEL,
     *          icon: Ext.Msg.QUESTION
     *     });
     */
    export class MessageBox extends Ext.window.Window implements Ext.window.MessageBoxConfig {
        /**
         * An object containing the default button text strings that can be overriden for localized language support.
         * Supported properties are: ok, cancel, yes and no.  Generally you should include a locale-specific
         * resource file for handling language support across the framework.
         * Customize the default text like so:
         *
         *     Ext.window.MessageBox.buttonText.yes = "oui"; //french
         */
        buttonText: any;

        /**
         * Button config that displays a single Cancel button
         */
        CANCEL: any;

        /**
         * The default height in pixels of the message box's multiline textarea if displayed.
         */
        defaultTextHeight: any;

        /**
         * The CSS class that provides the ERROR icon image
         */
        ERROR: any;

        /**
         * The CSS class that provides the INFO icon image
         */
        INFO: any;

        /**
         * The minimum width in pixels of the message box if it is a progress-style dialog.  This is useful
         * for setting a different minimum width than text-only dialogs may need.
         */
        minProgressWidth: any;

        /**
         * The minimum width in pixels of the message box if it is a prompt dialog.  This is useful
         * for setting a different minimum width than text-only dialogs may need.
         */
        minPromptWidth: any;

        /**
         * Button config that displays a single No button
         */
        NO: any;

        /**
         * Button config that displays a single OK button
         */
        OK: any;

        /**
         * Button config that displays OK and Cancel buttons
         */
        OKCANCEL: any;

        /**
         * The CSS class that provides the QUESTION icon image
         */
        QUESTION: any;

        /**
         * The CSS class that provides the WARNING icon image
         */
        WARNING: any;

        /**
         * Button config that displays a single Yes button
         */
        YES: any;

        /**
         * Button config that displays Yes and No buttons
         */
        YESNO: any;

        /**
         * Button config that displays Yes, No and Cancel buttons
         */
        YESNOCANCEL: any;

        closeAction: string;

        cls: string;

        constrain: boolean;

        hideMode: string;

        layout: Ext.enums.Layout|any;

        maxHeight: number;

        maxWidth: number;

        minHeight: number;

        minWidth: number;

        resizable: boolean|any;

        shrinkWrapDock: boolean|number;

        title: string;

        /**
         * Displays a standard read-only message box with an OK button (comparable to the basic JavaScript alert prompt).
         * If a callback function is passed it will be called after the user clicks the button, and the
         * id of the button that was clicked will be passed as the only parameter to the callback
         * (could also be the top-right close button, which will always report as "cancel").
         *
         * @param {String} title The title bar text
         * @param {String} msg The message box body text
         * @param {Function} [fn] The callback function invoked after the message box is closed.
         * See {@link #method-show} method for details.
         * @param {Object} [scope=window] The scope (<code>this</code> reference) in which the callback is executed.
         * @return {Ext.window.MessageBox} this
         */
        alert(title: string, msg: string, fn?: Function, scope?: any): Ext.window.MessageBox;

        /**
         * Displays a confirmation message box with Yes and No buttons (comparable to JavaScript's confirm).
         * If a callback function is passed it will be called after the user clicks either button,
         * and the id of the button that was clicked will be passed as the only parameter to the callback
         * (could also be the top-right close button, which will always report as "cancel").
         *
         * @param {String} title The title bar text
         * @param {String} msg The message box body text
         * @param {Function} [fn] The callback function invoked after the message box is closed.
         * See {@link #method-show} method for details.
         * @param {Object} [scope=window] The scope ('this' reference) in which the callback is executed.
         * @return {Ext.window.MessageBox} this
         */
        confirm(title: string, msg: string, fn?: Function, scope?: any): Ext.window.MessageBox;

        constructor(cfg: any);

        /**
         * Displays a message box with a progress bar.
         *
         * You are responsible for updating the progress bar as needed via {@link Ext.window.MessageBox#updateProgress}
         * and closing the message box when the process is complete.
         *
         * @param {String} title The title bar text
         * @param {String} msg The message box body text
         * @param {String} [progressText=''] The text to display inside the progress bar
         * @return {Ext.window.MessageBox} this
         */
        progress(title: string, msg: string, progressText?: string): Ext.window.MessageBox;

        /**
         * Displays a message box with OK and Cancel buttons prompting the user to enter some text (comparable to JavaScript's prompt).
         * The prompt can be a single-line or multi-line textbox.  If a callback function is passed it will be called after the user
         * clicks either button, and the id of the button that was clicked (could also be the top-right
         * close button, which will always report as "cancel") and the text that was entered will be passed as the two parameters to the callback.
         *
         * @param {String} title The title bar text
         * @param {String} msg The message box body text
         * @param {Function} [fn] The callback function invoked after the message box is closed.
         * See {@link #method-show} method for details.
         * @param {Object} [scope=window] The scope ('this' reference) in which the callback is executed.
         * @param {Boolean/Number} [multiline=false] True to create a multiline textbox using the defaultTextHeight
         * property, or the height in pixels to create the textbox/
         * @param {String} [value=''] Default value of the text input element
         * @return {Ext.window.MessageBox} this
         */
        prompt(title: string, msg: string, fn?: Function, scope?: any, multiline?: boolean|number, value?: string): Ext.window.MessageBox;

        /**
         * Updates a progress-style message box's text and progress bar. Only relevant on message boxes
         * initiated via {@link Ext.window.MessageBox#progress} or {@link Ext.window.MessageBox#wait},
         * or by calling {@link Ext.window.MessageBox#method-show} with progress: true.
         *
         * @param {Number} [value=0] Any number between 0 and 1 (e.g., .5)
         * @param {String} [progressText=''] The progress text to display inside the progress bar.
         * @param {String} [msg] The message box's body text is replaced with the specified string (defaults to undefined
         * so that any existing body text will not get overwritten by default unless a new value is passed in)
         * @return {Ext.window.MessageBox} this
         */
        updateProgress(value?: number, progressText?: string, msg?: string): Ext.window.MessageBox;

        /**
         * Displays a message box with an infinitely auto-updating progress bar.  This can be used to block user
         * interaction while waiting for a long-running process to complete that does not have defined intervals.
         * You are responsible for closing the message box when the process is complete.
         *
         * @param {String} msg The message box body text
         * @param {String} [title] The title bar text
         * @param {Object} [config] A {@link Ext.ProgressBar#wait} config object
         * @return {Ext.window.MessageBox} this
         */
        wait(msg: string, title?: string, config?: Ext.window.MessageBoxConfig): Ext.window.MessageBox;
    }

    interface WindowConfig extends Ext.panel.PanelConfig {
        /**
         * Id or element from which the window should animate while opening.
         *
         * Optional, Defaults to: null
         */
        animateTarget?: string|Ext.dom.Element;

        /**
         * Windows render to the body on first show.
         */
        autoRender?: any;

        /**
         * The base CSS class to apply to this panel's element.
         *
         * Optional, Defaults to: 'x-window'
         */
        baseCls?: string;

        /**
         * True to display the 'close' tool button and allow the user to close the window, false to hide the button and
         * disallow closing the window.
         *
         * By default, when close is requested by either clicking the close button in the header or pressing ESC when the
         * Window has focus, the {@link #method-close} method will be called. This will _{@link Ext.Component#method-destroy destroy}_ the
         * Window and its content meaning that it may not be reused.
         *
         * To make closing a Window _hide_ the Window so that it may be reused, set {@link #closeAction} to 'hide'.
         */
        closable?: boolean;

        /**
         * True to render the window collapsed, false to render it expanded. Note that if {@link #expandOnShow}
         * is true (the default) it will override the 'collapsed' config and the window will always be
         * expanded when shown.
         *
         * Optional, Defaults to: false
         */
        collapsed?: boolean;

        collapsible?: any;

        /**
         * @override
         * True to constrain the window within its containing element, false to allow it to fall outside of its containing
         * element. By default the window will be rendered to 'document.body'. To render and constrain the window within
         * another element specify {@link #renderTo}. Optionally the header only can be constrained
         * using {@link #constrainHeader}.
         */
        constrain?: boolean;

        /**
         * @override
         * True to constrain the window header within its containing element (allowing the window body to fall outside of
         * its containing element) or false to allow the header to fall outside its containing element.
         * Optionally the entire window can be constrained using {@link #constrain}.
         */
        constrainHeader?: boolean;

        /**
         * Specifies a Component to receive focus when this Window is focused.
         *
         * This may be one of:
         *
         *   - The index of a footer Button.
         *   - The id or {@link Ext.AbstractComponent#itemId} of a descendant Component.
         *   - A Component.
         */
        defaultFocus?: string|number|Ext.Component;

        /**
         * True to allow the window to be dragged by the header bar, false to disable dragging. Note that
         * by default the window will be centered in the viewport, so if dragging is disabled the window may need to be
         * positioned programmatically after render (e.g., 'myWindow.setPosition(100, 100);').
         */
        draggable?: boolean;

        /**
         * True to always expand the window when it is displayed, false to keep it in its current state (which may be
         * {@link #collapsed}) when displayed.
         */
        expandOnShow?: boolean;

        /**
         * Set to false to disable the ghost panel during dragging the window.
         * Do note that you should not set this to true, by default it is a function.
         */
        ghost?: boolean|Function;

        /**
         * Render this Window hidden. If 'true', the {@link #method-hide} method will be called internally.
         */
        hidden?: boolean;

        /**
         * Windows hide using offsets in order to preserve the scroll positions of their descendants.
         */
        hideMode?: any;

        /**
         * True to hide this Window's shadow when another floating item in the same z-index stack is activated.
         *
         * Optional, Defaults to: false
         */
        hideShadowOnDeactivate?: boolean;

        /**
         * True to display the 'maximize' tool button and allow the user to maximize the window, false to hide the button
         * and disallow maximizing the window. Note that when a window is maximized, the tool button
         * will automatically change to a 'restore' button with the appropriate behavior already built-in that will restore
         * the window to its previous size.
         */
        maximizable?: boolean;

        /**
         * True to initially display the window in a maximized state.
         *
         * Optional, Defaults to: false
         */
        maximized?: boolean;

        minHeight?: any;

        minWidth?: any;

        /**
         * True to display the 'minimize' tool button and allow the user to minimize the window, false to hide the button
         * and disallow minimizing the window. Note that this button provides no implementation -- the
         * behavior of minimizing a window is implementation-specific, so the minimize event must be handled and a custom
         * minimize behavior implemented for this option to be useful.
         */
        minimizable?: boolean;

        /**
         * True to make the window modal and mask everything behind it when displayed, false to display it without
         * restricting access to other UI elements.
         *
         * Optional, Defaults to: false
         */
        modal?: boolean;

        /**
         * Allows override of the built-in processing for the escape key. Default action is to close the Window (performing
         * whatever action is specified in {@link #closeAction}. To prevent the Window closing when the escape key is
         * pressed, specify this as {@link Ext#emptyFn Ext.emptyFn}.
         */
        onEsc?: Function;

        overlapHeader?: any;

        /**
         * True to render the window body with a transparent background so that it will blend into the framing elements,
         * false to add a lighter background color to visually highlight the body element and separate it more distinctly
         * from the surrounding frame.
         */
        plain?: boolean;

        /**
         * Specify as 'true' to allow user resizing at each edge and corner of the window, false to disable resizing.
         *
         * This may also be specified as a config object to Ext.resizer.Resizer
         */
        resizable?: boolean|any;

        /**
         * The X position of the left edge of the window on initial showing. Defaults to centering the Window within the
         * width of the Window's container {@link Ext.Element Element} (The Element that the Window is rendered to).
         */
        x?: number;

        /**
         * The Y position of the top edge of the window on initial showing. Defaults to centering the Window within the
         * height of the Window's container {@link Ext.Element Element} (The Element that the Window is rendered to).
         */
        y?: number;
    }

    /**
     * A specialized panel intended for use as an application window. Windows are floated, {@link #resizable}, and
     * {@link #cfg-draggable} by default. Windows can be {@link #maximizable maximized} to fill the viewport, restored to
     * their prior size, and can be {@link #method-minimize}d.
     *
     * Windows can also be linked to a {@link Ext.ZIndexManager} or managed by the {@link Ext.WindowManager} to provide
     * grouping, activation, to front, to back and other application-specific behavior.
     *
     * By default, Windows will be rendered to document.body. To {@link #constrain} a Window to another element specify
     * {@link Ext.Component#renderTo renderTo}.
     *
     * **As with all {@link Ext.container.Container Container}s, it is important to consider how you want the Window to size
     * and arrange any child Components. Choose an appropriate {@link #layout} configuration which lays out child Components
     * in the required manner.**
     *
     *     @example
     *     Ext.create('Ext.window.Window', {
     *         title: 'Hello',
     *         height: 200,
     *         width: 400,
     *         layout: 'fit',
     *         items: {  // Let's put an empty grid in just to illustrate fit layout
     *             xtype: 'grid',
     *             border: false,
     *             columns: [{header: 'World'}],                 // One header just for show. There's no data,
     *             store: Ext.create('Ext.data.ArrayStore', {}) // A dummy empty data store
     *         }
     *     }).show();
     */
    export class Window extends Ext.panel.Panel implements Ext.window.WindowConfig {
        /**
         * 'true' in this class to identify an object as an instantiated Window, or subclass thereof.
         */
        isWindow: boolean;

        /**
         * Id or element from which the window should animate while opening.
         *
         * Optional, Defaults to: null
         */
        animateTarget: string|Ext.dom.Element;

        /**
         * Windows render to the body on first show.
         */
        autoRender: boolean|string|HTMLElement|Ext.dom.Element;

        /**
         * The base CSS class to apply to this panel's element.
         *
         * Optional, Defaults to: 'x-window'
         */
        baseCls: string;

        /**
         * True to display the 'close' tool button and allow the user to close the window, false to hide the button and
         * disallow closing the window.
         *
         * By default, when close is requested by either clicking the close button in the header or pressing ESC when the
         * Window has focus, the {@link #method-close} method will be called. This will _{@link Ext.Component#method-destroy destroy}_ the
         * Window and its content meaning that it may not be reused.
         *
         * To make closing a Window _hide_ the Window so that it may be reused, set {@link #closeAction} to 'hide'.
         */
        closable: boolean;

        /**
         * True to render the window collapsed, false to render it expanded. Note that if {@link #expandOnShow}
         * is true (the default) it will override the 'collapsed' config and the window will always be
         * expanded when shown.
         *
         * Optional, Defaults to: false
         */
        collapsed: boolean;

        collapsible: boolean;

        /**
         * @override
         * True to constrain the window within its containing element, false to allow it to fall outside of its containing
         * element. By default the window will be rendered to 'document.body'. To render and constrain the window within
         * another element specify {@link #renderTo}. Optionally the header only can be constrained
         * using {@link #constrainHeader}.
         */
        constrain: boolean;

        /**
         * @override
         * True to constrain the window header within its containing element (allowing the window body to fall outside of
         * its containing element) or false to allow the header to fall outside its containing element.
         * Optionally the entire window can be constrained using {@link #constrain}.
         */
        constrainHeader: boolean;

        /**
         * Specifies a Component to receive focus when this Window is focused.
         *
         * This may be one of:
         *
         *   - The index of a footer Button.
         *   - The id or {@link Ext.AbstractComponent#itemId} of a descendant Component.
         *   - A Component.
         */
        defaultFocus: string|number|Ext.Component;

        /**
         * True to allow the window to be dragged by the header bar, false to disable dragging. Note that
         * by default the window will be centered in the viewport, so if dragging is disabled the window may need to be
         * positioned programmatically after render (e.g., 'myWindow.setPosition(100, 100);').
         */
        draggable: boolean;

        /**
         * True to always expand the window when it is displayed, false to keep it in its current state (which may be
         * {@link #collapsed}) when displayed.
         */
        expandOnShow: boolean;

        /**
         * Set to false to disable the ghost panel during dragging the window.
         * Do note that you should not set this to true, by default it is a function.
         */
        ghost: boolean|Function;

        /**
         * Render this Window hidden. If 'true', the {@link #method-hide} method will be called internally.
         */
        hidden: boolean;

        /**
         * Windows hide using offsets in order to preserve the scroll positions of their descendants.
         */
        hideMode: string;

        /**
         * True to hide this Window's shadow when another floating item in the same z-index stack is activated.
         *
         * Optional, Defaults to: false
         */
        hideShadowOnDeactivate: boolean;

        /**
         * True to display the 'maximize' tool button and allow the user to maximize the window, false to hide the button
         * and disallow maximizing the window. Note that when a window is maximized, the tool button
         * will automatically change to a 'restore' button with the appropriate behavior already built-in that will restore
         * the window to its previous size.
         */
        maximizable: boolean;

        /**
         * True to initially display the window in a maximized state.
         *
         * Optional, Defaults to: false
         */
        maximized: boolean;

        minHeight: number;

        /**
         * True to display the 'minimize' tool button and allow the user to minimize the window, false to hide the button
         * and disallow minimizing the window. Note that this button provides no implementation -- the
         * behavior of minimizing a window is implementation-specific, so the minimize event must be handled and a custom
         * minimize behavior implemented for this option to be useful.
         */
        minimizable: boolean;

        minWidth: number;

        /**
         * True to make the window modal and mask everything behind it when displayed, false to display it without
         * restricting access to other UI elements.
         *
         * Optional, Defaults to: false
         */
        modal: boolean;

        /**
         * Allows override of the built-in processing for the escape key. Default action is to close the Window (performing
         * whatever action is specified in {@link #closeAction}. To prevent the Window closing when the escape key is
         * pressed, specify this as {@link Ext#emptyFn Ext.emptyFn}.
         */
        onEsc: Function;

        overlapHeader: boolean;

        /**
         * True to render the window body with a transparent background so that it will blend into the framing elements,
         * false to add a lighter background color to visually highlight the body element and separate it more distinctly
         * from the surrounding frame.
         */
        plain: boolean;

        /**
         * Specify as 'true' to allow user resizing at each edge and corner of the window, false to disable resizing.
         *
         * This may also be specified as a config object to Ext.resizer.Resizer
         */
        resizable: boolean|any;

        /**
         * The X position of the left edge of the window on initial showing. Defaults to centering the Window within the
         * width of the Window's container {@link Ext.Element Element} (The Element that the Window is rendered to).
         */
        x: number;

        /**
         * The Y position of the top edge of the window on initial showing. Defaults to centering the Window within the
         * height of the Window's container {@link Ext.Element Element} (The Element that the Window is rendered to).
         */
        y: number;

        applyState(state: any);

        /**
         * Creates new Component.
         * @param {Ext.Element/String/Object} config The configuration options may be specified as either:
         *
         * - **an element** : it is set as the internal element and its id used as the component id
         * - **a string** : it is assumed to be the id of an existing element and is used as the component id
         * - **anything else** : it is assumed to be a standard config object and is applied to the component
         */
        constructor(config: Ext.dom.Element|string|Ext.ComponentConfig);

        /**
         * Gets the configured default focus item.  If a {@link #defaultFocus} is set, it will
         * receive focus when the Window's <code>focus</code> method is called, otherwise the
         * Window itself will receive focus.
         */
        getDefaultFocus();

        /**
         * Fits the window within its current container and automatically replaces the {@link #maximizable 'maximize' tool
         * button} with the 'restore' tool button. Also see {@link #toggleMaximize}.
         * @param {Boolean} animate 'true' to animate this Window to full size.
         * @return {Ext.window.Window} this
         */
        maximize(animate: boolean): Ext.window.Window;

        /**
         * Placeholder method for minimizing the window. By default, this method simply fires the {@link #event-minimize} event
         * since the behavior of minimizing a window is application-specific. To implement custom minimize behavior, either
         * the minimize event can be handled or this method can be overridden.
         * @return {Ext.window.Window} this
         */
        minimize(): Ext.window.Window;

        /**
         * Restores a {@link #maximizable maximized} window back to its original size and position prior to being maximized
         * and also replaces the 'restore' tool button with the 'maximize' tool button. Also see {@link #toggleMaximize}.
         * @return {Ext.window.Window} this
         */
        restore(): Ext.window.Window;

        /**
         * A shortcut method for toggling between {@link #method-maximize} and {@link #method-restore} based on the current maximized
         * state of the window.
         * @return {Ext.window.Window} this
         */
        toggleMaximize(): Ext.window.Window;
    }
}
